

// SeisWideDoc.cpp : implementation of the CSeisWideDoc class
//

#include "stdafx.h"
#include "SeisWide.h"
#include "cstringex.h"
#include "MainFrm.h"

#include "SeisWideDoc.h"
#include "CntrItem.h"
#include "SrvrItem.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#include "math.h"
#include "float.h"
#include "CSpreadSheet.h"
#include "suSwapByte.h"

#include "dlgVELOCITY1.h"
#include "dlgDEPTH1.h"
#include "dlgTIMESEC1.h"
#include "dlgTimeByTrc.h"
#include "dlgAddRange.h"
#include "dlgAddRangeFile.h"
#include "dlgChangeRanges.h"
#include "BoundNodes.h"
#include "dlgLayerNodes.h"
#include "dlgNewVelFile.h"
#include "dlgdigitize.h"
#include "dlgDigResolution.h"
#include "dlgNewLayer.h"
#include "dlgReorganize.h"
#include "dlgCohMix.h"
#include "dlgFilter1.h"
#include "dlgFilterOffset.h"
#include "DlgNewModel.h"
#include "dlgRaytrace1.h"
#include "dlgLoadZelt.h"
#include "dlgLoadReid.h"
#include "dlgLatShift.h"
#include "dlgSegyInfo.h"
#include "dlgTim2Dpth.h"
#include "dlgWide2Depth.h"
#include "dlgSourcePos.h"
#include "dlgModelResize.h"
#include "dlgFillArea.h"
#include "dlgSegyColor.h"
#include "dlgSegyAppend.h"
#include "dlgVred.h"
#include "dlgSegyPreview.h"
#include "dlgMergeModels.h"
#include "dlgMigPS.h"
#include "dlgVZCurve.h"
#include "dlgTTCurve.h"
#include "dlgInOut.h"
#include "dlgChangeReducingBMP.h"

#include "preKDMig.h"
#include "preRayTraceLiu.h"
#include "sumig.h"

#include "dlgHydrateDisp.h"
#include "dlgSonobouy.h"
#include "dlgTablizeLayer.h"
#include "dlgLatLong.h"
#include "dlgConvertRawSgy.h"
#include "dlgLineDrawTim.h"
#include "dlgLineDrawDep.h"
#include "dlgVel2Den.h"
#include "dlgVel2Den1.h"
#include "dlgMigLineDraw.h"
#include "dlgDigitizeShift.h"
#include "dlgInitAmp.h"
#include "dlgImportbitmap.h"
#include "dlgTimDepthBMP.h"
#include "dlgDispBitmap.h"
#include "bmp24.h"
#include "util.h"
#include "string.h"
#include "dlgUnix2PC.h"
#include "dlgResample.h"
#include "dlgWienerFilter.h"
#include "dlgDigResize.h"
#include "dlgDigSelectCurrent.h"
#include "dlgModelShiftBoundary.h"
#include "dlgLabelSizes.h"
#include "dlgInputValie.h"
#include "dlgVelocityTwtt2.h"
#include "dlgWide2Velocity.h"
#include "dlgLabelOverwrite.h"
#include "CShellFileOp.h"
#include "dlgSineModulate.h"
#include "dlgDespiking.h"
#include "dlgDesimate.h"
#include "dlgAttenuationCorr.h"
#include "dlgAddData.h"
#include "dlgNormTrcInt.h"
#include "SegyWrapper.h"
#include "SegyWrapperEx.h"
#include "segyMeta.h"

#include "dlgRmsVelocityAnalysis.h"
#include "dlgAgc.h"
#include "seiContour.h"
#include "dlgDigOption.h"
#include "dlgSonobuoyPoly.h"
#include "dlgSonobuoyAutoOffset.h"
#include "dlgTraceDub.h"
#include "dlgGainAdjust.h"
#include "dlgSegyColor2.h"
#include "dlgTraceBalanceXT.h"
#include "dlgDistanceAdjust.h"
#include "dlgRegionalModel.h"
//using namespace Utility;
#include "dlgVelocityPerturb.h"
#include "dlgPrint.h"
#include "dlgMagmod.h"
#include "dlgToolPoly.h"
#include "dlgBitmap2sgy.h"

#include "dcHelper.h"

#include "IniWriter.h"
#include "IniReader.h"
//#include "StringExScanf.h"
#include "xallocator.h"

// depreciated below
//#include "dlgKdmig.h"
#include "dlgKdmigPost.h"
#include "dlgAsciiHead.h"
#include "dlgBmpByTrace.h"

// std:: exception library is not compatible with VC++ debugging lib
// #include <stdexcept>

//#include "compare.h"
//using namespace metasharp;

//#define MIL 1000000.
//#define MINAMP 0.000000001
//#define velMod.depth velMod.depth
//#define VTOP velMod.vTop
//#define VBOT velMod.vBot

static BOOL digIsUpdatePartial = FALSE; // I move this static variable outside of function because I want to update it from another function.

/////////////////////////////////////////////////////////////////////////////
// CSeisWideDoc

IMPLEMENT_DYNCREATE(CSeisWideDoc, COleServerDoc)

BEGIN_MESSAGE_MAP(CSeisWideDoc, COleServerDoc)
	//{{AFX_MSG_MAP(CSeisWideDoc)
	ON_COMMAND(ID_VIEW_BOTH, OnViewBoth)
	ON_COMMAND(ID_VIEW_CONTOURS, OnViewContours)
	ON_COMMAND(ID_VIEW_TIMESECTION, OnViewTimesection)
	ON_COMMAND(ID_VIEW_VELOCITYCOLORMAP, OnViewVelocitycolormap)
	ON_COMMAND(ID_VIEW_DEPTHSECTION, OnViewDepthsection)
	ON_COMMAND(ID_VIEW_ADDRANGETOSEGY, OnProcessingAddrangetosegy)
	ON_COMMAND(ID_EDIT_BOUNDARY, OnEditBoundary)
	ON_COMMAND(ID_EDIT_VELOCITY, OnEditVelocity)
	ON_COMMAND(ID_EDIT_NONODES, OnEditNonodes)
	ON_COMMAND(ID_TOOBAR_MOVE, OnToobarMove)
	ON_COMMAND(ID_TOOLBAR__REMOVE, OnToolbarRemove)
	ON_COMMAND(ID_TOOLBAR_PICK, OnToolbarPick)
	ON_COMMAND(ID_TOOLBAR_ADD, OnToolbarAdd)
	ON_COMMAND(ID_TOOLBAR_DELLINE, OnToolbarDelLine)
	//ON_COMMAND(ID_TOOLBAR_NEWLINE, OnToolbarNewLine)
	ON_COMMAND(ID_EDIT_COPY, OnEditCopy)
	ON_COMMAND(ID_TOOLBAR_SAVEV, OnToolbarSavev)
	ON_COMMAND(ID_TOOLBAR_SAVEASV, OnToolbarSaveasv)
	ON_COMMAND(ID_EDIT_DIGITIZE, OnDigitizingStart)
	ON_COMMAND(ID_EDIT_SAVEDIG, OnDigitizingSavedig)
	ON_COMMAND(ID_EDIT_NEWCURVE, OnDigitizingNewcurve)
	ON_COMMAND(ID_DIGITIZE_FINISHDIGITIZING, OnDigitizeFinishdigitizing)
	ON_COMMAND(ID_PROCESSING_TRACEREORDER, OnProcessingTracereorder)
	ON_COMMAND(ID_PROCESSING_COHMIX, OnReflectionCoherencyplot)
	ON_COMMAND(ID_TOOLBAR_NEWMOD, OnModelNewmod)
	ON_COMMAND(ID_PROCESSING_LOADZELTSMODEL, OnModelLoadzeltsmodel)
	ON_COMMAND(ID_PROCESSING_DATAREDUCTIONANDFILTER, OnProcessingDatareductionandfilter)
	ON_COMMAND(ID_PROCESSING_LATERALSHIFT, OnProcessingLateralshift)
	ON_COMMAND(ID_PROCESSING_RAYTRACE, OnModelingRaytrace)
	ON_COMMAND(ID_PROCESSING_RAYPATH, OnModelingRaypath)
	ON_COMMAND(ID_VIEW_SEGYINFO, OnViewSegyinfo)
	ON_COMMAND(ID_PROCESSING_DEFINESOURCEPOSITION, OnModelingDefinesourceposition)
	ON_COMMAND(ID_EDIT_LABLES_OUTSIDE, OnEditLabelOutside)
	ON_COMMAND(ID_EDIT_TUNEUP_NOBOUNDARY, OnEditTuneupNoboundary)
	ON_COMMAND(ID_EDIT_TUNEUP_NOCOLORMAP, OnEditTuneupNocolormap)
	ON_COMMAND(ID_EDIT_TUNEUP_OBSPOSITIONS, OnEditTuneupObspositions)
	ON_COMMAND(ID_TOOLBAR_DUPLICATE, OnToolbarDuplicate)
	ON_COMMAND(ID_PROCESSING_CHECKMODELINTEGRITY, OnProcessingCheckmodelintegrity)
	ON_COMMAND(ID_TOOLBAR_RESIZEMOD, OnToolbarResizemod)
	ON_COMMAND(ID_EDIT_DISPLAYTUNEUP_FILLAREAONCE, OnEditDisplaytuneupFillareaonce)
	ON_COMMAND(ID_DIGITIZE_UNDOPOINT, OnDigitizeUndopoint)
	ON_COMMAND(ID_PROCESSING_APPENDASEGYFILE, OnProcessingAppendasegyfile)
	ON_COMMAND(ID_PROCESSING_REDUCEMANUAL, OnProcessingReducemanual)
	ON_COMMAND(ID_MODELING_EXTRACTVZCURVE, OnModelingExtractvzcurve)
	ON_COMMAND(ID_PROCESSING_KDMIGPOST, OnProcessingKdmigpost)
	ON_COMMAND(ID_VIEW_TIMESECTRC, OnViewTimesectrc)
	ON_COMMAND(ID_MENU_VIEW_HYDRO, OnViewHydro)
	ON_COMMAND(ID_PROCESSING_SB_KM, OnSonobuoyLinearKm)
	ON_COMMAND(ID_MODELING_EXTRACTLAYERINFOR, OnModelingExtractlayerinfor)
	ON_COMMAND(ID_TOOLBAR_REFRESH, OnToolbarRefresh2)
	ON_COMMAND(ID_MODELING_LOADREIDSMODEL, OnModelingLoadreidsmodel)
	ON_COMMAND(ID_PROCESSING_LATLONGTODISTANCE, OnProcessingLatlongtodistance)
	ON_COMMAND(ID_EDIT_DISPLAYTUNEUP_BIGMODELNODES, OnEditDisplaytuneupBigmodelnodes)
	ON_COMMAND(ID_EDIT_DISPLAYTUNEUP_CHANGCOLORTTCURVES, OnEditDisplaytuneupChangcolorttcurves)
	ON_COMMAND(ID_PROCESSING_UNIX2PCBATCH, OnProcessingUnix2pcbatch)
	ON_COMMAND(ID_PROCESSING_PC2UNIXBATCH, OnProcessingPc2unixbatch)
	ON_COMMAND(ID_PROCESSING_RAWTOSEGY, OnProcessingRawtosegy)
	ON_COMMAND(ID_VIEW_TRACEANALYSIS, OnViewTraceanalysis)
	ON_COMMAND(ID_DIGITIZING_LOADEXISTING, OnDigitizingLoadexisting)
	ON_COMMAND(ID_PROCESSING_TIMEDEPTH_DRAWINGS, OnProcessingTimeDepthDrawings)
	ON_COMMAND(ID_MODELING_DENBLOCKS, OnModelingDenblocks_Test)
	ON_COMMAND(ID_DIGITIZING_MIGRATELINEDRAWINGS, OnDigitizingMigratelinedrawings)
	ON_COMMAND(ID_DIGITIZING_CHANGECURVERES, OnDigitizingChangecurveres)
	ON_COMMAND(ID_DIGITIZING_LOADZELT_TX, OnDigitizingLoadzeltTx)
	ON_COMMAND(ID_DIGITIZING_WHEREANI, OnDigitizingWhereani)
	ON_COMMAND(ID_DIGITIZING_SHIFTDIGITING, OnDigitizingShiftdigiting)
	ON_COMMAND(ID_DIGITIZING_CHANGEERRORBAR_ASBAR, OnDigitizingChangeerrorbarAsBar)
	ON_COMMAND(ID_DIGITIZING_CHANGEERRORBAR_ASCIRCLE, OnDigitizingChangeerrorbarAscircle)
	ON_COMMAND(ID_DIGITIZING_CHANGEERRORBAR_ASSTAR, OnDigitizingChangeerrorbarAsstar)
	ON_COMMAND(ID_DIGITIZING_CHANGEERRORBAR_ASFILLCIRCLE, OnDigitizingChangeerrorbarAsfillcircle)
	ON_COMMAND(ID_EDIT_DISPLAYTUNEUP_REMOVEOUTSIDERAYPOINTS, OnEditDisplaytuneupRemoveoutsideraypoints)
	//	ON_COMMAND(ID_EDIT_DISPLAYTUNEUP_SKIPCOMPLAININGTRACETOODENSE, OnEditDisplaytuneupSkipcomplainingtracetoodense)
	ON_COMMAND(ID_TOOLBAR_FLIPMOD, OnModelFlipmod)
	ON_COMMAND(ID_MODELING_SUBSIDENCEBEFORESEDIMENTLOADING, OnModelingSubsidence)
	ON_COMMAND(ID_FILE_IMPORTBITMAP, OnFileImportbitmap)
//	ON_COMMAND(ID_FILE_RESIZEBITMAP, OnFileResizebitmap)
//	ON_COMMAND(ID_PROCESSING_TDCONVBMP, OnProcessingTdconvbmp)
	ON_COMMAND(ID_EDIT_PASTE, OnEditPaste)
	ON_COMMAND(ID_PROCESSING_DATARESAMPLE, OnProcessingDataresample)
	ON_COMMAND(ID_TOOLBAR_REFRESH_ALL, OnToolbarRefreshAll)
	ON_COMMAND(ID_EDIT_DISPLAYTUNEUP_REMOVETTOVERLAY, OnEditDisplaytuneupRemovettoverlay)
	ON_COMMAND(ID_PROCESSING_DEBIAS, OnProcessingDebias)
	ON_COMMAND(ID_PROCESSING_WIENER, OnProcessingWiener)
	ON_COMMAND(ID_DIGITIZING_RESIZE_SEGMENTS, OnDigitizingResizeSegments)
	ON_COMMAND(ID_MODEL_SHIFTXZ, OnModelShiftxz)
	ON_COMMAND(ID_DIGITIZING_SELECT_CURRENT, OnDigitizingSelectCurrent)
	ON_COMMAND(ID_DIGITIZING_CHANGEERRORBAR_REDEFINESOURCE, OnDigitizingChangeerrorbarRedefinesource)
	ON_COMMAND(ID_DIGITIZING_ZELTSFORMAT_TOGGLEZPLOT, OnDigitizingZeltsformatTogglezplot)
	ON_COMMAND(ID_EDIT_UNDO, OnEditUndo)
	ON_COMMAND(ID_PROCESSING_CHANGEREDUCEVELOCITYFORBMP, OnProcessingChangereducevelocityforbmp)
	ON_COMMAND(ID_MODELING_MOVEBOUNDARY, OnModelingMoveboundary)
	ON_COMMAND(ID_PROCESSING_CHOPDATA, OnProcessingChopdata)
	ON_COMMAND(ID_VIEW_STACKINGVELOCITYMAP, OnViewStackingvelocitymap)
	ON_COMMAND(ID_TOOLBAR_BIGGER, OnToolbarBiggerAmp)
	ON_COMMAND(ID_TOOLBAR_LESS, OnToolbarLessAmp)
	ON_COMMAND(ID_PROCESSING_APPENDMANYSEGYFILES, OnProcessingAppendmanysegyfiles)
	ON_COMMAND(ID_EDIT_DISPLAYTUNEUP_ADJUSTINGLABELSIZES, OnEditDisplaytuneupAdjustinglabelsizes)
	ON_COMMAND(ID_DIGITIZING_SPLIT, OnDigitizingSplit)
	ON_COMMAND(ID_DIGITIZING_REVISELINELABEL, OnDigitizingReviselinelabel)
	ON_COMMAND(ID_EDIT_LABEL_INSIDE, OnEditLabelInside)
	//}}AFX_MSG_MAP
	// Enable default OLE container implementation
	ON_UPDATE_COMMAND_UI(ID_EDIT_PASTE, COleServerDoc::OnUpdatePasteMenu)
	ON_UPDATE_COMMAND_UI(ID_EDIT_PASTE_LINK, COleServerDoc::OnUpdatePasteLinkMenu)
	ON_UPDATE_COMMAND_UI(ID_OLE_EDIT_CONVERT, COleServerDoc::OnUpdateObjectVerbMenu)
	ON_COMMAND(ID_OLE_EDIT_CONVERT, COleServerDoc::OnEditConvert)
	ON_UPDATE_COMMAND_UI(ID_OLE_EDIT_LINKS, COleServerDoc::OnUpdateEditLinksMenu)
	ON_COMMAND(ID_OLE_EDIT_LINKS, COleServerDoc::OnEditLinks)
	ON_UPDATE_COMMAND_UI(ID_OLE_VERB_FIRST, COleServerDoc::OnUpdateObjectVerbMenu)
	// ON_COMMAND(ID_DIGITIZING_RAYCODES, &CSeisWideDoc::OnDigitizingRaycodes)
	ON_COMMAND(ID_DIGITIZING_SAVEDIGFFID, &CSeisWideDoc::OnDigitizingSavedigffid)
	ON_COMMAND(ID_TIME_FORWIDE, &CSeisWideDoc::OnTimeForwide)
	ON_COMMAND(ID_VIEW_VELOCITYCOLORTWTT, &CSeisWideDoc::OnViewVelocitycolortwtt)
	//ON_COMMAND(ID_TIME_FORWIDE_SEMB, &CSeisWideDoc::OnTimeForwideSemb)
	ON_COMMAND(ID_TIME_FORWIDE_NMOVELOCITY, &CSeisWideDoc::OnTimeForwideNmovelocity)
	ON_COMMAND(ID_VIEW_NMO_VELOCITY, &CSeisWideDoc::OnViewNmoVelocity)
	ON_COMMAND(ID_MODELING_MERGEMODEL, &CSeisWideDoc::OnModelingMergemodel)
	ON_COMMAND(ID_MODELING_GENERATESYNTHETICSEGYDATA, &CSeisWideDoc::OnModelingGeneratesyntheticsegydata)
	ON_COMMAND(ID_MODELING_DOSCONSOL, &CSeisWideDoc::OnModelingDosconsol)
	ON_COMMAND(ID_TIME_TIMESECTIONWITHPERTURBEDTRAVEL, &CSeisWideDoc::OnTimeTimesectionwithperturbedtravel)
	ON_COMMAND(ID_DISPLAYTUNE_OVERWRITEXLABEL, &CSeisWideDoc::OnDisplaytuneOverwritexlabel)
	ON_COMMAND(ID_PROCESSING_TIMEDEPTH_CONV, &CSeisWideDoc::OnProcessingTimedepthConv)
	ON_COMMAND(ID_MODELING_DISPLAYCIRCLE, &CSeisWideDoc::OnModelingDisplaycircle)
	ON_COMMAND(ID_MODELING_ADDSINESHAPE, &CSeisWideDoc::OnModelingAddsineshape)
	ON_COMMAND(ID_PROCESSING_DATADESPIKE, &CSeisWideDoc::OnProcessingDatadespike)
	ON_COMMAND(ID_ACCELERATOR_FONTSIZE, &CSeisWideDoc::OnToolbarPlus)
	ON_COMMAND(ID_ACCELERATOR_FONTMINUS, &CSeisWideDoc::OnToolbarMinus)
	ON_COMMAND(ID_MODELING_DUMPCMP_TWTT, &CSeisWideDoc::OnModelingDumpcmpTwtt)
	ON_COMMAND(ID_PROCESSING_DUMPSEGYLATLONG, &CSeisWideDoc::OnProcessingDumpsegylatlong)
	ON_COMMAND(ID_PROCESSING_DECIMATEDATALINES, &CSeisWideDoc::OnProcessingDecimatedatalines)
	ON_COMMAND(ID_DIGITIZING_ZELT_SWAPSOURCE, &CSeisWideDoc::OnDigitizingZeltSwapsource)
	ON_COMMAND(ID_SEGYCONVERSION_UNIXTOPCCONVERT, &CSeisWideDoc::OnSegyconversionUnixtopcconvert)
	ON_COMMAND(ID_MODELUP, &CSeisWideDoc::OnModelup)
	ON_COMMAND(ID_MODELDOWN, &CSeisWideDoc::OnModeldown)
	ON_COMMAND(ID_EDIT_REDO, &CSeisWideDoc::OnEditRedo)
	ON_COMMAND(ID_MODELING_TOGGLEPEGLET, &CSeisWideDoc::OnModelingTogglepeglet)
	//ON_COMMAND(ID_EDIT_TEXT, &CSeisWideDoc::OnEditText)
	ON_COMMAND(ID_MODELING_TOGGLESWAVELABELS, &CSeisWideDoc::OnModelingToggleswavelabels)
	ON_COMMAND(ID_PROCESSING_DATASPLIT, &CSeisWideDoc::OnProcessingDatasplit)
	ON_COMMAND(ID_PROCESSING_ID_PROCESSING_TRACEDUB, &CSeisWideDoc::OnProcessingIdProcessingTracedub)
	ON_COMMAND(ID_TOOLS_MAPCONVERTTIME, &CSeisWideDoc::OnToolsMapconverttime)
	ON_COMMAND(ID_PROCESSING_SPHERICALCORRECTION, &CSeisWideDoc::OnProcessingSphericalcorrection)
	ON_COMMAND(ID_PROCESSING_CHOPDATA, &CSeisWideDoc::OnProcessingChopdata)
	ON_COMMAND(ID_PROCESSING_ADDDATA, &CSeisWideDoc::OnProcessingAdddata)
	ON_COMMAND(ID_TIME_RMSVELOCITYANALYSIS, &CSeisWideDoc::OnTimeRmsvelocityanalysis)
	ON_COMMAND(ID_Menu_TRACEBALANCING, &CSeisWideDoc::OnMenuProcessingTrcBalancing)
	ON_COMMAND(ID_MODELCONVERSION_RMS_INT_DEPTH, &CSeisWideDoc::OnModelconversionRmsToIntNotUsingModel)
	ON_COMMAND(ID_MODELCONVERSION_RMS_INT_MODELKM, &CSeisWideDoc::OnModelconversionRmsToIntUsingModel)
	ON_COMMAND(ID_MODELCONVERSION_RMS_INT_TWTT, &CSeisWideDoc::OnModelconversionRmsToIntTwtt)
	ON_COMMAND(ID_MODELCONVERSION_TORMSVELOCITY, &CSeisWideDoc::OnModelconversionIntToRmsvelocity)
	ON_COMMAND(ID_MODELCONVERSION_TORMSVELOCITY2, &CSeisWideDoc::OnModelconversionTormsvelocity2)
	ON_COMMAND(ID_SONOBUOY_AUTOCALCULATEOFFSETFROMLAT, &CSeisWideDoc::OnSonobuoyAutocalculateoffsetfromlat)
	ON_COMMAND(ID_SONOBUOY_POLY, &CSeisWideDoc::OnSonobuoyPoly)
	ON_COMMAND(ID_SEGYCONVERSION_IEEETOIBMFLOAT, &CSeisWideDoc::OnSegyconversionIeeetoibmfloat)
	ON_COMMAND(ID_PROCESSING_DATANORMALIZE, &CSeisWideDoc::OnProcessingDatanormalize)
	ON_COMMAND(ID_PROCESSING_FILTER_OFFSETVARYING, &CSeisWideDoc::OnProcessingFilterOffsetvarying)
	ON_COMMAND(ID_SONOBUOY_ASSIGNOFFSETFROMSEGY, &CSeisWideDoc::OnSonobuoyAssignoffsetfromsegy)
	ON_COMMAND(ID_PROCESSING_GAINADJUST, &CSeisWideDoc::OnProcessingGainadjust)
	ON_COMMAND(ID_PROCESSING_TRACESUBTRACTALONGCURVE, &CSeisWideDoc::OnProcessingTracesubtractalongcurve)
	ON_COMMAND(ID_PROCESSING_SPLITODDEVENTRACES, &CSeisWideDoc::OnProcessingSplitoddeventraces)
	ON_COMMAND(ID_REFLECTION_FAULTENHANCING, &CSeisWideDoc::OnReflectionFaultenhancing)
	ON_COMMAND(ID_REFLECTION_COHERENCYPLOT, &CSeisWideDoc::OnReflectionCoherencyplot)
	ON_COMMAND(ID_TOOL_DUMPPOLYNOMIALPOINTS, &CSeisWideDoc::OnToolDumppolynomialpoints)
	ON_COMMAND(ID_WIDE_NMOSTRETCHING, &CSeisWideDoc::OnWideNmostretching)
	ON_COMMAND(ID_Menu_TRACEBALANCE_XT, &CSeisWideDoc::OnMenuTracebalanceXt)
	ON_COMMAND(ID_SONOBUOY_SHIFTTRACENUMBER, &CSeisWideDoc::OnSonobuoyShifttracenumber)
	ON_COMMAND(ID_TOOLS_PICKNEXT, &CSeisWideDoc::OnToolsPicknext)
	ON_COMMAND(ID_PROCESSING_DISTANCEADJUSTMENT, &CSeisWideDoc::OnProcessingDistanceadjustment)
	// ON_COMMAND(ID_REFLECTION_FLATTENBOUNDARY, &CSeisWideDoc::OnReflectionFlattenboundary)
	ON_COMMAND(ID_MODELING_THEORETICALCURVES, &CSeisWideDoc::OnModelingTheoreticalcurves)
	ON_COMMAND(ID_MODEL_PERTURBVEL, &CSeisWideDoc::OnModelPerturbvel)
	ON_COMMAND(ID_MODEL_TOGGLEDETAILS, &CSeisWideDoc::OnModelToggledetails)
	ON_COMMAND(ID_VIEW_GRAVITYCONT2, &CSeisWideDoc::OnViewGravityCont2)
	ON_COMMAND(ID_EDIT_IMAGESTRETCHMODE, &CSeisWideDoc::OnEditImagestretchmode)
	ON_COMMAND(ID_PROCESS_ASCIIHEADER, &CSeisWideDoc::OnProcessAsciiheader)
	ON_COMMAND(ID_PROCESSING_TAUPSLANTSTACK, &CSeisWideDoc::OnProcessingTaupslantstack)
	ON_COMMAND(ID_PROCESSING_TAUPINV, &CSeisWideDoc::OnProcessingTaupinv)
	ON_COMMAND(ID_PROCESSING_TFDN, &CSeisWideDoc::OnProcessingTfdn)
	ON_COMMAND(ID_PROCESSING_SPECTRUM, &CSeisWideDoc::OnProcessingSpectrum)
	ON_COMMAND(ID_MODELING_MAG, &CSeisWideDoc::OnModelingMag)
	ON_COMMAND(ID_IMPORT_BITMAP2SEGY, &CSeisWideDoc::OnBitmap2Segy)
	ON_COMMAND(ID_OFFSET_CHOSENTRACE, &CSeisWideDoc::OnOffsetChosentrace)
	ON_COMMAND(ID_MODELING_GRAVITYMODELING_DENPLOT, &CSeisWideDoc::OnModelingGravitymodelingDenplot)
	ON_COMMAND(ID_SONOBUOY_COPYDATA, &CSeisWideDoc::OnSonobuoyCopydata)
	ON_COMMAND(ID_SONOBUOY_OFFSETJITTERINGREMOVAL, &CSeisWideDoc::OnSonobuoyOffsetjitteringremoval)
	ON_COMMAND(ID_PROCESSING_REVERSERANGE, &CSeisWideDoc::OnProcessingReverserange)
	ON_COMMAND(ID_OPTIONS_TOGGLECLIPCHANGEWITHGAIN, &CSeisWideDoc::OnOptionsToggleclipchangewithgain)
	ON_COMMAND(ID_TOOLS_DUMPLAT, &CSeisWideDoc::OnToolsDumplat)
	ON_COMMAND(ID_MODELTOOLS_GENERATEKML, &CSeisWideDoc::OnModeltoolsGeneratekml)
	ON_COMMAND(ID_SONOBUOY_AUTOINTERPOLATEINVALIDOFFSETS, &CSeisWideDoc::OnSonobuoyAutointerpolateinvalidoffsets)
	ON_COMMAND(ID_RAYTRACE_DEBUG, &CSeisWideDoc::OnRaytraceDebug)
	ON_COMMAND(ID_MODELING_FLATTENHORIZON, &CSeisWideDoc::OnModelingFlattenhorizon)
	ON_COMMAND(ID_WIDE_NORMALIZETRACEINTERVAL, &CSeisWideDoc::OnWideNormalizetraceinterval)
	ON_COMMAND(ID_WIDE_DEFINESRC, &CSeisWideDoc::OnWideDefinesrc)
	ON_COMMAND(ID_TOOLS_CALC_POISSON, &CSeisWideDoc::OnToolsCalcPoisson)
	ON_COMMAND(ID_MODELING_SETHORIZONLIMITSWITHRAYPATHS, &CSeisWideDoc::OnModelingSethorizonlimitswithraypaths)
		ON_COMMAND(ID_REFLECTION_ASSOCIATEKMTOTRACEFROMFILE, &CSeisWideDoc::OnReflectionAssociatekmtotracefromfile)
		ON_COMMAND(ID_DIGITIZE_CURVESTOSEGY, &CSeisWideDoc::OnDigitizeCurvestosegy)
		ON_COMMAND(ID_DIGITIZE_ENDCURVESTOSEGY, &CSeisWideDoc::OnDigitizeEndcurvestosegy)
		ON_COMMAND(ID_DIGITIZE_DEFINE_XVAL, &CSeisWideDoc::OnDigitizeDefineXval)
		ON_COMMAND(ID_MODELTOOLS_DUMPVELOCITYRANGETOKML, &CSeisWideDoc::OnModeltoolsDumpvelocityrangetokml)
		ON_COMMAND(ID_BITMAPS_TIMELINEREMOVAL, &CSeisWideDoc::OnBitmapsTimelineremoval)
		ON_COMMAND(ID_PROCESSING_RESETSAMPLERATE, &CSeisWideDoc::OnProcessingResetsamplerate)
		ON_COMMAND(ID_DIGITIZING_SHOWFILE, &CSeisWideDoc::OnDigitizingShowfile)
		ON_COMMAND(ID_TOOLS_INTERP_INVALID_T0, &CSeisWideDoc::OnToolsInterpInvalidT0)
		ON_COMMAND(ID_DIGITIZING_SWITCHDIGITIZINGFILE, &CSeisWideDoc::OnDigitizingSwitchdigitizingfile)
		ON_COMMAND(ID_DIGITIZING_STARTMARKER, &CSeisWideDoc::OnDigitizingStartmarker)
		ON_COMMAND(ID_FILE_OPENPROJECT, &CSeisWideDoc::OnFileOpenproject)
		ON_COMMAND(ID_FILE_SAVEPROJECT, &CSeisWideDoc::OnFileSaveproject)
		ON_COMMAND(ID_FILE_CLOSEPROJECT, &CSeisWideDoc::OnFileCloseproject)
		ON_COMMAND(ID_REFLECTION_ZT, &CSeisWideDoc::OnReflectionZt)
		ON_COMMAND(ID_WIDE_OFFSETSFROMSRC, &CSeisWideDoc::OnWideOffsetsfromsrc)
		ON_COMMAND(ID_DIGITIZING_SAVEHALFUNCERTAINTY, &CSeisWideDoc::OnDigitizingSavehalfuncertainty)
		
		END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSeisWideDoc construction/destruction

CSeisWideDoc::CSeisWideDoc()
{

	// Use OLE compound files
	EnableCompoundFile();

	//******* for all variables that are not saved in .SEI files, please initiate them in here!!! ******//
	sizeDoc = CSize(200, 200);
	velMod.velSecName = BLANK;
	velMod.flFloatNameOld = BLANK;


	//char* rh[11] = {
	//	"00", "00", "33", "99", "CA", "FF", "FF", "FF", "FF", "FE", "FE"
	//};
	//char* gh[11] = {
	//	"66", "99", "99", "CC", "CB", "FF", "FE", "FF", "CA", "43", "00"
	//};
	//char* bh[11] = {
	//	"CC", "FF", "FF", "FF", "FF", "FF", "C9", "98", "65", "41", "00"
	//};


}

CSeisWideDoc::~CSeisWideDoc()
{
	raypaths.freeRaypathsAll();
	raypathsTwtt.freeRaypathsAll();

	if (bmp24.ximage)
		delete bmp24.ximage;

	this->velMod.freeFlArrays();

	CSegyMeta::segyHeadFree(&head);

	if (cd.coord.isSwapX) {
		CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
		pFrame->statMain.isSwapXActive = FALSE;
	}
	dig.freeDigAll();
	digMarker.freeDigAll();
}

CSeisWideDoc * CSeisWideDoc::GetDoc()
{ // added by Deping to allow getting doc pointer from anywhere.
	CMDIChildWnd * pChild = ((CMDIFrameWnd*)(AfxGetApp()->m_pMainWnd))->MDIGetActive();
	if (!pChild) return NULL;
	CDocument * pDoc = pChild->GetActiveDocument();
	if (!pDoc) return NULL;

	return (CSeisWideDoc *)pDoc;
}


/////////////////////////////////////////////////////////////////////////////
// CSeisWideDoc server implementation

COleServerItem* CSeisWideDoc::OnGetEmbeddedItem()
{
	// OnGetEmbeddedItem is called by the framework to get the COleServerItem
	//  that is associated with the document.  It is only called when necessary.

	CSeisWideSrvrItem* pItem = new CSeisWideSrvrItem(this);
	ASSERT_VALID(pItem);
	return pItem;
}

/////////////////////////////////////////////////////////////////////////////
// CSeisWideDoc serialization

void CSeisWideDoc::Serialize(CArchive& ar)
{
	BOOL aBool = FALSE;
	byte aByte = (byte)0;
	int anInt = 1;  // disabled
	float aFloat = 0.f; // diabled 
	double aDouble = 0.;
	CString aName = BLANK; // disabled

	TRY
	{
		if (ar.IsStoring())
		{
			// now do the saving
			ar << areaFill.clip;
			ar << (int)cd.coord.isFaceUp;  // must be casted to int otherwise the SEI file cannot be read
			ar << areaFill.fillOff;
			ar << areaFill.gain;
			ar << draw.gainDist;
			ar << draw.baseGain;
			ar << draw.basePower;
			ar << cd.coord.isDistanceDisplay;
			ar << draw.distShift;
			ar << aBool;
			ar << cd.coord.trace1;
			ar << cd.coord.trace2;
			ar << tx.xShotRay;
			ar << cd.coord.m_tmax;
			ar << cd.coord.m_tmin;
			ar << draw.isRayShowing;
			ar << cd.coord.tTick;
			ar << draw.red.getVred(); // (draw.red.rvred == 0. ? 0. : 1. / draw.red.rvred);
			ar << draw.wiggle;
			ar << cd.coord.xmax;
			ar << cd.coord.xmin;
			ar << cd.coord.xTick;
			 
			ar << velColor.dz;
			ar << cd.coord.m_zmax;
			ar << cd.coord.m_zmin;
			ar << cd.coord.zTick;
			ar << velColor.dv;	//not used in version 2.0
			ar << velColor.dxVDesired;
			ar << velColor.vmin;
			ar << velColor.vmid;
			ar << velColor.vmax;

			ar << velColor.vminR;
			ar << velColor.vminG;
			ar << velColor.vminB;
			ar << velColor.vmidR;
			ar << velColor.vmidG;
			ar << velColor.vmidB;
			ar << velColor.vmaxR;
			ar << velColor.vmaxG;
			ar << velColor.vmaxB;

			ar << draw.timeSecName;
			ar << draw.depthSecName;
			ar << velMod.velSecName;
			ar << draw.plotTitle;
			ar << velColor.vmidR9; // replaced by newer integer on Aug. 12, 2020
			ar << draw.iLayerFocus;
			ar << velColor.vmidG9; // replaced by newer integer on Aug. 12, 2020
			ar << cd.coord.drawmode;
			ar << velColor.vmidB9; // replaced by newer integer on Aug. 12, 2020
			ar << draw.nodeMode;
			ar << anInt;
			ar << draw.printX;
			ar << draw.printY;
			ar << draw.rayName;
			ar << anInt;

			//These are additions in version 2.0
			ar << draw.isColBar;
			ar << aBool;
			ar << velColor.cxExt;
			ar << velColor.cxPos;
			ar << velColor.cyExt;
			ar << velColor.cyPos;
			ar << velColor.vmid2;
			ar << velColor.vmid3;
			ar << velColor.vmid4;
			ar << velColor.vmidB2;
			ar << velColor.vmidB3;
			ar << velColor.vmidB4;
			ar << velColor.vmidG2;
			ar << velColor.vmidG3;
			ar << velColor.vmidG4;
			ar << velColor.vmidR2;
			ar << velColor.vmidR3;
			ar << velColor.vmidR4;
			ar << velColor.vmid9; // replaced by newer double on Aug. 12, 2020
			ar << aDouble;
			ar << aDouble;
			ar << aDouble;
			ar << velColor.dv1;


			ar << seisBiColor2.maxAmpR;
			ar << seisBiColor2.maxAmpG;
			ar << seisBiColor2.maxAmpB;
			ar << seisBiColor2.negAmpR;
			ar << seisBiColor2.negAmpG;
			ar << seisBiColor2.negAmpB;
			ar << aByte;
			ar << aByte;
			ar << cd.coord.isFaceUp;
			ar << aByte;
			ar << anInt;
			ar << anInt;
			//aFloat = (float)velMod.wells[0].wellDist;
			ar << draw.xWell;

			//Version 3.2 should save the following:
			ar << draw.velSecNamesEx;
			ar << aBool;  // disabled
			//These parameters are for KD Migration
			ar << kd.ek;
			ar << kd.npv;
			ar << kd.amax;
			ar << kd.amin;
			ar << kd.da;
			ar << kd.doff;
			ar << kd.angmax;
			ar << kd.dzt;
			ar << kd.dzv;
			ar << kd.dxm;
			ar << kd.dxv;
			ar << kd.dxt;
			ar << kd.dxo;
			ar << kd.fa;
			ar << kd.fac;
			ar << kd.na;
			ar << kd.tmaxRay;
			ar << kd.dt;
			ar << kd.ns;
			ar << kd.ls;
			ar << kd.off0;
			ar << kd.offmax;
			ar << kd.v0;
			ar << kd.dvz;
			ar << kd.ds;
			ar << kd.fmax;
			ar << kd.aperx;
			ar << kd.memMax;

			ar << aFloat;
			ar << cd.coord.isSwapYLabel; //this is for ActiveX for not auto adjusting shotstep.

			//The following is only for spacial mapping in OnModelingExtractlayerinfor() .

			ar << draw.red.waterVelocityAboveObs;  // 
			ar << draw.ampPower;
			ar << aFloat;  // added Jan. 21, 2019
			ar << aFloat;  // disabled

			ar << bmp24.bmpName;
			ar << bmp24.xmin;
			ar << bmp24.xmax;
			ar << bmp24.ymin;
			ar << bmp24.ymax;
			ar << draw.isNoHorzGrid;  // disabled

			// ver. 4.2
			ar << dig.zeltBarForm; //For wide-angle error bars: 0=bar; 1=Circle (open); 2=Circle (filled); 3=Star.
			ar << anInt;  // disabled in saving
			//ar << draw.labelAsTWTT;
			ar << cd.coord.isSwapX;
			ar << draw.isNoOutSidePoints;
			ar << draw.isNoHorzGrid;  // depreciated
			ar << velMod.flFloatName;

			// ver 4.6.5--sept. 2006
			ar << draw.strYLabelOverwrite; // disabled
			ar << draw.logScaleThreshold;
			ar << areaFill.isNegativeFill;
			ar << digMarker.digName; // this one was missed before

			// v4.6.7--nov 2006
			ar << draw.txRaytraceName;
			ar << dig.digName;

			// v5.6--Feb 11, 2009
			ar << draw.red.targetDepth;

			// Apr 22, 2009
			ar << draw.strXLabelOverwrite;


			// June 24, 2010
			ar << anInt;   // added June 14, 2010
			ar << anInt;  // disabled   
			ar << draw.red.obsDepth;	//this initilizes for hydro display.


			ar << draw.red.gunDepth;  // added Feb 2008, later disabled and brought back to live on Nov 2011
			ar << draw.sphericOrder;
			ar << draw.attenuationCorr;     // added Oct. 2008
			ar << draw.attenuationSeafloor; // added Oct. 2008

			ar << draw.vrmsTauNameDisabled; // added Jan. 2011
			ar << aBool;

			// additions Sept. 2011
			ar << velColor.vmid5;
			ar << velColor.vmid6;
			ar << velColor.vmid7;
			ar << velColor.vmid8;
			ar << velColor.vmidR5;
			ar << velColor.vmidG5;
			ar << velColor.vmidB5;
			ar << velColor.vmidR6;
			ar << velColor.vmidG6;
			ar << velColor.vmidB6;
			ar << velColor.vmidR7;
			ar << velColor.vmidG7;
			ar << velColor.vmidB7;
			ar << velColor.vmidR8;
			ar << velColor.vmidG8;
			ar << velColor.vmidB8;

			// additions Dec. 7, 2012
			ar << velColor.colBarVmin;
			ar << velColor.colBarVmax;

			// additions Dec. 16, 2012
			ar << dig.transXMultFactor;
			ar << dig.transXShift;
			ar << dig.transYMultFactor;
			ar << dig.transYShift;
			ar << dig.transIsRevYAxis;
		}
		else
		{
			ULONGLONG lenCur;
			CFile* file = ar.GetFile();
			//	if (file!=NULL && !file->IsSerializable()) return; // this avoid crash problem

			ULONGLONG lenTot = file->GetLength();
			file->Seek(0, CFile::begin);

			ar >> areaFill.clip;
			ar >> anInt;
			// cd.coord.isFaceUp = iTopBound != 0;
			ar >> areaFill.fillOff;
			ar >> areaFill.gain;
			ar >> draw.gainDist;
			ar >> draw.baseGain;
			ar >> draw.basePower;
			ar >> cd.coord.isDistanceDisplay;
			ar >> draw.distShift;
			ar >> aBool;
			//cd.coord.isMinusXShot;
			//if (abs(cd.coord.isMinusXShot) > 1) cd.coord.isMinusXShot = FALSE; // it happens to invalid somtimes
			ar >> cd.coord.trace1;
			ar >> cd.coord.trace2;
			ar >> tx.xShotRay;
			ar >> cd.coord.m_tmax;
			ar >> cd.coord.m_tmin;
			ar >> draw.isRayShowing;
			ar >> cd.coord.tTick;
			
			ar >> aDouble; // note: this read in number is actually a velocity!
			if (isFloatEqual3((float)aDouble, 0.f))
				draw.red.rvred = 0.;
			else 
				draw.red.rvred = 1. / aDouble;
			ar >> draw.wiggle;
			ar >> cd.coord.xmax;
			ar >> cd.coord.xmin;
			ar >> cd.coord.xTick;

			ar >> velColor.dz;
			ar >> cd.coord.m_zmax;
			ar >> cd.coord.m_zmin;
			ar >> cd.coord.zTick;
			ar >> velColor.dv;	//not used in version 2.0
			if (velColor.dv < 0.000001 || velColor.dv > 9.) velColor.dv = 0.01;
			ar >> velColor.dxVDesired; // velColor.dxV = 0.0001;  // this should be reset everytime
			ar >> velColor.vmin;
			ar >> velColor.vmid;
			ar >> velColor.vmax;

			ar >> velColor.vminR;
			ar >> velColor.vminG;
			ar >> velColor.vminB;
			ar >> velColor.vmidR;
			ar >> velColor.vmidG;
			ar >> velColor.vmidB;
			ar >> velColor.vmaxR;
			ar >> velColor.vmaxG;
			ar >> velColor.vmaxB;

			//	lenCur = file->Seek(0, CFile::current);

			ar >> draw.timeSecName;
			ar >> draw.depthSecName;
			ar >> velMod.velSecName;
			ar >> draw.plotTitle;
			ar >> velColor.vmidR9; // replaced by newer integer on Aug. 12, 2020
			ar >> draw.iLayerFocus;
			ar >> velColor.vmidG9; // replaced by newer integer on Aug. 12, 2020
			ar >> cd.coord.drawmode;
			ar >> velColor.vmidB9; // replaced by newer integer on Aug. 12, 2020
			ar >> draw.nodeMode;
			ar >> anInt;
			ar >> draw.printX;
			ar >> draw.printY;
			ar >> draw.rayName;
			ar >> anInt;

			//These are additions in version 2.0

			ar.Flush();
			lenCur = file->Seek(0, CFile::current);
			if (lenCur >= lenTot - 4)
			{
				extraSerialize();
				goto FileEndSudden;
			}
			ar >> draw.isColBar;

			ar.Flush();
			lenCur = file->Seek(0, CFile::current);
			if (lenCur >= lenTot - 4)
			{
				extraSerialize();
				goto FileEndSudden;
			}
			ar >> aBool;

			ar >> velColor.cxExt;
			ar >> velColor.cxPos;
			ar >> velColor.cyExt;
			ar >> velColor.cyPos;
			ar >> velColor.vmid2;
			ar >> velColor.vmid3;
			ar >> velColor.vmid4;
			ar >> velColor.vmidB2;
			ar >> velColor.vmidB3;
			ar >> velColor.vmidB4;
			ar >> velColor.vmidG2;
			ar >> velColor.vmidG3;
			ar >> velColor.vmidG4;
			ar >> velColor.vmidR2;
			ar >> velColor.vmidR3;
			ar >> velColor.vmidR4;

			//These to upgrade to 2.1 version.
			ar >> velColor.vmid9; // replaced by newer double on Aug. 12, 2020

			ar >> aDouble;
			ar >> aDouble;
			ar >> aDouble;
			ar >> velColor.dv1;

			ar >> seisBiColor2.maxAmpR;
			ar >> seisBiColor2.maxAmpG;
			ar >> seisBiColor2.maxAmpB;
			ar >> seisBiColor2.negAmpR;
			ar >> seisBiColor2.negAmpG;
			ar >> seisBiColor2.negAmpB;

			// 4 lines not used
			ar >> aByte;
			ar >> aByte;
			ar >> cd.coord.isFaceUp;
			ar >> aByte;
			ar >> anInt;
			ar >> anInt;
			
			ar >> draw.xWell; 
			if (draw.xWell < -9999.f || draw.xWell>9999.f) draw.xWell = ERRORVAL; // fixup invalid cases

			//Version 3.2 should save the following:
			ar.Flush();
			lenCur = file->Seek(0, CFile::current);
			if (lenCur >= lenTot - 4) goto FileEndSudden;
			ar >> draw.velSecNamesEx;

			ar.Flush();
			lenCur = file->Seek(0, CFile::current);
			if (lenCur >= lenTot - 4) goto FileEndSudden;
			ar >> aBool;  // disabled in saving

			//These parameters are for KD Migration
			ar.Flush();
			lenCur = file->Seek(0, CFile::current);
			if (lenCur >= lenTot - 4) goto FileEndSudden;
			ar >> kd.ek;

			ar.Flush();
			lenCur = file->Seek(0, CFile::current);
			if (lenCur >= lenTot - 4) goto FileEndSudden;
			ar >> kd.npv;

			ar >> kd.amax;
			ar >> kd.amin;
			ar >> kd.da;
			ar >> kd.doff;
			ar >> kd.angmax;
			ar >> kd.dzt;
			ar >> kd.dzv;
			ar >> kd.dxm;
			ar >> kd.dxv;
			ar >> kd.dxt;
			ar >> kd.dxo;
			ar >> kd.fa;
			ar >> kd.fac;
			ar >> kd.na;
			ar >> kd.tmaxRay;
			ar >> kd.dt;
			ar >> kd.ns;
			ar >> kd.ls;
			ar >> kd.off0;
			ar >> kd.offmax;
			ar >> kd.v0;
			ar >> kd.dvz;
			ar >> kd.ds;
			ar >> kd.fmax;
			ar >> kd.aperx;
			ar >> kd.memMax;

			ar.Flush();
			lenCur = file->Seek(0, CFile::current);
			if (lenCur >= lenTot - 4) goto FileEndSudden;
			ar >> aFloat;

			ar.Flush();
			lenCur = file->Seek(0, CFile::current);
			if (lenCur >= lenTot - 4) goto FileEndSudden;
			ar >> cd.coord.isSwapYLabel; //this is for ActiveX for not auto adjusting shotstep.

			//The following is only for spacial mapping in OnModelingExtractlayerinfor() .
			ar.Flush();
			lenCur = file->Seek(0, CFile::current);
			if (lenCur >= lenTot - 4)
			{
				//xx1 = 0.f;
				//xx2 = 0.f;
				//yy1 = 0.f;
				//yy2 = 0.f;
				goto FileEndSudden;
			}
			ar >> draw.red.waterVelocityAboveObs;
			if (draw.red.waterVelocityAboveObs < 1.3f || draw.red.waterVelocityAboveObs>1.55f)
				draw.red.waterVelocityAboveObs = 1.44f;
			ar >> draw.ampPower;
			if (draw.ampPower < 0.1f || draw.ampPower > 7.9f)
				draw.ampPower = 1.f; // this means it is invalid. We want this verification since this .SEI file location was used for other purpose before
			// there is a catch: sometimes it is 8.0, after reading, maybe it is from old value of pseudo wells?

			//the following is new additions on Sept. 29.
			TRY{
				ar >> aFloat;  // added Jan. 21, 2019

				ar >> aFloat;
				ar >> bmp24.bmpName;
				ar >> bmp24.xmin;
				ar >> bmp24.xmax;
				ar >> bmp24.ymin;
				ar >> bmp24.ymax;
				ar >> aBool;  // disabled
				ar >> dig.zeltBarForm; //For wide-angle error bars: 0=bar; 1=Circle (open); 2=Circle (filled); 3=Star.
	
				// this can cause problem after we switch from ascii to Unicode
				ar >> anInt; // disabled in saving
				ar >> cd.coord.isSwapX;
				ar >> draw.isNoOutSidePoints;
				ar >> aBool;  // disabled
				ar >> velMod.flFloatName;

				// additions on Sept, 2006
				ar >> draw.strYLabelOverwrite;
				ar >> draw.logScaleThreshold;

				// additions on Oct, 2006
				ar >> areaFill.isNegativeFill;
				ar >> digMarker.digName; // this one was missed before

				// v4.6.7--nov 2006
				ar >> draw.txRaytraceName;

				ar >> dig.digName;
				ar >> draw.red.targetDepth;

			} // TRY 
				CATCH_ALL(e)
			{
				goto FileEndSudden;
			}
			END_CATCH_ALL
				


			// added apr 22, 2009
			TRY{
				// this can cause problem after we switch from ascii to Unicode
				ar >> draw.strXLabelOverwrite;

				// added June 24, 2010
				ar >> anInt;   // added June 14, 2010
				ar >> anInt;     // disabled
				ar >> draw.red.obsDepth;	//this initilizes for hydro display.
				ar >> draw.red.gunDepth; // para.gunDepth;  // added Feb 2008
				ar >> draw.sphericOrder;
				ar >> draw.attenuationCorr;     // added Oct. 2008
				ar >> draw.attenuationSeafloor; // added Oct. 2008

				// added Jan , 2011
				ar >> draw.vrmsTauNameDisabled;

				// added Jan 30, 2011
				ar >> aBool;

				// added Sept 26, 2011
				ar >> velColor.vmid5;
				ar >> velColor.vmid6;
				ar >> velColor.vmid7;
				ar >> velColor.vmid8;
				ar >> velColor.vmidR5;
				ar >> velColor.vmidG5;
				ar >> velColor.vmidB5;
				ar >> velColor.vmidR6;
				ar >> velColor.vmidG6;
				ar >> velColor.vmidB6;
				ar >> velColor.vmidR7;
				ar >> velColor.vmidG7;
				ar >> velColor.vmidB7;
				ar >> velColor.vmidR8;
				ar >> velColor.vmidG8;
				ar >> velColor.vmidB8;
			} // TRY 
				CATCH_ALL(e)
			{
				goto FileEndSudden;
			}
			END_CATCH_ALL


			// additions Dec. 7, 2012
			ar.Flush();
			lenCur = file->Seek(0, CFile::current);
			if (lenCur >= lenTot - 4) {
				velColor.colBarVmin = 1.5f;
				velColor.colBarVmax = 8.f;
			}
			else {
				ar >> velColor.colBarVmin;
				ar >> velColor.colBarVmax;
			}


			// additions Dec. 16, 2012
			ar.Flush();
			lenCur = file->Seek(0, CFile::current);
			if (lenCur >= lenTot - 4) {
				// no need to set since they are initial values
			}
			else {
				ar >> dig.transXMultFactor;
				ar >> dig.transXShift;
				ar >> dig.transYMultFactor;
				ar >> dig.transYShift;
				ar >> dig.transIsRevYAxis;
			}


			goto FileEndNormal;

		FileEndSudden:
			draw.logScaleThreshold = 70;

			bmp24.bmpName = BLANK;
			bmp24.xmin = (float)cd.coord.xmin;
			bmp24.xmax = (float)cd.coord.xmax;
			bmp24.ymin = (float)cd.coord.m_tmin;
			bmp24.ymax = (float)cd.coord.m_tmax;
			//	bmp24.isDepth = FALSE;

			dig.digName = BLANK;
			dig.zeltBarForm = 0; //For wide-angle error bars: 0=bar; 1=Circle (open); 2=Circle (filled); 3=Star.
			draw.distShift = 0.f;
			draw.isNoOutSidePoints = FALSE;
			digMarker.digName = BLANK; // this one was missed before
			draw.txRaytraceName = BLANK;
			draw.strXLabelOverwrite = BLANK;
			draw.strYLabelOverwrite = BLANK;
			digMarker.digName = BLANK;
			cd.coord.isSwapX = FALSE; // if the SEI reading not normally finished, we do not want the window to XSwap
			areaFill.isNegativeFill = FALSE;

			velColor.cxPos = 0.;
			velColor.cyPos = 0.;
			velColor.cxExt = 8.;
			velColor.cyExt = 1.;
			velColor.dv = .1;
			velColor.dxVDesired = .1;

			velColor.vmin = 1.6;
			velColor.vmid = 2.;
			velColor.vmid2 = 3.;
			velColor.vmid3 = 4.5;
			velColor.vmid4 = 5.0;
			velColor.vmid5 = 5.5;
			velColor.vmid6 = 6.2;
			velColor.vmid7 = 6.7;
			velColor.vmid8 = 7.3;
			velColor.vmax = 8.2;

			velColor.vminR = 255;
			velColor.vmidR = 234;
			velColor.vmidR2 = 181;
			velColor.vmidR3 = 192;
			velColor.vmidR4 = 255;
			velColor.vmidR5 = 255;
			velColor.vmidR6 = 255;
			velColor.vmidR7 = 255;
			velColor.vmidR8 = 255;
			velColor.vmaxR = 217;

			velColor.vminG = 255;
			velColor.vmidG = 255;
			velColor.vmidG2 = 255;
			velColor.vmidG3 = 245;
			velColor.vmidG4 = 235;
			velColor.vmidG5 = 220;
			velColor.vmidG6 = 198;
			velColor.vmidG7 = 171;
			velColor.vmidG8 = 142;
			velColor.vmaxG = 179;

			velColor.vminB = 0;
			velColor.vmidB = 0;
			velColor.vmidB2 = 0;
			velColor.vmidB3 = 103;
			velColor.vmidB4 = 205;
			velColor.vmidB5 = 178;
			velColor.vmidB6 = 140;
			velColor.vmidB7 = 132;
			velColor.vmidB8 = 140;
			velColor.vmaxB = 255;

			// additions Dec. 7, 2012
			velColor.colBarVmin = 1.5f;
			velColor.colBarVmax = 8.f;

			velMod.flFloatName = BLANK;

		FileEndNormal:
			if (draw.logScaleThreshold < 5 || draw.logScaleThreshold>100)
				draw.logScaleThreshold = 70;  // old file may have invalid logScaleThreshold values

			// all other initializations are moved to OnOpenDocument()
		} // else
	} // TRY 
		CATCH_ALL(e)
	{
		AfxMessageBox(_T("Failed loading."), MB_ICONQUESTION);
		return;
	}
	END_CATCH_ALL
		// Calling the base class COleServerDoc enables serialization
		//  of the container document's COleClientItem objects.
		// COleServerDoc::Serialize(ar);
}

/////////////////////////////////////////////////////////////////////////////
// CSeisWideDoc diagnostics

#ifdef _DEBUG
void CSeisWideDoc::AssertValid() const
{
	COleServerDoc::AssertValid();
}

void CSeisWideDoc::Dump(CDumpContext& dc) const
{
	COleServerDoc::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CSeisWideDoc commands
void CSeisWideDoc::OnViewBoth()
{
	if (dig.isDigitizing && (cd.coord.drawmode < 1 || (cd.coord.drawmode>4 && cd.coord.drawmode < 10)))
	{
		AfxMessageBox(_T(" Quit digitizing and then you can switch to depth domain."), MB_OK | MB_ICONINFORMATION| MB_ICONQUESTION);
		return;
	}

	cd.coord.drawmodeOld = cd.coord.drawmode;
	cd.coord.drawmode = 3;
	draw.isNodeChanged = FALSE;
	if (!myParas())
	{
		draw.isNodeChanged = TRUE;
		cd.coord.drawmode = cd.coord.drawmodeOld;
		return;
	}

	//if (cd.coord.drawmodeOld == 9) {
	//	// the user likely changed the model in tm[] and we now need to re-calc the zm[] array
	//	myModel_TWTT_Depth(&velMod, (float)velColor.dz);
	//}

//	if (isTimeDomainUtil(cd.coord.drawmodeOld)) draw.depthSecOld = BLANK;
	//this enforces re-initilize amplitude parameters 
	// for depth sections.

	cd.coord.drawmode = 3;	//Both velocity color and depth sections will be drawn.
	draw.isSameDataDisplay = FALSE; //indicate display has been changed and will re-load all data in OnDraw().
	SetModifiedFlag();
	UpdateAllViews(NULL);
	NotifyChanged();

}

void CSeisWideDoc::OnViewContours()
{
	if (dig.isDigitizing && (cd.coord.drawmode < 1 || (cd.coord.drawmode>4 && cd.coord.drawmode < 10)))
	{
		AfxMessageBox(_T(" Quit digitizing and then you can switch to depth domain."), MB_OK | MB_ICONINFORMATION| MB_ICONQUESTION);
		return;
	}
	cd.coord.drawmodeOld = cd.coord.drawmode;
	cd.coord.drawmode = 4;	//Velocity contours will be drawn.
	draw.isNodeChanged = FALSE;
	if (!myParas()) {
		draw.isNodeChanged = TRUE;
		cd.coord.drawmode = cd.coord.drawmodeOld;
		return;
	}

//	if (isTimeDomainUtil(cd.coord.drawmodeOld)) draw.depthSecOld = BLANK;
	draw.isNodeChanged = TRUE;	//when draw.isDigitizing=TRUE, this ensures
	//that a new time section plot instruction
	//gets passed thru the OnDraw(). A mouse click
	//will set this to FALSE again in digitize mode.
	draw.isSameDataDisplay = FALSE; //indicate display has been changed and will re-load all data in OnDraw().

	SetModifiedFlag();
	UpdateAllViews(NULL);
	NotifyChanged();
}

void CSeisWideDoc::OnViewStackingvelocitymap()
{
	// is this accessble???
	if (dig.isDigitizing && (cd.coord.drawmode < 1 || (cd.coord.drawmode>4 && cd.coord.drawmode < 10))) {
		AfxMessageBox(_T(" Quit digitizing and then you can switch to depth domain."), MB_OK | MB_ICONINFORMATION| MB_ICONQUESTION);
		return;
	}
	cd.coord.drawmodeOld = cd.coord.drawmode;
	cd.coord.drawmode = 8;	//stacking Velocity contours will be drawn.
	if (!myParas())
	{
		cd.coord.drawmode = cd.coord.drawmodeOld;
		return;
	}

	draw.isSameDataDisplay = FALSE; //indicate display has been changed and will re-load all data in OnDraw().

	SetModifiedFlag();
	UpdateAllViews(NULL);
	NotifyChanged();
}

void CSeisWideDoc::OnViewTimesection()
{
	if (dig.isDigitizing && !isTimeDomainUtil(cd.coord.drawmodeOld)) {
		AfxMessageBox(_T(" Quit digitizing and then you can switch to time domain."), MB_OK | MB_ICONINFORMATION| MB_ICONQUESTION);
		return;
	}

	if (!myParas()) {
		return;
	}

	draw.isSameDataDisplay = FALSE; //indicate display has been changed and will re-load all data.
	cd.coord.drawmode = 0;	//Time section will be drawn.
	cd.coord.drawmodeOld = cd.coord.drawmode;
	SetModifiedFlag();
	UpdateAllViews(NULL);
	NotifyChanged();
}

void CSeisWideDoc::OnViewTimesectrc()
{
	if (dig.isDigitizing && (cd.coord.drawmode > 0 && cd.coord.drawmode < 5)) {
		AfxMessageBox(_T("Sorry, you may exit digitizing and then you may switch to time domain."), MB_OK | MB_ICONINFORMATION| MB_ICONQUESTION);
		return;
	}

	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	if (isFileExistNotDirectory(bmp24.bmpName))  {
		CdlgBmpByTrace dlg;
		dlg.m_shot1 = cd.coord.trace1;
		dlg.m_shot2 = cd.coord.trace2;
		dlg.m_tmax = (float)cd.coord.m_tmax;
		dlg.m_tmin = (float)cd.coord.m_tmin;
		dlg.m_isSwapX = cd.coord.isSwapX;
		if (dlg.DoModal() == IDOK) {
			cd.coord.trace1 = dlg.m_shot1;
			cd.coord.trace2 = dlg.m_shot2;
			cd.coord.m_tmax = dlg.m_tmax;
			cd.coord.m_tmin = dlg.m_tmin;

			if (dlg.m_isSwapX != cd.coord.isSwapX) {
				// will need to change the mainframe status
				CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
				pFrame->statMain.isSwapXActive = dlg.m_isSwapX;

			}
			cd.coord.isSwapX = dlg.m_isSwapX;
		}
		else {
			return;
		}
	}
	else {
		CdlgTimeByTrc dlg;
		dlg.m_timeSecName = draw.timeSecName;

		dlg.m_clip = areaFill.clip;
		dlg.m_faceDown = cd.coord.isFaceUp;
		dlg.m_gain = areaFill.gain;
		if (fabs(areaFill.fillOff) > 10.) areaFill.fillOff = 0.1;
		dlg.m_fillOff = areaFill.fillOff;
		dlg.m_shot1 = cd.coord.trace1;
		dlg.m_shot2 = cd.coord.trace2;
		dlg.m_timeSecTitle = draw.plotTitle;
		dlg.m_wiggle = draw.wiggle;

		dlg.m_tmax = (float)cd.coord.Y2();
		dlg.m_tmin = (float)cd.coord.m_tmin;
		dlg.m_tTick = (float)cd.coord.tTick;
		//	dlg.m_colPalette = GetPathFromFile(draw.timeSecName) + _T("colPalette.txt");

		dlg.seisBiColor.maxAmpR = seisBiColor2.maxAmpR;
		dlg.seisBiColor.maxAmpG = seisBiColor2.maxAmpG;
		dlg.seisBiColor.maxAmpB = seisBiColor2.maxAmpB;
		dlg.seisBiColor.negAmpR = seisBiColor2.negAmpR;
		dlg.seisBiColor.negAmpG = seisBiColor2.negAmpG;
		dlg.seisBiColor.negAmpB = seisBiColor2.negAmpB;
		//dlg.m_isAvgAmp = draw.isAvgEnergy;
		dlg.m_ampPower = draw.ampPower;
		dlg.m_isSwapX = cd.coord.isSwapX;
		dlg.m_vred = (float)draw.red.getVred(); // if (dlg.m_vred != 0.) dlg.m_vred = 1.f / dlg.m_vred;
		dlg.m_logScaleThreshold = draw.logScaleThreshold;
		if (dlg.DoModal() == IDOK) {
			draw.plotTitle = dlg.m_timeSecTitle;
			areaFill.clip = dlg.m_clip;
			cd.coord.isFaceUp = dlg.m_faceDown != 0;
			areaFill.gain = dlg.m_gain;
			areaFill.fillOff = dlg.m_fillOff;
			cd.coord.trace1 = dlg.m_shot1;
			cd.coord.trace2 = dlg.m_shot2;
			draw.wiggle = dlg.m_wiggle;

			draw.timeSecName = dlg.m_timeSecName.Trim();
			cd.coord.m_tmax = dlg.m_tmax;
			cd.coord.m_tmin = dlg.m_tmin;
			cd.coord.tTick = dlg.m_tTick;

			draw.tstart = dlg.m_tstart;
			draw.overWrite = dlg.m_overWrite;

			draw.logScaleThreshold = dlg.m_logScaleThreshold;
			if (draw.logScaleThreshold < 0) draw.logScaleThreshold = 0;
			else if (draw.logScaleThreshold > 100) draw.logScaleThreshold = 100;

			seisBiColor2.maxAmpR = dlg.seisBiColor.maxAmpR;
			seisBiColor2.maxAmpG = dlg.seisBiColor.maxAmpG;
			seisBiColor2.maxAmpB = dlg.seisBiColor.maxAmpB;
			seisBiColor2.negAmpR = dlg.seisBiColor.negAmpR;
			seisBiColor2.negAmpG = dlg.seisBiColor.negAmpG;
			seisBiColor2.negAmpB = dlg.seisBiColor.negAmpB;
			//draw.isAvgEnergy = dlg.m_isAvgAmp;
			draw.ampPower = dlg.m_ampPower;
			if (dlg.m_isSwapX != cd.coord.isSwapX) {
				// will need to change the mainframe status
				pFrame->statMain.isSwapXActive = dlg.m_isSwapX;

			}
			cd.coord.isSwapX = dlg.m_isSwapX;
			double rvred = dlg.m_vred == 0. ? 0. : 1. / dlg.m_vred;
			draw.red.rvred = rvred;
		}
		else {
			cd.coord.drawmode = cd.coord.drawmodeOld;  // the action was canceled by the user
			return;
		}
	}


	cd.coord.drawmodeOld = cd.coord.drawmode;
	cd.coord.drawmode = 6;
	if (cd.coord.trace2 < cd.coord.trace1)  {
		pFrame->myCaption(_T("trace2 is smaller than trace1, please check!"));
		int ibak = cd.coord.trace1;
		cd.coord.trace1 = cd.coord.trace2;
		cd.coord.trace2 = ibak;
	}

	if (cd.coord.trace2 == cd.coord.trace1)
		cd.coord.trace2 = cd.coord.trace1 + 100;
	if (cd.coord.Y2() <= cd.coord.Y1())
		cd.coord.m_tmax = cd.coord.Y1() + 8.;
	
	cd.coord.tTick = getTickRounded(cd.coord.Y1(), cd.coord.Y2(), 2, 8, 1.0);

	cd.coord.isDistanceDisplay = FALSE; // this is important  

	draw.red.rvred = 0.;
	draw.isSameDataDisplay = FALSE; //internal control and not saved.
	SetModifiedFlag();
	UpdateAllViews(NULL);
	NotifyChanged();

}

void CSeisWideDoc::OnViewHydro()
{
	if (dig.isDigitizing && (cd.coord.drawmode > 0 && cd.coord.drawmode < 5)) {
		AfxMessageBox(_T(" You are still digitizing in depth "), MB_OK | MB_ICONINFORMATION| MB_ICONQUESTION);
		return;
	}

	cd.coord.drawmodeOld = cd.coord.drawmode;
	cd.coord.drawmode = 7;	//Hydro Time section will be drawn.

	CdlgHydrateDisp dlg;
	dlg.m_clip = areaFill.clip;
	dlg.m_faceDown = cd.coord.isFaceUp;
	dlg.m_isSwapX = cd.coord.isSwapX;
	dlg.m_isSwapYLabel = cd.coord.isSwapYLabel;
	dlg.m_gain = areaFill.gain;
	if (fabs(areaFill.fillOff) > 10.) areaFill.fillOff = 0.001;
	dlg.m_fillOff = areaFill.fillOff;
	dlg.m_obsDepth = draw.red.obsDepth;

	if (draw.red.targetDepth<-10. || draw.red.targetDepth>60.) draw.red.targetDepth = 0.f;
	dlg.m_targetDepth = draw.red.targetDepth;
	if (isFloatEqual3(draw.red.targetDepth, 0.) ||
		draw.red.targetDepth<-10. || draw.red.targetDepth>60.)
		draw.red.targetDepth = draw.red.targetDepth;
	dlg.m_targetDepth = draw.red.targetDepth;


	dlg.m_timeSecName = draw.timeSecName;
	dlg.m_velName = velMod.velSecName;
	dlg.m_timeSecTitle = draw.plotTitle;
	dlg.m_tmax = (float)cd.coord.m_tmax;
	dlg.m_tmin = (float)cd.coord.m_tmin;
	dlg.m_tTick = (float)cd.coord.tTick;
	double vred = draw.red.getVred(); //rvred == 0. ? 0. : 1. / draw.red.rvred;
	dlg.m_vRed = (float)vred;
	dlg.m_wiggle = draw.wiggle;
	dlg.m_xmax = cd.coord.xmax;
	dlg.m_xmin = cd.coord.xmin;
	dlg.m_xTick = cd.coord.xTick;
	dlg.m_viewAsOffset = cd.coord.isDistanceDisplay;
	dlg.m_travelTime = draw.isRayShowing;

	dlg.m_gainDist = draw.gainDist;
	dlg.m_baseGain = (float)draw.baseGain;
	dlg.m_basePower = (float)draw.basePower;
	//dlg.m_isAvgAmp = draw.isAvgEnergy;
	dlg.m_ampPower = draw.ampPower;
	dlg.m_isNegativeFill = areaFill.isNegativeFill;

	dlg.seisBiColor.maxAmpR = seisBiColor2.maxAmpR;
	dlg.seisBiColor.maxAmpG = seisBiColor2.maxAmpG;
	dlg.seisBiColor.maxAmpB = seisBiColor2.maxAmpB;
	dlg.seisBiColor.negAmpR = seisBiColor2.negAmpR;
	dlg.seisBiColor.negAmpG = seisBiColor2.negAmpG;
	dlg.seisBiColor.negAmpB = seisBiColor2.negAmpB;
	dlg.m_digFileName = dig.digName;
	dlg.m_markerName = digMarker.digName;

	dlg.m_logScaleThreshold = draw.logScaleThreshold;
	dlg.m_velWater = draw.red.waterVelocityAboveObs;
	dlg.m_gundepth = draw.red.gunDepth;
	dlg.m_isAvgReducedNMO = draw.red.isAvgReducedNMO;

	if (dlg.DoModal() == IDOK) {
		areaFill.clip = dlg.m_clip;
		cd.coord.isFaceUp = dlg.m_faceDown != 0;

		if (dlg.m_isSwapX != cd.coord.isSwapX) {
			// will need to change the mainframe status
			CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
			pFrame->statMain.isSwapXActive = dlg.m_isSwapX;
		}
		cd.coord.isSwapX = dlg.m_isSwapX == TRUE;
		cd.coord.isSwapYLabel = dlg.m_isSwapYLabel;
		areaFill.fillOff = dlg.m_fillOff;
		areaFill.gain = dlg.m_gain;
		draw.red.obsDepth = dlg.m_obsDepth;
		draw.red.targetDepth = dlg.m_targetDepth;

		draw.timeSecName = dlg.m_timeSecName.Trim();
		velMod.velSecName = dlg.m_velName.Trim();
		draw.plotTitle = dlg.m_timeSecTitle;
		cd.coord.m_tmax = dlg.m_tmax;
		cd.coord.m_tmin = dlg.m_tmin;
		cd.coord.tTick = dlg.m_tTick;
		double rvred = dlg.m_vRed == 0. ? 0. : 1. / dlg.m_vRed;
		draw.red.rvred = rvred;
		draw.wiggle = dlg.m_wiggle;
		cd.coord.xmax = (float)dlg.m_xmax;
		cd.coord.xmin = (float)dlg.m_xmin;
		cd.coord.xTick = (float)dlg.m_xTick;
		draw.isRayShowing = dlg.m_travelTime;
		if (dlg.m_viewAsOffset != cd.coord.isDistanceDisplay)  {
			cd.coord.isDistanceDisplay = dlg.m_viewAsOffset;
			// head.timeSecModTime = NULL; //if here then "display as offset" is changed so recalculate gain.
		}
		draw.gainDist = dlg.m_gainDist;
		draw.baseGain = dlg.m_baseGain;
		draw.basePower = dlg.m_basePower;
		//draw.isAvgEnergy = dlg.m_isAvgAmp;
		draw.ampPower = dlg.m_ampPower;
		areaFill.isNegativeFill = dlg.m_isNegativeFill;


		seisBiColor2.maxAmpR = dlg.seisBiColor.maxAmpR;
		seisBiColor2.maxAmpG = dlg.seisBiColor.maxAmpG;
		seisBiColor2.maxAmpB = dlg.seisBiColor.maxAmpB;
		seisBiColor2.negAmpR = dlg.seisBiColor.negAmpR;
		seisBiColor2.negAmpG = dlg.seisBiColor.negAmpG;
		seisBiColor2.negAmpB = dlg.seisBiColor.negAmpB;
		CDigitize dg;
		if (dig.digName.CompareNoCase(dlg.m_digFileName) != 0) {
			dig.digName = dlg.m_digFileName; // successful loading
			dg.myDigitizingLoadTXTUnix2(&dig, FALSE);
		}
		if (digMarker.digName.CompareNoCase(dlg.m_markerName) != 0) {
			digMarker.digName = dlg.m_markerName; // successful loading
			dg.myDigitizingLoadTXTUnix2(&digMarker, FALSE);
		}

		draw.logScaleThreshold = dlg.m_logScaleThreshold;
		draw.red.waterVelocityAboveObs = dlg.m_velWater;
		draw.red.gunDepth = dlg.m_gundepth;
		draw.red.isAvgReducedNMO = dlg.m_isAvgReducedNMO;
		
	}
	else {
		cd.coord.drawmode = cd.coord.drawmodeOld;  // the action was canceled by the user
		return;
	}

	if (cd.coord.drawmodeOld != 0 && cd.coord.drawmodeOld != 7)
		head.modifiedtime = zeroTime; //recalculate amplitude parameters
	//because current paras are for depth sections.
	draw.isSameDataDisplay = FALSE; //internal control and not saved.

	SetModifiedFlag();
	UpdateAllViews(NULL);
	NotifyChanged();

}

void CSeisWideDoc::OnViewVelocitycolormap()
{
	if (dig.isDigitizing && (cd.coord.drawmode < 1 || (cd.coord.drawmode>4 && cd.coord.drawmode < 10)))  {
		AfxMessageBox(_T(" Quit digitizing and then you can switch to depth domain."), MB_OK | MB_ICONINFORMATION| MB_ICONQUESTION);
		return;
	}
	cd.coord.drawmodeOld = cd.coord.drawmode;
	cd.coord.drawmode = 2;	//Velocity color map will be drawn.
	if (!myParas()) {
		cd.coord.drawmode = cd.coord.drawmodeOld;
		return;
	}

	draw.isSameDataDisplay = FALSE; //indicate display has been changed and will re-load all data in OnDraw().
	SetModifiedFlag();
	UpdateAllViews(NULL);
	NotifyChanged();
}







void CSeisWideDoc::OnProcessingTimedepthConv()
{
	// This routine converts segy data from time to depth.
	CString tStr;
	int j;
	CVelMod vm;
	CdlgTim2Dpth dlg;
	dlg.m_xmax = (float)cd.coord.xmax;
	dlg.m_xmin = (float)cd.coord.xmin;
	dlg.m_depthSecName = draw.depthSecName;
	dlg.m_dz = (float)velColor.dz;
	dlg.m_zmax = (float)cd.coord.Y2();
	dlg.m_zmin = (float)cd.coord.m_zmin;
	dlg.m_timeSecName = draw.timeSecName;
	dlg.m_depthSecName = getFileNameAppend(draw.timeSecName, _T("Depth_"));

	if (fabs(draw.sphericOrder) > 100.f) draw.sphericOrder = 0.f;
	dlg.m_sphericOrder = draw.sphericOrder; //not saved in documents
	dlg.m_velSecName = velMod.velSecName;
	dlg.m_distShift = draw.distShift;
	dlg.m_modelsEx = draw.velSecNamesEx;

	if (dlg.DoModal() == IDOK) {
		cd.coord.xmax = dlg.m_xmax;
		cd.coord.xmin = dlg.m_xmin;
		draw.depthSecName = dlg.m_depthSecName;
		velColor.dz = dlg.m_dz;
		cd.coord.m_zmax = dlg.m_zmax;
		cd.coord.m_zmin = dlg.m_zmin;
		draw.timeSecName = dlg.m_timeSecName.Trim();
		draw.sphericOrder = dlg.m_sphericOrder;	//not saved in documents
		velMod.velSecName = dlg.m_velSecName.Trim();
		draw.distShift = dlg.m_distShift;
		draw.velSecNamesEx = dlg.m_modelsEx;
	}
	else {
		return;
	}
	
	draw.depthSecName = SetFileExtension(draw.depthSecName, _T("sgy"));

	if (!isFileExistNotDirectory(velMod.velSecName) && draw.velSecNamesEx.IsEmpty()) {
		AfxMessageBox(_T("Input velocity model invalid."), MB_ICONQUESTION);
		return;
	}

	setCurrentPathAs(getWorkingPathSlash());
	segy tr;
	bhed bh;

	CFile file;
	if (!file.Open(draw.timeSecName, CFile::modeRead | CFile::typeBinary)) {
		AfxMessageBox(_T("Input time section cannot be read."), MB_ICONQUESTION);
		return;
	}
	CFile filez;
	if (!filez.Open(draw.depthSecName, CFile::modeCreate | CFile::modeReadWrite | CFile::typeBinary)) {
		file.Close();
		AfxMessageBox(_T("Output depth section cannot be created."), MB_ICONQUESTION);
		return;
	}

	file.Seek(0, CFile::begin);
	UINT bytesRead = file.Read(head.ascHead, 3200L);
	if (bytesRead < 3200)
		AfxMessageBox(_T("Ascii section header read wrong"), MB_ICONQUESTION);
	file.Read(&bh, 400L);
	if (bytesRead < 400)
		AfxMessageBox(_T("Binary section header read wrong"), MB_ICONQUESTION);
	//The following numbers have to be recalculated everytime,
	//because plotting the depth section will change these numbers.
	BOOL isUnixInFile = IsUnix(bh.format);
	if (isUnixInFile) SwapTapeHeader(&bh);
	int numsamp = bh.hns;
	int sampByte = (bh.format != 3) ? 4 : 2;
	short dformat_in = bh.format;
	int len = sampByte*numsamp + 240;
	if (bh.hdt == 0) bh.hdt = bh.dto;
	int tpp = bh.hdt;

	long nzmin = (long)floor(cd.coord.m_zmin / velColor.dz);
	long nzmax = (long)ceil(cd.coord.m_zmax / velColor.dz) + 1;

	//For progress control, need to know the last bytes no.
	LONGLONG curBytesRead, totBytesRead = file.GetLength();
	file.Seek(3600, CFile::begin);


	//Only after opening successfully, we begin progress control.
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	ASSERT(pFrame);
	ASSERT_KINDOF(CMainFrame, pFrame);
	if (pFrame) pFrame->BeginProgress();
	head.setAscHead(_T("XX5Depth"), 8); // we do not want to overwrite the entire ascHead
	filez.Write(head.ascHead, 3200L);

	bh.hns = (WORD)(nzmax - nzmin + 1); // numsamp;
	bh.nso = bh.hns;
	bh.format = 1;



	bh.hdt = (unsigned short)(velColor.dz*MIL);	//Sampling rate;
	bh.dto = bh.hdt;
	filez.Write(&bh, 400L);

	//Prepare to formulate velocity traces.
	WORD totShot = 0;
	double oneodt = (double)MIL / (double)tpp;
	double dt = 1. / oneodt;
	float *rData, *vTrc, *tTrc, *tTrc2;
	rData = (float*)ealloc1(numsamp, sizeof(float));
	vTrc = (float*)ealloc1(nzmax + 1, sizeof(float));
	tTrc = (float*)ealloc1(nzmax + 1, sizeof(float));
	tTrc2 = (float*)ealloc1(nzmax + 1, sizeof(float));
	if (ERROR == rData
		|| ERROR == vTrc
		|| ERROR == tTrc
		|| ERROR == tTrc2
		) {
		free1float(rData);
		free1float(vTrc);
		free1float(tTrc);
		free1float(tTrc2);
		return;
	}

	if (velMod.isVelModValid()) {
		if (cd.coord.isTimeDomain())
			vm.myModel_TWTT2Depth(&velMod, velColor.dz);
		else
			vm.myModel_Depth2TWTT(&velMod, velColor.dz);
	}

	CVelMod::VELMODS velms;
	vm.loadInitVel(&velms, draw.velSecNamesEx, velColor.dz);

	CVelMod::VELMOD_X modX, modX2;
	double range;

	setCurrentPathAs(getWorkingPathSlash()); // note: draw.velSecNamesEx frequently uses relative folder names, so we need to set the working folder as current!!!
	while (file.Read(&tr, len) == (UINT)len) {
		if (isUnixInFile) SwapTraceHeader(false, false, false, &tr);

		//Formulating velocity traces first.
		curBytesRead = file.Seek(0, CFile::current);
		int iPos = (int)((double)curBytesRead / (double)totBytesRead*100.);
		if (iPos < 0)iPos = 0;
		if (iPos > 100)iPos = 100;
		if (pFrame) pFrame->SetProgress(iPos);

		if (tr.trid == 2) { //dead traces.
			continue;
		}

		range = tr.getDistance() + draw.distShift;  //range here is actually distance.
		if (range > cd.coord.xmax || range<cd.coord.xmin) continue;

		// compute vTrc[iz], where iz=[0, nzmax]
		modX.dist = range;
		if (!vm.initModX(&velMod, &velms, &modX, &modX2, range, false, true, velColor.dz)) continue;

		if (modX.ncont > 0 && modX2.ncont == 0) {
			// if here, only modX is needed for T-Z conversion
			vm.getTzFromZMod(&modX, nzmax + 1, 0., velColor.dz, tTrc);
		}
		else if (modX.dist == modX2.dist) {
			// the 2 modX are the same
			vm.getTzFromZMod(&modX, nzmax + 1, 0., velColor.dz, tTrc);
		}
		else if (modX.ncont > 0 && modX2.ncont > 0) {
			// if here, both modX and modX2 are needed for T-Z conversion
			vm.getTzFromZMod(&modX, nzmax + 1, 0., velColor.dz, tTrc);
			vm.getTzFromZMod(&modX2, nzmax + 1, 0., velColor.dz, tTrc2);
			register float tFac = (float)((range - modX.dist) / (modX2.dist - modX.dist));
			for (j = 0; j < nzmax + 1; j++)
				tTrc[j] = interpolLinear(tTrc[j], tTrc2[j], tFac);
		}
		else if (modX.ncont == 0 && modX2.ncont > 0)
			// if here, only modX2 is needed for T-Z conversion
			vm.getTzFromZMod(&modX2, nzmax + 1, 0., velColor.dz, tTrc);
		else {
			continue;
		}


		//Construct trace in depth domain. To save memory, overwrite vTrc[] array.
		if (dformat_in == 3)
			for (j = 0; j < numsamp; j++) rData[j] = (float)tr.dat.datashort[j];
		else if (dformat_in == 1) {
			// if (tr.idistopt==8 || pFrame->gIsIBMFloatSegy)
			ibm_to_float((int *)tr.dat.data, (int *)tr.dat.data, (int)numsamp);
			for (j = 0; j < numsamp; j++) {
				rData[j] = tr.dat.data[j];
			}
		} // if
		else if (dformat_in == 2)
			for (j = 0; j < numsamp; j++) rData[j] = (float)tr.dat.dataint[j];
		else if (dformat_in == 5) {
			for (j = 0; j<numsamp; j++) {
				rData[j] = tr.dat.data[j];
			}
		} // if
		else continue;

		if (draw.sphericOrder > 0.f) {
			double a = tr.getTraceDelay();  // a is now the initial time in sec for this trace
			double b;
			for (j = 0; j<numsamp; j++) {
				b = a + j* (double)tpp * OMIL;      // b is now the actual time in sec for the inidex j
				if (b > 1.0)
					rData[j] *= (float)pow(b, (double)draw.sphericOrder);
			}
		}

		ints8r((int)numsamp, (float)(dt),
			tr.getTraceDelay(),
			rData, 0.f, 0.f, (int)(nzmax - nzmin + 1), (float *)&tTrc[nzmin], (float *)&vTrc[nzmin]);


		memcpy((void *)tr.dat.data, (void *)&vTrc[nzmin], (nzmax - nzmin + 1)*sizeof(float));
		tr.setTraceDelayF(cd.coord.m_zmin);
		tr.setDistance((float)range);
		tr.ns = (unsigned short)(nzmax - nzmin + 1);
		tr.dt = (unsigned short)(velColor.dz*MIL);


		if (bh.format == 1) {
			//tr.idistopt = 8;
			float_to_ibm((int *)tr.dat.data, (int *)tr.dat.data, (int)tr.ns);
		}

		filez.Write(&tr, (long)(240 + tr.ns * 4));
		totShot++;
	}

	if (totShot > 0) {
		CSegyMeta::setSegyTotalTrace(&filez, totShot);
	}

	file.Close();
	filez.Close();

	if (pFrame) pFrame->EndProgress();

	//Free up space
	free1float(rData);
	free1float(vTrc);
	free1float(tTrc);
	free1float(tTrc2);

	//Auto change mode to display both.
	cd.coord.isDistanceDisplay = TRUE;  // set display using distance instead of offset, this avoids problems in  amplitude prepararing and calculation in display
	cd.coord.drawmodeOld = cd.coord.drawmode;
	cd.coord.drawmode = 3;	//Both velocity color and depth sections will be drawn.
	tx.rayCodeShow = -1; // this make sure all TX curves are shown, otherwise it is hard to show all when I am showing only one curve
	this->clearGDC(draw.gDCs.gDC); // after the new segy depth file generated, we need to clear gDC otherwise it's clustered with old data
	draw.isSameDataDisplay = FALSE; //indicate display has been changed and will re-load all data in OnDraw().

	SetModifiedFlag();
	UpdateAllViews(NULL);
	NotifyChanged();

}

// Note: please retain this code for later reference *********
/*
void CSeisWideDoc::OnProcessingTdconvbmp()
{
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	pFrame->myCaption(_T("This function is disabled. It is recomended to convert the bitmap to segy, and then work from there."));
	return;

	// This routine converts bitmapped segy data from time to depth.
	//the bitmap must be properly displayed on screen before continue.
	//	int icont, j;
	if (!isFileExistNotDirectory(bmp24.bmpName))
		return;
	if (bmp24.isInitializeNeeded > 0) return;

	int nrow, nrow1, ncol, ncol1;

	CString newName;
	CString tStr;

	ncol = bmp24.ximage->GetWidth();
	nrow = bmp24.ximage->GetHeight();

	CdlgTimDepthBMP dlg;
	dlg.m_bmpIN = bmp24.bmpName;
	dlg.m_bmpOUT = bmp24.bmpName + _T("Out.bmp");
	dlg.m_col = ncol;
	dlg.m_row = 2 * nrow;
	dlg.m_velSecName = velMod.velSecName;
	dlg.m_xmax = (float)cd.coord.xmax;
	dlg.m_xmin = (float)cd.coord.xmin;
	dlg.m_zmax = (float)cd.coord.zmax;
	dlg.m_zmin = (float)cd.coord.zmin;
	int biForm = bmp24.ximage->head.biBitCount;
	dlg.m_bitSize = (biForm == 1) ? 0 : 1;
	if (dlg.DoModal() == IDOK) {
		bmp24.bmpName = dlg.m_bmpIN;
		newName = dlg.m_bmpOUT;
		ncol1 = dlg.m_col;
		nrow1 = dlg.m_row;
		velMod.velSecName = dlg.m_velSecName.Trim();
		cd.coord.xmax = dlg.m_xmax;
		cd.coord.xmin = dlg.m_xmin;
		cd.coord.zmax = dlg.m_zmax;
		cd.coord.zmin = dlg.m_zmin;
		biForm = (dlg.m_bitSize == 0) ? 1 : 24;
	}
	delete dlg;
	newName = SetFileExtension(newName, _T("bmp"));

	//now in output, cd.coord.zmin to cd.coord.zmax would cover nrow1 pixels.
	//so 1 pixel is (cd.coord.zmax-cd.coord.zmin)/(nrow1-1) km.
	double dx = (cd.coord.xmax - cd.coord.xmin) / (ncol1 - 1.0);
	double dz = (cd.coord.zmax - cd.coord.zmin) / (nrow1 - 1.0);
	long nzmin = (int)floor(cd.coord.zmin / dz);
	long nzmax = (int)ceil(cd.coord.zmax / dz) + 1;
	COLORREF *colArray; //32-bit color values.

	//Prepare to formulate velocity traces.
	long iz;
	float *vTrc, *tTrc;
	vTrc = (float*)ealloc1(nzmax + 1, sizeof(float));
	if (ERROR == vTrc) return;
	tTrc = (float*)ealloc1(nzmax + 1, sizeof(float));
	if (ERROR == tTrc) return;
	colArray = (COLORREF *)xmalloc(nrow1*ncol1*sizeof(COLORREF));
	if (colArray == NULL) {
		AfxMessageBox(_T("Can not allocate memory for bitmap"));
		return;
	}


	//Begin progress control.
	ASSERT(pFrame);
	ASSERT_KINDOF(CMainFrame, pFrame);
	if (pFrame) pFrame->BeginProgress();

	CVelMod vm;
	vm.myModel_TWTT2Depth(&velMod, velColor.dz);

	double a, z, range;
	int row, row1, col, col1;
	CVelMod::VELMOD_X modX;

	range = cd.coord.xmin - dx;
	velMod.m_isConvert = false;
	for (col1 = 0; col1 < ncol1; col1++) {
		range += dx;  //range here is actually distance in km.

		if (range<velMod.xm[0][0] || range>velMod.xm[velMod.nzed[0] - 1][0]) {
			for (iz = nzmin; iz <= nzmax; iz++) {
				row1 = iz - nzmin;
				colArray[row1*ncol1 + col1] = WHITE;
			}
			continue;
		}

		modX.dist = range;
		vm.initModX(&velMod, &modX, false, true, velColor.dz);
		//	vm.getZModFromZ(&velMod, &modX);
		vm.getTzFromZMod(&modX, nzmax + 1, 0., velColor.dz, tTrc);

		//Construct trace in depth domain. To save space, reuse vTrc[] array.
		col = (int)myRound((range - bmp24.xmin) / (bmp24.xmax - bmp24.xmin)*(ncol - 1)); //corresponding col in original bitmap.
		a = 1. / (bmp24.ymax - bmp24.ymin)*(nrow - 1);
		for (iz = nzmin; iz <= nzmax; iz++) {
			row1 = iz - nzmin;
			z = cd.coord.zmin + (iz - nzmin)*dz;
			row = (int)myRound((tTrc[iz] - bmp24.ymin)*a); //corresponding row in original bitmap.
			if (row<0 || row>nrow - 1 || col<0 || col>ncol - 1)
				colArray[row1*ncol1 + col1] = WHITE;
			else
				colArray[row1*ncol1 + col1] = CxImage::RGBQUADtoRGB(bmp24.ximage->GetPixelColor(col, row));
		}

		int iPos = (int)((float)col1 / (float)ncol1*100.0);
		if (iPos < 0)iPos = 0;
		if (iPos > 100)iPos = 100;
		if (pFrame) pFrame->SetProgress(iPos);

	}

	//Free up space
	free1float(vTrc);
	free1float(tTrc);

	//start writing to file.
	BYTE  r, g, b;

	//generate a new file for holding output bitmap.
	// ########################################################
	CString name = newName.GetBuffer(newName.GetLength());
	FILE* fou;
	unsigned char* bmpline;
	if (0 == (fou = BMP24CreateWriteStream(name, ncol1, nrow1, biForm)))  {
		AfxMessageBox(_T("Unable to generate a new file for output\n"), MB_ICONQUESTION);
		xfree(colArray);
		return;
	}
	newName.ReleaseBuffer();
	if (0 == (bmpline = BMP24CreateLineBuffer(ncol1, biForm))) {
		AfxMessageBox(_T("Unable to allocate memory for holding bitmap data"), MB_ICONQUESTION);
		xfree(colArray);
		return;
	}

	for (row1 = 0; row1 < nrow1; row1++) {
		int iPos = (int)((float)row1 / (float)nrow1*100.0);
		if (iPos < 0)iPos = 0;
		if (iPos > 100)iPos = 100;
		if (pFrame) pFrame->SetProgress(iPos);

		for (col1 = 0; col1 < ncol1; col1++) {
			if (colArray[row1*ncol1 + col1] < 0)
				r = g = b = 255;
			else
			{
				r = (int)GetRValue(colArray[row1*ncol1 + col1]);
				g = (int)GetGValue(colArray[row1*ncol1 + col1]);
				b = (int)GetBValue(colArray[row1*ncol1 + col1]);
			}
			BMP24SetRow(bmpline, col1, r, g, b, biForm);
		}
		BMP24WriteRow(bmpline, ncol1, fou, biForm);
		//	_ftprintf_s(stdout, _T("%s: %d rows total. %3d rows remaining        \r", fnou, nrow, nrow-1-row);
		// fflush(stdout);
	}

	//close bitmap file.
	fclose(fou);
	if (pFrame) pFrame->EndProgress();
	free(bmpline);


	xfree(colArray);
	bmp24.bmpName = newName;
	bmp24.isInitializeNeeded = 1;
	//	bmp24.isDepth = TRUE;
	bmp24.xmax = (float)cd.coord.xmax;
	bmp24.xmin = (float)cd.coord.xmin;
	bmp24.ymax = (float)cd.coord.zmax;
	bmp24.ymin = (float)cd.coord.zmin;

	//Auto change mode to display both.
	cd.coord.drawmodeOld = cd.coord.drawmode;
	cd.coord.drawmode = 3;	//Both velocity contours and depth sections will be drawn.
	draw.isNoColorMap = TRUE; //don't let color map overlay bitmap.
	draw.isSameDataDisplay = FALSE; //indicate display has been changed and will re-load all data in OnDraw().

	SetModifiedFlag();
	UpdateAllViews(NULL);
	NotifyChanged();

}
*/

void CSeisWideDoc::OnViewDepthsection()
{
	cd.coord.drawmodeOld = cd.coord.drawmode;
	if (dig.isDigitizing && (cd.coord.drawmode < 1 || cd.coord.drawmode>4))  {
		AfxMessageBox(_T(" You are still digitizing a time section "), MB_OK | MB_ICONINFORMATION| MB_ICONQUESTION);
		return;
	}


	if (!myParas()) {
		return;
	}
	//if (cd.coord.drawmodeOld == 9) {
	//	// the user likely changed the model in tm[] and we now need to re-calc the zm[] array
	//	myModel_TWTT_Depth(&velMod, (float)velColor.dz);
	//}

	cd.coord.drawmode = 1;	//Depth section will be drawn.
	draw.isSameDataDisplay = FALSE; //indicate display has been changed and will re-load all data in OnDraw().

	SetModifiedFlag();
	UpdateAllViews(NULL);
	NotifyChanged();
}


void CSeisWideDoc::myCursorsAll(bool isBusy)
{
	CSeisWideApp* pSeiApp = (CSeisWideApp*)AfxGetApp();
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	pFrame->statMain.myCursorsAll(isBusy, cd.coord.drawmode, cd.zoom.isMouseHand, pSeiApp->statWin.getShiftPressed());
}


//BOOL CSeisWideDoc::myMakeSameDrive(CString &fName, CString fNameRef)
//{
//	if (fName.Trim().GetLength() < 2) return FALSE;
//	if (fNameRef.Trim().GetLength() < 2) return TRUE;
//	if (fNameRef.Trim().Find(_T("\\\\")) == 0)
//		return myMakeSameNetwork(fName, fNameRef);
//
//	if (fName.GetAt(0) == fNameRef.GetAt(0)) return TRUE;
//	fName.SetAt(0, fNameRef.GetAt(0));
//	return TRUE;
//}
//BOOL CSeisWideDoc::myMakeSameNetwork(CString &fName, CString fNameRef) {
//	// this function is not tested since I do not have a network path to test yet. But it should work
//	if (fName.Trim().GetLength() < 4) return FALSE;
//	fName = fName.Trim();
//	fNameRef = fNameRef.Trim();
//	if (fNameRef.GetLength() < 4) return TRUE;
//	if (fNameRef.Find(_T("\\\\")) != 0) return FALSE;
//	int i = fNameRef.Find(_T("\\"), 2);
//	if (i < 0) return FALSE;
//	CString networkPathRootRef = fNameRef.Mid(0, i);
//
//	if (fName.Find(_T("\\\\")) != 0) return FALSE;
//	int j = fNameRef.Find(_T("\\"), 2);
//	if (j < 0) return FALSE;
//	fName = networkPathRootRef + fName.Mid(j);
//	return TRUE;
//}



BOOL CSeisWideDoc::myParas()
{
	if (draw.isPrintingW && cd.coord.isModelingMode()) return TRUE;

	// this is a catch for gravity modeling that, for speeding up, has not saved the gravity results, but indicate a backup name
	//if (dig.totCurve > 0 && dig.nPoint[0] > 0 &&
	//	dig.digName.Trim().IsEmpty() && !dig.digNameDelayed.Trim().IsEmpty()) {
	//	dig.digName = dig.digNameDelayed;
	//	dig.digNameDelayed = BLANK;
	//	CDigitize pDg;
	//	pDg.myDigSaveAs(&dig, tx.xShotRay);
	//}

	if (isFileExistNotDirectory(bmp24.bmpName))  {
		CdlgDispBitmap dlg;
		dlg.m_xMax = (float)cd.coord.xmax;
		dlg.m_xMin = (float)cd.coord.xmin;
		dlg.m_yMax = (float)cd.coord.Y2();
		dlg.m_yMin = (float)cd.coord.Y1();

		if (cd.coord.drawmode != 6)
			dlg.m_offset = cd.coord.isDistanceDisplay ? 1 : 0;
		else
			dlg.m_offset = 2;

		dlg.m_isFaceUp = !cd.coord.isFaceUp;


		dlg.m_isSwapX = cd.coord.isSwapX;
		dlg.m_isSwapYLabel = cd.coord.isSwapYLabel;
		dlg.m_travelTime = draw.isRayShowing;
		double vred = draw.red.getVred(); //rvred == 0. ? 0. : 1. / draw.red.rvred;
		dlg.m_vred = (float)myFloat(vred, 3);


		if (dlg.DoModal() == IDOK) {
			cd.coord.xmax = dlg.m_xMax;
			cd.coord.xmin = dlg.m_xMin;
			cd.coord.setY1(dlg.m_yMin);
			cd.coord.setY2(dlg.m_yMax);

			if (cd.coord.drawmode != 6)
				cd.coord.isDistanceDisplay = dlg.m_offset == 1;
			cd.coord.isFaceUp = !dlg.m_isFaceUp;
			draw.isNoLableOutside = FALSE;

			cd.coord.isSwapX = dlg.m_isSwapX;
			cd.coord.isSwapYLabel = dlg.m_isSwapYLabel;
			double rvred = dlg.m_vred == 0. ? 0. : 1. / dlg.m_vred;
			draw.red.rvred = rvred;
			draw.isRayShowing = dlg.m_travelTime;

			return TRUE;
		}
		else return FALSE;
	}

	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	CPropertySheet sheet(_T("Combined Parameter List"));

	CdlgTIMESEC1 dlg;	//This is now actually general plotting parameters, not really for time section.
	dlg.m_clip = (float)myFloat(areaFill.clip, 3);
	dlg.m_faceDown = cd.coord.isFaceUp;
	dlg.m_gain = (float)areaFill.gain;  // do not use myFloat3() here
	if (fabs(areaFill.fillOff) > 10.) areaFill.fillOff = 0.001;
	dlg.m_fillOff = (float)areaFill.fillOff;
	dlg.m_timeSecTitle = draw.plotTitle;
	dlg.m_wiggle = draw.wiggle;
	dlg.m_timeSecName = draw.timeSecName;
	if (!cd.coord.isTimeDomain())
		dlg.m_depthRefName = draw.depthSecName;
	dlg.m_offset = cd.coord.isDistanceDisplay;
	dlg.m_xmax = (float)myFloat(cd.coord.xmax, 3);
	dlg.m_xmin = (float)myFloat(cd.coord.xmin, 3);
	dlg.m_xTick = (float)myFloat(cd.coord.xTick, 3);
	dlg.m_isNegativeFill = areaFill.isNegativeFill;
	//dlg.m_isAvgAmp = draw.isAvgEnergy;
	dlg.m_ampPower = draw.ampPower;
	dlg.m_isSwapX = cd.coord.isSwapX;
	dlg.m_isSwapYLabel = cd.coord.isSwapYLabel;
	//dlg.m_maxLevels = draw.numContours;
	dlg.m_logScaleThreshold = draw.logScaleThreshold;

	dlg.seisBiColor.maxAmpR = seisBiColor2.maxAmpR;
	dlg.seisBiColor.maxAmpG = seisBiColor2.maxAmpG;
	dlg.seisBiColor.maxAmpB = seisBiColor2.maxAmpB;
	dlg.seisBiColor.negAmpR = seisBiColor2.negAmpR;
	dlg.seisBiColor.negAmpG = seisBiColor2.negAmpG;
	dlg.seisBiColor.negAmpB = seisBiColor2.negAmpB;

	CdlgDEPTH1 dlg1;
	dlg1.mode = cd.coord.drawmode;
	dlg1.m_depthSecName = draw.depthSecName;
	//dlg1.m_dz = velColor.dz;
	dlg1.m_zmax = (float)myFloat(cd.coord.m_zmax, 3);
	dlg1.m_zmin = (float)myFloat(cd.coord.m_zmin, 3);
	dlg1.m_zTick = (float)myFloat(cd.coord.zTick, 3);
	//	dlg1.m_timeSecName = draw.timeSecName;
	dlg1.m_tmax = (float)myFloat(cd.coord.m_tmax, 3);
	dlg1.m_tmin = (float)myFloat(cd.coord.m_tmin, 3);
	dlg1.m_tTick = (float)myFloat(cd.coord.tTick, 3);

	double vred = draw.red.getVred(); //rvred == 0. ? 0. : 1. / draw.red.rvred;
	dlg1.m_vred = (float)myFloat(vred, 3);
	dlg1.m_travelTime = draw.isRayShowing;
	dlg1.m_gainDist = draw.gainDist;
	dlg1.m_baseGain = (float)myFloat(draw.baseGain, 3);
	dlg1.m_basePower = (float)myFloat(draw.basePower, 3);
	dlg1.m_rayTracing = draw.rayName;
	dlg1.m_digName = dig.digName;
	dlg1.m_isShowLabel4LineDrawing = draw.isNoLabelInSide;
	dlg1.m_distShift = draw.distShift;


	CdlgVELOCITY1 dlg2;
	dlg2.m_velSecName = velMod.velSecName;
	dlg2.m_floatName = velMod.flFloatName;
	dlg1.m_markerName = digMarker.digName; // addition on Nov. 14, 2003
	dlg1.m_xMultFactor = dig.transXMultFactor;
	dlg1.m_xShift = dig.transXShift;
	dlg1.m_yMultFactor = dig.transYMultFactor;
	dlg1.m_markerRevYAxis = dig.transIsRevYAxis;
	dlg1.m_yShift = dig.transYShift;

	dlg2.m_vrmsTauName = draw.vrmsTauNameDisabled;
	dlg2.m_dxV = velColor.dxVDesired;
	dlg2.m_vmin = velColor.vmin;
	dlg2.m_vmid = velColor.vmid;
	dlg2.m_vmax = velColor.vmax;
	dlg2.m_vminR = velColor.vminR;
	dlg2.m_vminG = velColor.vminG;
	dlg2.m_vminB = velColor.vminB;
	dlg2.m_vmidR = velColor.vmidR;
	dlg2.m_vmidG = velColor.vmidG;
	dlg2.m_vmidB = velColor.vmidB;
	dlg2.m_vmaxR = velColor.vmaxR;
	dlg2.m_vmaxG = velColor.vmaxG;
	dlg2.m_vmaxB = velColor.vmaxB;

	//These are additions of version 2.0
	dlg2.m_colBar = draw.isColBar;
	dlg2.m_colBarVmin = velColor.colBarVmin;
	dlg2.m_colBarVmax = velColor.colBarVmax;
	dlg2.m_cxExt = (float)velColor.cxExt;
	dlg2.m_cxPos = (float)velColor.cxPos;
	dlg2.m_cyExt = (float)velColor.cyExt;
	dlg2.m_cyPos = (float)velColor.cyPos;
	dlg2.m_vmid2 = velColor.vmid2;
	dlg2.m_vmid3 = velColor.vmid3;
	dlg2.m_vmid4 = velColor.vmid4;
	dlg2.m_vmid5 = velColor.vmid5;
	dlg2.m_vmid6 = velColor.vmid6;
	dlg2.m_vmid7 = velColor.vmid7;
	dlg2.m_vmid8 = velColor.vmid8;
	dlg2.m_vmid9 = velColor.vmid9;

	dlg2.m_vmidB2 = velColor.vmidB2;
	dlg2.m_vmidB3 = velColor.vmidB3;
	dlg2.m_vmidB4 = velColor.vmidB4;
	dlg2.m_vmidB5 = velColor.vmidB5;
	dlg2.m_vmidB6 = velColor.vmidB6;
	dlg2.m_vmidB7 = velColor.vmidB7;
	dlg2.m_vmidB8 = velColor.vmidB8;
	dlg2.m_vmidB9 = velColor.vmidB9;

	dlg2.m_vmidG2 = velColor.vmidG2;
	dlg2.m_vmidG3 = velColor.vmidG3;
	dlg2.m_vmidG4 = velColor.vmidG4;
	dlg2.m_vmidG5 = velColor.vmidG5;
	dlg2.m_vmidG6 = velColor.vmidG6;
	dlg2.m_vmidG7 = velColor.vmidG7;
	dlg2.m_vmidG8 = velColor.vmidG8;
	dlg2.m_vmidG9 = velColor.vmidG9;

	dlg2.m_vmidR2 = velColor.vmidR2;
	dlg2.m_vmidR3 = velColor.vmidR3;
	dlg2.m_vmidR4 = velColor.vmidR4;
	dlg2.m_vmidR5 = velColor.vmidR5;
	dlg2.m_vmidR6 = velColor.vmidR6;
	dlg2.m_vmidR7 = velColor.vmidR7;
	dlg2.m_vmidR8 = velColor.vmidR8;
	dlg2.m_vmidR9 = velColor.vmidR9;

	dlg2.m_dv1 = (float)velColor.dv1;
	dlg2.m_xWell = (float)draw.xWell;
	dlg2.m_velModExtras = CVelMod::velNamesExReformat(draw.velSecNamesEx);

	dlg.mode = dlg1.mode = cd.coord.drawmode; //this tells the dialog box initialization to disable some particular items.

	//More additions:
	dlg.m_psp.dwFlags &= ~(PSP_HASHELP);
	dlg1.m_psp.dwFlags &= ~(PSP_HASHELP);
	dlg2.m_psp.dwFlags &= ~(PSP_HASHELP);
	sheet.AddPage(&dlg);
	sheet.AddPage(&dlg1);
	sheet.AddPage(&dlg2);
	if (cd.coord.drawmode >= 2 && cd.coord.drawmode <= 4) {
		sheet.SetActivePage(&dlg2);
	}
	else
		if (cd.coord.drawmode == 1 || cd.coord.drawmode == 10) {
			sheet.SetActivePage(&dlg1);
		}



	if (sheet.DoModal() == IDOK) {
		draw.plotTitle = dlg.m_timeSecTitle;
		draw.timeSecName = dlg.m_timeSecName.Trim();
		areaFill.clip = dlg.m_clip;
		cd.coord.isFaceUp = dlg.m_faceDown != 0;
		areaFill.gain = dlg.m_gain;
		areaFill.fillOff = dlg.m_fillOff;
		draw.wiggle = dlg.m_wiggle;
		// ampColorDyn.colFileName = dlg.m_colPalette;
		cd.coord.xmax = (float)dlg.m_xmax;
		cd.coord.xmin = (float)dlg.m_xmin;
		cd.coord.xTick = (float)dlg.m_xTick;
		// para.colorFillIllumination = dlg.m_illumination;
		areaFill.isNegativeFill = dlg.m_isNegativeFill;
		//draw.isAvgEnergy = dlg.m_isAvgAmp;
		draw.ampPower = dlg.m_ampPower;


		if (dlg.m_isSwapX != cd.coord.isSwapX) {
			// will need to change the mainframe status
			pFrame->statMain.isSwapXActive = dlg.m_isSwapX;
		}
		cd.coord.isSwapX = dlg.m_isSwapX;
		cd.coord.isSwapYLabel = dlg.m_isSwapYLabel;


		seisBiColor2.maxAmpR = dlg.seisBiColor.maxAmpR;
		seisBiColor2.maxAmpG = dlg.seisBiColor.maxAmpG;
		seisBiColor2.maxAmpB = dlg.seisBiColor.maxAmpB;
		seisBiColor2.negAmpR = dlg.seisBiColor.negAmpR;
		seisBiColor2.negAmpG = dlg.seisBiColor.negAmpG;
		seisBiColor2.negAmpB = dlg.seisBiColor.negAmpB;
		//draw.numContours = dlg.m_maxLevels;
		draw.logScaleThreshold = dlg.m_logScaleThreshold;
		if (draw.logScaleThreshold < 0) draw.logScaleThreshold = 0;
		else if (draw.logScaleThreshold > 100) draw.logScaleThreshold = 100;


		draw.depthSecName = dlg1.m_depthSecName;
		// velColor.dz = dlg1.m_dz;	dz not to be changed from here.
		cd.coord.m_zmax = dlg1.m_zmax;
		cd.coord.m_zmin = dlg1.m_zmin;
		cd.coord.zTick = dlg1.m_zTick;
		cd.coord.m_tmax = dlg1.m_tmax;
		cd.coord.m_tmin = dlg1.m_tmin;
		cd.coord.tTick = dlg1.m_tTick;

		double rvred = dlg1.m_vred == 0. ? 0. : 1. / dlg1.m_vred;
		draw.red.rvred = rvred;

		if (dig.isDigitizing && dlg.m_offset != cd.coord.isDistanceDisplay) {
			AfxMessageBox(_T("You can not switch between offset and distance display while digitizing"), MB_ICONQUESTION);
			return FALSE;
		}
		if (dlg.m_offset != cd.coord.isDistanceDisplay) {
			cd.coord.isDistanceDisplay = dlg.m_offset;
		}
		draw.isRayShowing = dlg1.m_travelTime;
		draw.gainDist = dlg1.m_gainDist;
		draw.baseGain = dlg1.m_baseGain;
		draw.basePower = dlg1.m_basePower;

		CDigitize dg;
		if (dig.digName.CompareNoCase(dlg1.m_digName) != 0) {
			dig.digName = dlg1.m_digName; // successful loading
			dg.myDigitizingLoadTXTUnix2(&dig, FALSE);
		}


		// Do not remove any on screen points even if they are not saved!!!
		//if (!isFileExistNotDirectory(dig.digName)) {
		//	dig.freeDigAll();
		//}

		draw.isNoLabelInSide = dlg1.m_isShowLabel4LineDrawing;
		draw.distShift = dlg1.m_distShift;

		velMod.velSecName = dlg2.m_velSecName.Trim();
		velMod.flFloatName = dlg2.m_floatName;

		if (digMarker.digName.CompareNoCase(dlg1.m_markerName) != 0) {
			digMarker.digName = dlg1.m_markerName; // successful loading
			dg.myDigitizingLoadTXTUnix2(&digMarker, FALSE);
		}

		dig.transXMultFactor = dlg1.m_xMultFactor;
		dig.transXShift = dlg1.m_xShift;
		dig.transYMultFactor = dlg1.m_yMultFactor;
		dig.transIsRevYAxis = dlg1.m_markerRevYAxis;
		dig.transYShift = dlg1.m_yShift;


		velColor.dxVDesired = dlg2.m_dxV;
		velColor.vmin = dlg2.m_vmin;
		velColor.vmid = dlg2.m_vmid;
		velColor.vmax = dlg2.m_vmax;
		velColor.vminR = dlg2.m_vminR;
		velColor.vminG = dlg2.m_vminG;
		velColor.vminB = dlg2.m_vminB;
		velColor.vmidR = dlg2.m_vmidR;
		velColor.vmidG = dlg2.m_vmidG;
		velColor.vmidB = dlg2.m_vmidB;
		velColor.vmaxR = dlg2.m_vmaxR;
		velColor.vmaxG = dlg2.m_vmaxG;
		velColor.vmaxB = dlg2.m_vmaxB;

		//These are additions of version 2.0
		draw.isColBar = dlg2.m_colBar;
		velColor.colBarVmin = dlg2.m_colBarVmin;
		velColor.colBarVmax = dlg2.m_colBarVmax;
		velColor.cxExt = dlg2.m_cxExt;
		velColor.cxPos = dlg2.m_cxPos;
		velColor.cyExt = dlg2.m_cyExt;
		velColor.cyPos = dlg2.m_cyPos;
		velColor.vmid2 = dlg2.m_vmid2;
		velColor.vmid3 = dlg2.m_vmid3;
		velColor.vmid4 = dlg2.m_vmid4;

		velColor.vmid5 = dlg2.m_vmid5;
		velColor.vmid6 = dlg2.m_vmid6;
		velColor.vmid7 = dlg2.m_vmid7;
		velColor.vmid8 = dlg2.m_vmid8;
		velColor.vmid9 = dlg2.m_vmid9;

		velColor.vmidB2 = dlg2.m_vmidB2;
		velColor.vmidB3 = dlg2.m_vmidB3;
		velColor.vmidB4 = dlg2.m_vmidB4;
		velColor.vmidB5 = dlg2.m_vmidB5;
		velColor.vmidB6 = dlg2.m_vmidB6;
		velColor.vmidB7 = dlg2.m_vmidB7;
		velColor.vmidB8 = dlg2.m_vmidB8;
		velColor.vmidB9 = dlg2.m_vmidB9;

		velColor.vmidG2 = dlg2.m_vmidG2;
		velColor.vmidG3 = dlg2.m_vmidG3;
		velColor.vmidG4 = dlg2.m_vmidG4;
		velColor.vmidG5 = dlg2.m_vmidG5;
		velColor.vmidG6 = dlg2.m_vmidG6;
		velColor.vmidG7 = dlg2.m_vmidG7;
		velColor.vmidG8 = dlg2.m_vmidG8;
		velColor.vmidG9 = dlg2.m_vmidG9;

		velColor.vmidR2 = dlg2.m_vmidR2;
		velColor.vmidR3 = dlg2.m_vmidR3;
		velColor.vmidR4 = dlg2.m_vmidR4;
		velColor.vmidR5 = dlg2.m_vmidR5;
		velColor.vmidR6 = dlg2.m_vmidR6;
		velColor.vmidR7 = dlg2.m_vmidR7;
		velColor.vmidR8 = dlg2.m_vmidR8;
		velColor.vmidR9 = dlg2.m_vmidR9;

		velColor.dv1 = dlg2.m_dv1;
		draw.xWell = dlg2.m_xWell;
		//if (velMod.wells[0].wellDist != dlg2.m_xWell) {
		//	velMod.wells[0].wellDist = dlg2.m_xWell;
		//	velMod.wells[0].wellLatLong[0] =
		//		velMod.wells[0].wellLatLong[1] =
		//		ERRORVAL;
		//}

		draw.velSecNamesEx = dlg2.m_velModExtras;

		//More additions:
		draw.rayName = dlg1.m_rayTracing;  // added Feb 12, 2008
		draw.vrmsTauNameDisabled = dlg2.m_vrmsTauName;
	}
	else return(FALSE);

	//Some checks to ensure correct parameters
	if (cd.coord.trace2 < cd.coord.trace1) {
		AfxMessageBox(_T("trace2 is smaller than trace1, please check!"), MB_ICONQUESTION);
		return FALSE;
	}
	if (cd.coord.xTick <= 0)  cd.coord.xTick = 1.;
	if (cd.coord.zTick <= 0)  cd.coord.zTick = 1.;
	if (cd.coord.tTick <= 0)  cd.coord.tTick = 1.;

	if (cd.coord.xmax < cd.coord.xmin) {
		AfxMessageBox(_T("xmax is smaller than xmin, please check!"), MB_ICONQUESTION);
		return FALSE;
	}
	if (cd.coord.m_zmax < cd.coord.m_zmin) {
		AfxMessageBox(_T("zmax is smaller than zmin, please check!"), MB_ICONQUESTION);
		return FALSE;
	}
	if (cd.coord.m_tmax < cd.coord.m_tmin) {
		AfxMessageBox(_T("tmax is smaller than tmin, please check!"), MB_ICONQUESTION);
		return FALSE;
	}

	//if (pFrame) pFrame->SetMessageText(draw.timeSecName);
	//pFrame->SetAppName(this->GetPathName() + _T(" - " + draw.timeSecName);
	//pFrame->OnUpdateFrameTitle(TRUE);
	static BOOL isPrompt = TRUE;
	if (cd.coord.drawmodeOld < 0 && cd.coord.drawmode == 0 && !cd.coord.isDistanceDisplay && isPrompt) {
		if (AfxMessageBox(_T(" Do you want to switch to distance display instead of offset? "), MB_YESNO | MB_ICONINFORMATION) == IDYES) {
			cd.coord.isDistanceDisplay = TRUE;
		}
		isPrompt = FALSE;
	}
	return(TRUE);
}


void CSeisWideDoc::OnEditBoundary()
{
	draw.nodeMode = 1;

	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();

	pFrame->statMain.pick = 1;
//	pFrame->statMain.pickOld = -1;  // indicate no previous state for right click 
	pFrame->statMain.remove = 0;
	pFrame->statMain.move = 0;
	pFrame->statMain.add = 0;
	//	draw.iLayerFocus = -1;
	//draw.isSameDataDisplay = FALSE; //indicate display has been changed and will re-load all data in OnDraw().
	SetModifiedFlag();
	UpdateAllViews(NULL);
	NotifyChanged();
}

void CSeisWideDoc::OnEditVelocity()
{
	draw.nodeMode = 2;

	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	pFrame->statMain.pick = 1;
//	pFrame->statMain.pickOld = -1;  // for use with the right-mouse click
	pFrame->statMain.remove = 0;
	pFrame->statMain.move = 0;
	pFrame->statMain.add = 0;
	//	draw.iLayerFocus = -1;
	//draw.isSameDataDisplay = FALSE; //indicate display has been changed and will re-load all data in OnDraw().
	SetModifiedFlag();
	UpdateAllViews(NULL);
	NotifyChanged();
}

// this function is a good idea, but not working. So I disabled it already
/*
void CSeisWideDoc::OnEditText()
{
draw.nodes = 3;
bool isEmpty = GetBaseFileName(draw.markerName).IsEmpty();
if (!isEmpty) {
CFile file;
if (file.Open(draw.markerName, CFile::modeRead | CFile::typeBinary | CFile::shareDenyNone)) {
int i = (int)file.GetLength();;
if (i == 0) isEmpty = true;
file.Close();
}
else {
isEmpty = true;
}
}


if (isEmpty) {
// since the marker is empty, we create a new one
if (isTimeDomain()) {
draw.markerName = draw.timeSecName + _T("Marker.txt");
}
else {
draw.markerName = velMod.velSecName + _T("Marker.txt");
}
if (isFileExistNotDirectory(draw.markerName))
showFileInNotePad(draw.markerName);
else
showStringInFile("#Use this file to edit Marker/text. Free formatted such as\r\n# 5.  8.  255   0   0    14   45.0       PmP\r\n# X   Y   red green blue size angle(deg) text\r\n# Note: actual text angle will auto adjust based on Y/X ratio changes on screen/printer\r\n# Click Refresh Drawing (in SeisWide) after changes in this Notepad.", draw.markerName);
}
else
showFileInNotePad(draw.markerName);

CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
pFrame->statMain.pick = 1;
pFrame->statMain.pickOld = -1;  // for use with the right-mouse click
pFrame->statMain.remove = 0;
pFrame->statMain.move = 0;
pFrame->statMain.add = 0;
draw.iTextFocus = -1;
//draw.isSameNodeDisplay = TRUE;
////draw.isSameDataDisplay = FALSE; //indicate display has been changed and will re-load all data in OnDraw().
//SetModifiedFlag();
UpdateAllViews(NULL);
//NotifyChanged();
}
*/

void CSeisWideDoc::OnEditNonodes()
{
	draw.isNoNodes = !draw.isNoNodes;
	draw.isNodeChanged = TRUE;
	// draw.isSameDataDisplay = FALSE; //indicate display has been changed and will re-load all data in OnDraw().
	SetModifiedFlag();
	UpdateAllViews(NULL);
	NotifyChanged();
}

void CSeisWideDoc::OnToobarMove()
{
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	//pFrame->statMain.pickOld =
	//	getPtdraw(pFrame->statMain.pick, pFrame->statMain.remove, pFrame->statMain.move, pFrame->statMain.add);
	pFrame->statMain.move = 1;

	pFrame->statMain.remove = 0;
	pFrame->statMain.pick = 0;
	pFrame->statMain.add = 0;
	draw.isNodeChanged = TRUE;
}

void CSeisWideDoc::OnToolbarRemove()
{
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	//pFrame->statMain.pickOld =
	//	getPtdraw(pFrame->statMain.pick, pFrame->statMain.remove, pFrame->statMain.move, pFrame->statMain.add);
	pFrame->statMain.remove = 1;

	pFrame->statMain.move = 0;
	pFrame->statMain.pick = 0;
	pFrame->statMain.add = 0;
	draw.isSameDataDisplay = FALSE; //indicate display has been changed and will re-load all data in OnDraw().
	SetModifiedFlag();
	draw.isNodeChanged = TRUE;
	draw.isSameDataDisplay = TRUE; //indicate display has been changed and will re-load all data in OnDraw().
}

void CSeisWideDoc::OnToolbarPick()
{
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	//pFrame->statMain.pickOld =
	//	getPtdraw(pFrame->statMain.pick, pFrame->statMain.remove, pFrame->statMain.move, pFrame->statMain.add);
	pFrame->statMain.pick = 1;

	pFrame->statMain.move = 0;
	pFrame->statMain.remove = 0;
	pFrame->statMain.add = 0;

	draw.isNodeChanged = TRUE;
	draw.isSameDataDisplay = TRUE;
	CString tStr = _T("Dragging mouse click to show slope or apparent velocity.");
	pFrame->myCaption(tStr);

	SetModifiedFlag();
}

void CSeisWideDoc::OnToolsPicknext()
{
	draw.isNodeChanged = FALSE;
	draw.isSameDataDisplay = TRUE;
	draw.iLayerFocus++;

	SetModifiedFlag();
	UpdateAllViews(NULL);
	NotifyChanged();
}


void CSeisWideDoc::OnToolbarAdd()
{
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	//pFrame->statMain.pickOld =
	//	getPtdraw(pFrame->statMain.pick, pFrame->statMain.remove, pFrame->statMain.move, pFrame->statMain.add);
	pFrame->statMain.add = 1;

	pFrame->statMain.move = 0;
	pFrame->statMain.remove = 0;
	pFrame->statMain.pick = 0;
	draw.isNodeChanged = TRUE;
	draw.isSameDataDisplay = TRUE;
	SetModifiedFlag();
}

void CSeisWideDoc::OnToolbarDelLine()
{
	if (AfxMessageBox(_T(" This will delete the selected curve or layer; Continue? "), MB_YESNO | MB_ICONINFORMATION| MB_ICONQUESTION) != IDYES)
		return;

	if (dig.isDigitizing && dig.nPoint != NULL) {
		CDigitize pDg;
		if (pDg.digDeleteCurve(&dig, dig.iCurveSel))
			OnToolbarRefreshAll();
		return;
	} // if


	if (!cd.coord.isModelingMode()) return;


	//Delete a boundary/layer.
	if (draw.iLayerFocus < 0) {
		AfxMessageBox(_T("Please select a layer first"), MB_OK | MB_ICONINFORMATION| MB_ICONQUESTION);
		return;
	}

	CVelMod vm;
	int j, icont;

	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	pFrame->statMain.add = 0;
	pFrame->statMain.move = 0;
	pFrame->statMain.remove = 0;
	pFrame->statMain.pick = 0;

	// the selected boundary for delete is: iLayerFocus.
	velMod.ncont--;
	for (icont = draw.iLayerFocus; icont < velMod.ncont; icont++)
	{
		velMod.nzed[icont] = velMod.nzed[icont + 1];
		for (j = 0; j < velMod.nzed[icont + 1]; j++)
		{
			velMod.xm[j][icont] = velMod.xm[j][icont + 1];
			if (cd.coord.drawmode != 9)
				velMod.zm[j][icont] = velMod.zm[j][icont + 1];
			else
				velMod.tm[j][icont] = velMod.tm[j][icont + 1];
		}
	}
	for (icont = draw.iLayerFocus; icont < velMod.ncont - 1; icont++)
	{
		velMod.nvel[icont][0] = velMod.nvel[icont + 1][0];
		velMod.nvel[icont][1] = velMod.nvel[icont + 1][1];
		for (j = 0; j < velMod.nvel[icont][0]; j++)
		{
			velMod.xvel[j][icont][0] = velMod.xvel[j][icont + 1][0];
			velMod.vf[j][icont][0] = velMod.vf[j][icont + 1][0];
		}
		for (j = 0; j < velMod.nvel[icont][1]; j++)
		{
			velMod.xvel[j][icont][1] = velMod.xvel[j][icont + 1][1];
			velMod.vf[j][icont][1] = velMod.vf[j][icont + 1][1];
		}
	}
	draw.iLayerFocus = -1;
	//End of delete a boundary/layer.

	// OnToolbarSavev();
	if (cd.coord.drawmode == 9)
		vm.myModel_TWTT2Depth(&velMod, velColor.dz);

	UpdateAllViews(NULL);
	return;

}

void CSeisWideDoc::OnToolbarDuplicate()
{
	if (!cd.coord.isModelingMode()) return;


	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	pFrame->statMain.add = 0;
	pFrame->statMain.move = 0;
	pFrame->statMain.remove = 0;
	pFrame->statMain.pick = 1;

	if (draw.iLayerFocus < 0) {
		AfxMessageBox(_T("Please select a boundary/layer to duplicate."), MB_OK | MB_ICONINFORMATION| MB_ICONQUESTION);
		return;
	}
	if (AfxMessageBox(_T("Boundary duplication is convenient for adding a local layer. Continue?"), MB_OKCANCEL | MB_ICONINFORMATION| MB_ICONQUESTION) == IDCANCEL) return;

	// the selected boundary for delete is: iLayerFocus.

	CVelMod vm;
	draw.iLayerFocus = vm.myModelBoundaryDup(&velMod, draw.iLayerFocus, velColor.dz);
	//End duplicating a boundary.

	// note: since have duplicated a boundary in the depth domain. We need to 
	// convert to time domain right now

	draw.isNodeChanged = TRUE;
	UpdateAllViews(NULL);
	NotifyChanged();
}

void CSeisWideDoc::OnEditDisplaytuneupRemoveoutsideraypoints()
{
	draw.isNoOutSidePoints = !draw.isNoOutSidePoints;
	draw.isSameDataDisplay = FALSE; //indicate display has been changed and will re-load all data in OnDraw().
	UpdateAllViews(NULL);
	NotifyChanged();
}
//
//BOOL CSeisWideDoc::getSegyMeta(CString t, HEAD *pHead)
//{
//	if (!isFileExistNotDirectory(t)) return TRUE;
//	if (segyHeadInit(t, pHead) != 1) return FALSE;
//	SegyWrapper sw(t);
//
//	// note: we cannot sort head.offsets[] or head.dist[], 
//	//  so we have to create offset[] and dist[] for sorting
//	float offset[100], dist[100], dx[100];
//	if (!sw.open(pHead, 100)) {
//		pHead->aveAmp = 1.f;
//		pHead->maxAmp = 1.f;
//		pHead->offsetInterval = .1;
//		pHead->distInterval = 1.;
//		return FALSE;
//	}
//
//	// NOTE: when the result is 18 million, if I do not have (double) cast, it returns 0. Why?
//	pHead->maxAmp = (double)sw.getMaxAmp();
//	if (pHead->maxAmp < MINAMP) pHead->maxAmp = 1.;
//
//	pHead->aveAmp = (double)sw.getAvgAmp();
//	if (pHead->aveAmp < MINAMP) pHead->aveAmp = 0.5;
//
//	int numsamp = sw.bh.hns;
//
//	int i;
//	int nxmax = min(100, sw.headRead.nxmax);
//	for (i=0; i<nxmax; i++) {
//		dist[i] = getDistance(&sw.headRead.trArr[i]);
//		offset[i] = getOffset(&sw.headRead.trArr[i]);
//	} // for i
//
//	if(nxmax>1) {
//		sort(&offset[0], nxmax);
//		sort(&dist[0], nxmax);
//		//if (!isTimeDomain()) 
//		//	cd.coord.isDistanceDisplay = TRUE; // we cannot display using offset[]
//
//		for (i=1; i<nxmax; i++) {
//			dx[i-1] = (float)fabs(offset[i]-offset[i-1]);
//		}
//		// note: dx[] only has totTrc-1 values
//		pHead->offsetInterval = getMedianAbsolute(&dx[0], nxmax - 1);	//This is the average trace interval in km.
//		if (pHead->offsetInterval < MINAMP) pHead->offsetInterval = .1;
//
//		for (i=1; i<sw.headRead.nxmax; i++) {
//			dx[i-1] = (float)fabs(dist[i]-dist[i-1]);
//		}
//		pHead->distInterval = getMedianAbsolute(&dx[0], nxmax - 1);	//This is the average trace interval in km.
//		if (pHead->distInterval < MINAMP) pHead->distInterval = 1.;
//	} else  {
//		pHead->offsetInterval = .1;
//		pHead->distInterval = 1.;
//	}
//
////So, the average ampl should be "stretched" to cover the distance "temp*gain",
////But since this routine cannot use para.gain or para.clip (since this routine only
////executes once and yet para changed many times), the draw.trcIntOavgAmp and
////para.clip will have to be multiplied in separate drawing routines.
////	head.timeSecModTime = getFileModifiedTime(draw.timeSecName);
//
//	return TRUE;
//}







//
//BOOL CSeisWideDoc::MyInitAmpTrc2(CString t)
//{
////This routine initializes segy data for displaying by trace.
//	if (!isFileExistNotDirectory(t)) return TRUE;
////		CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
//	SegyWrapper sw(t);
//	if (segyHeadInit(t, &head) == 1) {
//		head.offsetInterval = .1;
//		head.distInterval = 1.;
//		// strange: if I use 80 or 100 as desired numtraces, it will have 10 memory exceptions
//		// however, if I use 50, it has no exception. Why???
//		if (sw.open(&head, 50)) {  
//			int numsamp = sw.bh.hns;
//			head.aveAmp = (double)sw.getAvgAmp();
//			head.maxAmp = (double)sw.getMaxAmp();
//			return TRUE;
//		} // if sw
//		else {
//			head.aveAmp = 0.f;
//			head.maxAmp = 0.f;
//			return FALSE;
//		}
//	}
//	return FALSE;
//}




void CSeisWideDoc::OnEditCopy()
{
	CSeisWideApp* pSeiApp = (CSeisWideApp*)AfxGetApp();

	// BOOL tempNoLable=draw.isNoLableOutside;
	//	BOOL tempNoSeismic;
	// backup the global values first before overwritten
	BOOL t1 = draw.isNoLableOutside;
	BOOL t2 = draw.isNoLabelInSide;
	BOOL isNoBoundaryBackup = draw.isNoBoundary;
	BOOL isNoNodesBackup = draw.isNoNodes;
	BOOL isSeismicPlotBackup = draw.isSeismicPlot;


	if (cd.coord.drawmode >= 0) {
		CdlgFillArea dlg;
		// when opening an older .sei file, this may not be valid, so we give a fix here... sept, 2009
		if (draw.clipBoardSizeX < 10) draw.clipBoardSizeX = 880;
		if (draw.clipBoardSizeY < 10) draw.clipBoardSizeY = 50;
		dlg.m_XLen = draw.clipBoardSizeX;
		dlg.m_YLen = draw.clipBoardSizeY;

		if (!bmp24.bmpName.IsEmpty())
			dlg.m_mode = 1; //indicate drawing in bitmap.
		else if (cd.coord.drawmode == 2 || cd.coord.drawmode == 4)
			dlg.m_mode = 1; //indicate drawing of model with no seismics.
		dlg.m_noLablesOutside = t1;
		dlg.m_isNoLabelsInside = t2;
		dlg.m_isNoLines = draw.isNoBoundary;
		dlg.m_isNoNodes = draw.isNoNodes;

		dlg.m_XDecimate = (float)pSeiApp->statWin.xSkipIntervalAbs;
		if (dlg.DoModal() == IDOK) {
			draw.isNoLableOutside = dlg.m_noLablesOutside;
			draw.isNoLabelInSide = dlg.m_isNoLabelsInside;
			draw.isNoBoundary = dlg.m_isNoLines;
			draw.clipBoardSizeX = dlg.m_XLen;
			draw.clipBoardSizeY = dlg.m_YLen;
			draw.isNoNodes = dlg.m_isNoNodes;
			draw.isSeismicPlot = dlg.m_isSeismicPlot;

			pSeiApp->statWin.xSkipIntervalAbs = dlg.m_XDecimate;
		}
		delete dlg;
	}

	draw.isCopying = TRUE;

	// real place to do copying to clipboard
	CSeisWideSrvrItem* pItem = GetEmbeddedItem();
	pItem->CopyToClipboard(TRUE);

	// after copying, the bitmap is gone, so need to initialize
	//	bmp24.isInitializeNeeded = 1;

	// recover the old values
	// draw.isSameDataDisplay = FALSE;
	draw.isNoLableOutside = t1;
	draw.isNoLabelInSide = t2;
	draw.isNoBoundary = isNoBoundaryBackup;
	draw.isNoNodes = isNoNodesBackup;
	draw.isSeismicPlot = TRUE;
	draw.isCopying = FALSE;
	pSeiApp->statWin.xSkipIntervalAbs = 0.;  // after copying, we do not want to see some rays skipped otherwise it's confusing
}

void CSeisWideDoc::OnEditPaste()
{ // this routine not used for now.


	//POSITION pos = GetFirstDocTemplatePosition();
	//CDocTemplate *pTemplate = GetNextDocTemplate(pos);            
	//CDocument *pDoc = pTemplate->OpenDocumentFile(NULL);
	//pDoc->SetTitle ("My own title");

	AfxMessageBox(_T("Sorry, pasting within Seiswide is not implemented (although you may copy to clipboard)."), MB_ICONQUESTION);
	return;

	CWnd *pWnd;
	pWnd = pWnd->GetActiveWindow();
	if (pWnd->OpenClipboard())
	{
		HGLOBAL hMem = GetClipboardData(CF_METAFILEPICT);
		if (!hMem != NULL)
		{
			char *lpMeta = (char *)GlobalLock(hMem);
			if (lpMeta != NULL)
			{ //work with the METAFILEPICT structure...
			}
		}
	}
	else
		AfxMessageBox(_T("Couldn't get metafile from clipboard"), MB_ICONQUESTION);
	CloseClipboard();
}


//
//CPoint CSeisWideDoc::mm_coord(double x, double y, int xLen, int yLen)
//{
//// A routine to convert my world coordinates (in km, sec) into logical coordinates of windows. 
//// for facedown plot only: xmin->0, xmax->xLen;  ymin->0, ymax->yLen.
//	CPoint p;
//	double a;
//	a = (x-cd.coord.xmin)*cd.coord.mm_xscale;
//	p.x = (int)myRound(cd.coord.logicalAxes.left + a);
//
//	
//	if (isTimeDomain()) {
//		//if true then in time domain.
//		if(cd.coord.isFaceUp == 0)
//			a = (y-cd.coord.tmin)*cd.coord.mm_yscale;
//		else
//			a = (cd.coord.tmax-y)*cd.coord.mm_yscale;
//	}
//	else {
//		a = (y-cd.coord.zmin)*cd.coord.mm_yscale;
//	}
//
//	p.y = (int)myRound(a+cd.coord.logicalAxes.top);
//
//	return p;
//
//}

/////////////////////////////////////////////////////////////////////////////



BOOL CSeisWideDoc::DrawVel(CDC* pDC) {
	//	if (cd.coord.drawmode==4) return DrawCont(pDC);

	// note: draw.distShift is not used in the horizontal shifting of displayed velocity model!
	//       This is because, by definition, draw.distShift is used in shifting segy data only, not a model.
	//       A model can be shifted by another string parameter draw.velSecNamesEx in the time domain.
	// this->DrawVelocityColormapDepth(pDC, &velMod, draw.isNoNodes, 0., draw.iLayerFocus);

//	if (!isFileExistNotDirectory(velMod.velSecName)) 
//		return FALSE;
//
//	CVelMod vm;
//	if (!vm.loadInitVel(&velMod, velMod.velSecName, velColor.dz))
//		return FALSE;
//
//
////	CVelMod::VELMOD velm2;
//	if (velMod.ncontFlatten > 0) {
//		float xShot = CCoords::isXShotDefined(tx.xShotRay) ? tx.xShotRay : (float)cd.coord.xmin;
//		velMod.setHorizonFlatten2Model(xShot);
//	}
	if (cd.coord.isTimeDomain()) return FALSE;
	if (!velMod.isModelVisible(&cd.coord, 0.)) return FALSE;

	return DrawVelocityColormapDepth(pDC, &velMod, draw.isNoNodes, 0., draw.iLayerFocus);

	//BOOL isTrue = CVelMod::DrawVelocityColormapDepth(pDC, &velMod, 
	//	&cd.coord, &velColor, draw.isNoNodes, 
	//	0., draw.iLayerFocus,
	//	draw.isNoColorMap, draw.nodeMode);
	//this->DrawColorbar(pDC);
	//return isTrue;
}




BOOL CSeisWideDoc::DrawVelocityColormapDepth(CDC* pDC, CVelMod::VELMOD *velm, 
	BOOL isNoNodes,
	double xShift, int iLayerFocus)
{
	// note: if draw.isNoColorMap is true, we still need to continue this function, as we will 
	//       make a different display
	// if this model is not visible after initialization, we should not draw it

	if (!isFileExistNotDirectory(velm->velSecName))
		return FALSE;

	CVelMod vm;
	//if (!vm.loadInitVel(velm, velm->velSecName, velColor.dz))
	//	return FALSE;
	if (draw.ncontFlatten > 0) {
		float xShot = CCoords::isXShotDefined(tx.xShotRay) ? tx.xShotRay : (float)cd.coord.xmin;
		velm->setHorizonModel2Flat(draw.ncontFlatten, xShot);
	}

	// when the bitmap is dispayed, we do not show colormap, but only contours if needed
	bool isNoColorMap = draw.isNoColorMap;
	if (cd.coord.drawmode == 4 && isFileExistNotDirectory(bmp24.bmpName))
		isNoColorMap = true;
	BOOL isTrue =
		CVelMod::DrawVelocityColormapDepth(pDC, velm, 
		&cd.coord, &velColor, draw.isNoNodes, 
		xShift, iLayerFocus, 
		isNoColorMap, 
		draw.nodeMode);

	if (velm->velSecName.Compare(velMod.velSecName) == 0)
		this->DrawColorbar(pDC);

	return isTrue;
}



BOOL CSeisWideDoc::DrawVelocityBoundaryDepth(CDC* pDC, CVelMod::VELMOD *velm, BOOL isNoNodes, double xShift, CPen* pBluePen, int iLayerFocus)
{
	if (draw.isNoBoundary) return TRUE;
	if (!isFileExistNotDirectory(velm->velSecName)) return FALSE;
	CString tstr;
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();

	CVelMod vm;
	if (velm == NULL && velm->ncont < 1) {
		// this would means that the model needs re-loading
		//vm.velModSetArrays(velm);
		if (!vm.loadInitVel(velm, velm->velSecName, velColor.dz, tstr))
			pFrame->myCaption(tstr);
			return FALSE;
	}
	if (!this->isModelVisible(velm, xShift)) return FALSE;
	DrawVelocityUncontroledLeft(pDC, velm, xShift);
	DrawVelocityUncontroledRight(pDC, velm, xShift);

	short i, j, icont;
	short ix;
	double a, b, x1;
	CPoint p, p1, plt[MOD_POINTS_MAX * 2], pltOld[MOD_POINTS_MAX];
	double xx[MOD_POINTS_MAX * 2], zz[MOD_POINTS_MAX * 2];
	CPen *pOldPen;
	CBrush* oldBrush;
	bool isMainModelShowing = velm->velSecName.Compare(velMod.velSecName) == 0;

	COLORREF clMain = isMainModelShowing ? RED : RGB(200, 255, 0);
	int lineWidthThis = cd.coord.getPenThicknessNormal(); 
	CPen redPenThick(PS_SOLID, lineWidthThis*2, clMain);
	CPen redPenThin(PS_SOLID, lineWidthThis, clMain);
	CPen whitePen(PS_SOLID, lineWidthThis, WHITE);
	CPen greyUnconstrainedPen(PS_DOT, 4, BLUE); // Valid only when the pen width is 1 or less, in device units.
	CPen yellowPen(PS_SOLID, lineWidthThis, YELLOW);
	CPen regularPen(PS_SOLID, lineWidthThis, BLUE);
	CPen thinPen(PS_SOLID, 0, RGB(0, 200, 0));
	CPen whiteNodePen(PS_JOIN_BEVEL, (draw.isNoColorMap) ? 3 : 30, WHITE);
	CPen whiteNodeFocusPen(PS_SOLID, (draw.isNoColorMap) ? 5 : 80, WHITE);
	CBrush blackBrush(BLACK);
	CBrush redBrush(RED);
	CBrush greenBrush(GREEN);
	CBrush blueBrush(BLUE);



	int dPlt = (int)(lineWidthThis * pFrame->statMain.bigNodes * 0.5);
	if (dPlt < lineWidthThis) dPlt = lineWidthThis;

	int itop, ibot, ileft, iright;
	pOldPen = pDC->SelectObject(&regularPen); // select a default pen
	for (icont = 0; icont < velm->ncont; icont++) {
		if (icont == 0 && iLayerFocus != icont ) {
			register bool isSkip = true;
			for (j = 0; j < velm->nzed[0]; j++) {
				if (cd.coord.Y1() != velm->zm[j][icont]) {
					isSkip = false;
					break;
				}
			}
			if (isSkip) continue; // do not plot this boundary
		}
		
		i = 0;
		if (velm->xmMin[icont] == ERRORVAL) {
			for (j = 0; j < velm->nzed[icont]; j++) {
				xx[i] = velm->xm[j][icont];
				xx[i] += xShift;
				zz[i] = velm->zm[j][icont];
				i++;
			}
		}
		else {
			xx[i] = velm->getXmin(icont);
			zz[i] = velm->getCurrHorizonDepthAtDist((float)xx[i], icont);
			xx[i] += xShift;
			i++;
			for (j = 0; j < velm->nzed[icont]; j++) {
				xx[i] = velm->xm[j][icont];
				if (xx[i] >= velm->getXmin(icont) && xx[i] <= velm->getXmax(icont)) {
					xx[i] += xShift;
					zz[i] = velm->zm[j][icont];
					if (xx[i]!=xx[i-1])
						i++;
				}
			}
			xx[i] = velm->getXmax(icont);
			zz[i] = velm->getCurrHorizonDepthAtDist((float)xx[i], icont);
			xx[i] += xShift;
			if (xx[i] != xx[i - 1])
				i++;
		}
		if (i < 2) continue;
		register int nLimit = min(2 * i, MOD_POINTS_MAX*2);
		i = myClipPoints2(i, nLimit, xx, zz, cd.coord.X12Y12());
		if (i < 2) continue; // cannot draw a line with only 1 point
		for (j = 0; j < i; j++)
			plt[j] = cd.coord.mm_coord(xx[j], zz[j]);

		
		if (isMainModelShowing && icont == iLayerFocus) {
			if (draw.nodeMode == 1)
				pDC->SelectObject(&redPenThick);
			else {
				if (draw.isTopBound)
					pDC->SelectObject(&redPenThick);
				else 
					pDC->SelectObject(&redPenThin);
			}
		}
		else if (isMainModelShowing && icont == iLayerFocus + 1) {
			if (draw.nodeMode == 1) {
				if (icont < velm->ncontMaxConstrained)
					pDC->SelectObject(&regularPen);
				else
					pDC->SelectObject(&greyUnconstrainedPen);
			}
			else {
				if (draw.isTopBound)
					pDC->SelectObject(&redPenThin);
				else
					pDC->SelectObject(&redPenThick);
			}
		}
		else {
			if (icont + 1 > velm->ncontMaxConstrained)
				pDC->SelectObject(&greyUnconstrainedPen);
			else if (pBluePen)
				pDC->SelectObject(pBluePen);
			else
				pDC->SelectObject(&regularPen);
		}

		if (velm->isSedimentRegression(icont) || velm->isSedimentRegression(icont - 1))
			pDC->SelectObject(&yellowPen);

		//	pDC->Polyline(plt, i);
		// added Jan 30, 2017
		// when a polygon has a segment at the axes, I need to split the polygon into 2. 
		// The clipping routine above already modified the curve this way when it crosses the axes.
		register bool isLinePlotted = false;
		for (j = 0; j < i - 1; j++) { // note: i is the total number of points to plot
			if (plt[j].y == cd.coord.logicalAxes.top || plt[j].y == cd.coord.logicalAxes.bottom) {
				if (plt[j].y == plt[j + 1].y) {
					// now plot it with 2 polygons
					pDC->Polyline(plt, j + 1);
					pDC->Polyline(&plt[j + 1], i - j - 1);
					isLinePlotted = true;
					break;
				}
			}
		}
		if (!isLinePlotted)
			pDC->Polyline(plt, i);


	} // for icont
	pDC->SelectObject(pOldPen);

	for (icont = 1; icont < velm->ncont; icont++) {
		i = 0;
		if (draw.nodeMode == 1 && !draw.isNoNodes) {
			// drawing nodes need to get rid of the clipped points on two sides, so re-calculate
			i = 0;
			for (j = 0; j < velm->nzed[icont]; j++) {
				a = velm->xm[j][icont] + xShift;
				b = velm->zm[j][icont];
				if (cd.coord.isVisibleOrNot(a, b)) {
					plt[i] = cd.coord.mm_coord(a, b);
					i++;
				}
			}

			if (icont == iLayerFocus) {
				pOldPen = pDC->SelectObject(&whiteNodeFocusPen);
				oldBrush = pDC->SelectObject(&redBrush);
			}
			else {
				pOldPen = pDC->SelectObject(&whiteNodePen);
				oldBrush = pDC->SelectObject(&greenBrush);
			}
			if (!isNoNodes) {
				for (j = 0; j < i; j++) {
					if (icont == 0 && (j == 0 || j == i - 1)) continue; 
					// do not plot the nodes at the top corners otherwise it's hard to position on screen
					
					itop = plt[j].y - dPlt;
					ibot = plt[j].y + dPlt;
					ileft = plt[j].x - dPlt;
					iright = plt[j].x + dPlt;
					pDC->Ellipse(ileft, itop, iright, ibot);
				} // for j
			}
			pDC->SelectObject(pOldPen);
			pDC->SelectObject(oldBrush);
		} //if(draw.nodes==
	} // for i

	//Draw nodes specifying velocities within layer iLayerFocus.
	if (!draw.isNoBoundary && draw.nodeMode == 2 && iLayerFocus >= 0 && iLayerFocus < velm->ncont - 1) {
		//Calculate the depths for all nodes (not given by velocity input file).
		icont = iLayerFocus;
		BOOL DrawTopLine = TRUE;
		BOOL DrawBotLine = TRUE;
		i = 0;

		for (j = 0; j < velm->nvel[icont][0]; j++) {
			x1 = velm->xvel[j][icont][0];
			xx[i] = x1 + xShift;
			for (ix = 0; ix < (velm->nzed[icont] - 1); ix++) {
				if (x1 >= velm->xm[ix][icont] && x1 <= velm->xm[ix + 1][icont]) {
					zz[i] = velm->zm[ix][icont] + (velm->zm[ix + 1][icont] -
						velm->zm[ix][icont])*(x1 - velm->xm[ix][icont]) /
						(velm->xm[ix + 1][icont] - velm->xm[ix][icont]);
					break;
				}
			}
			if (cd.coord.isVisibleOrNot(xx[i], zz[i])) i++;
			else if (xx[i] >= cd.coord.X1() && xx[i] <= cd.coord.X2() &&
				(zz[i]<cd.coord.Y1() || zz[i]>cd.coord.Y2()))
				DrawTopLine = FALSE;
		}

		int nTop = i;
		for (j = 0; j < nTop; j++)
			plt[j] = cd.coord.mm_coord(xx[j], zz[j]);

		i = 0;
		for (j = 0; j < velm->nvel[icont][1]; j++) {
			x1 = velm->xvel[j][icont][1];
			xx[i] = x1 + xShift;
			for (ix = 0; ix < velm->nzed[icont + 1] - 1; ix++) {
				if (x1 >= velm->xm[ix][icont + 1] && x1 <= velm->xm[ix + 1][icont + 1]) {
					zz[i] = velm->zm[ix][icont + 1] + (velm->zm[ix + 1][icont + 1] -
						velm->zm[ix][icont + 1])*(x1 - velm->xm[ix][icont + 1]) /
						(velm->xm[ix + 1][icont + 1] - velm->xm[ix][icont + 1]);
					break;
				}
			}
			if (cd.coord.isVisibleOrNot(xx[i] + xShift, zz[i])) i++;
			else if (xx[i] >= cd.coord.X1() && xx[i] <= cd.coord.X2() &&
				(zz[i]<cd.coord.Y1() || zz[i]>cd.coord.Y2()))
				DrawBotLine = FALSE;
		}
		for (j = 0; j < i; j++)
			pltOld[j] = cd.coord.mm_coord(xx[j], zz[j]);

		if (!draw.isNoNodes) {

			if (draw.isTopBound) {
				pOldPen = pDC->SelectObject(&whitePen);
				oldBrush = pDC->SelectObject(&redBrush);
				for (j = 0; j < nTop; j++)
					pDC->Ellipse(plt[j].x - dPlt, plt[j].y - dPlt, plt[j].x + dPlt, plt[j].y + dPlt);
				pDC->SelectObject(oldBrush);
				pDC->SelectObject(pOldPen);
				pOldPen = pDC->SelectObject(&whitePen);
				oldBrush = pDC->SelectObject(&blueBrush);
				for (j = 0; j < i; j++)
					pDC->Ellipse(pltOld[j].x - dPlt, pltOld[j].y - dPlt, pltOld[j].x + dPlt, pltOld[j].y + dPlt);
				pDC->SelectObject(oldBrush);
				pDC->SelectObject(pOldPen);
			}
			else {
				pOldPen = pDC->SelectObject(&whitePen);
				oldBrush = pDC->SelectObject(&blueBrush);
				for (j = 0; j < nTop; j++)
					pDC->Ellipse(plt[j].x - dPlt, plt[j].y - dPlt, plt[j].x + dPlt, plt[j].y + dPlt);
				pDC->SelectObject(pOldPen);
				pDC->SelectObject(oldBrush);
				pOldPen = pDC->SelectObject(&whitePen);
				oldBrush = pDC->SelectObject(&redBrush);
				for (j = 0; j < i; j++)
					pDC->Ellipse(pltOld[j].x - dPlt, pltOld[j].y - dPlt, pltOld[j].x + dPlt, pltOld[j].y + dPlt);
				pDC->SelectObject(pOldPen);
				pDC->SelectObject(oldBrush);
			}
		} // if !draw.isNoNodes
	} // if draw.nodes == 2

	whitePen.DeleteObject();
	whitePen.DeleteObject();
	regularPen.DeleteObject();
	thinPen.DeleteObject();
	blackBrush.DeleteObject();

	redBrush.DeleteObject();
	greenBrush.DeleteObject();
	blueBrush.DeleteObject();

	return(TRUE);
}


// the problem is: if I only display a small portion of a big model, I can view more details of the model. How we do this?
// iLayerFocus: indicate which boundary to display as a thick line, set to 0 if all thin lines
// greenPen can be NULL and will default to zero with or thicker if at iLayerFocus boundary
//BOOL CSeisWideDoc::DrawVelocityDepth2Notused(CDC* pDC, CVelMod::VELMOD *velm, BOOL isBoundOnly, BOOL isNoNodes, double xShift,
//	CPen* greenPen, int iLayerFocus)
//{
//	// if this model is not visible after initialization, we should not draw it
//	CString tstr;
//	CVelMod vm;
//	if (velm == NULL && velm->ncont < 1)
//		vm.velModSetArrays(velm);
//	if (!isFileExistNotDirectory(velm->velSecName) || !this->isModelVisible(velm, xShift)) return FALSE;
//
//	bool isMainModelShowing = velm->velSecName.Compare(velMod.velSecName) == 0;
//
//	//bool isMainModelShowing = 
//	//	GetBaseFileName(velMod.velSecName) == GetBaseFileName(velm->velSecName);
//
//	//Generate velocity contours
//	short i, j, icont;
//	short ix, iv, nv;
//	double range;
//	double a, b, x1, v, dv, temp;
//	CPoint p, p1, plt[MOD_POINTS_MAX * 2], pltOld[MOD_POINTS_MAX];
//
//	if (!vm.loadInitVel(velm, velm->velSecName, velColor.dz))
//		return FALSE;
//
//
//	//Start plotting velocity color map.
//	CPen whitePen(PS_NULL, 0, WHITE);
//	CPen whiteLinePen(PS_SOLID, 0, WHITE);
//	CPen blackPen(PS_SOLID, 0, BLACK);
//	int thickThis = cd.coord.getPenThicknessNormal();
//	CPen redPen(PS_SOLID, thickThis, RED);
//	//CPen greenPen(PS_SOLID, (int)(cd.coord.logicalAxes.Height()/400), RGB(0,255,0));
//	CPen thickPen(PS_SOLID, thickThis, BLACK);
//	CPen thinPen(PS_SOLID, 0, RGB(0, 100, 0));
//	CBrush blackBrush(BLACK);
//	CBrush redBrush(RED);
//	CBrush greenBrush(GREEN);
//	CBrush blueBrush(BLUE);
//
//
//	//For each velocity contour, look for the right depth for each range.
//	//_stprintf(s, _T("at v,vtop,vbot=%d %d %d %d %d",(long)v,(long)vTop[0][ix],(long)vBot[0][ix],(long)vTop[1][ix],(long)vBot[1][ix]);
//	//AfxMessageBox(s);
//	//Cycle thru each layer and plot vel within each layer.
//	if (isMainModelShowing && !isBoundOnly) {
//		double vminLayer = 99999., vmaxLayer = 0.;
//		vm.myVelModInterpolDisplay(velm, cd.coord.xmin, cd.coord.xmax, xShift, velColor.dxVDesired); //calculate velocity interpolation.
//		double grdXmax = velm->grdXmin + (velm->grdNx - 1)*velm->grdDx;
//		for (icont = 0; icont < velm->ncont - 1; icont++) {
//			//Find the min and max vel for this layer.
//			vminLayer = 99999.;
//			for (ix = 0; ix<velm->grdNx; ix++)
//				if (vminLayer>velm->vTop[icont][ix]) vminLayer = velm->vTop[icont][ix];
//			for (ix = 0; ix<velm->grdNx; ix++)
//				if (vminLayer>velm->vBot[icont][ix]) vminLayer = velm->vBot[icont][ix];
//			vmaxLayer = 0.;
//			for (ix = 0; ix < velm->grdNx; ix++)
//				if (vmaxLayer < velm->vTop[icont][ix]) vmaxLayer = velm->vTop[icont][ix];
//			for (ix = 0; ix < velm->grdNx; ix++)
//				if (vmaxLayer < velm->vBot[icont][ix]) vmaxLayer = velm->vBot[icont][ix];
//
//
//			dv = velColor.dv1;
//
//			//vminLayer should be rounded to a multiple of dv.
//			vminLayer = (int)(vminLayer / dv) * dv;
//
//			// we only plot a max of  500 points in resolution. Others will interpolate
//			nv = (int)((vmaxLayer - vminLayer) / dv + .5);
//			if (nv < 2) nv = 2;
//			if (nv >= 500) {
//				dv = (vmaxLayer - vminLayer) / 499;
//				nv = 500;
//			}	//Make sure plt[] array do not exceed 500.
//
//			//Loop through colors for this layer.
//			for (iv = 0; iv < 500; iv++) {
//				v = vminLayer + iv*dv;
//				if (v > vmaxLayer) break;
//
//				COLORREF colThis = CColorHelper::getVelocityColor((float)v, &velColor);
//
//				//Search by interpolation for the curve for v in layer icont.
//				for (ix = 0; ix < velm->grdNx; ix++) {
//					if (ix == (velm->grdNx - 1)) range = grdXmax;
//					else range = velm->grdXmin + velm->grdDx *(double)ix;
//					temp = velm->vBot[icont][ix] - velm->vTop[icont][ix];
//					if (velm->grdDepth[icont + 1][ix] < velm->grdDepth[icont][ix]) {
//						a = velm->grdDepth[icont + 1][ix];
//						b = velm->grdDepth[icont + 1][ix];
//					}
//					else if (fabs(temp) < 0.001) {
//						//const vel, odd fix.
//						if (nv == 2 && iv == 0) { a = velm->grdDepth[icont][ix]; b = velm->grdDepth[icont + 1][ix]; }
//						else if (nv == 2 && iv == 1) a = b = velm->grdDepth[icont + 1][ix];
//						else if (fabs(v - velm->vTop[icont][ix]) <= dv) a = velm->grdDepth[icont][ix];
//						else if (iv <= nv - 1) a = velm->grdDepth[icont][ix];
//						else a = velm->grdDepth[icont + 1][ix];
//					}
//					else {
//						a = velm->grdDepth[icont][ix] + (velm->grdDepth[icont + 1][ix] - velm->grdDepth[icont][ix])
//							*(v - velm->vTop[icont][ix]) / temp;
//						b = velm->grdDepth[icont][ix] + (velm->grdDepth[icont + 1][ix] - velm->grdDepth[icont][ix])
//							*(v + dv - velm->vTop[icont][ix]) / temp;
//					}
//					if (a < velm->grdDepth[icont][ix]) a = velm->grdDepth[icont][ix];
//					if (a > velm->grdDepth[icont + 1][ix]) a = velm->grdDepth[icont + 1][ix];
//					if (a < cd.coord.zmin) a = cd.coord.zmin;
//					if (a > cd.coord.zmax) a = cd.coord.zmax;
//					if (b < velm->grdDepth[icont][ix]) b = velm->grdDepth[icont][ix];
//					if (b > velm->grdDepth[icont + 1][ix]) b = velm->grdDepth[icont + 1][ix];
//					if (b < cd.coord.zmin) b = cd.coord.zmin;
//					if (b > cd.coord.zmax) b = cd.coord.zmax;
//
//					plt[ix] = cd.coord.mm_coord(range + xShift, a);
//					plt[2 * velm->grdNx - ix - 1] = cd.coord.mm_coord(range + xShift, b);
//				}
//
//				if (!draw.isNoColorMap)  {
//					CBrush brush;
//					CPen* oldPen = pDC->SelectObject(&whitePen);
//					if (draw.nodeMode == 2 && icont == iLayerFocus)
//						brush.CreateHatchBrush(HS_DIAGCROSS, colThis);
//					else
//						brush.CreateSolidBrush(colThis);
//					CBrush* oldBrush = pDC->SelectObject(&brush);
//					pDC->Polygon(plt, 2 * velm->grdNx);
//					pDC->SelectObject(oldBrush);
//					pDC->SelectObject(oldPen);
//					brush.DeleteObject();
//				}
//				else if (draw.nodeMode == 2 && icont == iLayerFocus) {
//					CPen* oldPen = pDC->SelectObject(&whitePen);
//					CBrush brush;
//					brush.CreateHatchBrush(HS_DIAGCROSS, colThis);
//					CBrush* oldBrush = pDC->SelectObject(&brush);
//					pDC->Polygon(plt, 2 * velm->grdNx);
//					pDC->SelectObject(oldBrush);
//					pDC->SelectObject(oldPen);
//					brush.DeleteObject();
//				}
//			} //End of loop iv.
//		}  //End of loop icont.
//
//		//Draw color bar.
//		this->DrawColorbar(pDC);
//	} // 	if (!isBoundOnly)
//
//	if (draw.isNoBoundary) return TRUE;
//
//	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
//	int dPlt = (int)(cd.coord.getPenThicknessNormal() * pFrame->statMain.bigNodes;
//
//	CPen whiteNodePen(PS_JOIN_BEVEL, (draw.isNoColorMap) ? 3 : 30, WHITE);
//	CPen whiteNodeFocusPen(PS_SOLID, (draw.isNoColorMap) ? 5 : 80, WHITE);
//
//	double xx[MOD_POINTS_MAX * 2], zz[MOD_POINTS_MAX * 2];
//	int itop, ibot, ileft, iright;
//	CPen* oldPen;
//	CBrush* oldBrush;
//	for (icont = 0; icont < velm->ncont; icont++) {
//		i = 0;
//		for (j = 0; j < velm->nzed[icont]; j++) {
//			xx[i] = velm->xm[j][icont] + xShift;
//			zz[i] = velm->zm[j][icont];
//			i++;
//		}
//		register int nLimit = min(2 * i, MOD_POINTS_MAX * 2);
//		i = myClipPoints2(i, nLimit, xx, zz, cd.coord.X12Y12());
//		for (j = 0; j < i; j++)
//			plt[j] = cd.coord.mm_coord(xx[j], zz[j]);
//
//		if (draw.nodeMode == 1 && icont == iLayerFocus) {
//			if (isMainModelShowing)
//				oldPen = pDC->SelectObject(&redPen);
//			else
//				oldPen = pDC->SelectObject(&thickPen);
//		}
//		else if (draw.nodeMode == 2 && !(icont == iLayerFocus || icont == iLayerFocus + 1)) {
//			if (greenPen != NULL)
//				oldPen = pDC->SelectObject(greenPen);
//			else
//				oldPen = pDC->SelectObject(&thinPen);
//		}
//		else {
//			if (greenPen != NULL)
//				oldPen = pDC->SelectObject(greenPen);
//			else
//				oldPen = pDC->SelectObject(&thickPen);
//		}
//		pDC->Polyline(plt, i);
//		pDC->SelectObject(oldPen);
//
//		if (draw.nodeMode == 1 && !draw.isNoNodes) {
//			// drawing nodes need to get rid of the clipped points on two sides, so re-calculate
//			i = 0;
//			for (j = 0; j < velm->nzed[icont]; j++) {
//				a = velm->xm[j][icont] + xShift;
//				b = velm->zm[j][icont];
//				if (cd.coord.isVisibleOrNot(a, b)) {
//					plt[i] = cd.coord.mm_coord(a, b);
//					i++;
//				}
//			}
//
//			if (icont == iLayerFocus) {
//				oldPen = pDC->SelectObject(&whiteNodeFocusPen);
//				oldBrush = pDC->SelectObject(&redBrush);
//			}
//			else {
//				oldPen = pDC->SelectObject(&whiteNodePen);
//				oldBrush = pDC->SelectObject(&greenBrush);
//			}
//			if (!isNoNodes) {
//				//int ixBorder1 = cd.mm_coord((float)velm->xmin + xShift);
//				//int ixBorder2 = cd.mm_coord((float)velm->xmax + xShift);
//				for (j = 0; j < i; j++) {
//					//if (draw.isCopying || draw.isPrinting) 
//					//	if (plt[j].x == ixBorder1 || plt[j].x == ixBorder2) 
//					//		continue;
//
//					itop = plt[j].y - dPlt;
//					ibot = plt[j].y + dPlt;
//					ileft = plt[j].x - dPlt;
//					iright = plt[j].x + dPlt;
//					pDC->Ellipse(ileft, itop, iright, ibot);
//				} // for j
//			}
//			pDC->SelectObject(oldPen);
//			pDC->SelectObject(oldBrush);
//		} //if(draw.nodes==
//	} // for i
//
//	//When an invalid iLayerFocus is selected, and when boundary or layer
//	//mode is first started, do not draw layer nodes, only boundary nodes.
//	//	if(iLayerFocus<0 || iLayerFocus >velm->nlayer)
//	//		return(TRUE);
//
//	if (!isBoundOnly && draw.nodeMode == 2 && iLayerFocus >= 0 && iLayerFocus < velm->ncont - 1)
//		//Draw nodes specifying velocities within layer iLayerFocus.
//	{
//		//Calculate the depths for all nodes (not given by velocity input file).
//		icont = iLayerFocus;
//		BOOL DrawTopLine = TRUE;
//		BOOL DrawBotLine = TRUE;
//		i = 0;
//
//		for (j = 0; j < velm->nvel[icont][0]; j++) {
//			x1 = velm->xvel[j][icont][0];
//			xx[i] = x1 + xShift;
//			for (ix = 0; ix < (velm->nzed[icont] - 1); ix++) {
//				if (x1 >= velm->xm[ix][icont] && x1 <= velm->xm[ix + 1][icont]) {
//					zz[i] = velm->zm[ix][icont] + (velm->zm[ix + 1][icont] -
//						velm->zm[ix][icont])*(x1 - velm->xm[ix][icont]) /
//						(velm->xm[ix + 1][icont] - velm->xm[ix][icont]);
//					break;
//				}
//			}
//			if (cd.coord.isVisibleOrNot(xx[i], zz[i])) i++;
//			else if (xx[i] >= cd.coord.X1() && xx[i] <= cd.coord.X2() &&
//				(zz[i]<cd.coord.Y1() || zz[i]>cd.coord.Y2()))
//				DrawTopLine = FALSE;
//		}
//
//		int nTop = i;
//		for (j = 0; j < nTop; j++)
//			plt[j] = cd.coord.mm_coord(xx[j], zz[j]);
//
//		i = 0;
//		for (j = 0; j < velm->nvel[icont][1]; j++) {
//			x1 = velm->xvel[j][icont][1];
//			xx[i] = x1 + xShift;
//			for (ix = 0; ix < velm->nzed[icont + 1] - 1; ix++) {
//				if (x1 >= velm->xm[ix][icont + 1] && x1 <= velm->xm[ix + 1][icont + 1]) {
//					zz[i] = velm->zm[ix][icont + 1] + (velm->zm[ix + 1][icont + 1] -
//						velm->zm[ix][icont + 1])*(x1 - velm->xm[ix][icont + 1]) /
//						(velm->xm[ix + 1][icont + 1] - velm->xm[ix][icont + 1]);
//					break;
//				}
//			}
//			if (cd.coord.isVisibleOrNot(xx[i] + xShift, zz[i])) i++;
//			else if (xx[i] >= cd.coord.X1() && xx[i] <= cd.coord.X2() &&
//				(zz[i]<cd.coord.Y1() || zz[i]>cd.coord.Y2()))
//				DrawBotLine = FALSE;
//		}
//		for (j = 0; j < i; j++)
//			pltOld[j] = cd.coord.mm_coord(xx[j], zz[j]);
//
//		if (!draw.isNoNodes) {
//
//			if (draw.isTopBound) {
//				oldPen = pDC->SelectObject(&whiteLinePen);
//				oldBrush = pDC->SelectObject(&redBrush);
//				for (j = 0; j < nTop; j++)
//					pDC->Ellipse(plt[j].x - dPlt, plt[j].y - dPlt, plt[j].x + dPlt, plt[j].y + dPlt);
//				pDC->SelectObject(oldBrush);
//				pDC->SelectObject(oldPen);
//				oldPen = pDC->SelectObject(&whitePen);
//				oldBrush = pDC->SelectObject(&blueBrush);
//				for (j = 0; j < i; j++)
//					pDC->Ellipse(pltOld[j].x - dPlt, pltOld[j].y - dPlt, pltOld[j].x + dPlt, pltOld[j].y + dPlt);
//				pDC->SelectObject(oldBrush);
//				pDC->SelectObject(oldPen);
//			}
//			else {
//				oldPen = pDC->SelectObject(&whitePen);
//				oldBrush = pDC->SelectObject(&blueBrush);
//				for (j = 0; j < nTop; j++)
//					pDC->Ellipse(plt[j].x - dPlt, plt[j].y - dPlt, plt[j].x + dPlt, plt[j].y + dPlt);
//				pDC->SelectObject(oldPen);
//				pDC->SelectObject(oldBrush);
//				oldPen = pDC->SelectObject(&whiteLinePen);
//				oldBrush = pDC->SelectObject(&redBrush);
//				for (j = 0; j < i; j++)
//					pDC->Ellipse(pltOld[j].x - dPlt, pltOld[j].y - dPlt, pltOld[j].x + dPlt, pltOld[j].y + dPlt);
//				pDC->SelectObject(oldPen);
//				pDC->SelectObject(oldBrush);
//			}
//		} // if !draw.isNoNodes
//	} // if draw.nodes == 2
//
//	whitePen.DeleteObject();
//	whiteLinePen.DeleteObject();
//	blackPen.DeleteObject();
//	redPen.DeleteObject();
//	thickPen.DeleteObject();
//	thinPen.DeleteObject();
//	blackBrush.DeleteObject();
//
//	redBrush.DeleteObject();
//	greenBrush.DeleteObject();
//	blueBrush.DeleteObject();
//
//	//CString tStr;
//	//if (cd.coord.xmin < velm->xmin || cd.coord.xmax > velm->xmax) {
//	//	tStr.Format(_T("Model limits: %f , %f km."), velm->xmin, velm->xmax);
//	//	myCaption(tStr);
//	//}
//
//
//
//	return(TRUE);
//}


void CSeisWideDoc::DrawRayPath(CDC * pDC)
{
	// only depth domain here
	int i, j;
	//CPoint *plt;
	if (!draw.isRayShowing) return;
	if (cd.coord.isTimeDomain()) return;
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	CSeisWideApp* pSeiApp = (CSeisWideApp*)AfxGetApp();

	//CSegyMeta::segyHeadInit(draw.timeSecName, &head);
	//CRayHelper::setXShotAll(head.xshotInSegy, draw.rayName, &tx);

	//make rPath.out file in the same directory as velMod.velSecName.
	CString dirRef = getWorkingPathSlash();

	this->raypaths.rayFileName = dirRef + _T("rPath.out");
	if (!CRayHelper::loadRayPathFromFile(&this->raypaths)) return;

	pFrame->raysKept.getRaysKept(dirRef);

	int irrcolOld = -1;
	COLORREF colorThis = RGB(rand() * 205, rand() * 205, rand() * 205);

	CPen aPen;
	CPen* oldPen = pDC->SelectObject(&aPen);
	// CPen lowPointPen(PS_SOLID, 10, RGB(0, 255, 255));

	double *xtmp = alloc1double(raypaths.npMax * 2);
	double *ztmp = alloc1double(raypaths.npMax * 2);
	CPoint *plt2 = alloc1CPoint(raypaths.npMax * 2);

	//double xtmp[TX_POINTS_MAX * 2];
	//double ztmp[TX_POINTS_MAX * 2];
	//CPoint plt2[TX_POINTS_MAX * 2];
	register int nLimit = TX_POINTS_MAX * 2;


	CStringArray 	*xrr = new CStringArray();
	CStringArray 	*zrr = new CStringArray();
	CStringArray 	*icolrr = new CStringArray();
	CString cstr;

//	float xShotFlatten = CCoords::isXShotDefined(tx.xShotRay) ? tx.xShotRay : (float)cd.coord.xmin;
//	float yShotFlatten = velMod.getHorizonDepthAtDist(xShotFlatten, velMod.ncontFlatten - 1);


	// addition on Jan 2, 2019
	int ic;
	int curveStart = 0;
	int curveEnd = this->raypaths.getTotCurve() - 1;
	float x0 = ERRORVAL;
	if (raypaths.iShot >= 0) {
		int count = 0;
		for (ic = 0; ic < this->raypaths.getTotCurve(); ic++) {
			if (!isFloatEqual3(raypaths.xr[ic][0], x0)) {
				x0 = raypaths.xr[ic][0];
				count++;
			}
			if (raypaths.iShot + 1 == count) {
				curveStart = ic;
				break;
			}
		}

		x0 = raypaths.xr[curveStart][0];
		for (ic = curveStart+1; ic < this->raypaths.getTotCurve(); ic++) {
			if (!isFloatEqual3(raypaths.xr[ic][0], x0)) {
				curveEnd = ic;
				break;
			}
		}
	}
	// end addition



	if (raypaths.rayCodeShow >= 0) {
		// to avoid the screen not displaying any raypaths for ic inside [curveStart, curveEnd], 
		// we may need to adjust raypaths.rayCodeShow
		bool isRaypathsFound = false;
		for (ic = curveStart; ic <= curveEnd; ic++) {
			if (raypaths.irrcol[ic] == raypaths.rayCodeShow) {
				isRaypathsFound = true;
				break;
			}
		}
		if (!isRaypathsFound) {
			// increment raypaths.rayCodeShow so that some raypaths can show
			for (ic = curveStart; ic <= curveEnd; ic++) {
				if (raypaths.irrcol[ic] > raypaths.rayCodeShow) {
					isRaypathsFound = true;
					raypaths.rayCodeShow = raypaths.irrcol[ic];
					break;
				}
			}
		}
		if (!isRaypathsFound) {
			// still not found, so we need to set raypaths.rayCodeShow to show all
			raypaths.rayCodeShow = -1;
		}
	} // if raypaths




	//int icontBot;
	int irrcol;
	//register float x1;
	//register float x2;
	//register float z1;
	//register float z2;
	//register float dx;
	//register float z;
	irrcolOld = -1;
	int iLineThickness = (int)myRound(40.0* pFrame->statMain.thicknessLines);
	int icSkipped = 0;



	pSeiApp->statWin.xPrev = ERRORVAL;
	for (ic = curveStart; ic <= curveEnd; ic++) {
		register int npts = raypaths.npts[ic];
		if (npts < 2) continue;

		if (!pFrame->raysKept.isXInsideKeepZones(raypaths.xr[ic][npts - 1], raypaths.xr[ic][0])) {
			icSkipped++;
			continue;
		}
		if (ic!= curveStart && ic!= npts-1 && !pSeiApp->statWin.isXKeep(raypaths.xr[ic][npts - 1]))
			continue;
		irrcol = raypaths.irrcol[ic];
		if (irrcolOld != irrcol && irrcol > 0) {
			// a new ray group encountered. Need to change color
			// NOTE: the first  irrcol   is   1
			colorThis = this->getRaycodeColor(tx.ivray[irrcol - 1]);
			irrcolOld = irrcol;
		}


		//============================================================
		// now we want to calculate the reflection point. 
		//############This reflection point display is useless, and is found to cause some issues. So disable June 7, 2020 ##################
		//############The issue: in release mode, I found some raypaths not displaying. I suspect this is the issue. And it can be slower to have it?
		//register float zLow = 0.f;
		//register float xLow = ERRORVAL;
		//for (j = 0; j < npts; j++) {
		//	if (zLow < raypaths.zr[ic][j]) {
		//		xLow = raypaths.xr[ic][j];
		//		zLow = raypaths.zr[ic][j];
		//	}
		//}
		//if (cd.coord.isVisibleOrNot((double)xLow, (double)zLow)){
		//	//############################################################################
		//	// save 2 numbers for later handling diving rays
		//	icontBot = 0;
		//	// First interpolate the velocity model to see if (xLow,zLow) is on the boundary
		//	BOOL isFound = FALSE;
		//	for (int icont = 0; icont < velMod.ncont; icont++) {
		//		if (icont >= MOD_LAYER_MAX) break;
		//		if (isFound) break;
		//		for (j = 1; j < velMod.nzed[icont]; j++) {
		//			// if the icontBot is obtained, do not update it any more
		//			if (isFound || icontBot > 0) break;
		//			if (j >= MOD_POINTS_MAX) break;
		//			if (xLow >= velMod.xm[j - 1][icont] && xLow <= velMod.xm[j][icont]) {
		//				// now we found that xLow is inside [x1,x2].
		//				// we try to see if zLow is to be linearly interpolated
		//				x1 = velMod.xm[j - 1][ic];
		//				x2 = velMod.xm[j][icont];
		//				z1 = velMod.zm[j - 1][ic];
		//				z2 = velMod.zm[j][icont];
		//				dx = x2 - x1;
		//				if (fabs(dx) >= 0.00001f) {
		//					z = z1 + (xLow - x1)*(z2 - z1) / dx;
		//					if (fabs(z - zLow) < 0.00001f) {
		//						cstr.Format(_T("%f"), xLow);
		//						xrr->Add(cstr);
		//						cstr.Format(_T("%f"), zLow);
		//						zrr->Add(cstr);
		//						cstr.Format(_T("%d"), irrcol);
		//						icolrr->Add(cstr);
		//						isFound = TRUE;
		//						break;
		//					}
		//					if (z >= zLow) {
		//						icontBot = icont;
		//						break;
		//					}
		//				}
		//			} // if xLow
		//		} // for j
		//	} // for icont

		//	if (!isFound && icontBot > 0) {
		//		// now the (xLow,zLow) is NOT on a boundary, and it is a real diving ray. We need to search 
		//		// for an adjacent point on the boundary
		//		// if no ray point is not on this boundary, the reflecting point does not exist
		//		BOOL isFoundDiving = FALSE;
		//		for (j = 1; j < velMod.nzed[icontBot]; j++) {
		//			if (isFoundDiving) break;
		//			x1 = velMod.xm[j - 1][icontBot];
		//			x2 = velMod.xm[j][icontBot];
		//			z1 = velMod.zm[j - 1][icontBot];
		//			z2 = velMod.zm[j][icontBot];
		//			for (k = 0; k < npts; k++) {
		//				if (raypaths.xr[ic][k] >= x1 && raypaths.xr[ic][k] <= x2) {
		//					// now xr[k] is inside [x1,x2]
		//					if (fabs(x2 - x1) >= 0.00001f) {
		//						z = z1 + (raypaths.xr[ic][k] - x1)*(z2 - z1) / (x2 - x1);
		//						if (fabs(z - raypaths.zr[ic][k]) < 0.00001f) {
		//							if (cd.coord.isVisibleOrNot((double)raypaths.xr[ic][k], (double)raypaths.zr[ic][k])){
		//								cstr.Format(_T("%f"), raypaths.xr[ic][k]);
		//								xrr->Add(cstr);
		//								cstr.Format(_T("%f"), raypaths.zr[ic][k]);
		//								zrr->Add(cstr);
		//								cstr.Format(_T("%d"), irrcol);
		//								icolrr->Add(cstr);
		//								isFoundDiving = TRUE;
		//								break;
		//							} // if isvalid
		//						} // if fabs(z-zr[k])
		//					} // if fabs(x1-x1)
		//				} // if xr[k]
		//			} // for k
		//		} // for j
		//	} // if !isFound
		//	//############################################################################
		//} // if isVisibleOrNot
		//============================================================

		// now decide if we should plot this ray path
		// int raypaths.rayCodeShow;  // -1=Show All, otherwise 0-20(show only if a ray code equals raypaths.rayCodeShow). For ray codes>20, will deduct  (int)(irrCol/20) * 20
		BOOL isPlotThisRay = TRUE;
		if (raypaths.rayCodeShow >= 0) {
			register int rayCodeCurr = (irrcol > 20) ? (int)(irrcol / 20) * 20 : irrcol;
			isPlotThisRay = rayCodeCurr == raypaths.rayCodeShow;
		}

		// now do clipping
		if (isPlotThisRay) {
			for (i = 0; i < npts; i++) {
				xtmp[i] = raypaths.xr[ic][i];
				ztmp[i] = raypaths.zr[ic][i];
				if (draw.ncontFlatten > 0) {
					// need to set arrays for xFlatten[] and yFlatten[], and nFlatten. 
					// no need to free them since destructor will do it automatically
					// but must use eAllocFloat to allocate
					ztmp[i] -= 
						interpolLinear(velMod.xmFlatten, velMod.zmFlatten, velMod.nFlatten, (float)xtmp[i])
						- velMod.zShotDatum;
				}
			}
			npts = myClipPoints2(npts, nLimit, xtmp, ztmp, cd.coord.X12Y12());
			if (npts > 0) {
				for (j = 0; j < npts; j++) {
					plt2[j] = cd.coord.mm_coord(xtmp[j], ztmp[j]);
				}
				aPen.CreatePen(PS_SOLID, iLineThickness, colorThis);
				pDC->SelectObject(&aPen);
				pDC->Polyline(plt2, npts);
				aPen.DeleteObject();
			}
		} // if isPlotThisRay
	} // while

	// now plot the low points
	//if (!draw.isNoLabelInSide) {
	//	// NOTE: here it can cause exceptions. So please test more before release it
	//	short pdx = (short)cd.coord.getPenThicknessNormal();
	//	short dx = (short)((pdx - cd.coord.logicalAxes.left) / cd.coord.mm_xscale + cd.coord.xmin);

	//	try
	//	{
	//		pDC->SelectObject(&lowPointPen);
	//		POINT pts[2];
	//		for (j = 0; j < xrr->GetSize(); j++) {
	//			register float xLow = (float)_tstof(xrr->ElementAt(j));
	//			register float zLow = (float)_tstof(zrr->ElementAt(j));
	//			if (cd.coord.isVisibleOrNot((double)(xLow - dx), (double)zLow) && 
	//				cd.coord.isVisibleOrNot((double)(xLow + dx), (double)zLow)) {
	//				pts[0] = pts[1] = cd.coord.mm_coord(xLow, zLow);
	//				pts[0].x -= pdx;
	//				pts[1].x += pdx;
	//				pDC->Polyline(pts, 2);
	//			}
	//		} // for j
	//	}
	//	catch (CResourceException* e) {
	//		e->ReportError();
	//		e->Delete();
	//	}
	//} // if

	pDC->SelectObject(oldPen);
//	lowPointPen.DeleteObject();

	// clean up
	free1double(xtmp);
	free1double(ztmp);
	free1CPoint(plt2);

	xrr->RemoveAll();
	delete xrr;
	xrr = NULL;
	zrr->RemoveAll();
	delete zrr;
	zrr = NULL;
	icolrr->RemoveAll();
	delete icolrr;
	icolrr = NULL;

	if (icSkipped > 0) {
		CString tStr;
		tStr.Format(_T("%d raypaths skipped due to matched pattens as defined in _rayKept.txt in the working folder."), icSkipped);
		pFrame->myCaption(tStr);
	}
}




BOOL CSeisWideDoc::DrawColorbar(CDC* pDC) {
	if (!draw.isColBar) return FALSE;

	CString tstr;
	CPoint p, p1;
	CPen greenPen(PS_SOLID, cd.coord.getPenThicknessNormal(), GREEN);
	CPen whitePen(PS_NULL, 0, WHITE);
	CPen thinPen(PS_SOLID, 0, RGB(0, 100, 0));


	//Draw a frame for the color bar.
	p = cd.coord.mm_coord(velColor.cxPos, velColor.cyPos);
	p1 = cd.coord.mm_coord(velColor.cxPos + velColor.cxExt, velColor.cyPos + velColor.cyExt);
	CRect rect2(p.x, p.y, p1.x, p1.y);
	CPen* oldPen = pDC->SelectObject(&greenPen);
	CBrush brush(WHITE);
	CBrush* oldBrush = pDC->SelectObject(&brush);
	pDC->Rectangle(rect2);
	pDC->SelectObject(oldBrush);
	pDC->SelectObject(oldPen);
	brush.DeleteObject();


	//if (velColor.colBarVmax < velColor.colBarVmin + 1.f)
	//	velColor.colBarVmax = velColor.colBarVmin + 1.f;

	//velColor.colBarVmin = getMinRounded(velColor.colBarVmin, velColor.colBarVmax, 8);
	//velColor.colBarVmax = getMaxRounded(velColor.colBarVmin, velColor.colBarVmax, 8);

	velColor.colBarVmin = 1.5f;
	velColor.colBarVmax = 8.0f;

	int nvBar = 50;
	double dvBar = (velColor.colBarVmax - velColor.colBarVmin) / (double)(nvBar - 1);
	for (int iv = 0; iv<nvBar; iv++) {
		double v = velColor.colBarVmin + iv*dvBar;
		COLORREF colThis = CColorHelper::getVelocityColor((float)v, &velColor);
		double x1 = velColor.cxPos + velColor.cxExt*(v - velColor.colBarVmin) / (velColor.colBarVmax - velColor.colBarVmin);
		p = cd.coord.mm_coord(x1, velColor.cyPos);
		double x2 = x1 + velColor.cxExt / (double)(nvBar - 1) * 2;
		if (x2>velColor.cxPos + velColor.cxExt) x2 = velColor.cxPos + velColor.cxExt;
		p1 = cd.coord.mm_coord(x2, velColor.cyPos + velColor.cyExt);
		CRect rect2(p.x, p.y, p1.x, p1.y);
		CPen* oldPen = pDC->SelectObject(&whitePen);
		CBrush brush(colThis);
		oldBrush = pDC->SelectObject(&brush);
		pDC->Rectangle(rect2);
		pDC->SelectObject(oldBrush);
		pDC->SelectObject(oldPen);
		brush.DeleteObject();
	}	//End of loop iv.

	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	LOGFONT logFontNum;
	pDC->GetCurrentFont()->GetLogFont(&logFontNum);
	float xyRatio = (float)logFontNum.lfWidth / (float)logFontNum.lfHeight;
	int numWidth = (LONG)myRound(pFrame->statMain.fLabelDistance3 * cd.coord.device2Logical * cd.coord.getDefDisplayAdjust(pDC) * 6.);
	int numHeight = (LONG)(numWidth / xyRatio);


	COLORREF oldColor = pDC->SetTextColor(RGB(0xB0, 0, 0));
	logFontNum.lfHeight = numHeight;
	logFontNum.lfWidth = numWidth;
	logFontNum.lfEscapement = 0;
	logFontNum.lfOrientation = 0;
	logFontNum.lfWeight = FW_NORMAL;
	logFontNum.lfItalic = 0;
	logFontNum.lfUnderline = 0;
	logFontNum.lfStrikeOut = 0;
	logFontNum.lfCharSet = ANSI_CHARSET;
	logFontNum.lfOutPrecision = OUT_DEFAULT_PRECIS;
	logFontNum.lfClipPrecision = CLIP_DEFAULT_PRECIS;
	logFontNum.lfQuality = DEFAULT_QUALITY;
	logFontNum.lfPitchAndFamily = VARIABLE_PITCH | FF_SWISS;
	_tcscpy_s(logFontNum.lfFaceName, _T("Sans Serif"));
	CFont fontN; // = new CFont();
	fontN.CreateFontIndirect(&logFontNum);
	CFont* oldFont = pDC->SelectObject(&fontN);

	CPoint plt[2];
	for (int iv = 0; iv < 10; iv++) {
		double v = 1 + iv;
		if (v<velColor.colBarVmin || v>velColor.colBarVmax) continue;
		double x1 = velColor.cxPos + velColor.cxExt*(v - velColor.colBarVmin) / (velColor.colBarVmax - velColor.colBarVmin);
		p = cd.coord.mm_coord(x1, velColor.cyPos);
		p1 = cd.coord.mm_coord(x1, velColor.cyPos + velColor.cyExt);
		plt[0] = p;
		plt[1] = p1;
		CPen* oldPen = pDC->SelectObject(&thinPen);
		pDC->Polyline(plt, 2);
		pDC->SelectObject(oldPen);
		tstr.Format(_T("%d"), (int)v);
		pDC->TextOut(p1.x - tstr.GetLength()*numWidth / 2, p1.y, tstr);
	}
	pDC->SelectObject(oldFont);
	fontN.DeleteObject();

	whitePen.DeleteObject();
	greenPen.DeleteObject();
	thinPen.DeleteObject();
	return TRUE;
}


//
//BOOL CSeisWideDoc::DrawContNotUsed(CDC* pDC)
//{
//	int i, j, icont;
//
//	//Generate velocity contours
//	int ix, iv, nv;
//	double range;
//	double a, b, x1, v, dv, temp;
//	CPoint p, p1, plt[MOD_POINTS_MAX * 2], pltOld[MOD_POINTS_MAX];
//	CString tstr;
//
//	BOOL xminmaxChanged = FALSE;
//	CVelMod vm;
//	vm.myVelModInterpolDisplay(&velMod, velMod.xmin, velMod.xmax, draw.distShift, velColor.dxVDesired);
//
//	double grdXmax = velMod.grdXmin + (velMod.grdNx - 1)*velMod.grdDx;
//
//	//float xminDisp = (float)velMod.xmin;
//	//if (xminDisp < cd.coord.xmin) xminDisp = (float)cd.coord.xmin;
//	//else if (xminDisp > cd.coord.xmax) return FALSE;  // no need to display anything
//
//	//float xmaxDisp = (float)velMod.xmax;
//	//if (xmaxDisp < cd.coord.xmin) return FALSE;  // no need to display anything
//	//else if (xmaxDisp > cd.coord.xmax) xmaxDisp = (float)cd.coord.xmax;
//
//	//Start plotting velocity color map.
//	CPen whitePen(PS_NULL, 0, WHITE);
//	CPen whiteLinePen(PS_SOLID, 0, WHITE);
//	CPen blackPen(PS_SOLID, 0, BLACK);
//	CPen redPen(PS_SOLID, cd.coord.getPenThicknessNormal(), RED);
//	CPen thickPen(PS_SOLID, cd.coord.getPenThicknessNormal(), BLACK);
//	CPen thinPen(PS_SOLID, 0, RGB(0, 100, 0));
//	CBrush blackBrush(BLACK);
//	CBrush redBrush(RED);
//	CBrush greenBrush(GREEN);
//	CBrush blueBrush(BLUE);
//
//	//For each velocity contour, look for the right depth for each range.
//	//Cycle thru each layer and plot vel within each layer.
//	double vminLayer = 99999., vmaxLayer = 0.;
//	for (icont = 0; icont < velMod.ncont - 1; icont++) {
//		//Find the min and max vel for this layer.
//		for (ix = 0; ix < velMod.grdNx; ix++) {
//			if (fabs(velMod.vBot[icont][ix] - velMod.vTop[icont][ix]) < 0.001) velMod.vBot[icont][ix] = velMod.vTop[icont][ix] + 0.001;
//		}
//		vminLayer = 999999.;
//		for (ix = 0; ix<velMod.grdNx; ix++)
//			if (vminLayer>velMod.vTop[icont][ix]) vminLayer = velMod.vTop[icont][ix];
//		for (ix = 0; ix<velMod.grdNx; ix++)
//			if (vminLayer>velMod.vBot[icont][ix]) vminLayer = velMod.vBot[icont][ix];
//		vmaxLayer = 0.;
//		for (ix = 0; ix < velMod.grdNx; ix++)
//			if (vmaxLayer < velMod.vTop[icont][ix]) vmaxLayer = velMod.vTop[icont][ix];
//		for (ix = 0; ix < velMod.grdNx; ix++)
//			if (vmaxLayer < velMod.vBot[icont][ix]) vmaxLayer = velMod.vBot[icont][ix];
//
//
//		dv = velColor.dv1;
//
//		//vminLayer should be rounded to a multiple of dv.
//		vminLayer = (int)(vminLayer / dv) * dv;
//
//		// we only draw a max of 500 horizontal points.
//		nv = (int)((vmaxLayer - vminLayer) / dv + .5);
//		if (nv < 2)  nv = 2;
//		if (nv >= 500) {
//			dv = (vmaxLayer - vminLayer) / 499;
//			nv = 500;
//		}	//Make sure plt[] array do not exceed 500.
//
//		//Loop through colors for this layer.
//		for (iv = 0; iv < 500; iv++)
//		{
//			v = vminLayer + iv*dv;
//			if (v > vmaxLayer) break;
//
//			COLORREF colThis = CColorHelper::getVelocityColor((float)v, &velColor);
//
//			//Search by interpolation for the curve for v in layer icont.
//			for (ix = 0; ix < velMod.grdNx; ix++) {
//				if (ix == (velMod.grdNx - 1)) range = grdXmax;
//				else range = velMod.grdXmin + velMod.grdDx * (double)ix;
//				temp = velMod.vBot[icont][ix] - velMod.vTop[icont][ix];
//				if (velMod.grdDepth[icont + 1][ix] < velMod.grdDepth[icont][ix]) {
//					a = velMod.grdDepth[icont + 1][ix];
//					b = velMod.grdDepth[icont + 1][ix];
//				}
//				else if (fabs(temp) < 0.001) {
//					//const vel, odd fix.
//					if (nv == 2 && iv == 0) { a = velMod.grdDepth[icont][ix]; b = velMod.grdDepth[icont + 1][ix]; }
//					else if (nv == 2 && iv == 1) a = b = velMod.grdDepth[icont + 1][ix];
//					else if (fabs(v - velMod.vTop[icont][ix]) <= dv) a = velMod.grdDepth[icont][ix];
//					else if (iv <= nv - 1) a = velMod.grdDepth[icont][ix];
//					else a = velMod.grdDepth[icont + 1][ix];
//				}
//				else {
//					a = velMod.grdDepth[icont][ix] + (velMod.grdDepth[icont + 1][ix] - velMod.grdDepth[icont][ix])
//						*(v - velMod.vTop[icont][ix]) / temp;
//					b = velMod.grdDepth[icont][ix] + (velMod.grdDepth[icont + 1][ix] - velMod.grdDepth[icont][ix])
//						*(v + dv - velMod.vTop[icont][ix]) / temp;
//				}
//				if (a < velMod.grdDepth[icont][ix]) a = velMod.grdDepth[icont][ix];
//				if (a > velMod.grdDepth[icont + 1][ix]) a = velMod.grdDepth[icont + 1][ix];
//				if (a < cd.coord.zmin) a = cd.coord.zmin;
//				if (a > cd.coord.zmax) a = cd.coord.zmax;
//				if (b < velMod.grdDepth[icont][ix]) b = velMod.grdDepth[icont][ix];
//				if (b > velMod.grdDepth[icont + 1][ix]) b = velMod.grdDepth[icont + 1][ix];
//				if (b < cd.coord.zmin) b = cd.coord.zmin;
//				if (b > cd.coord.zmax) b = cd.coord.zmax;
//				plt[ix] = cd.coord.mm_coord(range, a);
//				plt[2 * velMod.grdNx - ix - 1] = cd.coord.mm_coord(range, b);
//			}
//			if (!bmp24.bmpName.IsEmpty())
//				pDC->Polyline(plt, 2 * velMod.grdNx);
//			else {
//
//
//				CPen* oldPen;
//				CBrush* oldBrush;
//				if (!draw.isNoColorMap) {
//					oldPen = pDC->SelectObject(&blackPen);
//					CBrush brush;
//					brush.CreateSolidBrush(colThis);
//					oldBrush = pDC->SelectObject(&brush);
//					pDC->Polygon(plt, 2 * velMod.grdNx);
//					pDC->SelectObject(oldBrush);
//					pDC->SelectObject(oldPen);
//					brush.DeleteObject();
//				}
//				else if (draw.nodeMode == 2 && icont == draw.iLayerFocus) {
//					oldPen = pDC->SelectObject(&blackPen);
//					CBrush brush;
//					brush.CreateHatchBrush(HS_DIAGCROSS, WHITE);
//					oldBrush = pDC->SelectObject(&brush);
//					pDC->Polygon(plt, 2 * velMod.grdNx);
//					pDC->SelectObject(oldBrush);
//					pDC->SelectObject(oldPen);
//					brush.DeleteObject();
//				}
//				else {
//					// if here, no color map, but we need to draw contours only
//					oldPen = pDC->SelectObject(&blackPen);
//					pDC->Polygon(plt, 2 * velMod.grdNx);
//					pDC->SelectObject(oldPen);
//				}
//			}
//		} //End of loop iv.
//	}  //End of loop icont.
//
//	//Draw color bar.
//	DrawColorbar(pDC);
//
//
//	if (xminmaxChanged)
//	{
//		AfxMessageBox(_T(" xmin or xmax cannot be beyond model limits; For proper display, re-calculate the drawing or resize the model"));
//		draw.isSameDataDisplay = FALSE;
//	}
//	if (draw.isNoBoundary) return TRUE;
//
//	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
//	int dPlt = (int)(MIN(cd.coord.logicalAxes.Width(), cd.coord.logicalAxes.Height()) / 300.) * pFrame->statMain.bigNodes;
//
//	double xx[MOD_POINTS_MAX * 2], zz[MOD_POINTS_MAX * 2];
//	CPen* oldPen;
//	CBrush* oldBrush;
//	for (icont = 0; icont < velMod.ncont; icont++) {
//		i = 0;
//		for (j = 0; j < velMod.nzed[icont]; j++) {
//			xx[i] = velMod.xm[j][icont];
//			zz[i] = velMod.zm[j][icont];
//			i++;
//		}
//		register int nLimit = min(2 * i, MOD_POINTS_MAX * 2);
//		i = myClipPoints2(i, nLimit, xx, zz, cd.coord.X12Y12());
//		for (j = 0; j < i; j++)
//			plt[j] = cd.coord.mm_coord(xx[j], zz[j]);
//
//		if (draw.nodeMode == 1 && icont == draw.iLayerFocus)
//			oldPen = pDC->SelectObject(&redPen);
//		else  if (draw.nodeMode == 2 && !(icont == draw.iLayerFocus || icont == draw.iLayerFocus + 1))
//			oldPen = pDC->SelectObject(&thinPen);
//		else
//			oldPen = pDC->SelectObject(&thickPen);
//		pDC->Polyline(plt, i);
//		pDC->SelectObject(oldPen);
//
//		if (draw.nodeMode == 1 && !draw.isNoNodes)
//		{
//			if (icont == draw.iLayerFocus)
//			{
//				oldPen = pDC->SelectObject(&whiteLinePen);
//				oldBrush = pDC->SelectObject(&redBrush);
//			}
//			else
//			{
//				oldPen = pDC->SelectObject(&whitePen);
//				oldBrush = pDC->SelectObject(&greenBrush);
//			}
//			for (j = 0; j < i; j++) pDC->Ellipse
//				(plt[j].x - dPlt, plt[j].y - dPlt, plt[j].x + dPlt, plt[j].y + dPlt);
//			pDC->SelectObject(oldPen);
//			pDC->SelectObject(oldBrush);
//		}
//	}
//
//	if (draw.nodeMode == 2 && draw.iLayerFocus >= 0 && draw.iLayerFocus < velMod.ncont - 1)  //Draw nodes specifying velocities within layer draw.iLayerFocus.
//	{
//		//Calculate the depths for all nodes (not given by velocity input file).
//		if (draw.iLayerFocus < -1) draw.iLayerFocus = -1;
//		icont = draw.iLayerFocus;
//		BOOL DrawTopLine = TRUE;
//		BOOL DrawBotLine = TRUE;
//		i = 0;
//
//		for (j = 0; j < velMod.nvel[icont][0]; j++)
//		{
//			for (ix = 0; ix < (velMod.nzed[icont] - 1); ix++)
//			{
//				x1 = velMod.xvel[j][icont][0];
//				xx[i] = x1;
//				if (x1 >= velMod.xm[ix][icont] && x1 <= velMod.xm[ix + 1][icont])
//				{
//					zz[i] = velMod.zm[ix][icont] + (velMod.zm[ix + 1][icont] -
//						velMod.zm[ix][icont])*(x1 - velMod.xm[ix][icont]) /
//						(velMod.xm[ix + 1][icont] - velMod.xm[ix][icont]);
//					break;
//				}
//			}
//			if (cd.coord.isVisibleOrNot(xx[i], zz[i])) i++;
//			else if (xx[i] >= cd.coord.X1() && xx[i] <= cd.coord.X2() &&
//				(zz[i]<cd.coord.Y1() || zz[i]>cd.coord.Y2()))
//				DrawTopLine = FALSE;
//		}
//
//		int nTop = i;
//		for (j = 0; j < nTop; j++)
//			plt[j] = cd.coord.mm_coord(xx[j], zz[j]);
//
//		i = 0;
//		for (j = 0; j < velMod.nvel[icont][1]; j++)
//		{
//			for (ix = 0; ix < velMod.nzed[icont + 1] - 1; ix++)
//			{
//				x1 = velMod.xvel[j][icont][1];
//				xx[i] = x1;
//				if (x1 >= velMod.xm[ix][icont + 1] && x1 <= velMod.xm[ix + 1][icont + 1])
//				{
//					zz[i] = velMod.zm[ix][icont + 1] + (velMod.zm[ix + 1][icont + 1] -
//						velMod.zm[ix][icont + 1])*(x1 - velMod.xm[ix][icont + 1]) /
//						(velMod.xm[ix + 1][icont + 1] - velMod.xm[ix][icont + 1]);
//					break;
//				}
//			}
//			if (cd.coord.isVisibleOrNot(xx[i], zz[i])) i++;
//			else if (xx[i] >= cd.coord.X1() && xx[i] <= cd.coord.X2() &&
//				(zz[i]<cd.coord.Y1() || zz[i]>cd.coord.Y2()))
//				DrawBotLine = FALSE;
//		}
//		for (j = 0; j < i; j++)
//			pltOld[j] = cd.coord.mm_coord(xx[j], zz[j]);
//
//		if (draw.isTopBound)
//		{
//			oldPen = pDC->SelectObject(&redPen);
//			//	if(DrawTopLine) pDC->Polyline(plt,nTop);
//			pDC->SelectObject(oldPen);
//			oldPen = pDC->SelectObject(&thickPen);
//			//	if(DrawBotLine) pDC->Polyline(pltOld,i);
//			pDC->SelectObject(oldPen);
//		}
//		else
//		{
//			oldPen = pDC->SelectObject(&redPen);
//			//	if(DrawBotLine) pDC->Polyline(pltOld,i);
//			pDC->SelectObject(oldPen);
//			oldPen = pDC->SelectObject(&thickPen);
//			//	if(DrawTopLine) pDC->Polyline(plt,nTop);
//			pDC->SelectObject(oldPen);
//		}
//		if (!draw.isNoNodes)
//		{
//			if (draw.isTopBound)
//			{
//				oldPen = pDC->SelectObject(&whiteLinePen);
//				oldBrush = pDC->SelectObject(&redBrush);
//				for (j = 0; j < nTop; j++)
//					pDC->Ellipse(plt[j].x - dPlt, plt[j].y - dPlt, plt[j].x + dPlt, plt[j].y + dPlt);
//				pDC->SelectObject(oldBrush);
//				pDC->SelectObject(oldPen);
//				oldPen = pDC->SelectObject(&whitePen);
//				oldBrush = pDC->SelectObject(&blueBrush);
//				for (j = 0; j < i; j++)
//					pDC->Ellipse(pltOld[j].x - dPlt, pltOld[j].y - dPlt, pltOld[j].x + dPlt, pltOld[j].y + dPlt);
//				pDC->SelectObject(oldBrush);
//				pDC->SelectObject(oldPen);
//			}
//			else
//			{
//				oldPen = pDC->SelectObject(&whitePen);
//				oldBrush = pDC->SelectObject(&blueBrush);
//				for (j = 0; j < nTop; j++)
//					pDC->Ellipse(plt[j].x - dPlt, plt[j].y - dPlt, plt[j].x + dPlt, plt[j].y + dPlt);
//				pDC->SelectObject(oldPen);
//				pDC->SelectObject(oldBrush);
//				oldPen = pDC->SelectObject(&whiteLinePen);
//				oldBrush = pDC->SelectObject(&redBrush);
//				for (j = 0; j < i; j++)
//					pDC->Ellipse(pltOld[j].x - dPlt, pltOld[j].y - dPlt, pltOld[j].x + dPlt, pltOld[j].y + dPlt);
//				pDC->SelectObject(oldPen);
//				pDC->SelectObject(oldBrush);
//			}
//		} //end of  !draw.isNoNodes
//	}
//
//	whitePen.DeleteObject();
//	whiteLinePen.DeleteObject();
//	blackPen.DeleteObject();
//	redPen.DeleteObject();
//	thickPen.DeleteObject();
//	thinPen.DeleteObject();
//	blackBrush.DeleteObject();
//
//	redBrush.DeleteObject();
//	greenBrush.DeleteObject();
//	blueBrush.DeleteObject();
//
//	return(TRUE);
//}


//BOOL CSeisWideDoc::MyDlgBound2(double xOld, double yOld, double xNew, double yNew)
//{
//	CBoundNodes dlg;
//	dlg.m_layerFocus = draw.iLayerFocus;
//	dlg.m_xNew = xNew;
//	dlg.m_yNew = yNew;
//	dlg.m_xOld = xOld;
//	dlg.m_yOld = yOld;
//	if (dlg.DoModal() == IDOK)
//	{
//		draw.iLayerFocus = dlg.m_layerFocus;
//		xNew = dlg.m_xNew;
//		yNew = dlg.m_yNew;
//		xOld = dlg.m_xOld;
//		yOld = dlg.m_yOld;
//		return (TRUE);
//	}
//	else return (FALSE);
//}

//BOOL CSeisWideDoc::showDigLineDraw(CDC *pDC)
//{
//	//this routine draws all digitized lines or any external line drawings, in time or depth.
//	//called only in OnDraw().
//	if (draw.isNoBoundary) return FALSE;
//	// if (!isFileExistNotDirectory(dig.digName))
//
//	myShowFloatReflectors(pDC); // draws floating reflectors.
//	if (dig.isDigitizing) {
//		myShowDigitize(pDC, &dig, false, !this->isHalfOffsetMode());
//	}
//	else
//		drawLineDrawing(pDC);
//
//	return TRUE;
//}


void CSeisWideDoc::drawFloatReflectors(CDC *pDC)
{
	if (!CVelMod::myLoadFloatReflectors(&velMod)) return;

	// draws floating reflectors. Called only from showDigLineDraw() which is called from OnDraw().
	int i, ii, j;
	float xpos, ypos, xpos2, ypos2, xpos3, ypos3;
	CPoint *plt, plt1[4];

	CPen* oldPen;



	// now start draw the floating reflectors.
	// CPen bluePen(PS_SOLID, (int)(min(cd.coord.logicalAxes.Width(), cd.coord.logicalAxes.Height())/600), RGB(0,0,255));
	CPen bluePen(PS_SOLID, 3, RGB(0, 255, 255));
	CPen thinBluePen(PS_SOLID, 1, BLUE);
	//	CPen blackPen(PS_SOLID, (int)(max(cd.coord.logicalAxes.Width(), cd.coord.logicalAxes.Height())/600), RGB(0,255,0));

	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	int dPlt = (int)(cd.coord.getPenThicknessNormal() * 2. * pFrame->statMain.bigNodes);


	for (i = 0; i < velMod.flTotCurve; i++) {
		ii = 0;
		plt = (CPoint *)alloc1CPoint(velMod.flNpArray[i]);
		if (plt == NULL)  {
			pFrame->myCaption(_T("Memory un-available 9"));
			return;
		}
		for (j = 0; j < velMod.flNpArray[i]; j++) {
			xpos3 = xpos2 = xpos = velMod.flXArray[j][i];
			ypos3 = ypos2 = ypos = velMod.flTArray[j][i];
			if (j + 1 < velMod.flNpArray[i]) {
				xpos2 = velMod.flXArray[j + 1][i];
				ypos2 = velMod.flTArray[j + 1][i];
			}
			if (j - 1 >= 0) {
				xpos3 = velMod.flXArray[j - 1][i];
				ypos3 = velMod.flTArray[j - 1][i];
			}
			if (!cd.coord.isVisibleOrNot(xpos, ypos) && !cd.coord.isVisibleOrNot(xpos2, ypos2) && !cd.coord.isVisibleOrNot(xpos3, ypos3)) continue;

			plt[ii] = cd.coord.mm_coord(xpos, ypos);

			ii++;
		}
		if (ii > 1)  {
			oldPen = pDC->SelectObject(&bluePen);
			pDC->Polyline(plt, ii);
			pDC->SelectObject(oldPen);
		}
		free1CPoint(plt);
	}

	bluePen.DeleteObject();
	thinBluePen.DeleteObject();
}




BOOL CSeisWideDoc::myShowTravelTime(CDC *pDC, CPen *pPen)
{
	// aPen is the default color to use. But if we want other colors, it can be calculated inside
	// if return FALSE, loading the travel-time curves has failed.
	if ((cd.coord.drawmode != 0    // time section in km
		&& cd.coord.drawmode != 7  // NMO or gas hydrate display
		) 
		|| !draw.isRayShowing
		|| draw.isNoBoundary
		|| !cd.coord.isTimeDomain()) return FALSE;

	//long i;
	CString txPath;
	double xpos, ypos;
	CString tStr;
	CPen* pOldPen;

	bool isDistanceLeftOfShot = false;
	 
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();

	//make tx.out file in the same directory as velMod.velSecName, and load "tx.out" into tx.***.
	// Even if the tx.out is already loaded, here I load it again.

	// note: we must calc the xShot each time we display the TT curves; it happens that even when xShot has a valid value, it represents a source for a different segy file
	txPath = getWorkingPathSlash() + _T("tx.out");
	if (!isDirectoryExist(txPath)) {
		txPath = _T("tx.out");
	}

	// get the TT curves for the correct xShot
	CSegyMeta::segyHeadInit(draw.timeSecName, &head);

	double xs = ERRORVAL;
	if (!draw.timeSecName.IsEmpty())
		xs = head.xshotInSegy; // get xs from segy 
	else if (dig.isZeltFormat)
		xs = dig.xShotCache;   // get xs from picks

	
	if (!CCoords::isXShotDefined(xs)) {
		if (myCountAllFrames() < 3)
			xs = tx.xShotRay;    // get xs from TT curves
		else
			return FALSE;
	}


	if (!CRayHelper::myLoadTravelTime(txPath, &tx, (float)xs)) {
		return FALSE;
	}
	
	if (!isFloatEqual((float)xs, tx.xShotRay, 0.00001f)) {
		if (myCountAllFrames() > 2)
			return FALSE; // we do not want to display this TX since there are >2 MDI windows open, otherwise it can be confusing to the user.

		tStr.Format(_T("Displayed travel time curves not for the same source (%s: %g km; raytrace: %g km)."), GetBaseFileName(draw.timeSecName), xs, tx.xShotRay);
		static bool isWarned = false;
		if (!isWarned) {
			AfxMessageBox(tStr);
			isWarned = true;
		}
		else pFrame->myCaption(tStr);
		// since only 2 MDI windows open, we hope the user can recognize it easily
	}

	//bool isHalfOffsets = cd.coord.isDistanceDisplay &&
	//	cd.coord.drawmode == 7 &&
	//	draw.red.rvred > 0.1 &&
	//	isModelVisible(&velMod, 0.);
	bool isHalfOffsets = isHalfOffsetMode(); 
	cd.coord.isMinusXShot = CRayHelper::isMinusXShot(&tx);

	int ip;
	int ii = 0;
	register double *xx = (double *)ealloc1double(TX_POINTS_MAX * 2);
	register double *tt = (double *)ealloc1double(TX_POINTS_MAX * 2);
	CPoint *plt = (CPoint *)alloc1CPoint(TX_POINTS_MAX * 2);
	if (xx == NULL || tt == NULL) {
		AfxMessageBox(_T("Memory un-available 4"));
		return FALSE;
	}
	bool isCurvesPlotted = false;
	bool isCircleDetected = false;
	int lineThickness = (int)myRound(40.0* pFrame->statMain.thicknessLines);
	for (int k = 0; k < 2; k++)
		for (int ic = 0; ic < tx.tot[k]; ic++) {
			register int n = tx.Num[k][ic];
			if (n < 2) continue;

			for (ip = 0; ip < n; ip++) {
				xpos = tx.X[k][ip][ic];
				register double offset = cd.coord.getOffsetFromDist((double)xpos, (double)tx.xShotRay);
				ypos = tx.T[k][ip][ic] - CCoords::getReduceTimeEx2(offset, cd.coord.drawmode, &draw.red);
				xx[ip] = (cd.coord.isDistanceDisplay) ? xpos : offset;

				if (isHalfOffsets)
					xx[ip] = xx[ip] - offset * 0.5f;

				tt[ip] = ypos;
			} // for i
			register int nLimit = min(2 * n, TX_POINTS_MAX * 2);
			ii = myClipPoints2(n, nLimit, xx, tt, cd.coord.X12Y12());
			if (ii > 0) {
				CPen redPen;

				if (pPen != NULL) {
					pOldPen = pDC->SelectObject(pPen);
				}
				else if (draw.TTCurveColor < 4) {
					redPen.CreatePen(PS_SOLID, lineThickness, getRayColor(draw.TTCurveColor));
					pOldPen = pDC->SelectObject(&redPen);
				}
				else {
					if (tx.isCurveReflection(ic, k)) {
						redPen.CreatePen(PS_DASH, lineThickness, NAVY);
						// PS_DASHDOT should be thinner otherwise it is not good in display
					}
					else {
						register int rayCodeThis = tx.RayCodePerCurve[k][ic];
						register int colourCodeThis = (rayCodeThis < tx.ncolour) ? tx.colour[rayCodeThis] : rayCodeThis;
						COLORREF colorThis = this->getRaycodeColor(colourCodeThis);
						redPen.CreatePen(PS_SOLID, lineThickness, colorThis);
					}
					pOldPen = pDC->SelectObject(&redPen);
				} // if ii

				int count = 0;
				for (ip = 0; ip < ii; ip++) {
					plt[count] = cd.coord.mm_coord(xx[ip], tt[ip]);
					count++;
					//if (cd.coord.isVisibleOrNot(xx[ip], tt[ip])) {
					//}
				}
				if (ic != tx.circleCurve)
					pDC->Polyline(plt, count);
				else {
					for (ip = 0; ip < count; ip++) {
						pDC->Ellipse(plt[ip].x - 200, plt[ip].y - 200, plt[ip].x + 200, plt[ip].y + 200);
					}
					isCircleDetected = true;
				}

				redPen.DeleteObject();

				pDC->SelectObject(pOldPen);
				isCurvesPlotted = true;
			}
	} // k and j
	free1double(xx);
	free1double(tt);
	free1CPoint(plt);

	if (tx.circleCurve >= 0 && !isCircleDetected) {
		// if here, the circle display is intended but no circles are detected. So we should set to no display
		tx.circleCurve = -1;
	}

	CString str;
	if (!isCurvesPlotted) {
		str.Format(_T("TT read in for source at %f km, but not plotted. Shooting direction compatible?"), tx.xShotRay);
		pFrame->myCaption(str);
	}


	return TRUE;

}


void CSeisWideDoc::myUpdateStatusBar()
{
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	ASSERT(pFrame);

	if (draw.wiggle > 3) {
		pFrame->statMain.gAmpThreshold.Format(_T("%d%%"), draw.logScaleThreshold);
	}
	else {
		pFrame->statMain.gAmpThreshold.Format(_T("%gC"), areaFill.clip);
	}

}


BOOL CSeisWideDoc::myShowDigitizeZeltOnly(CDC* pDC)
{
	if (dig.nPoint == NULL) return FALSE;  // this avoids program crash
	if (!dig.isDigitizing) return FALSE;
	if (!dig.isZeltFormat || !cd.coord.isTimeDomain()) return FALSE;
	//if (draw.is)
//	return FALSE;

	CPoint plt2[2];
	double xpos, ypos;
	int i, j;

	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	CSeisWideApp* pSeiApp = (CSeisWideApp*)AfxGetApp();

	// how thick should the error bars be? I choose they are roughly half the trace intervals (i.e. draw.trcInt), no!
	// int penThickness = min(60, (int)myRound(draw.trcInt * cd.coord.mm_xscale * pFrame->thicknessLines));

	//int penThickness = (int)myRound(2 * pFrame->statMain.thicknessLines);
	//if (penThickness > 4) penThickness = 60;
	//else if (penThickness > 100) penThickness = 100;
	int penThickness = 0; // later decided to only show thinest Zelt picks
	CPen greenPen(PS_SOLID, penThickness, RED);
	double dPlt;
	CBrush* oldBrush;
	CPen* oldPen = pDC->SelectObject(&greenPen);

	COLORREF col = RGB(255, 255, 0);
	CPen randomPen(PS_SOLID, penThickness, col);

	for (i = 0; i < dig.totCurve; i++) {
		//int ind = i + 2;  // note: why we add 2 to the index? It is because if not, the computed TT curves would likely have the same color
		// which cannot be seen clearly. Add just 1 is not enough.
		//while (ind >= lineColors.NUM_LINECOLORS)
		//	ind -= lineColors.NUM_LINECOLORS;
		//if (lineColors.r[ind] == lineColors.g[ind] == lineColors.b[ind]) ind ++; // skip any B/W colors
		//if (abs(lineColors.r[ind] - lineColors.g[ind]) + abs(lineColors.g[ind] - lineColors.b[ind]) + abs(lineColors.b[ind] - lineColors.r[ind]) < 40)
		//	ind ++;
		//register COLORREF col = RGB(lineColors.r[ind],
		//	lineColors.g[ind],
		//	lineColors.b[ind]);

		if (i == dig.iCurveSel)
			pDC->SelectObject(&greenPen);
		else
			pDC->SelectObject(&randomPen);

		int ii = 0;

		//digitize format with error bars.
		// CPoint plt2[2];
		// if the bar is too small, we need to boost it to display properly
		//if (dig.curveVal[i] < 2.*velColor.dz)
		//	dig.curveVal[i] = (float)(2.*velColor.dz);
		if (dig.zeltBarForm == 0) { //show as error bar.
			pSeiApp->statWin.xPrev = ERRORVAL;
			int npts = dig.nPoint[i];
			for (j = 0; j<npts; j++) {
				xpos = dig.x[j][i];

				if (j!=0 && j!=npts-1 && !pSeiApp->statWin.isXKeep(xpos))
					continue;

				ypos = dig.t[j][i];
				ypos -= CCoords::getReduceTimeEx2(cd.coord.getOffsetFromXVal(xpos, dig.xShotCache), cd.coord.drawmode, &draw.red);
				if (cd.coord.isVisibleOrNot(xpos, ypos)) {
					plt2[0] = cd.coord.mm_coord(xpos, ypos - dig.curveVal[i]);
					register double a = ypos + dig.curveVal[i];
					if (a > cd.coord.Y2()) a = cd.coord.Y2(); // this helps to make the rectangle perfect for resizing in corelDraw
					plt2[1] = cd.coord.mm_coord(xpos, a);
					plt2[1].x += 1;
					//pDC->Polyline(plt2, 2);
					pDC->MoveTo(plt2[0]);
					pDC->LineTo(plt2[1]);
				}
			}
		}
		else if (dig.zeltBarForm == 1 || dig.zeltBarForm == 2) { //show as circle (1=open; 2=filled).
			CBrush redBrush(RED);
			if (dig.zeltBarForm == 2)
				oldBrush = pDC->SelectObject(&redBrush);
			else
				pDC->SelectStockObject(NULL_BRUSH);
			for (j = 0; j<dig.nPoint[i]; j++) {
				xpos = dig.x[j][i];
				ypos = dig.t[j][i];
				ypos -= CCoords::getReduceTimeEx2(cd.coord.getOffsetFromXVal(xpos, dig.xShotCache), cd.coord.drawmode, &draw.red);

				if (cd.coord.isVisibleOrNot(xpos, ypos)) {
					dPlt = dig.curveVal[i];
					plt2[0] = cd.coord.mm_coord(xpos, ypos);
					register double a = ypos + dPlt;
					if (a > cd.coord.Y2()) a = cd.coord.Y2(); // this helps to make the rectangle perfect for resizing in corelDraw
					plt2[1] = cd.coord.mm_coord(xpos, a);
					int iPlt = abs(plt2[1].y - plt2[0].y);
					pDC->Ellipse(plt2[0].x - iPlt / 2, plt2[0].y - iPlt, plt2[0].x + iPlt / 2, plt2[0].y + iPlt);
				}
			}
			if (dig.zeltBarForm == 2)
				pDC->SelectObject(oldBrush);
		}
		else if (dig.zeltBarForm == 3) { //show as crosses.
			for (j = 0; j < dig.nPoint[i]; j++) {
				xpos = dig.x[j][i];
				ypos = dig.t[j][i];
				ypos -= CCoords::getReduceTimeEx2(cd.coord.getOffsetFromXVal(xpos, dig.xShotCache), cd.coord.drawmode, &draw.red);

				if (cd.coord.isVisibleOrNot(xpos, ypos)) {
					dPlt = dig.curveVal[i];
					plt2[0] = cd.coord.mm_coord(xpos, ypos - dPlt);
					plt2[1] = cd.coord.mm_coord(xpos, ypos + dPlt);
					pDC->Polyline(plt2, 2);
					int iPlt = abs(plt2[1].y - plt2[0].y) / 4;
					plt2[1] = plt2[0] = cd.coord.mm_coord(xpos, ypos);
					plt2[0].x -= iPlt;
					plt2[1].x += iPlt;
					pDC->Polyline(plt2, 2);
				}
			}
		} // if (dig.barForm
	} // for (i=0; i<=dig.iCurve


	// finally, plot the raycodes
	if (!draw.isNoLabelInSide) {
		LOGFONT logFontNum;
		CSize aSize = pFrame->getFontNumSize(pDC, &cd);
		logFontNum.lfHeight = (int)(aSize.cy * 1.8);
		logFontNum.lfWidth = (int)(aSize.cx * 1.8);

		logFontNum.lfEscapement = 0;
		logFontNum.lfOrientation = 0;
		// logFontNum.lfWeight = FW_NORMAL;
		logFontNum.lfWeight = FW_HEAVY;
		logFontNum.lfItalic = 0;
		logFontNum.lfUnderline = 0;
		logFontNum.lfStrikeOut = 0;
		logFontNum.lfCharSet = ANSI_CHARSET;
		logFontNum.lfOutPrecision = OUT_DEFAULT_PRECIS;
		logFontNum.lfClipPrecision = CLIP_DEFAULT_PRECIS;
		logFontNum.lfQuality = DEFAULT_QUALITY;
		logFontNum.lfPitchAndFamily = FF_SWISS;
		_tcscpy_s(logFontNum.lfFaceName, _T("Times"));
		CFont fontN;
		fontN.CreateFontIndirect(&logFontNum);
		CFont fontN2;
		logFontNum.lfWeight = FW_BOLD;
		fontN2.CreateFontIndirect(&logFontNum);

		CFont* oldFont;
		COLORREF oldColor;
		for (i = 0; i < dig.totCurve; i++) {
			// added Jan 2007 to plot labels for this curve
			int jSelected = dig.nPoint[i] - 1;
			if (jSelected<0) continue;
			xpos = (dig.x[jSelected][i] > cd.coord.X2()) ?
				cd.coord.X2() : dig.x[jSelected][i];

			ypos = dig.t[jSelected][i] -
				CCoords::getReduceTimeEx2(cd.coord.getOffsetFromXVal(xpos, dig.xShotCache), cd.coord.drawmode, &draw.red);

			if (cd.coord.isVisibleOrNot(xpos, ypos)) {
				register CPoint p = cd.coord.mm_coord(xpos, ypos);
				register CString a;
				a.Format(_T("%d"), dig.ivray[i]);
				for (int k = 0; k < tx.rayCodes->GetCount(); k++) {
					register CString strRayCode = tx.rayCodes->GetAt(k);
					strRayCode.Trim();
					if (strRayCode.Find(a) == 0) {
						a = strRayCode;
						break;
					}
				}
				oldFont = pDC->SelectObject(&fontN);
				oldColor = pDC->SetTextColor(WHITE);
				pDC->TextOut((int)p.x, (int)(p.y - aSize.cy*0.5), a);
				pDC->SelectObject(oldFont);
				pDC->SetTextColor(oldColor);

				oldFont = pDC->SelectObject(&fontN2);
				//oldColor = pDC->SetTextColor(getGoodColorRand(false));
				oldColor = pDC->SetTextColor(BLUE);
				pDC->TextOut((int)p.x, (int)(p.y - aSize.cy*0.5), a);
				pDC->SelectObject(oldFont);
				pDC->SetTextColor(oldColor);
			}
		} // for i

		fontN.DeleteObject();
		fontN2.DeleteObject();
	}


	pDC->SelectObject(oldPen);
	return TRUE;
}

//BOOL myShowDigitize(CDC* pDC, CDigitize::DIGITIZE *dig2);
BOOL CSeisWideDoc::myShowDigitize(CDC* pDC, CDigitize::DIGITIZE *pDig2, bool isMarker, bool isReduce)
{
	if (pDig2->nPoint == NULL) return FALSE;  // this avoids program crash
	if (!pDig2->isDigitizing) return FALSE;
	if (pDig2->isZeltFormat) {
		CSegyMeta::segyHeadInit(draw.timeSecName, &head);
		double xshotUse = cd.isXShotDefined(head.xshotInSegy) ? head.xshotInSegy : pDig2->xShotCache;
		CTime aTimeFile = getFileModifiedTime(pDig2->digName);
		if (pDig2->modifiedtime>0 && aTimeFile > pDig2->modifiedtime+100) {
			CString tStr;
			
			tStr.Format(_T("%s:\nFile on disk \n%s\n is newer than in memory. Do you want to load it (ignore newer editting if any)?"), this->GetTitle(), pDig2->digName);
			if (AfxMessageBox(tStr, MB_YESNO | MB_ICONQUESTION) == IDYES) {
				// load zelt data
				CDigitize pDg;
				pDg.myDigLoadZelt(pDig2, xshotUse);
			}
			pDig2->modifiedtime = aTimeFile; // this line will make it silent
		}

		return myShowDigitizeZeltOnly(pDC);
	}

	double xpos, ypos;
	int i, j;

	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();

	// how thick should the error bars be? I choose they are roughly half the trace intervals (i.e. draw.trcInt), no!
	// int penThickness = min(60, (int)myRound(draw.trcInt * cd.coord.mm_xscale * pFrame->thicknessLines));
	int penThickness = (int)myRound(60 * pFrame->statMain.thicknessLines);
	if (penThickness > 300) penThickness = 300;
	CPen greenPen(PS_SOLID, penThickness, RED); 
	int dPltPlain = (int)(cd.coord.getPenThicknessNormal() * pFrame->statMain.bigNodes);
	CPen* pOldPen;
	bool isTime = cd.coord.isTimeDomain() == TRUE;
	CPoint *plt = (CPoint *)alloc1CPoint(2 * pDig2->digPointMax);

	CPen bluePen(PS_SOLID, 0, GRAY);
	pOldPen = pDC->SelectObject(&bluePen);
	//for (i = 0; i < pDig2->totCurve; i++) {
	//	if (!isFloatEqual3(pDig2->curveVal[i], ERRORVAL)) {
	//		plt[0] = cd.coord.mm_coord(pDig2->curveVal[i], cd.coord.Y1());
	//		plt[1] = cd.coord.mm_coord(pDig2->curveVal[i], cd.coord.Y2());
	//		pDC->Polyline(plt, 2);
	//	}
	//}
	pDC->SelectObject(pOldPen);


	CBrush greenBrush;
	if (isMarker)
		greenBrush.CreateSolidBrush(GREEN);
	else
		greenBrush.CreateSolidBrush(BLUE);

	pDC->SelectObject(greenBrush);
	for (i = 0; i < pDig2->totCurve; i++) {
		int ind = i + 2;  // note: why we add 2 to the index? It is because if not, the computed TT curves would likely have the same color
		// which cannot be seen clearly. Add just 1 is not enough.
		while (ind >= lineColors.NUM_LINECOLORS)
			ind -= lineColors.NUM_LINECOLORS;
		register COLORREF col = RGB(lineColors.r[ind], lineColors.g[ind], lineColors.b[ind]);
		register CPen randomPen(PS_SOLID, penThickness, col);
		if (i == pDig2->iCurveSel)
			pOldPen = pDC->SelectObject(&greenPen);
		else
			pOldPen = pDC->SelectObject(&randomPen);

		register int ii = 0;
		if (plt == NULL) {
			AfxMessageBox(_T("Memory un-available 2"));
			return FALSE; //problem, and return.
		}
		for (j = 0; j < pDig2->nPoint[i]; j++) {
			xpos = pDig2->x[j][i];
			ypos = pDig2->t[j][i];
			//
			//if (cd.coord.isTimeDomain() && cd.coord.drawmode != 10) {
			if (isReduce) {
				ypos -= CCoords::getReduceTimeEx2(cd.coord.getOffsetFromXVal(xpos, pDig2->xShotCache), cd.coord.drawmode, &draw.red);
			}
			plt[ii] = cd.coord.mm_coord(xpos, ypos);
			ii++;
			//}
		}
		if (ii > 0) {
			// now for the selected curve, I need to show points in addition to curve!
			if (i == pDig2->iCurveSel || isMarker) {
				for (int j = 0; j < ii; j++) {
					pDC->Ellipse((int)(plt[j].x - dPltPlain), (int)(plt[j].y - dPltPlain),
						(int)(plt[j].x + dPltPlain), (int)(plt[j].y + dPltPlain));
				}
			}

			ii = CCoords::myClipPoints2b(ii, 2 * pDig2->digPointMax, plt, &cd);
			pDC->Polyline(plt, ii);
		}
	} // for (i=0; i<=dig.iCurve
	pDC->SelectObject(pOldPen);
	free1CPoint(plt);

	return TRUE;

}

BOOL CSeisWideDoc::myShowDigitizeTimeDomain_Depreciate(CDC* pDC)
{
	if (dig.isZeltFormat)
		return myShowDigitizeZeltOnly(pDC);

	if (dig.nPoint == NULL) return FALSE;  // this avoids program crash
	if (!dig.isDigitizing) return FALSE;

	double xpos, ypos;
	int i, j;

	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();

	// how thick should the error bars be? I choose they are roughly half the trace intervals (i.e. draw.trcInt), no!
	// int penThickness = min(60, (int)myRound(draw.trcInt * cd.coord.mm_xscale * pFrame->thicknessLines));
	int penThickness = (int)myRound(25 * pFrame->statMain.thicknessLines);
	if (penThickness > 200) penThickness = 200;
	CPen greenPen(PS_SOLID, penThickness, RED);
	int dPltPlain = (int)(cd.coord.getPenThicknessNormal() * pFrame->statMain.thicknessLines);
	CPen* pOldPen;
	bool isTime = cd.coord.isTimeDomain() == TRUE;
	CPoint *plt = (CPoint *)alloc1CPoint(2 * dig.digPointMax);

	CPen bluePen(PS_SOLID, 0, GRAY);
	pOldPen = pDC->SelectObject(&bluePen);
	for (i = 0; i < dig.totCurve; i++) {
		if (!isFloatEqual(dig.curveVal[i], ERRORVAL)) {
			plt[0] = cd.coord.mm_coord(dig.curveVal[i], cd.coord.Y1());
			plt[1] = cd.coord.mm_coord(dig.curveVal[i], cd.coord.Y2());
			pDC->Polyline(plt, 2);
		}
	} 
	pDC->SelectObject(pOldPen);



	for (i = 0; i < dig.totCurve; i++) {
		int ind = i + 2;  // note: why we add 2 to the index? It is because if not, the computed TT curves would likely have the same color
		// which cannot be seen clearly. Add just 1 is not enough.
		while (ind >= lineColors.NUM_LINECOLORS)
			ind -= lineColors.NUM_LINECOLORS;
		register COLORREF col = RGB(lineColors.r[ind], lineColors.g[ind], lineColors.b[ind]);
		register CPen randomPen(PS_SOLID, penThickness, col);
		if (i == dig.iCurveSel && dig.iCurveSel >= 0)
			pOldPen = pDC->SelectObject(&greenPen);
		else
			pOldPen = pDC->SelectObject(&randomPen);

		register int ii = 0;
		if (plt == NULL) {
			AfxMessageBox(_T("Memory un-available 2"));
			return FALSE; //problem, and return.
		}
		for (j = 0; j < dig.nPoint[i]; j++) {
			xpos = dig.x[j][i];
			ypos = dig.t[j][i];
			if (cd.coord.isTimeDomain() && cd.coord.drawmode != 10) {
				ypos -= CCoords::getReduceTimeEx2(cd.coord.getOffsetFromXVal(xpos, tx.xShotRay), cd.coord.drawmode, &draw.red);
			}
			plt[ii] = cd.coord.mm_coord(xpos, ypos);
			ii++;
			//}
		}
		if (ii > 0) {
			// now for the selected curve, I need to show points in addition to curve!
			if (i == dig.iCurveSel) {
				for (int j = 0; j < ii; j++) {
					pDC->Ellipse((int)(plt[j].x - dPltPlain), (int)(plt[j].y - dPltPlain),
						(int)(plt[j].x + dPltPlain), (int)(plt[j].y + dPltPlain));
				}
			}
			
			ii = CCoords::myClipPoints2b(ii, 2 * dig.digPointMax, plt, &cd);
			pDC->Polyline(plt, ii);
		}
	} // for (i=0; i<=dig.iCurve
	pDC->SelectObject(pOldPen);
	free1CPoint(plt);

	return TRUE;
}


// cdpt is the number of trace in a shot gather to plot. 
// If ffid>0, only that ffid shot gather will be plotted
BOOL CSeisWideDoc::DrawSectionPrestack(CDC* pDC, HEAD_READ *pHeadRead,
	double xminPlot, double xmaxPlot,
	double yminPlot, double ymaxPlot,
	int drawmode, int ffid, int wiggle,
	CColorHelper::AMPCOLORDYN *ampColorDyn2, CView* pView)
{
	if (draw.isSameDataDisplay && !pDC->IsPrinting()) return TRUE;  // printers can have very different resolutions, so we will calculate again
	if (!draw.isSeismicPlot) return TRUE;  // disable segy copying

	if (pHeadRead->getnx() < 2 || pHeadRead->getns() < 2) return FALSE;

	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	int j;
	double xpos;
	CString tStr;
	if (wiggle < 0) wiggle = 4;  // invalid wiggle value found
	bool isRealWaveForm = wiggle == 0 || wiggle == 2 || wiggle == 5;
	bool isXArrContainRange = wiggle < 4;
	bool isHalfOffsets = this->isHalfOffsetMode();
	bool isTime = cd.coord.isTimeDomain() == TRUE;

	double dt = (double)pHeadRead->getdt();
	double odt = (dt < OMIL) ? 1. : 1. / dt;
	int nx = pHeadRead->getnx();
	int numsampTrc = pHeadRead->getns();
	double fillOffThis = areaFill.fillOff;

	//sw.sortDistance(!cd.coord.isDistanceDisplay);
	double yminArrayReduced = yminPlot;
	double ymaxArrayReduced = ymaxPlot;
	int numsampArrayReduced = (int)ceil((ymaxArrayReduced - yminArrayReduced) * odt) + 1; // make sure numsampArray is not too big!!
	float *rangeArray = (float *)ealloc1float(nx);
	float *yArr = (float *)ealloc1float(numsampArrayReduced);
	float **ampArr = (float **)ealloc2float(numsampArrayReduced, nx);
	if (ampArr == NULL || yArr == NULL || rangeArray == NULL) {
		// memory prob; got to exit decently
		if (ampArr != NULL) free2float(ampArr);
		if (yArr != NULL) free1float(yArr);
		if (rangeArray != NULL) free1float(rangeArray);
		return FALSE;
	}
	bool *isFFIDAbnormal = (bool*)alloc1(nx, sizeof(bool));

	yArr[0] = (float)yminArrayReduced;
	for (j = 1; j < numsampArrayReduced; j++) {
		yArr[j] = yArr[j - 1] + (float)dt;
	}

	register float gainExtraAtTrace; // for each trace, the gain can change with offset
	double oBaseGain = 1. / draw.baseGain;
	int xcount = 0;
	int ffidOld = -1;

	float xShot;
	for (int ii = 0; ii < nx; ii++) {
			register segydynamic *trd = &pHeadRead->trArr[ii];
			if (trd->cdp == 0) continue;
			if (ffid < 1) {
				// work on only one receiver gather only
				if (trd->fldr == ffidOld)
					continue;
				ffidOld = trd->fldr;
			}
			else {
				// work on one shot gather only
				if (trd->fldr != ffid)
					continue;
			}

			xShot = trd->getDistance();
			register float trOffset = trd->getOffset();
			register float xval = xShot;
			if (ffid > 0) 
				xval += trOffset;
			if (isHalfOffsets)
				xval = xval - trOffset * 0.5f;
			if (xval < xminPlot || xval > xmaxPlot) continue;
			gainExtraAtTrace = (areaFill.isNegativeFill) ? -1.0f : 1.0f;
			if (isTime && draw.gainDist && fabs(trOffset) > (double)draw.baseGain) {
				gainExtraAtTrace *= (float)pow(fabs(trOffset)*oBaseGain, (double)draw.basePower);
			} // if

			// every trace can have a different starting index to copy data into &ampArr[xcount][k1] from &sw.headRead.trArr[ii].data[j1]
			register int k1 = 0;
			register int j1 = 0;
			register double a1 = trd->getTraceDelay();
			register double a2 = CCoords::getReduceTimeEx2(trOffset, drawmode, &draw.red);
			register double tShift = a1 - (float)a2;
			tShift -= yminArrayReduced;
			register int deltaj = (int)myRound(tShift * odt);
			register int lenCopy;
			if (deltaj >= 0) {
				k1 = deltaj;
				j1 = 0;
			}
			else {
				k1 = 0;
				j1 = -deltaj; // note: deltaj is negative here, and j1>0
			}
			memset(&ampArr[xcount][0], 0, numsampArrayReduced * sizeof(float));
			lenCopy = numsampTrc - j1;
			if (lenCopy > numsampArrayReduced - k1) lenCopy = numsampArrayReduced - k1;  // prevent index overflow
			if (j1 >= 0 && lenCopy > 0) {
				memcpy(&ampArr[xcount][k1], &trd->data[j1], lenCopy * sizeof(float));
			}
			
			if (gainExtraAtTrace != 1.) {
				for (j = k1; j < k1 + lenCopy; j++) {
					ampArr[xcount][j] *= gainExtraAtTrace;
				} // for j
			}

			if (isXArrContainRange) {
				register double tClip = fabs(areaFill.clip_real);
				for (j = k1; j < k1 + lenCopy; j++) {
					ampArr[xcount][j] *= (float)areaFill.gain_real;
					if (ampArr[xcount][j] > tClip) ampArr[xcount][j] = (float)tClip; // clipping
					else if (ampArr[xcount][j] < (-tClip)) ampArr[xcount][j] = -(float)tClip;
				} // for j

				for (j = 0; j < numsampArrayReduced; j++) {
					ampArr[xcount][j] += xval; // add range
					if (ampArr[xcount][j] < xminPlot) ampArr[xcount][j] = (float)xminPlot;
					if (ampArr[xcount][j] > xmaxPlot) ampArr[xcount][j] = (float)xmaxPlot;
				} // for j
			}

			// decide if an abnormal color should be used
			isFFIDAbnormal[xcount] = ii<nx - 1 && trd->fldr > pHeadRead->trArr[ii + 1].fldr;
			rangeArray[xcount] = xval;
			xcount++;
	} // for ii
	nx = xcount;

	// if the data is a very narrower strip, we can speed up by narrowing xmin and xmax. But if otherwise, we cannot change xmin, xmax
	float xminInData = getMinValue(rangeArray, nx, MIL);
	float xmaxInData = getMaxValue(rangeArray, nx, MIL);
	if (xminInData > xminPlot) xminPlot = xminInData;
	if (xmaxInData < xmaxPlot) xmaxPlot = xmaxInData;

	// note: the rangeArray[], ampArr[][] are not sorted along X-axis. So do it here!!!
	sortDistance(ampArr, rangeArray, nx, numsampArrayReduced);


	// now do the plotting
	register CPoint pPrev, pCurr;
	pPrev.y = pCurr.y = 0;
	pPrev.x = cd.coord.mm_coordx(rangeArray[0]);
	pDC->LPtoDP(&pPrev);
	switch (wiggle)
	{
		case 0:
			break;
		case 1:
		case 2:
			if (areaFill.isFillSmall) {
				CDCHelper::airColorSmallArr(pDC, nx, numsampArrayReduced, ampArr, rangeArray, yminArrayReduced, dt, BLACK, WHITE,
					fillOffThis, &cd);
			}
			else {
				CDCHelper::airColorBigArr(pDC, nx, numsampArrayReduced, ampArr, rangeArray, yminArrayReduced, dt, BLACK, WHITE,
					fillOffThis, &cd);
			}
			break;
		case 3:
			if (areaFill.isFillSmall) {
				if (dig.isDigitizing)
					CDCHelper::airColorSmallArr(pDC, nx, numsampArrayReduced, ampArr, rangeArray, yminArrayReduced, dt,
						seisBiColor2.getColor(true),
						seisBiColor2.getColor(false),
						fillOffThis, &cd, isFFIDAbnormal);
				else
					CDCHelper::airColorSmallArr(pDC, nx, numsampArrayReduced, ampArr, rangeArray, yminArrayReduced, dt,
						seisBiColor2.getColor(true),
						seisBiColor2.getColor(false),
						fillOffThis, &cd);
			}
			else {
				if (dig.isDigitizing)
					CDCHelper::airColorBigArr(pDC, nx, numsampArrayReduced, ampArr, rangeArray, yminArrayReduced, dt,
						seisBiColor2.getColor(true),
						seisBiColor2.getColor(false),
						fillOffThis, &cd, isFFIDAbnormal);
				else
					CDCHelper::airColorBigArr(pDC, nx, numsampArrayReduced, ampArr, rangeArray, yminArrayReduced, dt,
						seisBiColor2.getColor(true),
						seisBiColor2.getColor(false),
						fillOffThis, &cd);

			}
			break;
		case 4:
			this->floodFillArr5Multi(pDC, nx, numsampArrayReduced, ampArr, rangeArray,
				xminPlot, xmaxPlot, yminArrayReduced, ymaxArrayReduced, ampColorDyn2);
			break;
		case 5:
			this->floodFillArr5Multi(pDC, nx, numsampArrayReduced, ampArr, rangeArray,
				xminPlot, xmaxPlot, yminArrayReduced, ymaxArrayReduced, ampColorDyn2);
			break;
		case 6:
		default:
			StartOpenGL2(pView, pDC, ampArr, rangeArray, nx, (float)yminArrayReduced, (float)dt, numsampArrayReduced,
				ampColorDyn2, &cd.coord);
			break;
	} // switch


	if (isRealWaveForm) {
		if (!isXArrContainRange) {
				for (int i = 0; i < nx; i++) {
					register double tClip = fabs(areaFill.clip_real);
					for (j = 0; j < numsampArrayReduced; j++) {
						xpos = ampArr[i][j] * areaFill.gain_real;
						if (xpos > tClip) xpos = tClip; // clipping
						else if (xpos < (-tClip)) xpos = -tClip;
						xpos += rangeArray[i]; // add range
						if (xpos < xminPlot) xpos = xminPlot;
						if (xpos > xmaxPlot) xpos = xmaxPlot;
						ampArr[i][j] = (float)xpos;
					} // for j
				}
		}
		CDCHelper::wiggleArr(pDC, nx, numsampArrayReduced, ampArr, rangeArray, yArr, &cd);
	}

	// cleanup opengl stuff
	if (wiggle != 6 && m_GLWin.myGL.isOpenGLWindowsExists) {
		m_GLWin.mySeis3DFBO_End();
		m_GLWin.DestroySceneFBO();
	}

	try {
		if (ampArr != NULL) {
			free2float(ampArr);
		}
	}
	catch (...) {
	}
	ampArr = NULL;
	free1float(yArr);
	free1float(rangeArray);
	if (isFFIDAbnormal) {
		free1(isFFIDAbnormal); // this variable may not have been assigned, so a condition is needed here
	}

	if (isHalfOffsets) {
		tStr.Format(_T("Traces plotted at half-offset locations with valid model over RNMO section."));
		pFrame->myCaption(tStr);
	}

	if (ffid>0 ) {
		head.xshotInSegy = xShot; // indicates the xShot that is in place
	}

	return TRUE;
}

BOOL CSeisWideDoc::DrawSectionPrestack(CDC* pDC, CString fSection,
	double xminPlot, double xmaxPlot, double yminPlot, double ymaxPlot,
	CColorHelper::AMPCOLORDYN *ampColorDyn2, CView* pView)
{
	if (draw.isSameDataDisplay && !pDC->IsPrinting()) return TRUE;  // printers can have very different resolutions, so we will calculate again
	if (!draw.isSeismicPlot) return TRUE;  // disable segy copying
	if (!isFileExistNotDirectory(fSection)) return(TRUE);

	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	int j;
	CString tStr;
	CSegyMeta::segyHeadInit(fSection, &head);
	if (head.aveAmp < MINAMP) {
		tStr.Format(_T("Detected average amplitude is too small: %f"), head.aveAmp);
		pFrame->myCaption(tStr);
		head.aveAmp = 1.;
	}
	ampColorDyn2->isBitmap = head.isSegyBitmap();
	ampColorDyn2->isBitmapC = head.isSegyBitmapC();

	static bool isHalfOffsetWarning = true;
	bool isHalfOffsets = this->isHalfOffsetMode();
	if (isHalfOffsets && isHalfOffsetWarning) {
		isHalfOffsetWarning = false;
		tStr.Format(_T("%s\nData displayed with offsets now reduced by half for comparing with model. If regular offsets are desired instead, just do not specify the model file name."), fSection);
		AfxMessageBox(tStr, MB_ICONQUESTION);
	}

	SegyWrapper sw(fSection);

	bool isTime = cd.coord.isTimeDomain() == TRUE;
	int isSuc = sw.openCacheSmart(0, (int)MIL, &head, pFrame->psei->pCacheSegyWraps, NUM_CACHE, cd.zoom.isZooming != 0, 0, 0.);
	if (!isSuc) return FALSE;

	double dt = (double)sw.headRead.getdt();
	int nx = sw.headRead.getnx();
	int numsampTrc = sw.headRead.getns();

//	showArrayInFile(sw.headRead.trArr[nx/2].data, numsampTrc, _T("Trace"), dt);

	double odt = (dt < OMIL) ? 1. : 1. / dt;
	double fillOffThis = areaFill.fillOff;
	if (isSuc && nx > 0) {
		if (draw.wiggle < 0) draw.wiggle = 4;  // invalid wiggle value found
		double trcInterval = sw.getAvgShotIntervalPrestack(1);
		if (head.aveAmp < MINAMP)
			areaFill.gain_real = 1.0;
		else
			areaFill.gain_real = areaFill.gain / head.aveAmp * trcInterval; // when a sample multiplied by gain_real, it'll span a suitable trace span.
		areaFill.clip_real = areaFill.clip * trcInterval;
		//if (trcInterval < cd.coord.dxPerPixel()) {
		//		// but if a single trace is spanned to <1 pixel, it'll display blanks at all. So...
		//		double gainHike = cd.coord.dxPerPixel() / trcInterval * 1.2;
		//		areaFill.gain_real *= gainHike;
		//		areaFill.clip_real *= gainHike;
		//}

		if (draw.twin_isEnergy) {
			float ampl;  // we only want float here since the array is float only, not double
			float aMedian;
			for (int i = 0; i < nx; i++) {
				aMedian = (float)getMedianAbsolute(&sw.headRead.trArr[i].data[0], numsampTrc);
				if (aMedian > MINAMP) aMedian = 1.f / aMedian;
				for (j = 0; j < numsampTrc; j++) {
					ampl = sw.headRead.trArr[i].data[j] * aMedian;
					// why do we divide it by mean value? This is because if we do not, the values may be 
					// extremely large to go beyond floating max.
					if (ampl != 0.f) {
						ampl *= ampl;
						sw.headRead.trArr[i].data[j] = (sw.headRead.trArr[i].data[j] < 0.f) ? -ampl : ampl;
					}
				} // for j
			} // for i
		}

		if (isSuc == 2)
			tStr.Format(_T("Cache: loaded %d traces w/ %d samples... Preparing plot..."), nx, numsampTrc);
		else
			tStr.Format(_T("Loaded %d traces w/ %d samples... Preparing plot..."), nx, numsampTrc);
		pFrame->myCaption(tStr);

		DrawSectionPrestack(pDC, &sw.headRead, xminPlot, xmaxPlot, yminPlot, ymaxPlot, 
			cd.coord.drawmode, -1, draw.wiggle, ampColorDyn2, pView);
		DrawSectionPrestack(pDC, &sw.headRead, xminPlot, xmaxPlot, yminPlot, ymaxPlot,
			cd.coord.drawmode, 6063, 2, ampColorDyn2, pView);
	} // if sw
	else {
		// no data loaded
		pFrame->myCaption(_T("No traces found."));
	}

	if (isHalfOffsets) {
		tStr.Format(_T("Traces plotted at half-offset locations with valid model over RNMO section."));
		pFrame->myCaption(tStr);
	}
	return TRUE;

}





// this function will draw all segy in both time and depth domains, but only in distance mode and not in trace mode.
BOOL CSeisWideDoc::DrawSectionArr(CDC* pDC, CString fSection, double ymin, double ymax, 
	CColorHelper::AMPCOLORDYN *ampColorDyn2, CView* pView)
{
	if (draw.isSameDataDisplay && !pDC->IsPrinting()) return TRUE;  // printers can have very different resolutions, so we will calculate again
	if (!draw.isSeismicPlot) return TRUE;  // disable segy copying

	if (head.isPrestackShotGather())
		return DrawSectionPrestack(pDC, fSection, cd.coord.X1(), cd.coord.X2(), ymin, ymax, ampColorDyn2, pView);

	if (!isFileExistNotDirectory(fSection)) return(TRUE);

	if (draw.wiggle > 5) {
		CString fHilt = getFileNameAppend(fSection, _T("_Hilt"));
		CString fCohr = getFileNameAppend(fSection, _T("_Cohr"));
		if (isFileExistNotDirectory(fHilt) && isFileExistNotDirectory(fCohr)) {
			// only in this condition, we try
			BOOL isTrue = DrawSectionArr3D(pDC, fSection, fHilt, fCohr, ymin, ymax, pView);
			if (isTrue) return TRUE;
		}
	}
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	int j;
	double xpos;
	CString tStr;
	CSegyMeta::segyHeadInit(fSection, &head);
	if (head.aveAmp < MINAMP) {
		tStr.Format(_T("Detected average amplitude is too small: %f"), head.aveAmp);
		pFrame->myCaption(tStr);
		head.aveAmp = 1.;
	}
	ampColorDyn2->isBitmap = head.isSegyBitmap();
	ampColorDyn2->isBitmapC = head.isSegyBitmapC();
	if (draw.wiggle < 0) draw.wiggle = 4;  // invalid wiggle value found
	bool isRealWaveForm = draw.isWiggleInDisplay();
	bool isXArrContainRange = draw.wiggle < 4;
	
	static bool isHalfOffsetWarning = true;
	bool isHalfOffsets = this->isHalfOffsetMode();
	if (isHalfOffsets && isHalfOffsetWarning) {
		isHalfOffsetWarning = false;
		tStr.Format(_T("%s\nData displayed with offsets now reduced by half for comparing with model. If regular offsets are desired instead, just do not specify the model file name."), fSection);
		AfxMessageBox(tStr, MB_ICONQUESTION);
	}
		//cd.coord.isDistanceDisplay && cd.coord.drawmode == 7 && draw.red.rvred > 0.1 && velMod.isVelModValid();
		//isModelVisible(&velMod, 0.);
	//double x1Read = cd.coord.X1();
	//double x2Read = cd.coord.X2();
	//if (isHalfOffsets) {
	//	// for half offset display, we need to increase the data span
	//	x1Read -= head.offsetMaxAbs()*0.6;
	//	x2Read += head.offsetMaxAbs()*0.6;
	//}
	SegyWrapperEx sw(fSection, 0., 0., ymin, ymax, cd.coord.drawmode); // read the entire prestack data in memory
	// NOTE: drawing of depth domain segy also comes thru this routine. So please do not shift the data by draw.distShift for depth sections
	bool isTime = cd.coord.isTimeDomain() == TRUE;
	if (isTime && cd.coord.isDistanceDisplay)
		sw.m_distShift = draw.distShift;

	//tStr.Format(_T("Loading..."));
	//pFrame->myCaption(tStr);

	if (cd.coord.isDistanceDisplay && !head.isDistArrayValid()) {
		tStr.Format(_T("Trace distance invalid. Do you want to switch to offset display?"));
		if (AfxMessageBox(tStr, MB_YESNO | MB_ICONQUESTION) == IDYES)
			cd.coord.isDistanceDisplay = FALSE;
	}

	sw.m_dxMin = cd.coord.dxPerPixel() * 0.333;
	// NOTE: Why devide by 3? Because for each pixel interval, we need 2-3 traces to properly 
	//		interpolate colors. If I use 1, I see aliasing
	sw.m_dyMin = cd.coord.dyPerPixel() * 0.333;
	draw.red.clone(&sw.red2);
	sw.m_tmin = ymin;
	sw.m_tmax = ymax;
	// need to set arrays for xFlatten[] and yFlatten[], and nFlatten. 
	// no need to free them since destructor will do it automatically
	// but must use eAllocFloat to allocate
	if (draw.ncontFlatten > 0) {
		sw.nFlatten = velMod.nFlatten;
		sw.xFlatten = ealloc1float(sw.nFlatten);
		memcpy(sw.xFlatten, velMod.xmFlatten, sw.nFlatten*sizeof(float));
		sw.yFlatten = ealloc1float(sw.nFlatten);
		if (isTime) {
			memcpy(sw.yFlatten, velMod.tmFlatten, sw.nFlatten*sizeof(float));
		}
		else {
			memcpy(sw.yFlatten, velMod.zmFlatten, sw.nFlatten*sizeof(float));
		}
		float yShotDatum = isTime ? velMod.tShotDatum : velMod.zShotDatum;
		for (int i = 0; i < sw.nFlatten; i++)
			sw.yFlatten[i] -= yShotDatum;
	}
	int isSuc = sw.openDistanceCache(!cd.coord.isDistanceDisplay, 0, &head,
		pFrame->psei->pCacheSegyWrapEx, NUM_CACHE, false);
	if (!isSuc) return FALSE;

	double dt = (double)sw.headRead.getdt();
	double odt = (dt<OMIL) ? 1. : 1. / dt;
	int nx = sw.headRead.getnx();
	int numsampTrc = sw.headRead.getns();
	// note: by now, numsampTrc may be bigger than what is required to display. So be careful to handle this.

	double fillOffThis = areaFill.fillOff;
	if (isSuc && nx>0) {
		if (draw.wiggle == 0 || draw.wiggle == 1 || draw.wiggle == 2 
			|| draw.wiggle == 3 
			|| draw.wiggle == 5
			|| draw.wiggle == 6
			) {
			// NOTE: para.gain, gain_real, para.clip, clip_real, para.fillOff, fillOff are for area fill only
			double trcInterval = sw.getAvgKmInterval2(cd.coord.isDistanceDisplay == TRUE);
			if (head.aveAmp < MINAMP)
				areaFill.gain_real = 1.0;
			else 
				areaFill.gain_real = areaFill.gain / head.aveAmp * trcInterval; // when a sample multiplied by gain_real, it'll span a suitable trace span.
			areaFill.clip_real = areaFill.clip * trcInterval;
			if (trcInterval < cd.coord.dxPerPixel()) {
				// but if a single trace is spanned to <1 pixel, it'll display blanks at all. So...
				double gainHike = cd.coord.dxPerPixel() / trcInterval * 1.2;
				areaFill.gain_real *= gainHike;
				areaFill.clip_real *= gainHike;
			}
		}

		if (draw.twin_isEnergy) {
			float ampl;  // we only want float here since the array is float only, not double
			float aMedian;
			for (int i = 0; i<nx; i++) {
				aMedian = (float)getMedianAbsolute(&sw.headRead.trArr[i].data[0], numsampTrc);
				if (aMedian > MINAMP) aMedian = 1.f / aMedian;
				for (j = 0; j < numsampTrc; j++) {
					ampl = sw.headRead.trArr[i].data[j] * aMedian;
					// why do we divide it by mean value? This is because if we do not, the values may be 
					// extremely large to go beyond floating max.
					if (ampl != 0.f) {
						ampl *= ampl;
						sw.headRead.trArr[i].data[j] = (sw.headRead.trArr[i].data[j] < 0.f) ? -ampl : ampl;
					}
				} // for j
			} // for i
		}

		if (isSuc==2)
			tStr.Format(_T("Cache: loaded %d traces w/ %d samples... Preparing plot..."), nx, numsampTrc);
		else
			tStr.Format(_T("Loaded %d traces w/ %d samples... Preparing plot..."), nx, numsampTrc);
		pFrame->myCaption(tStr);

		sw.sortDistance(!cd.coord.isDistanceDisplay);
		// after the sorting, the first trace should have the m_xmin

		// if ymin or ymax are wider than the data itself, we need to narrow the gap 
		//  otherwise the plot has problem
		//if (yminPlot < sw.m_tmin) yminPlot = sw.m_tmin;
		//if (ymaxPlot > sw.m_tmax) ymaxPlot = sw.m_tmax;
		// the data array Y-limits after all reduction. Note that the original data may have traces changing tmin radically
		// not conforming to a plotting pattern. But during plotting, we need to form a rectangular pattern
		//float trOffset = sw.headRead.trArr[0].getOffset();
		//double tShift = sw.headRead.trArr[0].getTraceDelay() - (float)CCoords::getReduceTimeEx2(trOffset, cd.coord.drawmode, &draw.red);
		//double yminArrayReduced = (tShift<ymin) ? ymin : tShift;
		//double ymaxArrayReduced = yminArrayReduced + (numsampTrc-1)*dt;
		//int numsampArrayReduced = numsampTrc;
		//double yminArrayReduced = head.tminFile < cd.coord.tmin ? cd.coord.tmin : head.tminFile;
		//double ymaxArrayReduced = head.tmaxFile < cd.coord.tmax ? head.tmaxFile : cd.coord.tmax;
		double yminArrayReduced = cd.coord.Y1();
		double ymaxArrayReduced = cd.coord.Y2();
		int numsampArrayReduced = (int)ceil((ymaxArrayReduced - yminArrayReduced) * odt) + 1; // make sure numsampArray is not too big!!

		float *rangeArray = (float *)ealloc1float(nx);
		float *yArr = (float *)ealloc1float(numsampArrayReduced);
		float **ampArr = (float **)ealloc2float(numsampArrayReduced, nx);
		if (ampArr == NULL || yArr == NULL || rangeArray == NULL) {
			// memory prob; got to exit decently
			if (ampArr != NULL) free2float(ampArr);
			if (yArr != NULL) free1float(yArr);
			if (rangeArray != NULL) free1float(rangeArray);
			sw.freeSegyDataArrayOnly();
			return FALSE;
		}
		bool *isFFIDAbnormal = (bool*)malloc(nx);
		memset(isFFIDAbnormal, '\0', nx);

		yArr[0] = (float)yminArrayReduced;
		for (j = 1; j < numsampArrayReduced; j++) {
			yArr[j] = yArr[j - 1] + (float)dt;
		}

		register float gainExtraAtTrace; // for each trace, the gain can change with offset
		double oBaseGain = 1. / draw.baseGain;
		int xcount = 0;

		
		for (int ii = 0; ii < nx; ii++) {
		//	xcount++; continue;

			register segydynamic *trd = &sw.headRead.trArr[ii];	
			register float trOffset = trd->getOffset();
			register float xval = (cd.coord.isDistanceDisplay) ? trd->getDistance() : trOffset;
			if (isHalfOffsets)
				xval = xval - trOffset * 0.5f;
			if (xval < cd.coord.xmin || xval > cd.coord.xmax) continue;
			gainExtraAtTrace = (areaFill.isNegativeFill) ? -1.0f : 1.0f;
			if (cd.coord.isTimeDomain() && draw.gainDist && fabs(trOffset) >(double)draw.baseGain) {
				gainExtraAtTrace *= (float)pow(fabs(trOffset)*oBaseGain, (double)draw.basePower);
			} // if

			// every trace can have a different starting index to copy data into &ampArr[xcount][k1] from &sw.headRead.trArr[ii].data[j1]
			register int k1 = 0;
			register int j1 = 0;
			// NOTE: yminPlot and ymaxPlot are the desired plot/axis limits
			//    but the segy data may have VERY different time limits  sw.m_tmin, m_tmax
			register double a1 = trd->getTraceDelay();
			register double a2 = CCoords::getReduceTimeEx2(trOffset, cd.coord.drawmode, &draw.red);
			register double tShift = a1 - (float)a2;
			//register double tShift = sw.headRead.trArr[ii].getTraceDelay() - (float)CCoords::getReduceTimeEx2(trOffset, cd.coord.drawmode, &draw.red);
			tShift -= yminArrayReduced;
			register int deltaj = (int)myRound(tShift * odt);
			register int lenCopy;
			if (deltaj >= 0) {
				k1 = deltaj;
				j1 = 0;
			}
			else {
				k1 = 0;
				j1 = -deltaj; // note: deltaj is negative here, and j1>0
			}
			memset(&ampArr[xcount][0], 0, numsampArrayReduced * sizeof(float));
			lenCopy = numsampTrc - j1;
			if (lenCopy > numsampArrayReduced - k1) lenCopy = numsampArrayReduced - k1;  // prevent index overflow
			if (j1 >= 0 && lenCopy > 0) {
				memcpy(&ampArr[xcount][k1], &trd->data[j1], lenCopy * sizeof(float));
			}
			if (gainExtraAtTrace != 1.) {
				if (k1 < 0) k1 = 0;
				for (j = k1; j < k1+lenCopy; j++) {
					if (j < numsampArrayReduced)
						ampArr[xcount][j] *= gainExtraAtTrace;
				} // for j
			}

			if (isXArrContainRange) {
				register double tClip = fabs(areaFill.clip_real);
				for (j = k1; j<k1+lenCopy; j++) {
					ampArr[xcount][j] *= (float)areaFill.gain_real;
					if (ampArr[xcount][j] > tClip) ampArr[xcount][j] = (float)tClip; // clipping
					else if (ampArr[xcount][j] < (-tClip)) ampArr[xcount][j] = -(float)tClip;
				} // for j

				for (j = 0; j<numsampArrayReduced; j++) {
					ampArr[xcount][j] += xval; // add range
					if (ampArr[xcount][j] < cd.coord.X1()) ampArr[xcount][j] = (float)cd.coord.X1();
					if (ampArr[xcount][j] > cd.coord.X2()) ampArr[xcount][j] = (float)cd.coord.X2();
				} // for j
			}

			// decide if an abnormal color should be used
			if (ii < nx-1)
				isFFIDAbnormal[xcount] = trd->fldr > sw.headRead.trArr[ii + 1].fldr;

			rangeArray[xcount] = xval;
			xcount++;
		} // for ii
		sw.freeSegyDataArrayOnly();
		nx = xcount;

		// now do the plotting
		register CPoint pPrev, pCurr;
		pPrev.y = pCurr.y = 0;
		pPrev.x = cd.coord.mm_coordx(rangeArray[0]);
		pDC->LPtoDP(&pPrev);
		switch (draw.wiggle)
		{
		case 0:
			break;
		case 1:
		case 2:
			if (areaFill.isFillSmall) {
				CDCHelper::airColorSmallArr(pDC, nx, numsampArrayReduced, ampArr, rangeArray, yminArrayReduced, dt, BLACK, WHITE,
					fillOffThis, &cd);
			}
			else {
				CDCHelper::airColorBigArr(pDC, nx, numsampArrayReduced, ampArr, rangeArray, yminArrayReduced, dt, BLACK, WHITE,
					fillOffThis, &cd);
			}
			break;
		case 3:
			if (areaFill.isFillSmall) {
				if (dig.isDigitizing)
					CDCHelper::airColorSmallArr(pDC, nx, numsampArrayReduced, ampArr, rangeArray, yminArrayReduced, dt,
						seisBiColor2.getColor(true),
						seisBiColor2.getColor(false),
						fillOffThis, &cd, isFFIDAbnormal);
				else
					CDCHelper::airColorSmallArr(pDC, nx, numsampArrayReduced, ampArr, rangeArray, yminArrayReduced, dt,
						seisBiColor2.getColor(true),
						seisBiColor2.getColor(false),
						fillOffThis, &cd);
			}
			else {
				if (dig.isDigitizing)
					CDCHelper::airColorBigArr(pDC, nx, numsampArrayReduced, ampArr, rangeArray, yminArrayReduced, dt,
						seisBiColor2.getColor(true), 
						seisBiColor2.getColor(false),
						fillOffThis, &cd, isFFIDAbnormal);
				else
					CDCHelper::airColorBigArr(pDC, nx, numsampArrayReduced, ampArr, rangeArray, yminArrayReduced, dt,
						seisBiColor2.getColor(true),
						seisBiColor2.getColor(false),
						fillOffThis, &cd);

			}
			break;
		case 4:
			this->floodFillArr5Multi(pDC, nx, numsampArrayReduced, ampArr, rangeArray,
				sw.m_xmin, sw.m_xmax, yminArrayReduced, ymaxArrayReduced, ampColorDyn2);
			break;
		case 5:
			this->floodFillArr5Multi(pDC, nx, numsampArrayReduced, ampArr, rangeArray,
				sw.m_xmin, sw.m_xmax, yminArrayReduced, ymaxArrayReduced, ampColorDyn2);
			break;
		case 6:
		case 7:
		{
			// contouring works, but really no use.
			//double amax = draw.isAvgEnergy ? head.maxAmp*head.maxAmp : head.maxAmp;
			////CColorHelper::AMPCOLORDYN ampColorDyn2;
			////CColorHelper::initAmpColorArray(&ampColorDyn2, draw.numContours);
			////CColorHelper::getAmpColorArray(
			////	draw.colFileName,
			////	&ampColorDyn2,
			////	amax,
			////	false,
			////	draw.logScaleThreshold);
			//CSeiContour sc(&cd.coord);
			//sc.contourFillArr(pDC, nx, numsamp, xArray, rangeArray,
			//	sw.m_xmin, sw.m_xmax, sw.m_tmin, sw.m_tmax,
			//	ampColorDyn2, amax);
			//break;
		}
		default:
			//CDCHelper::tessellateFill2(pDC, nx, numsamp, xArray, rangeArray,
			//	sw.m_xmin, sw.m_xmax, sw.m_tmin, sw.m_tmax, ampColorDyn2, &cd, draw.memMaxMB);
			//double amax = draw.getDrawAmp(head.maxAmp);

			StartOpenGL2(pView, pDC, ampArr, rangeArray, nx, (float)yminArrayReduced, (float)dt, numsampArrayReduced,
				ampColorDyn2, &cd.coord);
			break;
		} // switch

		if (isRealWaveForm) {
			if (!isXArrContainRange) {
				for (int i = 0; i < nx; i++) {
					register double tClip = fabs(areaFill.clip_real);
					for (j = 0; j<numsampArrayReduced; j++) {
						xpos = ampArr[i][j] * areaFill.gain_real;
						if (xpos> tClip) xpos = tClip; // clipping
						else if (xpos < (-tClip)) xpos = -tClip;
						xpos += rangeArray[i]; // add range
						if (xpos < cd.coord.X1()) xpos = cd.coord.X1();
						if (xpos > cd.coord.X2()) xpos = cd.coord.X2();
						ampArr[i][j] = (float)xpos;
					} // for j
				}
			}
			CDCHelper::wiggleArr(pDC, nx, numsampArrayReduced, ampArr, rangeArray, yArr, &cd);
		}

		// cleanup opengl stuff
		if (draw.wiggle != 6 && m_GLWin.myGL.isOpenGLWindowsExists) {
			m_GLWin.mySeis3DFBO_End();
			m_GLWin.DestroySceneFBO();
		}

		try {
			if (ampArr != NULL) {
				free2float(ampArr);
				ampArr = NULL;
			}
		}
		catch (...){
		}
		free1float(yArr);
		free1float(rangeArray);
		free(isFFIDAbnormal); // this variable may not have been assigned, so a condition is needed here
		isFFIDAbnormal = NULL;
		
	} // if sw
	else {
		// no data loaded
		pFrame->myCaption(_T("No traces found."));
	}

	if (isHalfOffsets) {
		tStr.Format(_T("Traces plotted at half-offset locations with valid model over RNMO section."));
		pFrame->myCaption(tStr);
	}
	return TRUE;
}



// this function draws 3D with CDC, which works with small dataset but will fail with big data, so do not use it.
BOOL CSeisWideDoc::DrawSectionArr3D(CDC* pDC, CString fSection, CString fHilt, CString fCohr, double ymin, double ymax, CView* pView)
{
	if (draw.isSameDataDisplay && !pDC->IsPrinting()) return TRUE;  // printers can have very different resolutions, so we will calculate again
	if (!draw.isSeismicPlot) return TRUE;  // disable segy copying
	if (!isFileExistNotDirectory(fSection)) return(FALSE);
	if (!isFileExistNotDirectory(fHilt)) return(FALSE);
	if (!isFileExistNotDirectory(fCohr)) return(FALSE);

	bool isTime = cd.coord.isTimeDomain() == TRUE;
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();

	int i, j;

	CSegyMeta::segyHeadInit(fSection, &head);
	SegyWrapperEx sw(fSection, cd.coord.X1(), cd.coord.X2(), ymin, ymax, cd.coord.drawmode);
	if (isTime && cd.coord.isDistanceDisplay) sw.m_distShift = draw.distShift;

	CString tStr;
	tStr.Format(_T("Loading..."));
	pFrame->myCaption(tStr);

	if (!head.isDistArrayValid())
		cd.coord.isDistanceDisplay = FALSE;
	sw.m_dxMin = cd.coord.dxPerPixel() * 0.333;
	// NOTE: Why devide by 3? Because for each pixel interval, we need 2-3 traces to properly 
	//		interpolate colors. If I use 1, I see aliasing
	sw.m_dyMin = cd.coord.dyPerPixel() * 0.333;
	draw.red.clone(&sw.red2);
	sw.m_tmin = ymin;
	sw.m_tmax = ymax;

	if (draw.ncontFlatten > 0) {
		sw.nFlatten = velMod.nFlatten;
		sw.xFlatten = ealloc1float(sw.nFlatten);
		memcpy(sw.xFlatten, velMod.xmFlatten, sw.nFlatten * sizeof(float));
		sw.yFlatten = ealloc1float(sw.nFlatten);
		if (isTime) {
			memcpy(sw.yFlatten, velMod.tmFlatten, sw.nFlatten * sizeof(float));
		}
		else {
			memcpy(sw.yFlatten, velMod.zmFlatten, sw.nFlatten * sizeof(float));
		}
		float yShotDatum = isTime ? velMod.tShotDatum : velMod.zShotDatum;
		for (i = 0; i < sw.nFlatten; i++)
			sw.yFlatten[i] -= yShotDatum;
	}

	int isSuc = sw.openDistanceCache(!cd.coord.isDistanceDisplay, 0, &head,
		pFrame->psei->pCacheSegyWrapEx, NUM_CACHE, cd.zoom.isZooming != 0);
	int nx = sw.headRead.getnx();
	int numsamp = sw.headRead.getns();
	sw.sortDistance(!cd.coord.isDistanceDisplay);




	HEAD head2;
	if (CSegyMeta::segyHeadInit(fHilt, &head2) != 1) return FALSE;
	SegyWrapperEx sw2(fHilt, cd.coord.X1(), cd.coord.X2(), ymin, ymax, cd.coord.drawmode);
	sw.copyParaTo(&sw2);
	isSuc = sw2.openDistanceCache(!cd.coord.isDistanceDisplay, 0, &head2,
		pFrame->psei->pCacheSegyWrapEx, NUM_CACHE, cd.zoom.isZooming != 0);
	if (nx != sw2.headRead.getnx() || numsamp != sw2.headRead.getns()) {
		AfxMessageBox(_T("_Hilt.sgy file is different from .sgy file."));
		CSegyMeta::segyHeadFree(&head2);  // head2 must free manually, but head should not free
		SegyWrapper::freeSegyArray(&sw2.headRead);
		return FALSE;
	}
	sw2.sortDistance(!cd.coord.isDistanceDisplay);



	HEAD head3;
	if (CSegyMeta::segyHeadInit(fCohr, &head3) != 1) return FALSE;
	SegyWrapperEx sw3(fCohr, cd.coord.X1(), cd.coord.X2(), ymin, ymax, cd.coord.drawmode);
	sw.copyParaTo(&sw3);
	isSuc = sw3.openDistanceCache(!cd.coord.isDistanceDisplay, 0, &head3,
		pFrame->psei->pCacheSegyWrapEx, NUM_CACHE, cd.zoom.isZooming != 0);
	if (nx != sw3.headRead.getnx() || numsamp != sw3.headRead.getns()) {
		AfxMessageBox(_T("_Cohr.sgy file is different from .sgy file."));
		CSegyMeta::segyHeadFree(&head2);
		CSegyMeta::segyHeadFree(&head3);
		SegyWrapper::freeSegyArray(&sw2.headRead);
		SegyWrapper::freeSegyArray(&sw3.headRead);
		return FALSE;
	}
	sw3.sortDistance(!cd.coord.isDistanceDisplay);

	double dt = (double)sw.headRead.getdt();
	float *yArr = (float *)ealloc1float(numsamp);
	yArr[0] = (float)ymin;
	for (j = 1; j < numsamp; j++) {
		yArr[j] = yArr[j - 1] + (float)dt;
	}
	if (ymin < sw.m_tmin) ymin = sw.m_tmin;
	if (ymax > sw.m_tmax) ymax = sw.m_tmax;

	float *xArr = (float *)ealloc1float(nx);
	for (i = 0; i < nx; i++) {
		xArr[i] = (cd.coord.isDistanceDisplay) ?
			sw.headRead.trArr[i].getDistance() : sw.headRead.trArr[i].getOffset();
	} // for i

	double gainExtraAtTrace; // for each trace, the gain can change with offset
	double oBaseGain = 1. / draw.baseGain;
	for (i = 0; i < nx; i++) {
		register float trOffset = sw.headRead.trArr[i].getOffset();
		// register float tShift = sw.headRead.trArr[i].getTraceDelay() - (float)CCoords::getReduceTimeEx2(trOffset, cd.coord.drawmode, &draw.red);
		gainExtraAtTrace = (areaFill.isNegativeFill) ? -1.0 : 1.0;
		if (cd.coord.isTimeDomain() && draw.gainDist && fabs(trOffset) >(double)draw.baseGain) {
			gainExtraAtTrace *= pow(fabs(trOffset)*oBaseGain, (double)draw.basePower);
		} // if

		if (gainExtraAtTrace != 1.) {
			for (j = 0; j < numsamp; j++) {
				sw.headRead.trArr[i].data[j] *= (float)gainExtraAtTrace;
				sw2.headRead.trArr[i].data[j] *= (float)gainExtraAtTrace;
				sw3.headRead.trArr[i].data[j] *= (float)gainExtraAtTrace;
			} // for j
		}
	} // for i


	CColorHelper::rgb **colorsArr = (CColorHelper::rgb **)alloc2(numsamp, nx, sizeof(CColorHelper::rgb));
	if (head.maxAmp < MINAMP) head.maxAmp = MINAMP;
	if (head2.maxAmp < MINAMP) head2.maxAmp = MINAMP;
	if (head3.maxAmp < MINAMP) head3.maxAmp = MINAMP;
	double oGain = 0.5 / head.maxAmp;
	double oGain2 = 1. / head2.maxAmp;
	double oGain3 = 0.5 / head3.maxAmp;
	for (i = 0; i < nx; i++) {
		// ampColor->getColorRef4Ampf(ampArr[ix], colorsArr[ix], nt);
		for (j = 0; j < numsamp; j++) {
			colorsArr[i][j].r = sw.headRead.trArr[i].data[j] * oGain + 0.5;
			colorsArr[i][j].g = sw2.headRead.trArr[i].data[j] * oGain2;
			colorsArr[i][j].b = sw3.headRead.trArr[i].data[j] * oGain3 + 0.5;
		}
	}
	CSegyMeta::segyHeadFree(&head2);  // head2 must free manually, but head should not free
	CSegyMeta::segyHeadFree(&head3);  // head2 must free manually, but head should not free
	sw.freeSegyArray();
	sw2.freeSegyArray();
	sw3.freeSegyArray();
	StartOpenGL3_2DOnly(pView, pDC, nx, numsamp, colorsArr, xArr, yArr, &cd.coord);
	
	try {
	}
	catch (...) {
	}
	free2((void **)colorsArr);
	free1float(yArr);
	free1float(xArr);

	return TRUE;
}



BOOL CSeisWideDoc::DrawSectionTrcArr(CDC* pDC, CString fSection, int trace1, int trace2, 
	CColorHelper::AMPCOLORDYN *ampColorDyn2, CView* pView)
{
	CString tStr;
	if (draw.isSameDataDisplay && !pDC->IsPrinting()) return TRUE;
	//	if (draw.isNoSeismic) return TRUE;
	if (!isFileExistNotDirectory(fSection)) {
		// if here,  the time section does not exist, and no need to continue this routine
		return(TRUE);
	}
	if (trace2 < trace1 + 1) return TRUE; // this prevents problems
	int i, j;
	CPoint p, p1;
	double a;

	// need to decide trace step for reading
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	CSegyMeta::segyHeadInit(fSection, &head);
	if (head.aveAmp < MINAMP*0.00001) {
		tStr.Format(_T("Could not estimate gain based on the first 100 traces."));
		pFrame->myCaption(tStr);
	}
	ampColorDyn2->isBitmap = head.isSegyBitmap();
	ampColorDyn2->isBitmapC = head.isSegyBitmapC();

	// fixup odds
	if (draw.wiggle < 0) draw.wiggle = 4;

	//if (!isFileExistNotDirectory(draw.colFileName))
	//	draw.colFileName = GetPathFromFileSlash(fSection) + _T("colPalette.txt");
	// colFileName is enough: the actual plotting function will use it to load the color table for display.

	// NOTE: para.gain, gain_real, para.clip, clip_real, para.fillOff, fillOff are for area fill only
	//if (head.maxAmp < head.aveAmp * 2.) head.maxAmp = head.aveAmp * 2.0;

	//double aMean = draw.getDrawAmp(head.aveAmp);
	//double aMean = draw.isAvgEnergy ? head.aveAmp*head.aveAmp : head.aveAmp;
	areaFill.gain_real = areaFill.gain / head.aveAmp * cd.coord.dxPerPixel(); // when a sample multiplied by gain_real, it'll span a suitable trace span.
	areaFill.clip_real = areaFill.clip * cd.coord.dxPerPixel();
	double fillOffThis = areaFill.fillOff * cd.coord.dxPerPixel();

	//Note draw.trcInt is the average trace interval in km.
	double res = (double)pDC->GetDeviceCaps(HORZRES) / (double)pDC->GetWindowExt().cx;
	p = cd.coord.mm_coord((double)cd.coord.X1(), 0.);
	p1 = cd.coord.mm_coord((double)(cd.coord.X1() + 1.0), 0.);
	a = (p1.x - p.x)*res;  //a is double prec.
	if (areaFill.clip_real < 0.0) areaFill.clip_real = fabs(areaFill.clip_real);

	double clipInLoop = areaFill.clip_real;
	double gainExtraAtTrace;
	bool isRealWaveForm = draw.isWiggleInDisplay();
	bool isXArrContainRange = draw.wiggle < 4;

	CPen blackPen(PS_SOLID, 0, BLACK);
	CBrush brush(BLACK);
//	CPen* pOldPen;
	gainExtraAtTrace = (areaFill.isNegativeFill) ? -1.0 : 1.0;

	SegyWrapper sw(fSection);

	// NOTE: Why devide by 2? Because for each pixel interval, we need 2-3 traces to properly 
	//		interpolate colors. If I use 1, I see aliasing
	int iDxPerPixel = (int)(floor(cd.coord.dxPerPixel() / 2.));
	double dyPerPixel = cd.coord.dyPerPixel() / 2.;
	int isSuc = sw.openCacheSmart(trace1, trace2, &head,
		pFrame->psei->pCacheSegyWraps, NUM_CACHE, cd.zoom.isZooming != 0,
		iDxPerPixel, dyPerPixel);
	double dt = sw.headRead.getdt();
	int nx = sw.headRead.getnx();

	if (isSuc && nx>0) {
		double odt = 1. / sw.headRead.getdt();
		int sampByte = (sw.headRead.bh.format != 3) ? 4 : 2;

		int numsampTrc = sw.headRead.getns();
		if (isSuc==2)
			tStr.Format(_T("Cached: loaded %d traces w/ %d samples..."), nx, numsampTrc);
		else
			tStr.Format(_T("Loaded %d traces w/ %d samples..."), nx, numsampTrc);
		pFrame->myCaption(tStr);


		// note: data min and max time might have changed after reading the data
		// so we need to re-calc the ymin and ymax:
		// if ymin or ymax are wider than the data itself, we need to narrow the gap 
		//  otherwise the plot has problem
		// double tShift = sw.headRead.trArr[0].getTraceDelay();
		//double ymaxArrayReduced = yminArrayReduced + (numsampTrc - 1)*dt;
		double yminArrayReduced = head.tminFile < cd.coord.Y1() ? cd.coord.Y1() : head.tminFile;
		double ymaxArrayReduced = head.tmaxFile < cd.coord.Y2() ? head.tmaxFile : cd.coord.Y2();
		int numsampArray = (int)ceil((ymaxArrayReduced - yminArrayReduced) * odt) + 1; // make sure numsampArray is not too big!!
		if (numsampArray < 2) {
			// problem
			ymaxArrayReduced = yminArrayReduced + cd.coord.Y2() - cd.coord.Y1();
			numsampArray = (int)ceil((ymaxArrayReduced - yminArrayReduced) * odt) + 1;
		}

		float **ampArr = (float **)ealloc2float(numsampArray, nx);
		float *yArr = (float *)ealloc1float(numsampArray);
		float *rangeArray = (float *)ealloc1float(nx);
		//	CPoint *plt = (CPoint *)alloc1CPoint(numsampTrc);
		if (ampArr == NULL || yArr == NULL || rangeArray == NULL) {
			// memory prob; got to exit decently
			if (ampArr != NULL) free2float(ampArr);
			if (yArr != NULL) free1float(yArr);
			if (rangeArray != NULL) free1float(rangeArray);
			CSegyMeta::freeSegyDataArrayOnly(sw.headRead.trArr, nx);
			return FALSE;
		}

		yArr[0] = (float)yminArrayReduced;
		for (j = 1; j < numsampArray; j++) {
			yArr[j] = yArr[j - 1] + (float)dt;
		}

		double tShift;
		for (i = 0; i < nx; i++) {
			rangeArray[i] = (float)sw.headRead.trArr[i].tracl;
			if (rangeArray[i] < cd.coord.X1() || rangeArray[i] > cd.coord.X2())
				continue;
			register int k1 = 0;
			register int j1 = 0;
			tShift = sw.headRead.trArr[i].getTraceDelay() - yminArrayReduced;
			register int deltaj = (int)myRound(tShift * odt);
			register int lenCopy;
			if (deltaj >= 0) {
				k1 = deltaj;
				j1 = 0;
			}
			else {
				k1 = 0;
				j1 = -deltaj; // note: deltaj is negative here, and j1>0
			}

			memset(&ampArr[i][0], 0, numsampArray * sizeof(float));
			lenCopy = numsampTrc - j1;
			if (lenCopy > numsampArray - k1) lenCopy = numsampArray - k1;  // prevent index overflow
			if (j1>=0 && lenCopy > 0)
				memcpy(&ampArr[i][k1], &sw.headRead.trArr[i].data[j1], lenCopy * sizeof(float));

			if (gainExtraAtTrace != 1.) {
				for (j = k1; j < k1+lenCopy; j++) {
					ampArr[i][j] *= (float)gainExtraAtTrace;
				} // for j
			}

			if (isXArrContainRange) {
				for (j = k1; j < k1 + lenCopy; j++) {
					ampArr[i][j] *= (float)areaFill.gain_real;
					if (ampArr[i][j] > clipInLoop) ampArr[i][j] = (float)clipInLoop; // clipping
					else if (ampArr[i][j] < (-clipInLoop)) ampArr[i][j] = -(float)clipInLoop;
				} // for j

				for (j = 0; j < numsampArray; j++) {
					ampArr[i][j] += rangeArray[i]; // add range
					if (ampArr[i][j] < cd.coord.X1()) ampArr[i][j] = (float)cd.coord.X1();
					if (ampArr[i][j] > cd.coord.X2()) ampArr[i][j] = (float)cd.coord.X2();
				} // for j
			} // if
		} // for i
		//		freeSegyDataArrayOnly(sw.headRead.trArr, nxmax);

		// now do the plotting
		switch (draw.wiggle)
		{
		case 0:
			break;
		case 1:
		case 2:
			if (areaFill.isFillSmall) {
				CDCHelper::airColorSmallArr(pDC, nx, numsampArray, ampArr, rangeArray, yminArrayReduced,
					dt, BLACK, WHITE, fillOffThis, &cd);
			}
			else {
				CDCHelper::airColorBigArr(pDC, nx, numsampArray, ampArr, rangeArray, yminArrayReduced,
					dt, BLACK, WHITE, fillOffThis, &cd);
			}
			break;
		case 3:
			if (areaFill.isFillSmall) {
				CDCHelper::airColorSmallArr(pDC, nx, numsampArray, ampArr, rangeArray, yminArrayReduced,
					dt, fillOffThis, &cd, &seisBiColor2);
			}
			else {
				CDCHelper::airColorBigArr(pDC, nx, numsampArray, ampArr, rangeArray, yminArrayReduced,
					dt, fillOffThis, &cd, &seisBiColor2);
			}
			break;
		case 4:
			this->floodFillArr5Multi(pDC, nx, numsampArray, ampArr, rangeArray,
				(double)trace1, (double)trace2, yminArrayReduced, ymaxArrayReduced, ampColorDyn2);
			break;
		case 5:
			this->floodFillArr5Multi(pDC, nx, numsampArray, ampArr, rangeArray,
				(double)trace1, (double)trace2, yminArrayReduced, ymaxArrayReduced, ampColorDyn2);
			break;
		case 6:
		case 7:
		default:
			//CDCHelper::tessellateFill2(pDC, nxmax, numsampPlot, xArray, rangeArray,
			//	(double)trace1, (double)trace2, yminPlot, ymaxPlot, ampColorDyn2, &cd, draw.memMaxMB);
			// double amax = draw.getDrawAmp(head.maxAmp);
			//double amax = draw.isAvgEnergy ? head.maxAmp*head.maxAmp : head.maxAmp;
			//StartOpenGL(pView, pDC, nxmax, numsampPlot, 
			//	xArray, (float)amax, rangeArray, yArr,
			//	(double)trace1, (double)trace2, yminPlot, ymaxPlot, ampColorDyn2, areaFill.gain_real, areaFill.clip_real); // note: this init call must be after coordinate system has been set


			//StartOpenGL2_OLD(pView, pDC, nxmax, numsampPlot,
			//	xArray, rangeArray, yArr,
			//	ampColorDyn2, &cd.coord);

			StartOpenGL2(pView, pDC, ampArr, rangeArray, nx, (float)yminArrayReduced, (float)dt, numsampArray,
				ampColorDyn2, &cd.coord);

			break;
		} // switch

		double xpos;
		if (draw.isWiggleInDisplay()) {
			if (!isXArrContainRange) {
				for (int i = 0; i < nx; i++) {
					register double tClip = fabs(areaFill.clip_real);
					for (j = 0; j<numsampArray; j++) {
						xpos = ampArr[i][j] * areaFill.gain_real;
						if (xpos> tClip) xpos = tClip; // clipping
						else if (xpos < (-tClip)) xpos = -tClip;
						xpos += rangeArray[i]; // add range
						if (xpos < cd.coord.X1()) xpos = cd.coord.X1();
						if (xpos > cd.coord.X2()) xpos = cd.coord.X2();
						ampArr[i][j] = (float)xpos;
					} // for j
				}
			}

			CDCHelper::wiggleArr(pDC, nx, numsampArray, ampArr, rangeArray, yArr, &cd);
		}

		// cleanup opengl stuff
		if (draw.wiggle != 6 && m_GLWin.myGL.isOpenGLWindowsExists) {
			m_GLWin.mySeis3DFBO_End();
			m_GLWin.DestroySceneFBO();
		}

		if (ampArr != NULL) free2float(ampArr);
		free1float(yArr);
		free1float(rangeArray);
	}
	// if sw


	return TRUE;
}




// for all drawing routines, Draw trace meta info such as trace numbers, FFIDs et al.
// x is the trace distance in km
BOOL CSeisWideDoc::drawTrcInfo(CDC* pDC, float xkm, segy *tr, int *sPos, int *sLen, BOOL isDetail)
{
	if (draw.isNoLableOutside) return FALSE;
	if (tr == NULL) return TRUE;

	//int numHeight = max(cd.coord.logicalAxes.Width(), cd.coord.logicalAxes.Height())/100;
	//int numWidth = max(cd.coord.logicalAxes.Width(), cd.coord.logicalAxes.Height())/180;
	int numHeight = 300;
	int numWidth = 150;
	LOGFONT logFontNum;
	logFontNum.lfHeight = numHeight;
	logFontNum.lfWidth = numWidth;
	logFontNum.lfEscapement = 0;
	logFontNum.lfOrientation = 0;
	logFontNum.lfWeight = FW_REGULAR;
	logFontNum.lfItalic = 0;
	logFontNum.lfUnderline = 0;
	logFontNum.lfStrikeOut = 0;
	logFontNum.lfCharSet = ANSI_CHARSET;
	logFontNum.lfOutPrecision = OUT_DEFAULT_PRECIS;
	logFontNum.lfClipPrecision = CLIP_DEFAULT_PRECIS;
	logFontNum.lfQuality = DEFAULT_QUALITY;
	logFontNum.lfPitchAndFamily = VARIABLE_PITCH | FF_SWISS;
	_tcscpy_s(logFontNum.lfFaceName, _T("Sans Serif"));
	CFont fontN;
	fontN.CreateFontIndirect(&logFontNum);
	CFont* oldFont;
	COLORREF oldColor;


	//if (isDetail) {
	//	oldFont = pDC->SelectObject(&fontN);
	//	oldColor = pDC->SetTextColor(CColorHelper::BLUE);
	//	if(draw.headInfo=="Trace No.") pDC->TextOut(0,0,"Trc");
	//	if(draw.headInfo=="FFID") pDC->TextOut(0,0,"FFID");
	//	if(draw.headInfo=="CDP") pDC->TextOut(0,0,"CDP");
	//	if(draw.headInfo=="All")
	//	{
	//		pDC->TextOut(0,0,"Trc");
	//		pDC->TextOut(0,numHeight,"FFID");
	//		pDC->TextOut(0,numHeight*2,"SP");
	//		pDC->TextOut(0,numHeight*3,"CDP");
	//		pDC->TextOut(0,numHeight*4,"Dist");
	//		pDC->TextOut(0,numHeight*5,"sx");
	//		pDC->TextOut(0,numHeight*6,"gx");
	//		pDC->TextOut(0,numHeight*7,"Offset");
	//	}

	//	pDC->SelectObject(oldFont);
	//	pDC->SetTextColor(oldColor);
	//}



	bool isTime = cd.coord.isTimeDomain() == TRUE;
	int x = cd.coord.mm_coordx((double)xkm);   // x is now the client coordinate

	oldFont = pDC->SelectObject(&fontN);
	oldColor = pDC->SetTextColor(BLUE);
	//if(draw.headInfo=="Trace No.")
	//{
	//	_stprintf(s, "%d", tr->tracl);
	//	lenThis = numWidth*_tcslen(s);
	//	if(tr->tracl % 10 == 0  &&   abs(x - *sPos) > lenThis*1.3)
	//	{
	//		pDC->TextOutA(x-lenThis/2, 0,s);
	//		*sPos = x;
	//	}
	//}
	//else if(draw.headInfo=="FFID")
	//{
	//	_stprintf(s, "%d", tr->fldr);
	//	lenThis = numWidth*_tcslen(s);
	//	if(tr->tracl % 10 == 0  &&   abs(x - *sPos) > lenThis*1.3)
	//	{
	//		pDC->TextOutA(x-lenThis/2, 0,s);
	//		*sPos = x;
	//	}
	//}
	//else if(draw.headInfo=="CDP")
	//{
	//	_stprintf(s, "%d", tr->cdp);
	//	lenThis = numWidth*_tcslen(s);
	//	if(tr->tracl % 10 == 0  &&   abs(x - *sPos) > lenThis*1.3)
	//	{
	//		pDC->TextOutA(x-lenThis/2, 0,s);
	//		*sPos = x;
	//	}
	//}
	//else if(draw.headInfo=="All")
	//{
	//	_stprintf(s, "%d", tr->tracl);
	//	lenThis = numWidth*_tcslen(s);
	//	int sPosNew = -1;
	//	
	//	if(tr->tracl % 10 == 0  &&   abs(x - *sPos) > lenThis*1.3)
	//	{
	//		pDC->TextOutA(x-lenThis/2, 0,s);
	//		sPosNew = max(sPosNew, x+lenThis/2);

	//		_stprintf(s, "%d", tr->fldr);  
	//		lenThis = numWidth*_tcslen(s);
	//		pDC->TextOutA(x-lenThis/2, numHeight,s);

	//		_stprintf(s, "%d", tr->ep);
	//		lenThis = numWidth*_tcslen(s);
	//		pDC->TextOutA(x-lenThis/2, numHeight*2,s);

	//		_stprintf(s, "%d", tr->cdp); 
	//		lenThis = numWidth*_tcslen(s);
	//		pDC->TextOutA(x-lenThis/2, numHeight*3,s);

	//		
	//		_stprintfA(s, "%d", (int)myRound( getDistance(tr)*1000.f ) );
	//		lenThis = numWidth*_tcslen(s);
	//		pDC->TextOutA(x-lenThis/2, numHeight*4,s);

	//		_stprintf(s, "%d", tr->sx);
	//		lenThis = numWidth*_tcslen(s);
	//		pDC->TextOutA(x-lenThis/2, numHeight*5,s);

	//		_stprintf(s, "%d", tr->gx);
	//		lenThis = numWidth*_tcslen(s);
	//		pDC->TextOutA(x-lenThis/2, numHeight*6,s);

	//		_stprintf(s, "%d", tr->offset);
	//		lenThis = numWidth*_tcslen(s);
	//		pDC->TextOutA(x-lenThis/2, numHeight*7,s);

	//		if (sPosNew > 0) *sPos = sPosNew;
	//	} // if abs(x
	//}
	pDC->SelectObject(oldFont);
	pDC->SetTextColor(oldColor);

	fontN.DeleteObject();
	// oldFont->DeleteObject();  do not delete oldFont since it is the default one on screen

	return FALSE;
}



//
////yminExact, ymaxExact are the exact values of min and max box to plot, although they may not be the "nice" numbers to show. 
////   Note:  1. ymin and ymax already considered the time or depth domain issues correctly.
////          2. I have not pre-calculated the xminNice, xmaxNice values; this is because we may have issues of trace or distance/offset which may need separate handling. 
////             If you really want to do this, you need to test before commiting.
////          3. This routine is only called by ticks()  and is therefore put to the protected section in header file
////          4. ideltx, idelty are the length of ticks in logical coordinates. Labels should not overlay with them
//void CSeisWideDoc::DrawAxesTicksValues(CDC* pDC, int fontWidth, int fontHeight, BOOL isMainXSwap)
//{
//	CPoint p, tick[2];
//	CString tStr;
//	//int ideltx = (int)(-130 * mul); 
//	//int idelty = (int)(120 * mul);
//
//	// xmin can be 1, which should be rounded to 0, and incremented by a regular tick value
//	// xmax cannot be rounded, otherwise 899 becomes 1000, which is not good
//	double xminNice = getMinRounded(cd.coord.X1(), cd.coord.X2(), 10);
//	double xmaxNice = (float)niceNumMinMax(cd.coord.X2(), true);
//	double xTickNice = getTickRounded(cd.coord.X1(), cd.coord.X2(), 2, 50, cd.coord.xTick);
//	if (xTickNice < (xmaxNice - xminNice)*0.05) xTickNice = (xmaxNice - xminNice)*0.05;
//	else if (xTickNice > (xmaxNice - xminNice)*0.5) xTickNice = (xmaxNice - xminNice)*0.5;
//	xTickNice = getTickRounded(cd.coord.X1(), cd.coord.X2(), 2, 50, xTickNice);
//
//	if (xminNice > cd.coord.X1()) {
//		do {
//			xminNice -= xTickNice;
//		} while (xminNice > cd.coord.X1());
//	}
//
//	double yminNice = getMinRounded(cd.coord.Y1(), cd.coord.Y2(), 10);
//	double yTickNice = getTickRounded(cd.coord.Y1(), cd.coord.Y2(), 1, 50, cd.coord.getYTick());
//	if (yminNice > cd.coord.Y1()) {
//		do {
//			yminNice -= yTickNice;
//		} while (yminNice > cd.coord.Y1());
//	}
//
//	// testing
//	double mul = cd.coord.getDeviceResAdjust(pDC);
//	int idelty = (int)(120 * mul);
//
//	bool isTime = cd.coord.isTimeMode() == TRUE;
//	double yPlot = cd.coord.isFaceUp ? cd.coord.Y1() : cd.coord.Y2();
//	double x = floor(xminNice);
//	double xCurrent;
//	int pixelX, pixelX2;
//	do {
//		// first, draw major ticks
//		if (cd.coord.isVisibleOrNot(x)) {
//			tick[0] = cd.coord.mm_coord(x, yPlot);	//delty is negative.
//			tick[1].x = tick[0].x;
//			tick[1].y = tick[0].y + (long)(1.5*idelty);
//
//			//if (xTickNice < 0.01) tStr.Format(_T("%1.2f"), x);
//			//else if (xTickNice < 1.) tStr.Format(_T("%1.1f"), x);
//			//else tStr.Format(_T("%d"), (int)x);
//			tStr = getNiceLabelFromValue(x, xTickNice);
//
//			int countS = tStr.GetLength();
//			pDC->Polyline(tick, 2);
//
//			// before drawing X-labels, we want to make sure they draw visibly.
//			pixelX = tick[1].x - (countS*fontWidth) / 2;
//			if (pixelX <  (int)ceil(mul)) pixelX = (int)ceil(mul);
//			pixelX2 = pixelX + tStr.GetLength()*fontWidth + (int)ceil(mul);
//			if (pixelX2 > cd.coord.viewLogicalTotal.right)
//				pixelX -= pixelX2 - cd.coord.viewLogicalTotal.right;
//
//			// now the labels are all in good condition
//			pDC->TextOut(pixelX, tick[1].y + (int)ceil(mul), tStr);
//		}
//
//		// now draw minor ticks
//		xCurrent = x + xTickNice*0.2;
//		if (cd.coord.isVisibleOrNot(xCurrent)) {
//			tick[0] = cd.coord.mm_coord(xCurrent, yPlot);
//			tick[1].x = tick[0].x;
//			tick[1].y = tick[0].y + idelty;
//			pDC->Polyline(tick, 2);
//		}
//		xCurrent = x + xTickNice*0.4;
//		if (cd.coord.isVisibleOrNot(xCurrent)) {
//			tick[0] = cd.coord.mm_coord(xCurrent, yPlot);
//			tick[1].x = tick[0].x;
//			tick[1].y = tick[0].y + idelty;
//			pDC->Polyline(tick, 2);
//		}
//		xCurrent = x + xTickNice*0.6;
//		if (cd.coord.isVisibleOrNot(xCurrent)) {
//			tick[0] = cd.coord.mm_coord(xCurrent, yPlot);
//			tick[1].x = tick[0].x;
//			tick[1].y = tick[0].y + idelty;
//			pDC->Polyline(tick, 2);
//		}
//		xCurrent = x + xTickNice*0.8;
//		if (cd.coord.isVisibleOrNot(xCurrent)) {   // the last one has to include cd.coord.X2()
//			tick[0] = cd.coord.mm_coord(xCurrent, yPlot);
//			tick[1].x = tick[0].x;
//			tick[1].y = tick[0].y + idelty;
//			pDC->Polyline(tick, 2);
//		}
//
//		x += xTickNice;
//	} while (x <= cd.coord.X2() + xTickNice + 0.001);	  //Finish drawing xTicks
//
//
//
//
//
//	CPen* pOldPen;
//	CPen gridPen(PS_DOT, 0, RGB(200, 200, 200));
//
//
//
//
//	double xLeftAxis;
//	double xRightAxis;
//	int ideltx = (int)(130 * mul);
//	if (cd.coord.isSwapYLabel) isMainXSwap = !isMainXSwap;
//	if (isMainXSwap == cd.coord.isSwapX) ideltx = -ideltx;
//	if (isMainXSwap) {
//		xLeftAxis = cd.coord.X2();
//		xRightAxis = cd.coord.X1();
//	}
//	else {
//		xLeftAxis = cd.coord.X1();
//		xRightAxis = cd.coord.X2();
//	}
//
//
//	double y = yminNice;
//	// why use -0.001 ? It is because if we do not, the tick for ymin may be missed since 
//	//  cd.coord.Y1() can be 3.000001
//	if (y > cd.coord.Y1()) y -= yTickNice;
//	
//	// now we need a fix: suppose ymin=3.7 and yTick=1, yTickNice becomes 3.5, 
//	// we need to start from 3 instead of 3.5! 
//	y = floor(y);
//
//
//	do  {
//		// first, draw major ticks
//		if (y >= cd.coord.Y1() - 0.001 &&  y <= cd.coord.Y2() + 0.001) {
//			tick[0] = cd.coord.mm_coord(xLeftAxis, y);
//			tick[1].x = tick[0].x + (long)(1.5*ideltx);
//			tick[1].y = tick[0].y;
//
//			tStr = getNiceLabelFromValue(y, yTickNice);
//			pDC->MoveTo(tick[0]);
//			pDC->LineTo(tick[1]);
//
//			// before drawing X-labels, we want to make sure they draw visibly.
//			if (isMainXSwap && !cd.coord.isSwapX)
//				pixelX = tick[1].x + tStr.GetLength()*fontWidth - (int)ceil(mul);
//			else if (!isMainXSwap && cd.coord.isSwapX)
//				pixelX = tick[1].x + (int)ceil(mul);
//			else
//				pixelX = tick[1].x - tStr.GetLength()*fontWidth - (int)ceil(mul);
//
//			if (pixelX <  (int)ceil(mul)) pixelX = (int)ceil(mul);
//			pixelX2 = pixelX + tStr.GetLength()*abs(fontWidth) + (int)ceil(mul);
//			if (pixelX2 > cd.coord.viewLogicalTotal.right)
//				pixelX -= pixelX2 - cd.coord.viewLogicalTotal.right;
//
//			// now the labels are all in good condition
//			pDC->TextOut(pixelX, tick[1].y - fontHeight / 2, tStr);
//
//			// draw grids
//			if (!draw.isNoHorzGrid && y > cd.coord.Y1() && y < cd.coord.Y2()) {
//				tick[1].x = cd.coord.mm_coordx(xRightAxis);
//				pOldPen = pDC->SelectObject(&gridPen);
//				pDC->MoveTo(tick[0]);
//				pDC->LineTo(tick[1]);
//				// pDC->Polyline(tick, 2);
//				pDC->SelectObject(pOldPen);
//			} // if y
//		} // if y
//
//
//		// now draw minor ticks
//		double yCurrent;
//		yCurrent = y + yTickNice*0.2;
//		if (cd.coord.isVisibleOrNotY(yCurrent)) {
//			tick[0] = cd.coord.mm_coord(xLeftAxis, yCurrent);
//			tick[1].x = tick[0].x + ideltx;
//			tick[1].y = tick[0].y;
//			pDC->Polyline(tick, 2);
//		}
//		yCurrent = y + yTickNice*0.4;
//		if (cd.coord.isVisibleOrNotY(yCurrent)) {
//			tick[0] = cd.coord.mm_coord(xLeftAxis, yCurrent);
//			tick[1].x = tick[0].x + ideltx;
//			tick[1].y = tick[0].y;
//			pDC->Polyline(tick, 2);
//		}
//		yCurrent = y + yTickNice*0.6;
//		if (cd.coord.isVisibleOrNotY(yCurrent)) {
//			tick[0] = cd.coord.mm_coord(xLeftAxis, yCurrent);
//			tick[1].x = tick[0].x + ideltx;
//			tick[1].y = tick[0].y;
//			pDC->Polyline(tick, 2);
//		}
//		yCurrent = y + yTickNice*0.8;
//		if (cd.coord.isVisibleOrNotY(yCurrent)) {
//			tick[0] = cd.coord.mm_coord(xLeftAxis, yCurrent);
//			tick[1].x = tick[0].x + ideltx;
//			tick[1].y = tick[0].y;
//			pDC->Polyline(tick, 2);
//		}
//
//		// now go to the next major tick
//		y += yTickNice;
//	} while (y <= cd.coord.Y2() + yTickNice + 0.001);	  //Finish drawing yTicks
//
//
//}

/*
rect: the overall drawing window
rectLogicalAxes: the area defined by the X-Y axes

Our tick marks and labels will be both outside and inside the X-Y axes
*/
void CSeisWideDoc::Tick(CDC* pDC)
{
	//if (draw.wiggle == 6)
	//	this->clearTicks(pDC); // now clear the 4 borders, since they are not covered in 3D display


	bool isSeismicExist =
		(cd.coord.isTimeDomain() && isFileExistNotDirectory(draw.timeSecName))
		||
		(!cd.coord.isTimeDomain() && isFileExistNotDirectory(draw.depthSecName))
		;
	CCoords::DrawAxes(pDC, &cd.coord, cd.coord.logicalAxes,
		isSeismicExist && 
		draw.isSeismicPlot && 
		!draw.isVectoring && 
		!draw.isCopying);
	draw.isVectoring = FALSE; // this indicates the next time it should plot axis normally.
	CPoint p, p1, tick[2], temp;
	double y;
	int countS, i;
	CString tStr;
	CPen* pOldPen;


	// since the tick() needs to consider both time and depth domains, we use general variables to describe the vertical axis
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	ASSERT(pFrame);
	ASSERT_KINDOF(CMainFrame, pFrame);

	if (pFrame->statMain.fLabelDistance3 == 0.f) pFrame->statMain.fLabelDistance3 = 1.f;
	COLORREF oldColor;
	oldColor = pDC->SetTextColor(BLACK);

	// Initialize a LOGFONT structure for the fonts.
	LOGFONT logFont; // font for drawing labels such as Distance (km)
	pDC->GetCurrentFont()->GetLogFont(&logFont);
	double xyRatio = (double)logFont.lfWidth / (double)logFont.lfHeight;
	double onePointSize = pFrame->statMain.fLabelDistance3 * cd.coord.device2Logical * cd.coord.getDefDisplayAdjust(pDC);
	_tcscpy_s(logFont.lfFaceName, _T("Arial"));
	logFont.lfWidth = (LONG)myRound(onePointSize * 8.);
	logFont.lfHeight = (LONG)(logFont.lfWidth / xyRatio);
	logFont.lfEscapement = 0;
	logFont.lfOrientation = 0; //important: make both 900.
	logFont.lfWeight = 700;
	logFont.lfItalic = 0;
	logFont.lfUnderline = 0;
	logFont.lfStrikeOut = 0;
	logFont.lfCharSet = ANSI_CHARSET;
	logFont.lfOutPrecision = OUT_DEFAULT_PRECIS;
	logFont.lfClipPrecision = CLIP_DEFAULT_PRECIS;
	logFont.lfQuality = DEFAULT_QUALITY;
	logFont.lfPitchAndFamily = FF_SWISS;


	LOGFONT logFontNum;  // font for drawing numbers
	pDC->GetCurrentFont()->GetLogFont(&logFontNum);
	_tcscpy_s(logFontNum.lfFaceName, _T("Arial"));
	logFontNum.lfWidth = (LONG)myRound(onePointSize * 7.);
	logFontNum.lfHeight = (LONG)(logFontNum.lfWidth / xyRatio);
	logFontNum.lfEscapement = 0;
	logFontNum.lfOrientation = 0;
	logFontNum.lfWeight = FW_NORMAL;
	logFontNum.lfItalic = 0;
	logFontNum.lfUnderline = 0;
	logFontNum.lfStrikeOut = 0;
	logFontNum.lfCharSet = ANSI_CHARSET;
	logFontNum.lfOutPrecision = OUT_DEFAULT_PRECIS;
	logFontNum.lfClipPrecision = CLIP_DEFAULT_PRECIS;
	logFontNum.lfQuality = DEFAULT_QUALITY;
	logFontNum.lfPitchAndFamily = FF_SWISS;


	LOGFONT logFontH; // header font
	pDC->GetCurrentFont()->GetLogFont(&logFontH);
	_tcscpy_s(logFontH.lfFaceName, _T("Arial"));
	logFontH.lfWidth = (LONG)myRound(onePointSize * 8.);
	logFontH.lfHeight = (LONG)(logFontH.lfWidth / xyRatio);
	logFontH.lfEscapement = 0;
	logFontH.lfOrientation = 0;
	logFontH.lfWeight = 700;
	logFontH.lfItalic = 0;
	logFontH.lfUnderline = 0;
	logFontH.lfStrikeOut = 0;
	logFontH.lfCharSet = ANSI_CHARSET;
	logFontH.lfOutPrecision = OUT_DEFAULT_PRECIS;
	logFontH.lfClipPrecision = CLIP_DEFAULT_PRECIS;
	logFontH.lfQuality = DEFAULT_QUALITY;
	logFontH.lfPitchAndFamily = FF_SWISS;

	LOGFONT logFontHS; // header font
	pDC->GetCurrentFont()->GetLogFont(&logFontHS);
	_tcscpy_s(logFontHS.lfFaceName, _T("Arial"));
	logFontHS.lfWidth = (LONG)myRound(onePointSize * 7.);
	logFontHS.lfHeight = (LONG)(logFontHS.lfWidth / xyRatio);
	logFontHS.lfEscapement = 0;
	logFontHS.lfOrientation = 0;
	logFontHS.lfWeight = 700;
	logFontHS.lfItalic = 0;

	LOGFONT logFontNumS;  // font for drawing numbers
	pDC->GetCurrentFont()->GetLogFont(&logFontNumS);
	_tcscpy_s(logFontNumS.lfFaceName, _T("Arial"));
	logFontNumS.lfWidth = (LONG)myRound(onePointSize * 5.);
	logFontNumS.lfHeight = (LONG)(logFontNumS.lfWidth / xyRatio);
	logFontNumS.lfEscapement = 0;
	logFontNumS.lfOrientation = 0;
	logFontNumS.lfWeight = FW_NORMAL;

	LOGFONT logFontV; // font for drawing labels such as TWTT (s)
	pDC->GetCurrentFont()->GetLogFont(&logFontV);
	_tcscpy_s(logFontV.lfFaceName, _T("Arial"));
	logFontV.lfWidth = (LONG)myRound(onePointSize * 8.);
	logFontV.lfHeight = (LONG)(logFontV.lfWidth / xyRatio);
	logFontV.lfEscapement = 900;
	logFontV.lfOrientation = 900; //important: make both 900.
	logFontV.lfWeight = 700;
	logFontV.lfItalic = 0;
	logFontV.lfUnderline = 0;
	logFontV.lfStrikeOut = 0;
	logFontV.lfCharSet = ANSI_CHARSET;
	logFontV.lfOutPrecision = OUT_DEFAULT_PRECIS;
	logFontV.lfClipPrecision = CLIP_DEFAULT_PRECIS;
	logFontV.lfQuality = DEFAULT_QUALITY;
	logFontV.lfPitchAndFamily = FF_SWISS;


	CFont* oldFont;  // note it's a pointer
	CFont font;  // font for axis labels
	CFont fontN;  // for numbering on the axes
	CFont fontH;  // the biggest title
	CFont fontVertical;  // the verticle axis, such as Distance and Time, Depth
	CFont fontHSmall; // small header, for ?
	CFont fontNumSmall; // small numbers  for meta data texts

	fontN.CreateFontIndirect(&logFontNum);
	font.CreateFontIndirect(&logFont);
	fontH.CreateFontIndirect(&logFontH);
	fontVertical.CreateFontIndirect(&logFontV);
	fontHSmall.CreateFontIndirect(&logFontHS);
	fontNumSmall.CreateFontIndirect(&logFontNumS);



	CPen thinPen(PS_SOLID, 0, BLACK);
	CPen gridPen(PS_DOT, 0, RGB(200, 200, 200));

	bool isTime = cd.coord.isTimeDomain() == TRUE;

	CVelMod vm;
	//****************************
	// print out some meta data for this plot
	oldFont = pDC->SelectObject(&fontNumSmall);
	
	velMod.m_isConvert = true;
	if (!draw.isNoLabelInSide && cd.coord.isModelingMode() && velMod.ncont > 1) {
		CVelMod::VELMOD_X modX;
		modX.dist = cd.coord.X2();
		vm.initModX(&velMod, &modX, isTime, false, velColor.dz);

		CVelMod::VELMOD_X modX2;
		modX2.dist = cd.coord.xmin;
		vm.initModX(&velMod, &modX2, isTime, true, velColor.dz);

		if (isFileExistNotDirectory(draw.rayName)) {
			CTime aTime = getFileModifiedTime(draw.rayName);

			if (poissonRay.rayParaName != draw.rayName || aTime != poissonRay.modifiedRay) {
				CStringArray *sArr = new CStringArray();
				loadParam(draw.rayName, _T("pois"), sArr);
				memset(poissonRay.poisson, 0, MOD_LAYER_MAX * sizeof(double));
				for (i = 0; i < velMod.ncont; i++) {
					if (i < sArr->GetCount()) {
						poissonRay.poisson[i] = (float)_tstof(sArr->GetAt(i));
					}
				}
				poissonRay.modifiedRay = aTime;
				poissonRay.rayParaName = draw.rayName;
				sArr->RemoveAll();
				delete sArr;
			}
		}

		int xplot;
		int yplot;
		int oldBkMode = pDC->SetBkMode(OPAQUE);

		for (i = 0; i < velMod.ncont - 1; i++) {
			register int n1 = velMod.nzed[i];
			register int n2 = velMod.nzed[i + 1];
			if (n1 < 1 || n2 < 1) continue;  // no points defined for this layer
			register double zt1 = isTime ? modX.timeMod[i] : modX.depthMod[i];
			register double zt2 = isTime ? modX.timeMod[i + 1] : modX.depthMod[i + 1];
			if (zt2 <= zt1) continue;  // no points defined for this layer
			if (zt1 >= cd.coord.Y2()) continue;
			if (zt1 >= cd.coord.Y1() && zt1 <= cd.coord.Y2()) {
				register CPoint cp = cd.coord.mm_coord(0.f, zt1);
				if (velMod.anisotropy[i] != 0.f) {
					if (modX2.depthMod[i + 1] <= modX2.depthMod[i]) continue;  // no points defined for this layer
					if (modX2.depthMod[i] >= cd.coord.m_zmin && modX2.depthMod[i] <= cd.coord.m_zmax) {
						cp = cd.coord.mm_coord(0.f, modX2.depthMod[i]);
						yplot = cp.y - logFontNum.lfHeight;
						tStr.Format(_T("[ %1.3g ]"), modX2.vTop[i]);
						oldColor = pDC->SetTextColor(RGB(255, 100, 0));
						pDC->TextOut(cd.coord.logicalAxes.left + 200, cp.y, tStr);
						pDC->SetTextColor(oldColor);
					}
				}
			} // if

			if (zt2 >= cd.coord.Y1() && zt2 <= cd.coord.Y2()) {
				register CPoint cp = cd.coord.mm_coord(0.f, zt2);
				if (velMod.anisotropy[i] != 0.f) {
					if (modX2.depthMod[i + 1] <= modX2.depthMod[i]) continue;  // no points defined for this layer
					if (modX2.depthMod[i + 1] >= cd.coord.m_zmin && modX2.depthMod[i + 1] <= cd.coord.m_zmax) {
						cp = cd.coord.mm_coord(0.f, modX2.depthMod[i + 1]);
						yplot = cp.y - logFontNum.lfHeight;
						tStr.Format(_T("[ %1.3g ]"), modX2.vBot[i]);
						oldColor = pDC->SetTextColor(RED);
						pDC->TextOut(cd.coord.logicalAxes.left + 200, yplot, tStr);
						pDC->SetTextColor(oldColor);
					}
				}
			} // if

			// now print out the layer number in red on the rightmost side of the model
			register double zt = (zt1 + zt2)*0.5;
			if (zt1<cd.coord.Y2() && zt2>cd.coord.Y2() && zt > cd.coord.Y2()) {
				zt = (zt1 + cd.coord.Y2())*0.5;
			}

			if (!draw.isNoLabelInSide) {
				register double pois = poissonRay.poisson[i]; // actual Poisson's ratio for a layer numbered i
				if (pois > 0.f) {
					double vpvs = CVelMod::calcVpovs(pois); 
					// if (velMod.anisotropy[i]  != 0.f) pois *= (1 - velMod.anisotropy[i]);
					if (vpvs > 0.) {
						tStr.Format(_T("( %1.4g - %1.4g ) %0.4g(%0.4g)%d"), modX.vTop[i] / vpvs, modX.vBot[i] / vpvs, pois, vpvs, i+1);

						// Need to use the model bounds instead of window bounds. Help!!!
						register double xvmin = velMod.getXmin();
						register double xvmax = velMod.getXmax();
						xvmin = max(xvmin, cd.coord.xmin);
						xvmax = min(xvmax, cd.coord.xmax);

						// this prevents the S labeling printed on top of pseudo well info
						if (fabs(tx.xShotRay - xvmin) > fabs(tx.xShotRay - xvmax))
							xplot = logFontNum.lfWidth*tStr.GetLength();
						else
							xplot = cd.coord.logicalAxes.right - logFontNum.lfWidth*tStr.GetLength();

						CPoint cp = cd.coord.mm_coord(0.f, zt);
						yplot = cp.y - logFontNum.lfHeight / 2;

						if (pFrame->statMain.isDisplayVsModel) {
							oldColor = pDC->SetTextColor(RED);
							pDC->TextOut(xplot, yplot, tStr);
							pDC->SetTextColor(oldColor);
						}
					}
				} // if pois > 0
			} // if sArr
		} // for i

		pDC->SetBkMode(oldBkMode);
		velMod.m_isConvert = true;

		if (draw.iModelPeglet >= 0 && velMod.ncont - 1 > 1) {
			float ov = 4.f / (velMod.vf[0][0][0] + velMod.vf[0][0][1]);
			// now, we draw a faint line for the water multiple in the depth domain
			float x, t, zsf, tsf2, tBoundary;

			CPoint* pint = (CPoint *)alloc1CPoint(MOD_POINTS_MAX);

			int nz = (int)(velMod.zmax / velColor.dz);
			double *twtt = (double *)ealloc1double((nz + 2));
			if (draw.iModelPeglet == 1) {
				for (int icont = 1; icont < velMod.ncont - 1; icont++) {
					int num = 0;
					for (i = 0; i < velMod.nzed[icont]; i++) {
						x = velMod.xm[i][icont]; // boundary 1 means the seafloor
						zsf = getDepthAtSeafloor(x);
						tsf2 = zsf * ov;  // 2-way time, assumes constant water vel
						modX.dist = x;
						vm.initModX(&velMod, &modX, isTime, true, velColor.dz);
						tBoundary = (float)vm.getTimeAtZ(&modX, velMod.zm[i][icont], velColor.dz, twtt, nz+2);
						// now tBoundary is 2-way time at the layer boundary

						register double zMult = vm.my2WayTime2Depth2(&velMod, x, tBoundary + tsf2*0.5, velColor.dz, twtt, nz+2);  //pass two-way time only to this routine to get the true depth.
						pint[num] = cd.coord.mm_coord(x, zMult);
						num++;
					} // for i
					if (num > 1) {
						pOldPen = pDC->SelectObject(&gridPen);
						pDC->Polyline(pint, num);
						pDC->SelectObject(pOldPen);
					}
				} // for icont
			}
			else {
				int np = velMod.nzed[draw.iModelPeglet]; // num of points for the boundary
				for (i = 0; i < np; i++) {
					x = velMod.xm[i][draw.iModelPeglet];
					zsf = getDepthAtSeafloor(x);
					tsf2 = zsf * ov;  // two-way time, assumes constant water vel
					modX.dist = x;
					vm.initModX(&velMod, &modX, isTime, true, velColor.dz);
					t = (float)vm.getTimeAtZ(&modX, (double)velMod.zm[i][draw.iModelPeglet], velColor.dz, twtt, nz+2);
					register double zMult = vm.my2WayTime2Depth2(&velMod, x, t - tsf2*0.5, velColor.dz, twtt, nz+2);
					pint[i] = cd.coord.mm_coord(x, zMult);
				} // for i
				pOldPen = pDC->SelectObject(&gridPen);
				pDC->Polyline(pint, np);
				pDC->SelectObject(pOldPen);
			}
			free1CPoint(pint);
			free1double(twtt);



		} // if
	} // if !draw.isNoLableOutside, can be OK for botu time and depth domains
	pDC->SelectObject(oldFont);
	//****************************



	if (this->draw.isNoLableOutside || this->cd.coord.drawmode < 0) {
		font.DeleteObject();
		fontH.DeleteObject();
		fontVertical.DeleteObject();
		fontHSmall.DeleteObject();
		fontN.DeleteObject();
		fontNumSmall.DeleteObject();
		return;
	}




	//Draw tick marks around the axes.
	//controls for the tick length in drawing in X and Y axes, in client coord
	pOldPen = pDC->SelectObject(&thinPen);
	oldFont = pDC->SelectObject(&fontN);
	cd.DrawAxesTicksValues(pDC, logFontNum.lfWidth, logFontNum.lfHeight, 
		pFrame->statMain.isSwapXActive, draw.isNoHorzGrid);

	if ( (cd.coord.drawmode==0 || cd.coord.drawmode == 7) &&
		CCoords::isXShotDefined((float)head.xshotInSegy)) {
		pDC->SelectObject(&fontNumSmall);

		if (cd.coord.isDistanceDisplay)
			cd.DrawAxesTicksOffsets(pDC, logFontNum.lfWidth, head.xshotInSegy);
		else
			cd.DrawAxesTicksDistance(pDC, logFontNum.lfWidth, head.xshotInSegy);
	}

	pDC->SelectObject(pOldPen);
	pDC->SelectObject(oldFont);

	double vred = draw.red.getVred(); //rvred == 0. ? 0. : 1. / draw.red.rvred;
	if (!draw.strYLabelOverwrite.IsEmpty()) {
		tStr = draw.strYLabelOverwrite;
	}
	else if (cd.coord.drawmode == 9 || (cd.coord.drawmode == 10)) {
		tStr = _T("TWTT (s)");
	}
	else if (cd.coord.drawmode == 7) {
		// NMO display
		tStr = draw.red.toString(true);
	}
	else if (cd.coord.isTimeDomain()) {
		tStr = draw.red.toString(false);
	}
	else {
		tStr = _T("Depth (km)");
	}

	oldFont = pDC->SelectObject(&fontVertical);
	int oldBkMode = pDC->SetBkMode(OPAQUE);
	bool isYLabelOnRight = pFrame->statMain.isSwapXActive != cd.coord.isSwapX;
	if (cd.coord.isSwapYLabel) isYLabelOnRight = !isYLabelOnRight;
	int ix = isYLabelOnRight ? 
		cd.coord.viewLogicalTotal.right - 1 - logFontV.lfHeight
		: 2;
	pDC->TextOut(ix, (cd.coord.viewLogicalTotal.bottom + tStr.GetLength()*logFontV.lfWidth) / 2, tStr);

	pDC->SelectObject(oldFont);
	pDC->SetBkMode(oldBkMode);


	// now we got a chance to better plot ticks/axis labels for the line drawings
	CDigitize pDg;
	if (
		(dig.totCurve > 0 || digMarker.totCurve > 0) && !draw.red.isReduced() &&
		!(dig.transYShift == 0.f && dig.transYMultFactor == 1.f)
		) {
//		float yminRound = pDg.getDigYMin(&dig);
		float yminRound = dig.getDigYMin();
		float ymax = dig.getDigYMax();
		//yminRound = MIN(yminRound, pDg.getDigYMin(&digMarker));
		yminRound = MIN(yminRound, digMarker.getDigYMin());
		ymax = MAX(ymax, digMarker.getDigYMax());
		float ytickRound = getTickRounded(yminRound, ymax, 1, 10, cd.coord.getYTick());

		yminRound = (float)niceNumMinMax((double)yminRound, true);
		oldColor = pDC->SetTextColor(GREEN);
		double mul = cd.coord.getDefDisplayAdjust(pDC);
		int ideltx = (int)(-130 * mul);
		y = yminRound;
		do
		{
			double yPrintedValue = (dig.transIsRevYAxis) ? -y : y;
			tick[0] = cd.coord.mm_coord(cd.coord.X2(), 
				(yPrintedValue*dig.transYMultFactor + dig.transYShift));
			tick[1].x = tick[0].x + (long)(1.5*ideltx);
			tick[1].y = tick[0].y;

			if (ytickRound < 0.1) tStr.Format(_T("%1.2f"), myFloat(y, 2));
			else if (ytickRound < 1.) tStr.Format(_T("%1.1f"), myFloat(y, 1));
			else tStr.Format(_T("%d"), (int)y);
			countS = tStr.GetLength();

			if (y >= yminRound && y <= ymax) {
				pOldPen = pDC->SelectObject(&thinPen);
				pDC->Polyline(tick, 2);
				pDC->SelectObject(pOldPen);

				if (y == (int)(y*0.1) * 10) {
					oldFont = pDC->SelectObject(&fontN);
					pDC->TextOut(
						(LONG)(tick[1].x - 4 * cd.coord.device2Logical - logFontNum.lfWidth*countS),
						tick[0].y - logFontNum.lfHeight / 2,
						tStr);
					pDC->SelectObject(oldFont);
				}
			}
			y += ytickRound;
		} while (y <= ymax);	  //Finish drawing yTicks. 
		pDC->SetTextColor(oldColor);
	} // if myfloat2






	// label for the X-axis
	if (draw.strXLabelOverwrite.IsEmpty()) {
		if (cd.coord.drawmode == 10) {
			tStr = _T("Velocity");
			tStr += _T(" (km/s)");
		}
		else if (cd.coord.drawmode == 6)
			tStr = _T("Trace");
		else {
			if (cd.coord.isOffsetDisplay())
				tStr = _T("Offset");
			else
				tStr = _T("Distance");
			tStr += _T(" (km)");
		}
	}
	else {
		tStr = draw.strXLabelOverwrite;
	}
	oldFont = pDC->SelectObject(&font);
	oldBkMode = pDC->SetBkMode(OPAQUE);
	//	pDC->DrawText(tstr, &rect, DT_CENTER|DT_BOTTOM|DT_SINGLELINE);

	//testing line
	//pDC->TextOut(
	//	(cd.coord.viewLogicalTotal.right - tStr.GetLength()*logFont.lfWidth) / 2,
	//	cd.coord.viewLogicalTotal.bottom - logFont.lfHeight*4 + cd.coord.getDeviceResAdjust(pDC, 2),
	//	tStr, tStr.GetLength());


	pDC->TextOut(
		(cd.coord.viewLogicalTotal.right - tStr.GetLength()*logFont.lfWidth) / 2,
		cd.coord.viewLogicalTotal.bottom - logFont.lfHeight + cd.coord.getDeviceResAdjust(pDC, 2),
		tStr, tStr.GetLength());


	pDC->SetBkMode(oldBkMode);
	pDC->SelectObject(oldFont);
	pDC->SetTextColor(oldColor);




	// finally, print out the title, and segy/vel names in the top left side 
	oldFont = pDC->SelectObject(&fontNumSmall);
	int jpos = 1;



	// print segy file if any
	tStr = BLANK;
	CString fPrint = (cd.coord.isTimeDomain()) ? draw.timeSecName : draw.depthSecName;
	if (fPrint.IsEmpty())  fPrint = bmp24.bmpName;
	if (!fPrint.IsEmpty()) {
		CString tStr2;
		tStr += GetBaseFileName(fPrint);
		tStr += _T(".");
		if (fabs(draw.distShift) > 0.f && cd.coord.isDistanceDisplay) {
			// we need to print the xmin and xmax before the dist shifting
			tStr2.Format(_T("(%8.3f ~ %8.3f km: xmin,xmax before X-reposition)"), cd.coord.X1() - draw.distShift,
				cd.coord.X2() - draw.distShift);
		}
		tStr += GetFileExtension(fPrint) + tStr2;
	}

	// now print out the date of work
	oldFont = pDC->SelectObject(&fontNumSmall);
	CTime theTime = CTime::GetCurrentTime();
	tStr.Format(_T("%s; %s "), tStr, theTime.Format("%H:%M %B %d, %Y"));
	pDC->TextOut(
		cd.coord.viewLogicalTotal.right - tStr.GetLength() * logFontNumS.lfWidth - cd.coord.getDeviceResAdjust(pDC, 2),
		cd.coord.viewLogicalTotal.bottom - logFontNumS.lfHeight - cd.coord.getDeviceResAdjust(pDC, 2),
		tStr, tStr.GetLength());
	pDC->SelectObject(oldFont);


	//pDC->TextOut(cd.coord.logicalAxes.left, jpos, tStr, tStr.GetLength());
	//jpos += logFontNumS.lfHeight + cd.coord.getDeviceResAdjust(pDC, 1);
	//pDC->SelectObject(oldFont);


	if (!draw.plotTitle.Trim().IsEmpty()) {
		oldFont = pDC->SelectObject(&fontH);
		pDC->TextOut((cd.coord.viewLogicalTotal.right - draw.plotTitle.GetLength()*logFontH.lfWidth) / 2,
			2, draw.plotTitle, draw.plotTitle.GetLength());
		pDC->SelectObject(oldFont);
	}


	font.DeleteObject();
	fontH.DeleteObject();
	fontVertical.DeleteObject();
	fontHSmall.DeleteObject();
	fontN.DeleteObject();
	fontNumSmall.DeleteObject();
}


void CSeisWideDoc::OnToolbarSavev()
{
	CString tStr;
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	if (!cd.coord.isModelingMode() || velMod.ncont < 2) {
		tStr.Format(_T("Only when a valid model is displayed, can it save to file."));
		pFrame->myCaption(tStr);
		return;
	}

	float xShot = CCoords::isXShotDefined(tx.xShotRay)
		? tx.xShotRay
		: (float)cd.coord.xmin;

	// Model2Flat() operation
	if (draw.ncontFlatten > 0) {
		velMod.setHorizonFlat2Model(draw.ncontFlatten, xShot, cd.coord.isTimeDomain());
	}

	//This tells OnDraw() not to initiate velocity arrays when refreshing screen next time.
	CVelMod vm;
	if (vm.saveModelAs(&velMod, velMod.velSecName, velColor.dz, cd.coord.isTimeDomain(), 3)) {
		//now update the velFile status so that DrawVel() would not complain that another process has changed the model file.
		//CFile::GetStatus( velMod.velSecName, draw.velFileStatus ); // static function
		tStr.Format(_T("'%s' saved successfully."), getFileNameOnly(velMod.velSecName));
		pFrame->myCaption(tStr);
	}
	else {
		tStr.Format(_T("'%s' failed to save."), getFileNameOnly(velMod.velSecName));
		pFrame->myCaption(tStr);
	}

	// undo the Model2Flat() operation
	if (draw.ncontFlatten > 0) {
		velMod.setHorizonModel2Flat(draw.ncontFlatten, xShot);
	}

}



void CSeisWideDoc::OnToolbarSaveasv()
{
	CString tStr;
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	if (!cd.coord.isModelingMode() && !velMod.velSecName.IsEmpty()) {
		// we want to prevent saving a valid model when not displaying it. 
		// But we also want to always save a newly created model without any names yet
		tStr.Format(_T("Only when a valid model is displayed, can it save to file."));
		pFrame->myCaption(tStr);
		return;
	}

	if (velMod.velSecName.IsEmpty()) {
		// if there is no path info in f, we need to allocate it
		TCHAR curDir[_MAX_PATH];
		GetCurrentDirectory(_MAX_PATH, curDir);
		velMod.velSecName = CString(curDir) + _T("\\newModel.vxml");
	}
	BOOL isViewXML = TRUE; // I want to encourage using VXML format, so I do not make it static any more.
	static CString metaTitle = BLANK;
	static CString metaCruise = BLANK;
	static CString metaProcessor = BLANK;
	static CString metaCompany = BLANK;
	if (!velMod.deploys[0].metaTitle.IsEmpty()) 
		metaTitle = velMod.deploys[0].metaTitle;
	if (!velMod.metaCruise.IsEmpty()) metaCruise = velMod.metaCruise;
	if (!velMod.metaProcessor.IsEmpty()) metaProcessor = velMod.metaProcessor;
	if (!velMod.metaCompany.IsEmpty()) metaCompany = velMod.metaCompany;

	CString newName;
	CdlgNewVelFile dlg;
	tStr = GetFileExtension(velMod.velSecName);
	if (tStr.IsEmpty())
		velMod.velSecName = SetFileExtension(velMod.velSecName, _T("vxml"));
//	dlg.m_velNewFileName = getFileNameAppend(velMod.velSecName, BLANK);
	dlg.m_velNewFileName = velMod.velSecName;
	dlg.m_title = metaTitle;
	dlg.m_cruise = metaCruise;

	if (metaProcessor.IsEmpty()) {
		CLicenseCheck ls;
		if (ls.parseLicenseFile2()) {
			// strLicenseName example: Deping Chian, Chian Consulting Inc
			CStringArray *sArr = CString2LinesByComma(ls.licenseStruct.strLicenseName);
			metaProcessor = sArr->ElementAt(0);
			if (metaCompany.IsEmpty() && sArr->GetCount() > 1) {
				metaCompany = sArr->ElementAt(1);
			}
			sArr->RemoveAll();
			delete sArr;
		}
	}
	dlg.m_author = metaProcessor;
	dlg.m_company = metaCompany;
	CTime curTime = CTime::GetCurrentTime();
	velMod.metaDate = dateTimeToCString(curTime);
	dlg.m_date = velMod.metaDate;
	if (velMod.deploys[0].deployDist == ERRORVAL) velMod.deploys[0].deployDist = tx.xShotRay;
	dlg.m_deployDist = velMod.deploys[0].deployDist;
	dlg.m_deployDepth = velMod.deploys[0].deployDepth;
	dlg.m_deployLat = velMod.deploys[0].deployLatLong[0];
	dlg.m_deployLong = velMod.deploys[0].deployLatLong[1];
	dlg.m_startDist = (float)velMod.deploys[0].startDist;
	if (dlg.m_startDist == ERRORVAL) dlg.m_startDist = (float)velMod.getXmin();
	dlg.m_startLat = velMod.deploys[0].startLatLong[0];
	dlg.m_startLong = velMod.deploys[0].startLatLong[1];
	dlg.m_endDist = (float)velMod.deploys[0].endDist;
	if (dlg.m_endDist == ERRORVAL) dlg.m_endDist = (float)velMod.getXmax();
	dlg.m_endLat = velMod.deploys[0].endLatLong[0];
	dlg.m_endLong = velMod.deploys[0].endLatLong[1];

	dlg.m_wellTitle = velMod.wells[0].title;
	dlg.m_wellDist = velMod.wells[0].wellDist;
	// dlg.m_wellDist = cd.coord.isMinusXShot ? dlg.m_deployDist - 8.f : dlg.m_deployDist + 8.f;
	// note: tx.xShot  is frequently used in raytracing as a source, and is defied in CRayHelper. 
	//       velMod.wellDist is used in .vxml model file. They are usually the same, but cannot replace each other
	//       partly since one model can have several pseudo-wells. 
	//       But for sonobuoys, usually only 1 pseudo-well is meaningful.

	dlg.m_wellLat = velMod.wells[0].wellLatLong[0];
	dlg.m_wellLong = velMod.wells[0].wellLatLong[1];

	// these are for internal calculation only
	dlg.m_secName = draw.timeSecName;
	dlg.m_xShift = draw.distShift;
	dlg.m_velm = &velMod;
	dlg.m_isViewXml = isViewXML;
	
	dlg.m_maxHorizonValid = (velMod.ncontMaxConstrained == 0) ?
		velMod.ncont - 1
		:
		velMod.ncontMaxConstrained;
	dlg.m_isVelBelowValid = velMod.isVelBelowValid;
	dlg.m_isNoNodeNav = velMod.isNoNodeNav;
	dlg.m_velFormat = 4; // we now encourage vxml format

	if (dlg.DoModal() == IDOK) {
		newName = dlg.m_velNewFileName;
		draw.velFormat = dlg.m_velFormat;

		// optional; only for the .vxml format
		metaTitle = velMod.deploys[0].metaTitle = dlg.m_title;
		metaCruise = velMod.metaCruise = dlg.m_cruise;
		metaProcessor = velMod.metaProcessor = dlg.m_author;
		metaCompany = velMod.metaCompany = dlg.m_company;
		velMod.metaDate = dlg.m_date;

		// formatting the various longitudes
		if (dlg.m_deployLong != ERRORVAL) {
			if (dlg.m_deployLong > 180.f) dlg.m_deployLong -= 360.f;
			else if (dlg.m_deployLong < -180.f) dlg.m_deployLong += 360.f;
		}
		if (dlg.m_startLong != ERRORVAL) {
			if (dlg.m_startLong > 180.f) dlg.m_startLong -= 360.f;
			else if (dlg.m_startLong < -180.f) dlg.m_startLong += 360.f;
		}
		if (dlg.m_endLong != ERRORVAL) {
			if (dlg.m_endLong > 180.f) dlg.m_endLong -= 360.f;
			else if (dlg.m_endLong < -180.f) dlg.m_endLong += 360.f;
		}
		if (dlg.m_wellLong != ERRORVAL) {
			if (dlg.m_wellLong > 180.f) dlg.m_wellLong -= 360.f;
			else if (dlg.m_wellLong < -180.f) dlg.m_wellLong += 360.f;
		}

		tx.xShotRay = (float)dlg.m_deployDist;

		velMod.deploys[0].deployDist = dlg.m_deployDist;
		velMod.deploys[0].deployDepth = dlg.m_deployDepth;
		velMod.deploys[0].deployLatLong[0] = (float)dlg.m_deployLat;
		velMod.deploys[0].deployLatLong[1] = (float)dlg.m_deployLong;
		velMod.deploys[0].startDist = (float)dlg.m_startDist;
		velMod.deploys[0].startLatLong[0] = (float)dlg.m_startLat;
		velMod.deploys[0].startLatLong[1] = (float)dlg.m_startLong;
		velMod.deploys[0].endDist = (float)dlg.m_endDist;
		velMod.deploys[0].endLatLong[0] = (float)dlg.m_endLat;
		velMod.deploys[0].endLatLong[1] = (float)dlg.m_endLong;

		velMod.wells[0].title = dlg.m_wellTitle;
		velMod.wells[0].wellDist = (float)dlg.m_wellDist;
		velMod.wells[0].wellLatLong[0] = (float)dlg.m_wellLat;
		velMod.wells[0].wellLatLong[1] = (float)dlg.m_wellLong;
		isViewXML = dlg.m_isViewXml;

		velMod.ncontMaxConstrained = dlg.m_maxHorizonValid;
		velMod.isVelBelowValid = dlg.m_isVelBelowValid;
		velMod.isNoNodeNav = dlg.m_isNoNodeNav;


		draw.timeSecName = dlg.m_secName;
	}
	else return;
	// ;

	if (draw.velFormat == 4)
		newName = SetFileExtension(newName, _T("vxml"));

	CVelMod vm;
	if (draw.velFormat == 0 || draw.velFormat == 4)	 {
		if (GetFileExtension(newName).IsEmpty())
			newName = SetFileExtension(newName, _T("vxml"));

		CSegyMeta::segyHeadInit(draw.timeSecName, &head);
		SegyWrapper sw(draw.timeSecName);
		sw.m_isHeadersOnly = true;
		if (sw.open(&head, 0)) {
			for (int i = 0; i < TX_SHOTS_MAX; i++) {
				if (velMod.deploys[i].deployDist == ERRORVAL) break;
				if (sw.headRead.isStartEndSwapped(-draw.distShift+ velMod.deploys[i].startDist, 
					-draw.distShift+velMod.deploys[i].endDist)) {
					tStr.Format(_T("Start-end positions (%g, %g km) appear swapped compairing with deployment at %g km. Do you want to swap back?"),
						velMod.deploys[i].startDist, velMod.deploys[i].endDist, tx.xShotRay);
					if (AfxMessageBox(tStr, MB_YESNO | MB_ICONINFORMATION | MB_ICONQUESTION) == IDYES)
						velMod.deploys[i].swapStartEnd();
				}
			}
			sw.freeSegyArray(&sw.headRead);
		}

		//if (velMod.ncont > 4 && velMod.nzed[3] == 13) {
		//	velMod.xm[11][3] == -11.16217f;
		//	velMod.zm[11][3] == 5.499304f;
		//	velMod.tm[11][3] == 5.928579f;
		//}

		// Model2Flat() operation
		float xShot = CCoords::isXShotDefined(tx.xShotRay)
			? tx.xShotRay
			: (float)cd.coord.xmin;
		if (draw.ncontFlatten > 0) {
			velMod.setHorizonFlat2Model(draw.ncontFlatten, xShot, cd.coord.isTimeDomain());
		}

		if (vm.saveModelAs(&velMod, newName, velColor.dz, cd.coord.isTimeDomain(), 3)) {
			//now update the velFile status so that DrawVel() would not complain that another process has changed the model file.
			//CFile::GetStatus( velMod.velSecName, draw.velFileStatus ); // static function
			tStr.Format(_T("Model saved successfully."));
			if (velMod.velSecName != newName) {
				velMod.velSecName = newName;  // file name updated only when save success
				SetModifiedFlag();
			}
		}
		else
			tStr.Format(_T("Model failed to save."));

		// undo the Model2Flat() operation
		if (draw.ncontFlatten > 0) {
			velMod.setHorizonModel2Flat(draw.ncontFlatten, xShot);
		}

		pFrame->myCaption(tStr);
	}
	else {
		// now we start to save the model in ascii format. 
		if (cd.coord.isTimeDomain())
			vm.myModel_TWTT2Depth(&velMod, velColor.dz);

		if (draw.velFormat == 1) {
			newName = SetFileExtension(newName, _T("in"));
			vm.saveModelZelt4(&velMod, newName);
		}
		else if (draw.velFormat == 2) {
			newName = SetFileExtension(newName, _T("in"));
			vm.saveModelZelt3(&velMod, newName);
		}
		else if (draw.velFormat == 3) {
			newName = SetFileExtension(newName, _T("in"));
			vm.saveModelZelt2(&velMod, newName);
		}
	}

	if (isViewXML && draw.velFormat != 0)
		showFileInNotePad(newName);


}

void CSeisWideDoc::OnModelFlipmod()
{
	if (cd.coord.drawmode < 2 || (cd.coord.drawmode>4 && cd.coord.drawmode != 9) || velMod.ncont < 2)
	{
		AfxMessageBox(_T("Please show a valid model first."), MB_ICONQUESTION);
		return;
	}

	CString newName = getFileNameAppend(velMod.velSecName, _T("Mod"));
	newName = SetFileExtension(newName, _T("vxml")); // we now promote .vxml format

	//new file dialog.
	CFileDialog dlg(FALSE, newName, _T("*.vxml;*.bin"),
		OFN_HIDEREADONLY | OFN_EXPLORER,
		_T("File name for new model (*.vxml)|*.vxml|Older format (*.bin)|*.bin|"));
	//	dlg.m_ofn.lpstrTitle = _T("Each shot number in one line please";
	if (dlg.DoModal() == IDOK)
		velMod.velSecName = dlg.GetPathName();
	else
		return;

	CVelMod vm;

	//first shift data points.
	float xshift = (float)(velMod.getXmin() + velMod.getXmax());
	int icont, j;

	for (icont = 0; icont < velMod.ncont; icont++)
		for (j = 0; j < velMod.nzed[icont]; j++)
			velMod.xm[j][icont] = xshift - velMod.xm[j][icont];

	for (icont = 0; icont < velMod.ncont - 1; icont++)
		for (j = 0; j < velMod.nvel[icont][0]; j++)
			velMod.xvel[j][icont][0] = xshift - velMod.xvel[j][icont][0];

	for (icont = 0; icont < velMod.ncont - 1; icont++)
		for (j = 0; j < velMod.nvel[icont][1]; j++)
			velMod.xvel[j][icont][1] = xshift - velMod.xvel[j][icont][1];

	//now all points have to be flipped....1st becomes last and last becomes 1st.
	float* a;
	int n;
	for (icont = 0; icont < velMod.ncont; icont++) {
		n = velMod.nzed[icont];
		a = (float *)ealloc1float(n);
		for (j = 0; j < n; j++)
			a[j] = velMod.xm[n - j - 1][icont];
		for (j = 0; j < n; j++)
			velMod.xm[j][icont] = a[j];


		if (cd.coord.drawmode != 9) {
			for (j = 0; j < n; j++)
				a[j] = velMod.zm[n - j - 1][icont];
			for (j = 0; j < n; j++) {
				velMod.zm[j][icont] = a[j];
			}
		}
		else {
			for (j = 0; j < n; j++)
				a[j] = velMod.tm[n - j - 1][icont];
			for (j = 0; j < n; j++) {
				velMod.tm[j][icont] = a[j];
			}
		}



		free1float(a);
	}

	for (icont = 0; icont < velMod.ncont - 1; icont++) {
		n = velMod.nvel[icont][0];
		a = (float *)ealloc1float(n);
		for (j = 0; j < n; j++)
			a[j] = velMod.xvel[n - j - 1][icont][0];
		for (j = 0; j < n; j++)
			velMod.xvel[j][icont][0] = a[j];
		for (j = 0; j < n; j++)
			a[j] = velMod.vf[n - j - 1][icont][0];
		for (j = 0; j < n; j++)
			velMod.vf[j][icont][0] = a[j];
		free1float(a);

		n = velMod.nvel[icont][1];
		a = (float *)ealloc1float(n);
		for (j = 0; j < n; j++)
			a[j] = velMod.xvel[n - j - 1][icont][1];
		for (j = 0; j < n; j++)
			velMod.xvel[j][icont][1] = a[j];
		for (j = 0; j < n; j++)
			a[j] = velMod.vf[n - j - 1][icont][1];
		for (j = 0; j < n; j++)
			velMod.vf[j][icont][1] = a[j];
		free1float(a);
	}

	// now need to swap the latlong for velMod.xmin and velMod.xmax -- disabled: because even after swap the model, the start-end can still be the same.
	//for (j = 0; j < TX_SHOTS_MAX; j++) {
	//	if (velMod.deploys[j].deployDist == ERRORVAL) break;
	//	velMod.deploys[j].swapStartEnd();
	//}

	// and also swap pseudoWell and remove its latlong
	for (j = 0; j < TX_SHOTS_MAX; j++) {
		if (velMod.wells[j].wellDist == ERRORVAL) break;
		velMod.wells[j].wellDist = velMod.getXmax() - velMod.wells[j].wellDist;
		velMod.wells[j].wellLatLong[0] = velMod.wells[j].wellLatLong[1] = ERRORVAL;
	}


	cd.coord.xmin = velMod.getXmin();
	cd.coord.xmax = velMod.getXmax();
	cd.coord.xTick = (cd.coord.xmax - cd.coord.xmin)*0.1;
	if (cd.coord.drawmode == 9)
		vm.myModel_TWTT2Depth(&velMod, velColor.dz);
	OnToolbarSavev();  // finally save it
	//velMod.velSecOld = BLANK;
	//This tells OnDraw() not to initiate velocity arrays when refreshing screen next time.

	draw.isSameDataDisplay = FALSE; //indicate display has been changed and will re-load all data in OnDraw().
	SetModifiedFlag();
	UpdateAllViews(NULL);

}

void CSeisWideDoc::OnModelShiftxz()
{
	CString tStr;

	// TODO: Add your command handler code here
	if (cd.coord.drawmode < 2 || (cd.coord.drawmode>4 && cd.coord.drawmode != 9) || velMod.ncont < 2) {
		AfxMessageBox(_T("Please show a valid model first."), MB_ICONQUESTION);
		return;
	}

	float dx = 0.f, dz = 0.f;
	CdlgDigitizeShift dlg0;
	if (dlg0.DoModal() == IDOK) {
		dx = dlg0.m_dx;
		dz = dlg0.m_dt;
	}
	else return;
	delete dlg0;

	CVelMod vm;

	//new file dialog.
	CFileDialog dlg(FALSE, velMod.velSecName, _T("*.vxml;*.bin"),
		OFN_HIDEREADONLY | OFN_EXPLORER,
		_T("File name for new model (*.vxml)|*.vxml|Older format (*.bin)|*.bin|"));
	//CFileDialog dlg( FALSE,BLANK,_T("*.bin"),
	//	OFN_HIDEREADONLY|OFN_EXPLORER,
	//	_T("File name for the new model (*.bin)|*.bin|"));
	//	dlg.m_ofn.lpstrTitle = _T("Each shot number in one line please";
	if (dlg.DoModal() != IDOK)
		return;


	CVelMod::myModelShiftX(&velMod, dx);

	int icont, j;
	for (icont = 0; icont < velMod.ncont; icont++)
		for (j = 0; j < velMod.nzed[icont]; j++)  {
			// we only shift zm  when icont>0
			if (icont > 0) {
				if (cd.coord.drawmode != 9)
					velMod.zm[j][icont] += dz;
				else
					velMod.tm[j][icont] += dz;
			}
		}

	if (cd.coord.drawmode == 9)
		vm.myModel_TWTT2Depth(&velMod, velColor.dz);

	if (cd.coord.xmin > velMod.getXmin())
		cd.coord.xmin = velMod.getXmin();
	if (cd.coord.xmax < velMod.getXmax())
		cd.coord.xmax = velMod.getXmax();


	if (vm.saveModelAs(&velMod, dlg.GetPathName(), velColor.dz, cd.coord.isTimeDomain())) {
		SetModifiedFlag();
		UpdateAllViews(NULL);
	}
}

void CSeisWideDoc::OnModelingMoveboundary()
{
	// Oct 24, 2004  deping
	if (cd.coord.drawmode < 2 || (cd.coord.drawmode>4 && cd.coord.drawmode != 9)) {
		AfxMessageBox(_T("Please display the model first"), MB_ICONQUESTION);
		return;
	}

	if (draw.iLayerFocus < 0) {
		AfxMessageBox(_T("Please select a boundary to shift."), MB_ICONQUESTION);
		return;
	}

	static float xmin = 0.f;
	static float xmax = 0.f;
	static float dz = 0.f; // make this static is good


	CdlgModelShiftBoundary dlg;
	dlg.m_xmin = xmin;
	dlg.m_xmax = xmax;
	dlg.m_zinc = dz;
	if (dlg.DoModal() == IDOK) {
		xmin = dlg.m_xmin;
		xmax = dlg.m_xmax;
		dz = dlg.m_zinc;
	}
	else return;
	delete dlg;

	CVelMod vm;


	BOOL isCompleteBoundary = isFloatEqual(xmax, xmin);

	int icont = draw.iLayerFocus;

	for (int j = 0; j < velMod.nzed[icont]; j++)  {
		float x = velMod.xm[j][icont];
		if (isCompleteBoundary || x >= xmin && x <= xmax) {
			if (cd.coord.drawmode != 9)
				velMod.zm[j][icont] += dz;
			else {
				velMod.tm[j][icont] += dz;
			}
		}
	}
	if (cd.coord.drawmode == 9)
		vm.myModel_TWTT2Depth(&velMod, velColor.dz);

	draw.modelUpInc = dz;
	if (fabs(draw.modelUpInc) < 0.001f) draw.modelUpInc = 0.001f;
	else
		if (fabs(draw.modelUpInc) > 0.2f) draw.modelUpInc = 0.2f;


	// OnToolbarSavev();
	//velMod.velSecOld = BLANK;
	//This tells OnDraw() not to initiate velocity arrays when refreshing screen next time.

	draw.isSameDataDisplay = FALSE; //indicate display has been changed and will re-load all data in OnDraw().
	SetModifiedFlag();
	UpdateAllViews(NULL);

}

void CSeisWideDoc::OnModelingAddsineshape()
{
	// Sept 15, 2009  deping
	if (cd.coord.drawmode < 2 || cd.coord.drawmode>4) {
		AfxMessageBox(_T("Please display the model first"), MB_ICONQUESTION);
		return;
	}

	if (cd.coord.drawmode < 2 || cd.coord.drawmode>4 || velMod.ncont < 2) {
		AfxMessageBox(_T("Please show a valid model first."), MB_ICONQUESTION);
		return;
	}

	if (draw.iLayerFocus < 1 || draw.iLayerFocus >= velMod.ncont - 1) {
		AfxMessageBox(_T("Please select an inside boundary to add sine wave modulation."), MB_ICONQUESTION);
		return;
	}


	float xmin = velMod.xm[0][0];  // this is model limit
	float xmax = velMod.xm[velMod.nzed[0] - 1][0];

	static float xmin_modulate = (float)cd.coord.X1();  // desired limits for modulation
	static float xmax_modulate = (float)cd.coord.X2();
	static float lumda = (xmax_modulate - xmin_modulate) * 0.1f;
	static float amp = lumda*0.05f;
	CdlgSineModulate dlg;
	dlg.m_lumda = lumda;
	dlg.m_modDepth = amp;
	dlg.m_xmin = xmin_modulate;
	dlg.m_xmax = xmax_modulate;
	if (dlg.DoModal() == IDOK)
	{
		lumda = dlg.m_lumda;
		amp = dlg.m_modDepth;
		xmin_modulate = dlg.m_xmin;
		xmax_modulate = dlg.m_xmax;
	}
	else return;
	delete dlg;

	int icont = draw.iLayerFocus;

	CVelMod::VELMOD velMod2;
	CVelMod vm;
	//vm.velModSetArrays(&velMod2);

	// first, we just copy the left side to velMod2
	velMod2.nzed[icont] = 0;
	for (int j = 0; j < velMod.nzed[icont]; j++)  {
		if (velMod.xm[j][icont] >= xmin_modulate) {
			// we do not want further
			break;
		}
		velMod2.xm[j][icont] = velMod.xm[j][icont];
		velMod2.zm[j][icont] = velMod.zm[j][icont];
		velMod2.nzed[icont]++;
	}

	// do the modulation for this boundary icont
	float dx = lumda * 0.1f;
	int i = 0;
	bool isLastPoint = false;
	while (!isLastPoint)  {
		float x2 = xmin_modulate + (float)i*dx;
		if (x2 >= xmax_modulate) {
			x2 = xmax_modulate;
			isLastPoint = true;
		}
		int i2 = velMod2.nzed[icont];

		for (int j = 0; j < velMod.nzed[icont] - 1; j++)  {
			float xleft = velMod.xm[j][icont];
			float xright = velMod.xm[j + 1][icont];
			if (xright == xleft) continue;
			float zleft = velMod.zm[j][icont];
			float zright = velMod.zm[j + 1][icont];
			if (x2 >= xleft && x2 <= xright) {
				velMod2.xm[i2][icont] = x2;
				velMod2.zm[i2][icont] = zleft + (zright - zleft)*(x2 - xleft) / (xright - xleft);
				break;
			}
		} // for j

		// modulate here
		velMod2.zm[i2][icont] += amp * (float)sin(2.f*PI*x2 / lumda);
		velMod2.nzed[icont]++; // 1 more point successfully added to velMod2

		i++;
	} // while

	// now, we just copy the right side to velMod2
	for (int j = 0; j < velMod.nzed[icont]; j++)  {
		if (velMod2.xm[j][icont] <= xmax_modulate){
			continue;
		}
		int i2 = velMod2.nzed[icont];
		velMod2.xm[i2][icont] = velMod.xm[j][icont];
		velMod2.zm[i2][icont] = velMod.zm[j][icont];
		velMod2.nzed[icont]++;
	}


	// now copy the boundary back to velMod struct
	velMod.nzed[icont] = velMod2.nzed[icont];
	for (int j = 0; j < velMod2.nzed[icont]; j++)  {
		velMod.xm[j][icont] = velMod2.xm[j][icont];
		velMod.zm[j][icont] = velMod2.zm[j][icont];
	}
	//vm.velModFreeArrays(&velMod2);

	// make sure the boundary does not intercect with adjacent boundaries
	for (int i = 0; i < velMod.nzed[icont]; i++)  {
		float x = velMod.xm[i][icont];

		// point [x,z] should not exceed the top limit
		for (int j = 0; j < velMod.nzed[icont - 1] - 1; j++)  {
			float xleft = velMod.xm[j][icont - 1];
			float xright = velMod.xm[j + 1][icont - 1];
			if (xright == xleft) continue;
			float zleft = velMod.zm[j][icont - 1];
			float zright = velMod.zm[j + 1][icont - 1];
			if (x >= xleft && x <= xright) {
				float ztop = zleft + (zright - zleft)*(x - xleft) / (xright - xleft);
				if (velMod.zm[i][icont] < ztop) {
					velMod.zm[i][icont] = ztop + 0.00001f;
				}
				break;
			}
		} // for j

		// point [x,z] should not exceed the bottom limit
		for (int j = 0; j < velMod.nzed[icont + 1] - 1; j++)  {
			float xleft = velMod.xm[j][icont + 1];
			float xright = velMod.xm[j + 1][icont + 1];
			if (xright == xleft) continue;
			float zleft = velMod.zm[j][icont + 1];
			float zright = velMod.zm[j + 1][icont + 1];
			if (x >= xleft && x <= xright) {
				float zbot = zleft + (zright - zleft)*(x - xleft) / (xright - xleft);
				if (velMod.zm[i][icont] > zbot) velMod.zm[i][icont] = zbot - 0.00001f;
				break;
			}
		} // for j
	} // for i



	CString tempStr = velMod.velSecName;
	tempStr.MakeLower();
	velMod.velSecName = getFileNameAppend(tempStr, _T("_sine"));
	OnToolbarSavev();

	draw.isSameDataDisplay = FALSE; //indicate display has been changed and will re-load all data in OnDraw().
	SetModifiedFlag();
	UpdateAllViews(NULL);
}


// note: if your model is already shifted in displaying, make sure you deduct it from xOld and xNew first
//   this function is for model editting only. It does not handle digitizing functions!
// Return true if the model is changed. FALSE if the model is not changed
BOOL CSeisWideDoc::MyMouseClickModelingTimeMode9(CVelMod::VELMOD *velm, SEI_QUAD* pQuad)
{
	if (!cd.coord.isTimeDomain()) return FALSE;
	if (!cd.coord.isModelingMode()) return FALSE;
	// The following mouse manipulation is only for editting a model in TWTT domain!

	double xOld = pQuad->x1;
	double yOld = pQuad->y1; 
	double xNew = pQuad->x2; 
	double yNew = pQuad->y2;
	if (xNew < velm->getXmin()) {
		xNew = velm->getXmin();
	}
	else if (xNew > velm->getXmax()) {
		xNew = velm->getXmax();
	}

	CString tStr;
	CPoint p, selPoint;
	int k, icont, jSel;
	double tempv;
	double z1[MOD_LAYER_MAX];
	CVelMod vm;
	CVelMod::VELMOD_X modX;
	SEI_PAIR pNew;
	pNew.set(xNew, yNew);

	SEI_PAIR pOld;
	pOld.set(xOld, yOld);

	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	CSeisWideApp* pSeiApp = (CSeisWideApp*)AfxGetApp();
	if (pFrame->statMain.pick == 1 && draw.nodeMode == 1)  {
		if (xNew < cd.coord.X1() || xNew > cd.coord.X2()
			||
			yNew < cd.coord.Y1() || yNew > cd.coord.Y2()) 
			draw.iLayerFocus = -1;
		else
			draw.iLayerFocus = vm.getClosestLayerNum(velm, pNew, cd.coord.isTimeDomain());
		return TRUE;
	}  //End pick a boundary.

	//pick a layer.
	if (pFrame->statMain.pick == 1 && draw.nodeMode == 2)  {
		draw.iLayerFocus = -1;
		if (xNew < cd.coord.X1() || xNew > cd.coord.X2()
			||
			yNew < cd.coord.Y1() || yNew > cd.coord.Y2()) {
			draw.iLayerFocus = -1; 
			return TRUE;
		}

		for (icont = 0; icont < velm->ncont; icont++) {
			z1[icont] = -1.;
			for (int j = 0; j < velm->nzed[icont] - 1; j++) {
				if (xOld >= velm->xm[j][icont] && xOld <= velm->xm[j + 1][icont]) {
					z1[icont] = velm->tm[j][icont] +
						(velm->tm[j + 1][icont] - velm->tm[j][icont])*
						(xOld - velm->xm[j][icont]) /
						(velm->xm[j + 1][icont] - velm->xm[j][icont]);
					break;
				}
			}
			if (xOld >= velm->getXmin() && xOld < velm->getXmax() && z1[icont] < 0)  {
				// z1[icont] can be negative
				//tStr.Format(_T("x,x0,x1: %g %g %g"), &xOld, &velm->xm[0][icont], &velm->xm[1][icont]);
				//AfxMessageBox(tStr);
				//return FALSE;
			}
		}
		for (icont = 0; icont < velm->ncont - 1; icont++) {
			if (yOld >= z1[icont] && yOld <= z1[icont + 1]) {
				draw.iLayerFocus = icont;
				if (yOld < cd.coord.Y1())
					draw.isTopBound = true;
				else if (yOld > cd.coord.Y2())
					draw.isTopBound = false;
				else if (fabs(yOld - z1[icont]) < fabs(yOld - z1[icont + 1]))
					draw.isTopBound = true;
				else
					draw.isTopBound = false;
				break;
			}
		}

		return TRUE;
	}  //End pick a layer.

	//Add a point for specified boundary (draw.iLayerFocus).
	if (pFrame->statMain.add == 1 && draw.nodeMode == 1)  {
		icont = draw.iLayerFocus;
		//jSel = vm.getPointIndexBeforeOnBoundary(velm, xNew, icont);
		//if (jSel < 0) return FALSE;
		if (vm.velModInsPoint(velm, icont, pNew, cd.coord.isTimeDomain())) {
			cd.coord.xMouse = xNew;
			cd.coord.yMouse = yNew;
			return TRUE;
		}
		else return FALSE;
	}	//End of add a node for specified boundary.

	//Add a point for specified layer (draw.iLayerFocus).
	//if draw.iTopBound=1, edit nodes  for its top bound, otherwise,
	//edit the layer's lower bound.
	//Need to consider: Low velocity layer not allowed.
	//One layer/boundary may have one point only (done).
	// static int anisotropy_layer0 = -1;
	velm->m_isConvert = true;
	double adepth0, adepth1, adepth2;
	if (pFrame->statMain.add == 1 && draw.nodeMode == 2) {
		// if(!isVisibleOrNot(xNew,yNew)) return FALSE;
		//First calculate the velocity at the clicked point.
		icont = draw.iLayerFocus;
		jSel = vm.getPointIndexBeforeOnLayer(velm, xNew, icont, draw.isTopBound, &tempv);
		if (jSel < 0) return FALSE;

		// note: in the UI, the user sees 1 meaning the first layer. But in programming, 0=the first layer
		CdlgLayerNodes dlg1;
		dlg1.m_layerNum = draw.isTopBound ? icont : icont + 1;
		//dlg1.m_layerX = (float)((int)(xNew * 100 + .5)*0.01);  //The float oper. reduce num of digits displayed.
		modX.dist = xNew;
		vm.initModX(velm, &modX, true, true, velColor.dz);
		dlg1.m_isTimeDomain = true;
		// double aDepth = (draw.isTopBound) ? modX.depthMod[icont] : modX.depthMod[icont + 1];
		//dlg1.m_layerY = (float)((int)(aDepth * 100 + .5)*0.01);  // m_layerY is in time domain. We need to convert it to depth
		dlg1.setLayerV(tempv); // (float)((int)(tempv * 100 + .5)*0.01);
		dlg1.m_isRegressionChecked = modX.isSedimentRegression(icont);
		CVelMod::getStringRegression(velm, dlg1.m_strRegression);
		dlg1.m_anisotropy = velm->anisotropy[icont];
		dlg1.m_anisotropy_layer0 = pFrame->psei->anisotropy_layer0 + 1;
		dlg1.m_modX = &modX;
		if (dlg1.DoModal() == IDOK) {
			velm->setSedimentRegression(icont, dlg1.m_isRegressionChecked);
			CVelMod::parseString2Regression2(velm, dlg1.m_strRegression);
			tempv = dlg1.getLayerV();
			pFrame->psei->anisotropy_layer0 = dlg1.m_anisotropy_layer0 - 1;
			if (pFrame->psei->anisotropy_layer0 > -1 && pFrame->psei->anisotropy_layer0 < icont) {
				// this means we need to interpolate for anisotropy for all the overlying layers below anisotropy_layer0
				modX.dist = xNew;
				vm.initModX(velm, &modX, true, true, velColor.dz);
				adepth2 = (modX.depthMod[icont] + modX.depthMod[icont + 1]) * 0.5;  // we know icont<velm->ncont
				adepth0 = (modX.depthMod[pFrame->psei->anisotropy_layer0] + modX.depthMod[pFrame->psei->anisotropy_layer0 + 1]) * 0.5;
				for (int j = pFrame->psei->anisotropy_layer0; j < icont; j++) {
					adepth1 = (modX.depthMod[j] + modX.depthMod[j + 1]) * 0.5;
					velm->anisotropy[j] = (adepth2 - adepth0)>0 ?
						dlg1.m_anisotropy * (float)((adepth1 - adepth0) / (adepth2 - adepth0))
						:
						dlg1.m_anisotropy;
				}
			}
			velm->anisotropy[icont] = dlg1.m_anisotropy;
		}
		else return FALSE;
		delete dlg1;

		if (vm.velModVelInsPoint(velm, draw.iLayerFocus, jSel + 1, draw.isTopBound, (float)xNew, (float)tempv)) {
			return TRUE;
		}
		else return FALSE;
	}	//End of add a node for specified layer.




	//Move boundary points.
	if (pFrame->statMain.move == 1 && draw.nodeMode == 1) {
		//		distOld = 200000.;
		icont = draw.iLayerFocus;
		jSel = vm.getPointIndexClosestOnBoundary(velm, pOld, icont, TRUE);
		if (jSel < 0) return FALSE;
		cd.coord.xMouse = xNew;	//Save points for Invalidate(FALSE).
		cd.coord.yMouse = yNew;
		if (jSel != 0 && jSel != (velm->nzed[icont] - 1)) {
			if (!cd.coord.isVisibleOrNot(xNew, yNew)) return FALSE;
			if (xNew < velm->xm[jSel - 1][icont] + 0.00001) return FALSE; //The model's resolution has to be 0.00001 km.
			if (xNew > velm->xm[jSel + 1][icont] - 0.00001) return FALSE; //The model's resolution has to be 0.00001 km.
		}
		else xNew = velm->xm[jSel][icont];  //left/right boundary points cann't change X values.

		if (pSeiApp->statWin.getControlPressed()) {
			if (jSel == 0) yNew = velm->tm[jSel + 1][icont];
			else yNew = velm->tm[jSel - 1][icont];
		}
		else if (jSel == velm->nzed[icont] - 1)
			pFrame->myCaption(_T("Use Ctrl key to flatten the segment"));

		//now make sure the point doesn't go above or below adjacent boundary.
		//to do this: (1) calculate Z for xNew of boundaries jSel-1 and jSel+1; (2) decide.
		modX.dist = xNew;
		vm.initModX(velm, &modX, true, true, velColor.dz);
		if ((icont > 0 && yNew < modX.timeMod[icont - 1]) || (icont<velm->ncont - 1 && yNew>modX.timeMod[icont + 1])) {
			// the new point is above another boundary
			tStr.Format(_T("You tried to merge a node to another boundary. Are you sure?"));
			if (AfxMessageBox(tStr, MB_YESNO | MB_ICONINFORMATION) == IDNO) return FALSE;
			if (!vm.velModInterceptPointMode9(velm, icont, jSel, pNew, cd.coord.isTimeDomain())) return FALSE;
		}
		else {
			velm->xm[jSel][icont] = (float)xNew;
			velm->tm[jSel][icont] = (float)yNew;
		}

		// now move all underlying nodes the same way as long as they are at the same point
		if (pSeiApp->statWin.isAPressed) {
			for (int i = icont + 1; i < velm->ncont; i++) {
				for (register int j = 0; j < velm->nzed[i]; j++) {
					if (fabs(velm->xm[jSel][icont] - velm->xm[j][i]) <= 0.00001f 
						&& fabs(velm->tm[jSel][icont] - velm->tm[j][i]) <= 0.00001f) {
						velm->xm[j][i] = (float)xNew;
						velm->tm[j][i] = (float)yNew;
					}
				}
			}
		}

		// after point moving, the nav values are invalid anymore
		velMod.longitude[jSel][icont] = ERRORVAL;
		velMod.latitude[jSel][icont] = ERRORVAL;
		return TRUE;
	}	//End moving boundary points.


	//Move  points defining a velocity layer.
	if (pFrame->statMain.move == 1 && draw.nodeMode == 2) {
		if (draw.iLayerFocus < 0) return FALSE;
		icont = draw.iLayerFocus;
		if (draw.isTopBound)	k = 0;
		else k = 1;

		icont = draw.iLayerFocus;

		// small fixes
		if (velm->nvel[icont][k]<1 || velm->nvel[icont][k]>MOD_LAYER_MAX - 2)
			velm->nvel[icont][k] = 2;

		jSel = -1;
		for (int j = 0; j<velm->nvel[icont][k] - 1; j++) {
			if (xOld >= velm->xvel[j][icont][k] && xOld <= velm->xvel[j + 1][icont][k]) {
				jSel = j;
				break;
			}
		}
		if (jSel < 0 || jSel>velm->nvel[icont][k] - 1) jSel = 0;
		if (fabs(xOld - velm->xvel[jSel][icont][k]) >
			fabs(xOld - velm->xvel[jSel + 1][icont][k])) jSel++;
		if (jSel < 0 || jSel>velm->nvel[icont][k] - 1) return FALSE;

		xOld = velm->xvel[jSel][icont][k];
		tempv = velm->vf[jSel][icont][k];
		//So the old point is at xOld, yOld in km, 
		//The new point is: xNew, yNew in km.

		// note: in the UI, the user sees 1 meaning the first layer. But in programming, 0=the first layer
	//	static BOOL isApply4All = false;
		CdlgLayerNodes dlg1;
		dlg1.m_layerNum = draw.isTopBound ? icont : icont + 1;
		modX.dist = xOld;
		vm.initModX(velm, &modX, true, true, velColor.dz);
		dlg1.m_modX = &modX;
		dlg1.m_isTimeDomain = true;
		dlg1.setLayerV(tempv);  // (float)((int)(tempv * 100000 + .5)*0.00001);
		dlg1.m_isRegressionChecked = modX.isSedimentRegression(icont);
		CVelMod::getStringRegression(velm, dlg1.m_strRegression);
		dlg1.m_apply4All = false;
		dlg1.m_anisotropy = velm->anisotropy[icont];
		dlg1.m_anisotropy_layer0 = pFrame->psei->anisotropy_layer0 + 1;

		if (dlg1.DoModal() == IDOK) {
			velm->setSedimentRegression(icont, dlg1.m_isRegressionChecked);
			CVelMod::parseString2Regression2(velm, dlg1.m_strRegression);
			tempv = dlg1.getLayerV();

		//	isApply4All = dlg1.m_apply4All;
			pFrame->psei->anisotropy_layer0 = dlg1.m_anisotropy_layer0 - 1;
			modX.dist = xOld;
			vm.initModX(velm, &modX, true, true, velColor.dz);
			if (dlg1.m_anisotropy == -1 && pFrame->psei->anisotropy_layer0 > -1 && pFrame->psei->anisotropy_layer0 < icont) {
				// this means we need to interpolate for anisotropy for all the overlying layers below anisotropy_layer0
				// interpolate using an empirical formula
				for (int j = pFrame->psei->anisotropy_layer0; j < icont; j++) {
					double vh = (modX.vTop[j] + modX.vBot[j]) * 0.5;
					velm->anisotropy[j] = (float)(1. - (0.393 + 0.74 * vh) / vh);
				}
			}
			else if (dlg1.m_anisotropy == 0.f && pFrame->psei->anisotropy_layer0 > -1 && pFrame->psei->anisotropy_layer0 < icont) {
				for (int j = pFrame->psei->anisotropy_layer0; j < icont; j++) {
					velm->anisotropy[j] = 0.f;
				}
			}

			// note: dlg1.m_anisotropy  can be  -1, 0, or >0
			if (dlg1.m_anisotropy == -1) {
				double vh = (modX.vTop[icont] + modX.vBot[icont]) * 0.5;
				dlg1.m_anisotropy = (float)(1. - (0.393 + 0.74 * vh) / vh);
			}
			velm->anisotropy[icont] = dlg1.m_anisotropy;
		}
		else return FALSE;

		if (dlg1.m_apply4All) {
			for (int j = 0; j < velm->nvel[icont][k]; j++) {
				velm->vf[j][icont][k] = (float)tempv;
			}
		} // if

		if (jSel == 0 || jSel == velm->nvel[icont][k] - 1) {
			velm->vf[jSel][icont][k] = (float)tempv;
		}
		else {
			if (xNew < velm->xvel[jSel - 1][icont][k] + 0.00001) return FALSE; //The model's resolution has to be 0.00001 km.
			if (xNew > velm->xvel[jSel + 1][icont][k] - 0.00001) return FALSE; //The model's resolution has to be 0.00001 km.
			velm->xvel[jSel][icont][k] = (float)xNew;
			velm->vf[jSel][icont][k] = (float)tempv;
		}
		return TRUE;
	} //End of moving layer points.


	//deleting boundary points.
	if (pFrame->statMain.remove == 1 && draw.nodeMode == 1) {
		//	distOld = 200000.;
		icont = draw.iLayerFocus;
		jSel = vm.getPointIndexClosestOnBoundary(velm, pNew, icont, TRUE);
		if (jSel < 0) return FALSE;
		cd.coord.xMouse = velm->xm[jSel][icont];
		cd.coord.yMouse = velm->tm[jSel][icont];

		if (pSeiApp->statWin.getShiftPressed()) {
			// we delete 3 consecutive points when shift key is pressed
			if (jSel - 1 > 0) velm->delPoint(icont, jSel-1);
			velm->delPoint(icont, jSel);
			if (jSel + 1 < velm->nzed[icont]-1) velm->delPoint(icont, jSel + 1);
			return TRUE;
		}
		else if (velm->delPoint(icont, jSel)) {
			return TRUE;
		}
		else return FALSE;
	}	//End deleting boundary points.

	//delete  points defining a velocity layer.
	if (pFrame->statMain.remove == 1 && draw.nodeMode == 2) {
		icont = draw.iLayerFocus;
		jSel = vm.getPointIndexClosestOnLayer(velm, xNew, icont, draw.isTopBound, &tempv);
		if (jSel < 0) return FALSE;

		if (vm.velModVelDelPoint(velm, icont, jSel, draw.isTopBound)) {
			return TRUE;
		}
		else return FALSE;
	} //End deleting layer points.

	return FALSE;

}


BOOL CSeisWideDoc::MyMouseClickDigitizing(SEI_QUAD* pQuad, CDigitize::DIGITIZE *pdig2)
{
	if (!pdig2->isDigitizing) return FALSE;

	double xOld = pQuad->x1;
	double yOld = pQuad->y1;
	double xNew = pQuad->x2;
	double yNew = pQuad->y2;
	if (pdig2->iCurveSel < 0) pdig2->iCurveSel = 0;
	if (pdig2->x == NULL) {
		pdig2->initDigitizeArray(1000, 1);
	}

	//Digitize points.
	if (pdig2->isXValClicking) {
		pdig2->curveVal[pdig2->iCurveSel] = (float)xOld;
		pdig2->isXValClicking = FALSE;
		return TRUE;
	}

	CSeisWideApp* pSeiApp = (CSeisWideApp*)AfxGetApp();
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	CDigitize pDg;
	CString tStr;
	CPoint p, selPoint;
	int jSel;
	double dist, distOld, distNew;
	SEI_PAIR pNew;
	bool isReduceUsed = !this->isHalfOffsetMode() && bmp24.bmpName.IsEmpty() && draw.red.isReduced();
	int ic;

	//in case of no time section, do  not use reduction velocity.
	// note: yNew, yOld are whatever screen values are, therefore already reduced if Vred>0,
	//       whereas dig.t[] are absolute time values NOT reduced.
	if (pFrame->statMain.pick == 1) {
		// pick digitized curve number
		if (isReduceUsed)
			yOld += CCoords::getReduceTimeEx2(cd.coord.getOffsetFromXVal(xOld, pdig2->xShotCache), cd.coord.drawmode, &draw.red);	   //Apply reduction velocity.
		pNew.x = (float)xOld;
		pNew.y = (float)yOld;
		ic = pdig2->iCurveSel = pDg.getClosestDigNum(pdig2, pNew);
		draw.isNodeChanged = TRUE;
		if (pdig2->isZeltFormat)
			tStr.Format(_T("ivray %d value: %g."), pdig2->ivray[ic], pdig2->curveVal[ic]);
		else
			tStr.Format(_T("Curve %d value: %g."), ic, pdig2->curveVal[ic]);
		pFrame->myCaption(tStr);
		return TRUE;
	}
	else if (pFrame->statMain.add == 1) {
		// when adding points, ignore xNew,yNew, but only use xOld,yOld.
		// Always add to after the last point of the curve
		//	if (!isVisibleOrNot(xOld, yOld)) return FALSE;
		ic = pdig2->iCurveSel;
		// NOTE: dig.x[]i] can be either in offset mode or in distance mode. The program has to handle both situ
		// what about reduction time? dig.t[][i] is always in absolute time before reduction applied!

		//If Zelt's format, make sure xOld is on the same side of the profile source as the first digitized point, otherwise it'll be a mess
		if (pdig2->isZeltFormat &&
			(pSeiApp->statWin.getControlPressed() || pSeiApp->statWin.isAPressed) &&
			!isFloatEqual((float)xNew, (float)xOld)) {
				bool isSameSign = sgn(cd.coord.getOffsetFromXVal(xOld, pdig2->xShotCache)) ==
					sgn(cd.coord.getOffsetFromXVal(xNew, pdig2->xShotCache));
				if (!isSameSign) {
					// we will make one of them to be at the pDig2->xShotCache, and in offset domain, just check the signs
					xNew = cd.coord.isDistanceDisplay ? pdig2->xShotCache : 0.;
				}
		} // if

		// With Zelt's format, I need to restrict to make sure any curve not crossing the the source.
		if (pdig2->isZeltFormat && pdig2->nPoint[ic]>0) {
			bool isSameSign = sgn(cd.coord.getOffsetFromXVal(xOld, pdig2->xShotCache)) ==
				sgn(cd.coord.getOffsetFromXVal(pdig2->x[0][ic], pdig2->xShotCache));
			if (!isSameSign) {
				tStr.Format(_T("Sorry, the same curve cannot cross the source location. You may digitize on a new curve."));
				AfxMessageBox(tStr, MB_ICONQUESTION);
				return FALSE;
			}

		}
		
		if (xNew < xOld) {
			// what about the user dragged from right to left? We just swap the 2 clicks
			double t = xOld; xOld = xNew; xNew = t;
			t = yOld; yOld = yNew; yNew = t;
		} // if

		cd.coord.xMouse = xOld;
		cd.coord.yMouse = yOld;

		// correct for reduction velocity. trace display will automatically have zero reduction
		//Apply reduction velocity. no effect on displaying by trace!
		if (isReduceUsed) {
			yOld += cd.coord.getReduceTimeEx2(xOld, pdig2->xShotCache, &draw.red);
			yNew += cd.coord.getReduceTimeEx2(xNew, pdig2->xShotCache, &draw.red);
		}


		double winLenWorking = fabs((yNew * 2 - yOld)*1.0);  // this must be after reduction applied
		if (winLenWorking < draw.twin_min) winLenWorking = draw.twin_min;
		if (winLenWorking > draw.twin_max) winLenWorking = draw.twin_max;
		// float winLenInSec = 0.6f;  // this must be after reduction applied

		pDg.myDigSort(pdig2);	// this must be done for each loop!

		if (
			(cd.coord.drawmode == 0 || cd.coord.drawmode == 7) &&
			(pSeiApp->statWin.getControlPressed() || pSeiApp->statWin.isAPressed) &&
			!isFloatEqual((float)xNew, (float)xOld) &&
			isFileExistNotDirectory(draw.timeSecName)) {
			// find the min time, time window for extract segy data
			double tminExOld = yOld;
			double tminExNew = yNew;
			if (isReduceUsed) {
				tminExOld -= CCoords::getReduceTimeEx2(cd.coord.getOffsetFromXVal(xOld, pdig2->xShotCache), cd.coord.drawmode, &draw.red);
				tminExNew -= CCoords::getReduceTimeEx2(cd.coord.getOffsetFromXVal(xNew, pdig2->xShotCache), cd.coord.drawmode, &draw.red);
			}
			double tminOut = min(tminExOld, tminExNew) - winLenWorking*0.5;  // min time for the segy data to extract out
			pFrame->statMain.myCursor(true);
			CSegyMeta::segyHeadInit(draw.timeSecName, &head);
			SegyWrapperEx sw(draw.timeSecName,
				xOld,
				xNew,
				tminOut,
				tminOut + winLenWorking,
				cd.coord.drawmode);
			// note: when vred is considered, starting time plus reduced time will be absolute time.
			sw.m_dxMin = sw.m_dyMin = 0.; // read all traces
			draw.red.clone(&sw.red2);
			register double dxResolution = fabs(xNew - xOld) * 0.001;
			if (dxResolution > 0.005) dxResolution = 0.001;  // cannot be greater than 1m
			else if (dxResolution < 0.00001) dxResolution = 0.00001; // cannot be less than 1cm

			HEAD_READ headTo;  // will hold the output data

			if (sw.openDistanceCache(!cd.coord.isDistanceDisplay, head.numTraces, &head, 
				pFrame->psei->pCacheSegyWrapEx, NUM_CACHE, true) && sw.headRead.getnx() > 1) {
				if (sw.m_tmax == head.tmaxFile) {
					tStr.Format(_T("Cohenrency computation using entire trace length; please wait..."));
					pFrame->myCaption(tStr);
				}
				sw.sortDistance(!cd.coord.isDistanceDisplay);
				CDigitize pDg;
				pDg.myDigSort(pdig2);
				float aRange = sw.headRead.trArr[0].getTraceXVal(cd.coord.drawmode, cd.coord.isDistanceDisplay);

				// since the first point is outside the selected range, we adjust aRange otherwise it does not work
				if (!isInsideDouble((double)aRange, xOld, xNew)) {
					for (int i = 0; i < sw.headRead.getnx(); i++) {
						aRange = sw.headRead.trArr[i].getTraceXVal(cd.coord.drawmode, cd.coord.isDistanceDisplay);
						if (isInsideDouble((double)aRange, xOld, xNew)) {
							break;
						}
					}
				}

				double odx = 1. / (xNew - xOld);
				int na = pDg.getDigIndexExact(pdig2, ic, aRange, (float)dxResolution);
				if (na < 0) {
					// this point does not exist in the dig array. we add it
						pDg.myDigAddPoint(pdig2, ic, aRange, yOld + (yNew - yOld) * (aRange - xOld) * odx);
						pDg.myDigSort(pdig2);	// this must be done for each loop!
						na = pDg.getDigIndexExact(pdig2, ic, aRange, (float)dxResolution);
				}
				if (na < 0) return FALSE; // this should never happen 
				// by now,  na points to the first trace in the sw class

				double slope;
				double tReda;
				if (isReduceUsed) {
					slope = (yNew - CCoords::getReduceTimeEx2(cd.coord.getOffsetFromXVal(xNew, pdig2->xShotCache), cd.coord.drawmode, &draw.red) - yOld +
						CCoords::getReduceTimeEx2(cd.coord.getOffsetFromXVal(xOld, pdig2->xShotCache), cd.coord.drawmode, &draw.red)) * odx;  // here the  reduction velocity is compensated already
					tReda = CCoords::getReduceTimeEx2(cd.coord.getOffsetFromXVal(xOld, pdig2->xShotCache), cd.coord.drawmode, &draw.red);
				}
				else {
					slope = (yNew - yOld) * odx;  // here the  reduction velocity is compensated already
					tReda = 0.;
				}

				double anErrorStaticFromCoh = 0.; // the coherency computing result has an error of static shift 
				for (int n = 0; n < sw.headRead.getnx(); n++) {
					pDg.myDigSort(pdig2);	// this must be done for each loop!  prob: after this sort, na should be changed!

					na = pDg.getDigIndexExact(pdig2, ic, aRange, (float)dxResolution); //na = -1; // reference trc seq number, we must re-calculate for each loop since new points may be added and sorted.
					if (na < 0) {
						continue; // this point should be removed!!!
					}
					// now na points to the first trace in the sw class again

					if (n > 100) {
						int sfds = 1;
					}
					register float bRange = sw.headRead.trArr[n].getTraceXVal(cd.coord.drawmode, cd.coord.isDistanceDisplay);
					if (bRange < xOld || bRange>xNew) continue; // this line is needed since the data may be wider than [xOld, xNew]
					register double tRedb = isReduceUsed ? 
						CCoords::getReduceTimeEx2(cd.coord.getOffsetFromXVal(bRange, pdig2->xShotCache),
						cd.coord.drawmode, &draw.red) 
						: 
						0.;

					register int nb = pDg.getDigIndexExact(pdig2, ic, bRange, (float)dxResolution); //int nb = -1;  // is this trace n already digitized?
					register double bTimeEstimate = yOld + slope*(bRange - xOld) + tRedb - tReda;

					// note: if I enable the following code, the first pick sometimes mis-match with the rest of picks
					//if (nb == na) {
					//	pdig2->x[na][ic] = bRange;  // note here aRange and bRange may be slight different because of round off error introduced in isFloatEqual()
					//	pdig2->t[na][ic] = (float)bTimeEstimate;
					//	pDg.myDigSort(pdig2);	// this must be done for each loop!  prob: after this sort, na should be changed!
					//	continue;
					//}

					if (!pSeiApp->statWin.isAPressed && n < sw.headRead.getnx()) {
						register int iTrc = (cd.coord.isDistanceDisplay) ?
							sw.getClosestTrcIndexAtDistance(bRange) : 
							sw.getClosestTrcIndexAtOffset(bRange);
						//register float aShift = sw.getShiftTrcCoh3(iTrc, (float)draw.twin_lag, (float)slope, draw.twin_lagWeight, draw.twin_numSubdivide);
						register float aShift = sw.getShiftTrcCoh3Reduced(&headTo, iTrc, (float)draw.twin_lag, (float)slope, draw.twin_lagWeight, draw.twin_numSubdivide);

						if (nb == na && aShift > ERRORVAL) {
							// static error can only be obtained from here, since ideally there should be no shift for the first trace
							anErrorStaticFromCoh = aShift;
						}

						// note: even if the aShift=0, the absolute shift will be non-zero when vred=1.44km/s !
						if (aShift > ERRORVAL)
							bTimeEstimate += aShift;
					} // if
					else {
						// now "A" is pressed, do nothing since aShiftEstimate is already interpolated
					}

					bTimeEstimate -= anErrorStaticFromCoh; // final correction

					if (nb >= 0) {
						pdig2->x[nb][ic] = bRange;
						pdig2->t[nb][ic] = (float)bTimeEstimate;
					}
					else {
						pDg.myDigAddPoint(pdig2, ic, bRange, bTimeEstimate);
					}
					pDg.myDigSort(pdig2);	// this must be done for each loop!  prob: after this sort, na should be changed!

					if (n > 0) {
						register float bRange0 = 
							sw.headRead.trArr[n - 1].getTraceXVal(cd.coord.drawmode, cd.coord.isDistanceDisplay);
						if (bRange>bRange0)
							pDg.myDigRemoveInside3(pdig2, ic, bRange0, bRange);
					} // if n
				} // for n

				pDg.myDigSort(pdig2);	// this must be done for each loop!
			} // if sw.open
			pFrame->statMain.myCursor(false);
			SegyWrapper::freeSegyArray(&headTo);

			// now I want remove all other points inside [xOld and xNew]
			register int nxmax = sw.headRead.getnx();
			if (nxmax > 2) {
				register float x1 = sw.headRead.trArr[0].getTraceXVal(cd.coord.drawmode, cd.coord.isDistanceDisplay);
				register float x2 = sw.headRead.trArr[nxmax - 1].getTraceXVal(cd.coord.drawmode, cd.coord.isDistanceDisplay);
				if (x1>xOld)  // it is possible x1<xOld, and it would delete some my existing points
					pDg.myDigRemoveInside3(pdig2, ic, (float)xOld, x1);
				//pDg.myDigRemoveInside3(&dig, ic, (float)xNew, x2); // this seems not needed
			}
		} // if cd.coord.drawmode==0
		else {
			// just make sure we do not have exactly duplicated point here
			int num = pdig2->nPoint[ic];
			if (num<1)
				pDg.myDigAddPoint(pdig2, ic, xOld, yOld);
			else if (pdig2->x[num - 1][ic] != xOld &&
				!isFloatEqual(pdig2->x[num - 1][ic], (float)xOld) &&
				!isFloatEqual(pdig2->t[num - 1][ic], (float)yOld)) {
				pDg.myDigAddPoint(pdig2, ic, xOld, yOld);
			}

			if (pSeiApp->statWin.getControlPressed() && pdig2->isTraceFormat) {
				pDg.myDigSort(pdig2);	// this must be done for each loop!
				double ax;
				double ay = cd.coord.Y1();
				for (int j = 0; j< pdig2->nPoint[ic]; j++) {
					if (pdig2->t[j][ic]<yOld-0.004 && ay< pdig2->t[j][ic])
						ay = pdig2->t[j][ic];
				} // for j
				if (ay > cd.coord.Y1()) {
					ay = (ay + yOld) * 0.5;
					if (fabs(ay - yOld) > 0.004) {
						ax = CDigitize::getDigXfromTSpline(pdig2, (float)ay, ic);
						pDg.myDigAddPoint(pdig2, ic, ax, ay);
						pDg.myDigSort(pdig2);	// this must be done for each loop!
					}
				}

				ay = cd.coord.Y2();
				for (int j = 0; j< pdig2->nPoint[ic]; j++) {
					if (pdig2->t[j][ic]>yOld + 0.004 && ay> pdig2->t[j][ic])
						ay = pdig2->t[j][ic];
				} // for j
				if (ay < cd.coord.Y2()) {
					ay = (ay + yOld) * 0.5;
					if (fabs(ay - yOld) > 0.004) {
						ax = CDigitize::getDigXfromTSpline(pdig2, (float)ay, ic);
						pDg.myDigAddPoint(pdig2, ic, ax, ay);
					}
				}
			}
		}

		pDg.myDigSort(pdig2);	// this must be done for each loop!

		draw.pt_addedR.x = cd.coord.xMouse;
		draw.pt_addedR.y = cd.coord.yMouse;
		draw.pt_addedR.isValid = false;  // this will ask the ondraw() to temporarily display this point and then disable it

		return TRUE;
	}
	//Move points.
	else if (pFrame->statMain.move == 1) {
		tStr.Format(_T("xOld=%f, xNew=%f, yOld=%f, yNew=%f, xShotInSegy=%f, para.rvred=%f, redTime=%f"),
			xOld, xNew, yOld, yNew,
			pdig2->xShotCache,
			draw.red.rvred, 
			cd.coord.getReduceTimeEx2(xOld, pdig2->xShotCache, &draw.red)
			);
		pFrame->myCaption(tStr);

		ic = pdig2->iCurveSel;
		if (ic < 0) return FALSE;
		distOld = MIL;
		jSel = -1;
		if (isReduceUsed)
			yOld += cd.coord.getReduceTimeEx2(xOld, pdig2->xShotCache, &draw.red);
		//Apply reduction velocity.

		int maxPointsAtCurve = pdig2->nPoint[ic];
		for (int j = 0; j < maxPointsAtCurve; j++) {
			//distNew = fabs(dig.x[j][ic] - xOld) +
			//	fabs(dig.t[j][ic] - yOld);
			distNew = fabs(pdig2->x[j][ic] - xOld); // this is more convenient for digitizing every trace
			dist = min(distNew, distOld);
			if (dist == distNew) {
				jSel = j;
				distOld = distNew;
			}
		}
		//So the old point is at x,t[jSel, i] in km, 
		//The new point is: xNew, yNew in km.
		if (jSel < 0) return FALSE;
		cd.coord.xMouse = xNew;	//Save points for Invalidate(FALSE).
		cd.coord.yMouse = yNew;
		pdig2->x[jSel][ic] = (float)xNew;
		if (isReduceUsed)
			yNew += cd.coord.getReduceTimeEx2(xNew, pdig2->xShotCache, &draw.red);
		//Apply reduction velocity.

		pdig2->t[jSel][ic] = (float)yNew;
		if (pSeiApp->statWin.getControlPressed()) {
			if (jSel == 0 && maxPointsAtCurve > 0) pdig2->t[jSel][ic] = pdig2->t[jSel + 1][ic];
			else if (jSel > 0) pdig2->t[jSel][ic] = pdig2->t[jSel - 1][ic];
		}

		pDg.myDigSort(pdig2);
		//t.Format(_T("i=%d, jSel=%d, xOld=%f, xNew=%f, yOld=%f, yNew=%f, xShotInSegy=%f, para.rvVred=%f", i, jSel, xOld, xNew, yOld, yNew, tx.xShotInSegy, para.rvVred);
		//this->myCaption(t);
		return TRUE;
	}
	else if (pFrame->statMain.remove == 1) {
		if (!cd.coord.isVisibleOrNot(xNew, yNew)) return FALSE;
		ic = pdig2->iCurveSel;
		if (ic < 0) return FALSE;

		// first calculate the index for removal
		distOld = 200000.;
		jSel = -1;
		if (isReduceUsed)
			yOld += CCoords::getReduceTimeEx2(
			cd.coord.getOffsetFromXVal(xOld, pdig2->xShotCache),
			cd.coord.drawmode, &draw.red);
		//Apply reduction velocity.

		// when cntl key is pressed, we delete 3 points to speed up 
		int i1 = 0;
		int i2 = (pSeiApp->statWin.getControlPressed()) ? 2 : 0;
		if (pSeiApp->statWin.getShiftPressed()) i2 = 8; // let the user ddelete 8 points at one click when shift key is pressed
		for (int i = i1; i <= i2; i++) {
			for (int j = 0; j < pdig2->nPoint[ic]; j++) {
				distNew = fabs(pdig2->x[j][ic] - xOld) +
					fabs(pdig2->t[j][ic] - yOld);
				dist = min(distNew, distOld);
				if (dist == distNew) {
					jSel = j;
					distOld = distNew;
				}
			}
			//So the removal point is at x,t[jSel, i] 

			if (jSel >= 0) {
				//now save the removal point for Invalidate() in onDraw().
				cd.coord.xMouse = pdig2->x[jSel][ic];
				cd.coord.yMouse = pdig2->t[jSel][ic];
				if (isReduceUsed)
					cd.coord.yMouse -= CCoords::getReduceTimeEx2(
						cd.coord.getOffsetFromXVal(pdig2->x[jSel][ic], pdig2->xShotCache),
						cd.coord.drawmode, &draw.red);
				//Apply reduction velocity.

				// now remove the point.
				pdig2->nPoint[ic]--;
				for (int j = jSel; j < pdig2->nPoint[ic]; j++) {
					pdig2->x[j][ic] = pdig2->x[j + 1][ic];
					pdig2->t[j][ic] = pdig2->t[j + 1][ic];
				}
			}
		} // for i
		return TRUE;

	} //End deleting point.
	return FALSE;

	// end digitizing functions
}

// 
BOOL CSeisWideDoc::MyMouseClickDenView(SEI_QUAD* pQuad)
{
	// The following mouse manipulation is only for editting a model in depth domain!
	double xOld = pQuad->x1;
	double yOld = pQuad->y1;
	double xNew = pQuad->x2;
	double yNew = pQuad->y2;

	// just to be consistent when adding points
	xOld = xNew;
	yOld = yNew;
	int icont;
	bool isTrue;

	draw.iLayerFocus = -1;
	DENMOD* pden = &this->gden;

	// search for the polygon that contains point (xOld, yOld) 
	for (icont = 0; icont < pden->ncont; icont++) {
		int n = pden->nzed[icont];
		isTrue = is_inPoly(pden->xm[icont], pden->zm[icont], n, (float)xOld, (float)yOld);
		if (isTrue) {
			// found it
			draw.iLayerFocus = icont;
			return TRUE;
		}
	}
	return FALSE;
}

BOOL CSeisWideDoc::MyMouseClickModelingDepth(SEI_QUAD* pQuad)
{
	// The following mouse manipulation is only for editting a model in depth domain!
	double xOld = pQuad->x1;
	double yOld = pQuad->y1;
	double xNew = pQuad->x2;
	double yNew = pQuad->y2;

	CSeisWideApp* pSeiApp = (CSeisWideApp*)AfxGetApp();
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	if (pFrame->statMain.add == 1) {
		// just to be consistent when adding points
		xOld = xNew;
		yOld = yNew;
	}


	CVelMod vm;
	CString tStr;
	CPoint p, selPoint;
	int k, icont, jSel;
//	TCHAR s[80];
	double tempv, z1[MOD_LAYER_MAX];
	CVelMod::VELMOD_X modX;
	SEI_PAIR pNew;
	pNew.x = (float)xNew;
	pNew.y = (float)yNew;

	SEI_PAIR pOld;
	pOld.x = (float)xOld;
	pOld.y = (float)yOld;

	//pick boundary.
	if (pFrame->statMain.pick == 1 && draw.nodeMode == 1) {
		if (xNew < cd.coord.X1() || xNew > cd.coord.X2()
			||
			yNew < cd.coord.Y1() || yNew > cd.coord.Y2())
			draw.iLayerFocus = -1;
		else
			draw.iLayerFocus = vm.getClosestLayerNum(&velMod, pNew, false);
		return TRUE;
	}  //End pick a boundary.

	//pick a layer.
	if (pFrame->statMain.pick == 1 && draw.nodeMode == 2)  {
		draw.iLayerFocus = -1;
		if (!cd.coord.isVisibleOrNot(xNew, yNew)) {
			return TRUE;
		}
		for (icont = 0; icont < velMod.ncont; icont++) {
			z1[icont] = -1.;
			for (int j = 0; j < velMod.nzed[icont] - 1; j++) {
				if (xOld >= velMod.xm[j][icont] && xOld <= velMod.xm[j + 1][icont]) {
					z1[icont] = velMod.zm[j][icont] +
						(velMod.zm[j + 1][icont] - velMod.zm[j][icont])*
						(xOld - velMod.xm[j][icont]) /
						(velMod.xm[j + 1][icont] - velMod.xm[j][icont]);
					break;
				}
			}
			if (xOld >= velMod.getXmin() && xOld < velMod.getXmax() && z1[icont] < 0)  {
				// z1[icont] can be negative
				//_stprintf_s(s, _T("x,x0,x1: %g %g %g"), xOld, velMod.xm[0][icont], velMod.xm[1][icont]);
				//AfxMessageBox(s);
				//return FALSE;
			}
		}
		for (icont = 0; icont < velMod.ncont - 1; icont++) {
			if (yOld >= z1[icont] && yOld <= z1[icont + 1]) {
				draw.iLayerFocus = icont;
				if (yOld < cd.coord.Y1())
					draw.isTopBound = true;
				else if (yOld > cd.coord.Y2())
					draw.isTopBound = false;
				else if (fabs(yOld - z1[icont]) < fabs(yOld - z1[icont + 1]))
					draw.isTopBound = true;
				else
					draw.isTopBound = false;
				break;
			}
		}
		return TRUE;
	}  //End pick a layer.

	//Add a point for specified boundary (draw.iLayerFocus).
	if (pFrame->statMain.add == 1 && draw.nodeMode == 1)  {
		if (!cd.coord.isVisibleOrNot(xNew, yNew)) return FALSE;
		//		distOld = 200000.;
		icont = draw.iLayerFocus;
		//jSel = vm.getPointIndexBeforeOnBoundary(&velMod, xNew, icont);
		//if (jSel < 0) return FALSE;
		if (vm.velModInsPoint(&velMod, icont, pNew, false)) {
			cd.coord.xMouse = xNew;
			cd.coord.yMouse = yNew;
			return TRUE;
		}
		else return FALSE;
	}	//End of add a node for specified boundary.

	//Add a point for specified layer (draw.iLayerFocus).
	//Need to consider: Low velocity layer not allowed.
	//One layer/boundary may have one point only (done).
	// static int anisotropy_layer0 = -1;
	velMod.m_isConvert = true;
	double adepth0, adepth1, adepth2;
	if (pFrame->statMain.add == 1 && draw.nodeMode == 2)  {
		if (!cd.coord.isVisibleOrNot(xNew, yNew)) return FALSE;
		//First calculate the velocity at the clicked point.
		icont = draw.iLayerFocus;
		jSel = vm.getPointIndexBeforeOnLayer(&velMod, xNew, icont, draw.isTopBound, &tempv);
		if (jSel < 0) return FALSE;

		// note: in the UI, the user sees 1 meaning the first layer. But in programming, 0=the first layer
		CdlgLayerNodes dlg1;
//		dlg1.m_layerNum = icont + 1;
		dlg1.m_layerNum = draw.isTopBound ? icont : icont + 1;
		dlg1.setLayerV(tempv);
		modX.dist = xNew;
		vm.initModX(&velMod, &modX, cd.coord.isTimeDomain(), true, velColor.dz);
		dlg1.m_modX = &modX;
		dlg1.m_isTimeDomain = false;
		dlg1.m_isRegressionChecked = modX.isSedimentRegression(icont);
		CVelMod::getStringRegression(&velMod, dlg1.m_strRegression);
		dlg1.m_anisotropy = velMod.anisotropy[icont];
		dlg1.m_anisotropy_layer0 = pFrame->psei->anisotropy_layer0 + 1;
		if (dlg1.DoModal() == IDOK) {
			velMod.setSedimentRegression(icont, dlg1.m_isRegressionChecked);
			CVelMod::parseString2Regression2(&velMod, dlg1.m_strRegression);
			tempv = dlg1.getLayerV();
			pFrame->psei->anisotropy_layer0 = dlg1.m_anisotropy_layer0 - 1;
			if (pFrame->psei->anisotropy_layer0 > -1 && pFrame->psei->anisotropy_layer0 < icont) {
				// this means we need to interpolate for anisotropy for all the overlying layers below anisotropy_layer0
				modX.dist = xOld;
				vm.initModX(&velMod, &modX, false, true, velColor.dz);
				int L0 = pFrame->psei->anisotropy_layer0;
				adepth2 = (modX.depthMod[icont] + modX.depthMod[icont + 1]) * 0.5;  // we know icont<velMod.ncont
				adepth0 = (modX.depthMod[L0] + modX.depthMod[L0 + 1]) * 0.5;
				for (int j = L0; j < icont; j++) {
					adepth1 = (modX.depthMod[j] + modX.depthMod[j + 1]) * 0.5;
					velMod.anisotropy[j] = (adepth2 - adepth0)>0 ?
						dlg1.m_anisotropy * (float)((adepth1 - adepth0) / (adepth2 - adepth0))
						:
						dlg1.m_anisotropy;
				}
			}
			velMod.anisotropy[icont] = dlg1.m_anisotropy;
		}
		else return FALSE;
		delete dlg1;
		if (vm.velModVelInsPoint(&velMod, draw.iLayerFocus, jSel + 1, draw.isTopBound, (float)xNew, (float)tempv)) {
			return TRUE;
		}
		else return FALSE;
	}	//End of add a node for specified layer.


	//Move boundary points.
	if (pFrame->statMain.move == 1 && draw.nodeMode == 1) {
		//		distOld = MIL;
		icont = draw.iLayerFocus;
		jSel = vm.getPointIndexClosestOnBoundary(&velMod, pOld, icont, false);
		if (jSel < 0) return FALSE;
		cd.coord.xMouse = xNew;	//Save points for Invalidate(FALSE).
		cd.coord.yMouse = yNew;
		if (jSel != 0 && jSel != (velMod.nzed[icont] - 1)) {
			if (xNew < velMod.getXmin()) xNew = velMod.getXmin();
			else if (xNew > velMod.getXmax()) xNew = velMod.getXmax();
			if (!cd.coord.isVisibleOrNot(xNew, yNew)) return FALSE;
			if (xNew < velMod.xm[jSel - 1][icont] + 0.00001) return FALSE; //The model's resolution has to be 0.00001 km.
			if (xNew > velMod.xm[jSel + 1][icont] - 0.00001) return FALSE; //The model's resolution has to be 0.00001 km.
		}
		else xNew = velMod.xm[jSel][icont];  //left/right boundary points cann't change X values.

		if (pSeiApp->statWin.getControlPressed()) {
			if (jSel == 0) yNew = velMod.zm[jSel + 1][icont];
			else yNew = velMod.zm[jSel - 1][icont];
		}
		else if (jSel == velMod.nzed[icont] - 1)
			pFrame->myCaption(_T("Use Ctrl key to flatten the segment"));

		//now make sure the point doesn't go above or below adjacent boundary.
		//to do this: (1) calculate Z for xNew of boundaries jSel-1 and jSel+1; (2) decide.
		modX.dist = xNew;
		vm.initModX(&velMod, &modX, cd.coord.isTimeDomain(), true, velColor.dz);
		if ((icont > 0 && yNew < modX.depthMod[icont - 1]) || (icont<velMod.ncont - 1 && yNew>modX.depthMod[icont + 1])) {
			// the new point is above another boundary
			tStr.Format(_T("You tried to merge a node to another boundary. Are you sure?"));
			if (AfxMessageBox(tStr, MB_YESNO | MB_ICONINFORMATION) == IDNO) return FALSE;
			if (!vm.velModInterceptPoint(&velMod, icont, jSel, pNew, cd.coord.isTimeDomain())) return FALSE;
		}
		else {
			velMod.xm[jSel][icont] = (float)xNew;
			velMod.zm[jSel][icont] = (float)yNew;
		}

		// after point moving, the nav values are invalid anymore
		velMod.longitude[jSel][icont] = ERRORVAL;
		velMod.latitude[jSel][icont] = ERRORVAL;

		return TRUE;
	}	//End moving boundary points.

	//Move  points defining a velocity layer.
	if (pFrame->statMain.move == 1 && draw.nodeMode == 2) {
		if (draw.iLayerFocus < 0) return FALSE;
		icont = draw.iLayerFocus;
		if (draw.isTopBound)	k = 0;
		else k = 1;

		icont = draw.iLayerFocus;
		jSel = -1;
		for (int j = 0; j<velMod.nvel[icont][k] - 1; j++) {
			if (xOld >= velMod.xvel[j][icont][k] && xOld <= velMod.xvel[j + 1][icont][k]) {
				jSel = j;
				break;
			}
		}
		if (jSel < 0 || jSel>velMod.nvel[icont][k] - 1) return FALSE;
		if (fabs(xOld - velMod.xvel[jSel][icont][k]) >
			fabs(xOld - velMod.xvel[jSel + 1][icont][k])) jSel++;
		if (jSel < 0 || jSel>velMod.nvel[icont][k] - 1) return FALSE;

		xOld = velMod.xvel[jSel][icont][k];
		tempv = velMod.vf[jSel][icont][k];
		//So the old point is at xOld, yOld in km, 
		//The new point is: xNew, yNew in km.

		// note: in the UI, the user sees 1 meaning the first layer. But in programming, 0=the first layer
		//static BOOL isApply4All = false;
		CdlgLayerNodes dlg1;
//		dlg1.m_layerNum = icont + 1;
		dlg1.m_layerNum = draw.isTopBound ? icont : icont + 1;
		dlg1.setLayerV(tempv);
		modX.dist = xOld;
		vm.initModX(&velMod, &modX, cd.coord.isTimeDomain(), true, velColor.dz);
		dlg1.m_modX = &modX;
		dlg1.m_isTimeDomain = false;
		dlg1.m_isRegressionChecked = modX.isSedimentRegression(icont);
		CVelMod::getStringRegression(&velMod, dlg1.m_strRegression);
		//dlg1.m_apply4All = isApply4All;
		dlg1.m_anisotropy = velMod.anisotropy[icont];
		dlg1.m_anisotropy_layer0 = pFrame->psei->anisotropy_layer0 + 1;

		if (dlg1.DoModal() == IDOK) {
			velMod.setSedimentRegression(icont, dlg1.m_isRegressionChecked);
			CVelMod::parseString2Regression2(&velMod, dlg1.m_strRegression);

			tempv = dlg1.getLayerV();
			//isApply4All = dlg1.m_apply4All;
			pFrame->psei->anisotropy_layer0 = dlg1.m_anisotropy_layer0 - 1;
			modX.dist = xOld;
			vm.initModX(&velMod, &modX, cd.coord.isTimeDomain(), true, velColor.dz);
			if (dlg1.m_anisotropy == -1 && pFrame->psei->anisotropy_layer0 > -1 && pFrame->psei->anisotropy_layer0 < icont) {
				// this means we need to interpolate for anisotropy for all the overlying layers below anisotropy_layer0
				// interpolate using an empirical formula
				for (int j = pFrame->psei->anisotropy_layer0; j < icont; j++) {
					double vh = (modX.vTop[j] + modX.vBot[j]) * 0.5;
					velMod.anisotropy[j] = (float)(1. - (0.393 + 0.74 * vh) / vh);
				}
			}
			else if (dlg1.m_anisotropy == 0.f && pFrame->psei->anisotropy_layer0 > -1 && pFrame->psei->anisotropy_layer0 < icont) {
				for (int j = pFrame->psei->anisotropy_layer0; j < icont; j++) {
					velMod.anisotropy[j] = 0.f;
				}
			}

			// note: dlg1.m_anisotropy  can be  -1, 0, or >0
			if (dlg1.m_anisotropy == -1) {
				double vh = (modX.vTop[icont] + modX.vBot[icont]) * 0.5;
				dlg1.m_anisotropy = (float)(1. - (0.393 + 0.74 * vh) / vh);
			}
			velMod.anisotropy[icont] = dlg1.m_anisotropy;
		}
		else return FALSE;
		// delete dlg1;

		// We disable auto check for dlg1.m_apply4All, otherwise it's too easy to make mistakes.
		// I have made such mistakes nearly everyday I use seisWide.
		if (dlg1.m_apply4All) {
			for (int j = 0; j < velMod.nvel[icont][k]; j++) {
				velMod.vf[j][icont][k] = (float)tempv;
			}
		} // if

		if (jSel == 0 || jSel == velMod.nvel[icont][k] - 1) {
			velMod.vf[jSel][icont][k] = (float)tempv;
		}
		else {
			if (xNew < velMod.xvel[jSel - 1][icont][k] + 0.00001) return FALSE; //The model's resolution has to be 0.00001 km.
			if (xNew > velMod.xvel[jSel + 1][icont][k] - 0.00001) return FALSE; //The model's resolution has to be 0.00001 km.
			velMod.xvel[jSel][icont][k] = (float)xNew;
			velMod.vf[jSel][icont][k] = (float)tempv;
		}
		return TRUE;
	} //End of moving layer points.

	//deleting boundary points.
	if (pFrame->statMain.remove == 1 && draw.nodeMode == 1) {
		//		distOld = 200000.;
		icont = draw.iLayerFocus;
		jSel = vm.getPointIndexClosestOnBoundary(&velMod, pNew, icont, false);
		if (jSel < 0) return FALSE;
		cd.coord.xMouse = velMod.xm[jSel][icont];
		cd.coord.yMouse = velMod.zm[jSel][icont];
		if (velMod.delPoint(icont, jSel)) {
			return TRUE;
		}
		else return FALSE;
	}	//End deleting boundary points.
	else if (pFrame->statMain.remove == 1 && draw.nodeMode == 2) {
		//delete  points defining a velocity layer.
		icont = draw.iLayerFocus;
		jSel = vm.getPointIndexClosestOnLayer(&velMod, xNew, icont, draw.isTopBound, &tempv);
		if (jSel < 0) return FALSE;

		if (vm.velModVelDelPoint(&velMod, icont, jSel, draw.isTopBound)) {
			draw.isNodeChanged = TRUE;  // setting this to FALSE removes the screen flicker
			return TRUE;
		}
		else return FALSE;
	} //End deleting layer points.
	return FALSE;
}


void CSeisWideDoc::OnDigitizingStart()
{
	if (dig.isDigitizing) {
		AfxMessageBox(_T("You are still digitizing."), MB_ICONQUESTION);
		return;
	}
	CDigitize pDg;

	// initialize the dig array sizes, big enough for most purposes.
	int ncurve = 5;
	int npoint = 100;

	CSeisWideApp* pSeiApp = (CSeisWideApp*)AfxGetApp();
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	//pSeiApp->statWin.getControlPressed() = FALSE;
	//pSeiApp->statWin.isShiftPressed = FALSE;
	CdlgDigitize dlg;
	
	bool isTxt;
	CString tStr = GetBaseFileName(dig.digName);
	if (isFileExistNotDirectory(dig.digName)) {
		tStr = dig.digName;
		isTxt = (GetFileExtension(tStr).CompareNoCase(_T("in")) == 0) ? false : true;
	}
	else {
		// since the digName's directory not existing, we cannot use it
		double vred = draw.red.getVred(); //rvred == 0. ? 0. : 1. / draw.red.rvred;
		isTxt = !cd.coord.isDistanceDisplay || cd.coord.drawmode == 10 || 
			cd.coord.drawmode == 6 || fabs(vred) < 3.0;
		tStr = getWorkingPathSlash();
		tStr = getFileNameTemp(tStr + _T("Digi"), isTxt ? _T("txt") : _T("in"));
		tStr.Replace(_T("_digZelt.in"), _T(".in"));
		tStr.Replace(_T("_digi.txt"), _T(".txt"));
		tStr.Replace(_T("_digTrc.txt"), _T(".txt"));
		if (GetPathFromFileSlash(tStr).IsEmpty()) {
			tStr = getWorkingPathSlash() + tStr;
		}
		if (cd.coord.drawmode == 6) {
			tStr = getFileNameAppend(tStr, _T("_digTrc"));
		}
		else  {
			tStr = getFileNameAppend(tStr, _T("_digi"));
		}
	}

	//if (tStr.Find(_T("\\")) < 0) {
	//	// this file does not contain a path, so we have to add one
	//	tStr = this->getWorkingPathSlash() + dlg.m_digName;
	//}
	CSegyMeta::segyHeadInit(draw.timeSecName, &head);
	dig.xShotCache = (float)head.xshotInSegy;
	dlg.m_digName = tStr;
	if (cd.coord.drawmode == 6)
		dig.xMode = CDigitize::trace;
	else if (cd.coord.isDistanceDisplay)
		dig.xMode = CDigitize::distance;
	else
		dig.xMode = CDigitize::offset;

	dlg.m_digFileFormat = isTxt ? 0 : 1;
	dlg.m_xs = (float)dig.xShotCache;
	dlg.m_mode = 0;
	dlg.m_comments = dig.strComment;
	dlg.m_isMinusXShot = cd.coord.isMinusXShot;
	dlg.m_isSort = 0;

	// additions
	dlg.m_isEnergy = draw.twin_isEnergy;
	dlg.m_tlag = (float)draw.twin_lag;
	dlg.m_lagWeight = draw.twin_lagWeight;
	dlg.m_tmin = (float)draw.twin_min;
	dlg.m_tmax = (float)draw.twin_max;
	dlg.m_numSubdivide = draw.twin_numSubdivide;


	if (dlg.DoModal() == IDOK) {
		dig.digName = dlg.m_digName;
		dig.isZeltFormat = dlg.m_digFileFormat != 0;
		if (dlg.m_comments == _T("Comments")) dlg.m_comments = BLANK;
		dig.strComment = dlg.m_comments;
		cd.coord.isMinusXShot = dlg.m_isMinusXShot;
		ncurve = dlg.m_curves;
		npoint = dlg.m_points;
		dig.xShotCache = dlg.m_xs;
		if (dlg.m_isSort == 0) {
			dig.isSortedX = TRUE;
			dig.isSortedY = FALSE;
		}
		else if (dlg.m_isSort == 1) {
			dig.isSortedX = FALSE;
			dig.isSortedY = TRUE;
		}
		else {
			dig.isSortedX = FALSE;
			dig.isSortedY = FALSE;
		}
		draw.twin_isEnergy = dlg.m_isEnergy != FALSE;
		draw.twin_lag = dlg.m_tlag;
		draw.twin_lagWeight = dlg.m_lagWeight;
		draw.twin_min = dlg.m_tmin;
		draw.twin_max = dlg.m_tmax;
		draw.twin_numSubdivide = dlg.m_numSubdivide;
	}
	else return;

	// fix up for users' ignorance
	if (!cd.coord.isTimeDomain()) {
		dig.isZeltFormat = FALSE;  // for depth domain, we only allow plain text format
	}

	if (!dig.isZeltFormat) {
		dig.digName = SetFileExtension(dig.digName, _T("txt"));
	}
	else {
		dig.digName = SetFileExtension(dig.digName, _T("in"));
	}
	dig.isDigitizing = TRUE;
	draw.isSameDataDisplay = TRUE;
	draw.isNoPromptLabel = FALSE; //when loading, prompt for showing labels. This is he only way to recover the dialog box without restarting the SeisWide program.

	if (isFileExistNotDirectory(dig.digName) && !dig.isZeltFormat) {
		// already exists, so we simply returm
		if (pDg.myDigitizingLoadTXTUnix2(&dig)) {
			if (dig.totCurve < 1) dig.totCurve = 1;
			dig.iCurveSel = dig.totCurve - 1;
			OnToolbarRefreshAll(); // this makes the existing curves to show up
			//OnDigitizingNewcurve();
			//OnToolbarAdd();
			return;
		}
	}
	else if (isFileExistNotDirectory(dig.digName) && dig.isZeltFormat) {
		pDg.myDigLoadZelt(&dig, dig.xShotCache);
		//dig.xShotCache = (float)xShotRay;
		if (CCoords::isXShotDefined(dig.xShotCache)) {
			// For zelt format, in offset mode, we need to convert distance to offset
			if (dig.xMode == CDigitize::XMODE::offset) {
				for (int i = 0; i<dig.totCurve; i++) {
					for (int j = 0; j<dig.nPoint[i]; j++) {
						dig.x[j][i] = 
							(float)(cd.coord.isMinusXShot ?
								dig.xShotCache - dig.x[j][i]
							: 
							dig.x[j][i] - dig.xShotCache);
					}
				}
			}

			if (dig.totCurve < 1) dig.totCurve = 1;
			dig.iCurveSel = dig.totCurve - 1;
			dig.isSortedX = TRUE; // always sort Zelt's format.
			dig.isSortedY = FALSE;
			OnToolbarRefreshAll(); // this makes the existing curves to show up
			//OnDigitizingNewcurve();
			//OnToolbarAdd();
			return;
		}
	}


	// If here, no existing dig files arwe found. So we start a new one.
	if (!dig.initDigitizeArray(npoint, ncurve)) return;
	if (dig.nPoint == NULL || dig.curveVal == NULL || dig.x == NULL || dig.t == NULL) {
		AfxMessageBox(_T("Memory unavailable 14"));
		return;
	}


	// reset contents even if is duplication work (already reset during initDigitizeArray() )
	dig.iCurveSel = 0;	//first curve.
	dig.nPoint[0] = 0; // actual number of points
	dig.totCurve = 1;  // starting from 1 even no points in it yet.

	if (dig.isZeltFormat) {
		//Here Zelt's format is chosen, so need to ask for resolution.
		CdlgDigResolution dlg;

		if (dig.iCurveSel == 0) {
			dlg.m_digResolution = 0.04f;
			dlg.m_ivray = 1;

		}
		else {
			dlg.m_digResolution = dig.curveVal[dig.iCurveSel - 1];
			dlg.m_ivray = dig.ivray[dig.iCurveSel - 1] + 1;
		}

		dlg.m_nCurve = dig.iCurveSel; // dlg.m_nCurve is actually the curve seq. number from 0, read-only
		if (dlg.DoModal() == IDOK) {
			dig.curveVal[0] = dlg.m_digResolution;
			dig.ivray[0] = dlg.m_ivray;
		}
		dig.isSortedX = TRUE; // always sort Zelt's format.
		dig.isSortedY = FALSE;
		pFrame->myCaption(_T("Always sort Zelt's format."));
	}
	else {
		//dlgDigOption dlg;
		//dlg.m_nCurve = 0;
		//dlg.m_label.Format(_T("%d"), 1);
		//dlg.m_NotShow = FALSE;
		//dlg.m_isSort = dig.isSortedX;
		//dlg.m_isSortY = dig.isSortedY;
		//if (dlg.DoModal() == IDOK) {
		//	//dig.labelArr->SetAt(dig.iCurveSel, dlg.m_label);
		//	//dig.labelArr->Add(dlg.m_label);
		//	dig.curveVal[0] = (float)StringToFloat(dlg.m_label);
		//	draw.isNoPromptLabel = dlg.m_NotShow;
		//	dig.isSortedX = dlg.m_isSort;
		//	dig.isSortedY = dlg.m_isSortY;
		//}
		//digIsUpdatePartial = FALSE; // This is static variable. when a new digitizing starts, we have to update all numbers first. 

	}

	OnDigitizingNewcurve();
	OnToolbarAdd();

	pFrame->myCaption(_T("Hold the Shift key to temporarily shift the display area."));
	this->NotifyChanged();
//	OnToolbarRefreshAll();

}

void CSeisWideDoc::OnDigitizingStartmarker()
{
	if (dig.isDigitizing) {
		OnDigitizingSavedig();
		dig.isDigitizing = FALSE;
	}

	if (digMarker.isDigitizing) {
		AfxMessageBox(_T("You are still digitizing a marker file."), MB_ICONQUESTION);
		return;
	}
	CDigitize pDg;

	// initialize the dig array sizes, big enough for most purposes.
	int ncurve = 5;
	int npoint = 100;

	CSeisWideApp* pSeiApp = (CSeisWideApp*)AfxGetApp();
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
//	pSeiApp->statWin.isControlPressed = FALSE;
//	pSeiApp->statWin.isShiftPressed = FALSE;
	CdlgDigitize dlg;

	bool isTxt;
	CString tStr = GetBaseFileName(digMarker.digName);
	if (isFileExistNotDirectory(digMarker.digName)) {
		tStr = digMarker.digName;
		isTxt = (GetFileExtension(tStr).CompareNoCase(_T("in")) == 0) ? false : true;
	}
	else {
		// since the digName's directory not existing, we cannot use it
		double vred = draw.red.getVred(); //rvred == 0. ? 0. : 1. / draw.red.rvred;
		isTxt = !cd.coord.isDistanceDisplay || cd.coord.drawmode == 10 ||
			cd.coord.drawmode == 6 || fabs(vred) < 3.0;
		tStr = getWorkingPathSlash();
		tStr = getFileNameTemp(tStr + _T("DigMarker"), isTxt ? _T("txt") : _T("in"));
		tStr.Replace(_T("_digZelt.in"), _T(".in"));
		tStr.Replace(_T("_digi.txt"), _T(".txt"));
		tStr.Replace(_T("_digTrc.txt"), _T(".txt"));
		if (GetPathFromFileSlash(tStr).IsEmpty()) {
			tStr = getWorkingPathSlash() + tStr;
		}
		if (cd.coord.drawmode == 6) {
			tStr = getFileNameAppend(tStr, _T("_digMTrc"));
		}
		else {
			tStr = getFileNameAppend(tStr, _T("_digMarker"));
		}
	}

	CSegyMeta::segyHeadInit(draw.timeSecName, &head);
	digMarker.xShotCache = (float)head.xshotInSegy;
	//head.xshotInSegy = digMarker.xShotCache = CSegyMeta::getXShotInSegy(draw.timeSecName);
	dlg.m_digName = tStr;
	if (cd.coord.drawmode == 6)
		digMarker.xMode = CDigitize::trace;
	else if (cd.coord.isDistanceDisplay)
		digMarker.xMode = CDigitize::distance;
	else
		digMarker.xMode = CDigitize::offset;

	dlg.m_digFileFormat = isTxt ? 0 : 1;
	dlg.m_xs = (float)digMarker.xShotCache;
	dlg.m_mode = 0;
	dlg.m_comments = digMarker.strComment;
	dlg.m_isMinusXShot = cd.coord.isMinusXShot;
	dlg.m_isSort = 0;

	// additions
	dlg.m_isEnergy = draw.twin_isEnergy;
	dlg.m_tlag = (float)draw.twin_lag;
	dlg.m_lagWeight = draw.twin_lagWeight;
	dlg.m_tmin = (float)draw.twin_min;
	dlg.m_tmax = (float)draw.twin_max;
	dlg.m_numSubdivide = draw.twin_numSubdivide;


	if (dlg.DoModal() == IDOK) {
		digMarker.digName = dlg.m_digName;
		digMarker.isZeltFormat = FALSE;
		if (dlg.m_comments == _T("Comments")) dlg.m_comments = BLANK;
		digMarker.strComment = dlg.m_comments;
		cd.coord.isMinusXShot = dlg.m_isMinusXShot;
		ncurve = dlg.m_curves;
		npoint = dlg.m_points;
		digMarker.xShotCache = dlg.m_xs;
		if (dlg.m_isSort == 0) {
			digMarker.isSortedX = TRUE;
			digMarker.isSortedY = FALSE;
		}
		else if (dlg.m_isSort == 1) {
			digMarker.isSortedX = FALSE;
			digMarker.isSortedY = TRUE;
		}
		else {
			digMarker.isSortedX = FALSE;
			digMarker.isSortedY = FALSE;
		}
		draw.twin_isEnergy = dlg.m_isEnergy != FALSE;
		draw.twin_lag = dlg.m_tlag;
		draw.twin_lagWeight = dlg.m_lagWeight;
		draw.twin_min = dlg.m_tmin;
		draw.twin_max = dlg.m_tmax;
		draw.twin_numSubdivide = dlg.m_numSubdivide;
	}
	else return;

	digMarker.digName = SetFileExtension(digMarker.digName, _T("txt"));
	digMarker.isDigitizing = TRUE;
	draw.isSameDataDisplay = TRUE;
	draw.isNoPromptLabel = FALSE; //when loading, prompt for showing labels. This is he only way to recover the dialog box without restarting the SeisWide program.
	if (isModelVisible(&velMod, 0.))
		draw.isNoNodes = TRUE; // to avoid too many nodes showing in screen
	
	if (isFileExistNotDirectory(digMarker.digName)) {
		// already exists, so we simply returm
		if (pDg.myDigitizingLoadTXTUnix2(&digMarker)) {
			if (digMarker.totCurve < 1) digMarker.totCurve = 1;
			digMarker.iCurveSel = digMarker.totCurve - 1;
			OnToolbarRefreshAll();
			return;
		}
	}

	// If here, no existing dig files arwe found. So we start a new one.
	if (!digMarker.initDigitizeArray(npoint, ncurve)) return;
	digMarker.iCurveSel = 0;	//first curve.
	digMarker.nPoint[0] = 0; // actual number of points
	digMarker.totCurve = 1;  // starting from 1 even no points in it yet.
	OnDigitizingNewcurve();
	OnToolbarAdd();

	pFrame->myCaption(_T("Hold the Shift key to temporarily shift the display area."));
	this->NotifyChanged();
	OnToolbarRefreshAll();

	
}

void CSeisWideDoc::OnDigitizingLoadexisting()
{
	// here deals with text only format
	// this function is disabled, I believe.
	if (dig.isDigitizing) {
		AfxMessageBox(_T("You are still digitizing"), MB_ICONQUESTION);
		return;
	}




	CFileDialog dlgf(TRUE, BLANK, _T("*.txt"),
		OFN_HIDEREADONLY | OFN_EXPLORER,
		_T("Input text File (*.txt)|*.txt|"));
	dlgf.m_ofn.lpstrTitle = _T("Ascii file to load (3 columns; no convert)");
	if (dlgf.DoModal() == IDOK)
		dig.digName = dlgf.GetPathName();
	else
	{
		return;
	}
	delete dlgf;


	//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	dlgDigOption dlg;
	dlg.m_nCurve = 0;
	dlg.m_label = BLANK;
	dlg.m_NotShow = FALSE;
	//dlg.m_isSort = dig.isSorted;
	//dlg.m_isSortY = dig.isSortedY;
	dlg.m_isSort = TRUE;
	dlg.m_isSortY = FALSE;
	if (dlg.DoModal() == IDOK)  {
		draw.isNoPromptLabel = dlg.m_NotShow;
		dig.isSortedX = dlg.m_isSort;
		dig.isSortedY = dlg.m_isSortY;
	}

	CDigitize pDg;
	if (pDg.myDigitizingLoadTXTUnix2(&dig)) {
		dig.isDigitizing = TRUE;
		//	dig.totCurve++;	//start with a new curve.
		dig.iCurveSel = dig.totCurve - 1;
		//	dig.nPoint[dig.iCurve] = 0;

		draw.isNoPromptLabel = FALSE; //when loading, prompt for showing labels. This is he only way to recover the dialog box without restarting the SeisWide program.
		//	draw.isNoLabelInSide = FALSE; //when loading, 
		//	if( !cd.coord.isFaceUp==0) cd.coord.isFaceUp=0;	//Only this mode works for digitizing, a bug to be fixed.
		dig.isZeltFormat = FALSE;
		draw.isSameDataDisplay = TRUE;
		OnToolbarRefreshAll();
		OnToolbarPick();
	}
	else {
		AfxMessageBox(_T("Sorry, failed to load the file."), MB_ICONQUESTION);
	}
	//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

}

//BOOL CSeisWideDoc::myDigitizingLoadzeltTx() {
//	if (!isFileExistNotDirectory(dig.digName)) return FALSE;
//	return myDigitizingLoadzeltTx(&dig);
//}


void CSeisWideDoc::OnDigitizingLoadzeltTx()
{
	if (dig.isDigitizing) {
		AfxMessageBox(_T("You are still digitizing. You may finish digitizing and load again."), MB_ICONQUESTION);
		return;
	}

	//if (!cd.coord.isDistanceDisplay) {
	//	//	AfxMessageBox(_T("Traveltime picks can only be done when displaying with model distance mode, as opposed to offsets. Please load again.");
	//	AfxMessageBox(_T("For Zelt's format, traveltime picks can only be done when displaying with model distance mode, as is hereby set so."), MB_ICONQUESTION);
	//	cd.coord.isDistanceDisplay = TRUE;
	//	this->OnToolbarRefreshAll();
	//	return;
	//}
	CString tStr;

	BOOL firstTim = TRUE, textErr = FALSE;

	//new file dialog.
	CFileDialog dlg(TRUE, BLANK, dig.digName,
		OFN_HIDEREADONLY | OFN_EXPLORER,
		_T("Input text File (*.in)|*.in|"));
	dlg.m_ofn.lpstrTitle = _T("Zelt's file of TX.IN format)");
	
	if (dlg.DoModal() == IDOK)
		dig.digName = dlg.GetPathName();
	else {
		return;
	}
	delete dlg;

	dig.isZeltFormat = TRUE;
	bool isXsForced = !draw.timeSecName.IsEmpty();
	
	CDigitize pDg;
	if (isXsForced) {
		CSegyMeta::segyHeadInit(draw.timeSecName, &head);
		dig.xShotCache = (float)head.xshotInSegy;
	}
	pDg.myDigLoadZelt(&dig, dig.xShotCache, isXsForced);
	if (dig.totCurve < 1 || !dig.nPoint) {
		dig.modifiedtime = 0; // reload this file
		tStr.Format(_T("Failed to load picks for Zelt format at a source at %g km. You may try again by redefining the source position."), dig.xShotCache);
		AfxMessageBox(tStr, MB_ICONQUESTION);
		return;
	}
	//if (CCoords::isXShotDefined(xShotRay))
	//	dig.xShotCache = (float)xShotRay;
	if (CCoords::isXShotDefined(dig.xShotCache)) {
		// For zelt format, in offset mode, we need to convert distance to offset
		if (dig.xMode == CDigitize::XMODE::offset) {
			for (int i = 0; i<dig.totCurve; i++) {
				for (int j = 0; j<dig.nPoint[i]; j++) {
					dig.x[j][i] =
						(float)(cd.coord.isMinusXShot ?
							dig.xShotCache - dig.x[j][i]
							:
							dig.x[j][i] - dig.xShotCache);
				}
			}
		}

		dig.isDigitizing = TRUE;
		draw.isSameDataDisplay = TRUE;
		draw.isNoPromptLabel = FALSE; //when loading, prompt for showing labels. This is he only way to recover the dialog box without restarting the SeisWide program.
		if (dig.totCurve < 1) dig.totCurve = 1;
		dig.iCurveSel = dig.totCurve - 1;
		CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
		tStr.Format(_T("Successfully loaded %d curves for digitizing. The last curve with %d points is highlighted and you may continue digitizing this curve."),
			dig.totCurve, dig.nPoint[dig.iCurveSel]);
		pFrame->myCaption(tStr);
		// AfxMessageBox(tStr, MB_ICONQUESTION);
		dig.isSortedX = TRUE; // always sort Zelt's format.
		dig.isSortedY = FALSE;
		draw.isSameDataDisplay = TRUE;
		OnToolbarRefreshAll();
		//OnDigitizingNewcurve();
		//OnToolbarAdd();
		return;
	}

}

void CSeisWideDoc::OnDigitizingNewcurve()
{
	CDigitize::DIGITIZE *pDig = NULL;
	if (dig.isDigitizing && dig.nPoint != NULL)
		pDig = &dig;
	else if (digMarker.isDigitizing && digMarker.nPoint != NULL)
		pDig = &digMarker;
	else
		return;


	// Now if the last curve has no points digitized, return without changes
	CString str;
	if (pDig->totCurve > 0 && pDig->nPoint[pDig->totCurve - 1] == 0) {
		pDig->iCurveSel = pDig->totCurve - 1;
		OnDigitizingReviselinelabel();
		//CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
		//str.Format(_T("Already digitizing a new curve."));
		//pFrame->myCaption(str);
		return;
	}


	// now jump to the last curve
	pDig->totCurve++;
	pDig->iCurveSel = pDig->totCurve - 1;
	pDig->nPoint[pDig->iCurveSel] = 0;

	if (pDig->isZeltFormat) {	//Here Zelt's format is chosen, so need to ask for resolution.
		CdlgDigResolution dlg;
		if (pDig->iCurveSel == 0) {
			dlg.m_digResolution = 0.04f;
			dlg.m_ivray = 1;
		}
		else {
			dlg.m_digResolution = pDig->curveVal[pDig->iCurveSel - 1];
			dlg.m_ivray = pDig->getIvrayNext();
		}
		dlg.m_nCurve = pDig->iCurveSel + 1;
		if (dlg.DoModal() == IDOK) {
			pDig->curveVal[pDig->iCurveSel] = dlg.m_digResolution;
			pDig->ivray[pDig->iCurveSel] = dlg.m_ivray;
		}
	}
	else {
		//if (!pDig->isTraceFormat) { //Here the plain format.
		if (!draw.isNoPromptLabel) {
			dlgDigOption DLG;
			DLG.m_label.Format(_T("%g"), pDig->getCurveValNext());
			DLG.m_nCurve = pDig->iCurveSel;
			DLG.m_isSort = pDig->isSortedX;
			DLG.m_isSortY = pDig->isSortedY;
			if (DLG.DoModal() == IDOK) {
				//   strncpy_s(&dig.label[dig.iCurve*8], 8, DLG.m_label, 8);
				str = DLG.m_label;
				draw.isNoPromptLabel = DLG.m_NotShow;
				pDig->isSortedX = DLG.m_isSort;
				pDig->isSortedY = DLG.m_isSortY;
			}
		}
		else {
			str.Format(_T("%d"), pDig->iCurveSel);
		}

		//pDig->labelArr->SetAt(pDig->iCurveSel, str);
		//pDig->labelArr->Add(str);
		pDig->curveVal[pDig->iCurveSel] = (float)StringToFloat(str);
	}


	draw.isSameDataDisplay = TRUE;
	OnToolbarRefreshAll(); // this makes the existing curves to show up
	OnToolbarAdd();
}

void CSeisWideDoc::OnDigitizingZeltsformatTogglezplot()
{
	// TODO: Add your command handler code here
	if (!dig.isDigitizing) return;
	if (cd.coord.isDistanceDisplay) {
		gIsZplotFormat = !gIsZplotFormat;
		if (gIsZplotFormat)
			AfxMessageBox(_T("ZPlot format support is turned on."), MB_ICONQUESTION);
		else
			AfxMessageBox(_T("ZPlot format support is turned off."), MB_ICONQUESTION);
	}
	else {
		AfxMessageBox(_T("ZPlot format support only works in time-distance domain."), MB_ICONQUESTION);
	}

}

void CSeisWideDoc::OnDigitizingSavedig()
{
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	bool isXInt = cd.coord.isTraceMode();
	CDigitize pDg;
	CString tStr;
	if (dig.totCurve > 0 && dig.isDigitizing) {
		//if (dig.totCurve < 1 || dig.nPoint == NULL || dig.nPoint[0] < 1) return;
		if (dig.digName.Trim().IsEmpty()) {
			dig.digName = getWorkingPathSlash() + _T("digX.txt");
		}

		// note: dig.digName may be empty, or may have a .shp or .in extension
		tStr = dig.digName;
		if (!dig.isZeltFormat) {
			dig.digName = SetFileExtension(dig.digName, _T("txt"));
			pDg.myDigSaveAs2(&dig, isXInt);
		}
		else {
			// now save for Zelt format
			dig.digName = SetFileExtension(dig.digName, _T("in"));
			pDg.myDigSaveAsZelt(&dig, dig.xShotCache, cd.coord.isMinusXShot);
			//pDg.myDigSaveAsZeltFFID(&dig, dig.xShotCache, cd.coord.isMinusXShot,
			//	head.numTraces, head.traces, head.dist, head.ffid, head.offsets);
		}

		if (isFileExistNotDirectory(dig.digName))
			pFrame->myCaption(_T("Digitizing saved successfuly."));
		// showFileInNotePad(dig.digName);
		dig.digName = tStr;
	}

	if (digMarker.totCurve > 0 && digMarker.isDigitizing) {
		//if (digMarker.totCurve < 1 || digMarker.nPoint == NULL || digMarker.nPoint[0] < 1) return;
		if (digMarker.digName.Trim().IsEmpty()) {
			digMarker.digName = getWorkingPathSlash() + _T("digMarker.txt");
		}
		// note: dig.digName may be empty, or may have a .shp extension
		tStr = digMarker.digName;
		pDg.myDigSaveAs2(&digMarker, isXInt);
		if (isFileExistNotDirectory(digMarker.digName))
			pFrame->myCaption(_T("Digitizing saved successfuly."));
		// showFileInNotePad(digMarker.digName);
		digMarker.digName = tStr;
	}

}


void CSeisWideDoc::OnDigitizingShowfile()
{
	OnDigitizingSavedig();

	if (digMarker.isDigitizing && isFileExistNotDirectory(digMarker.digName))
		showFileInNotePad(digMarker.digName);
	else if (dig.isDigitizing && isFileExistNotDirectory(dig.digName))
		showFileInNotePad(dig.digName);
}


void CSeisWideDoc::OnDigitizeFinishdigitizing()
{
	if (!dig.isDigitizing && !digMarker.isDigitizing) return;
	bool isSave = false;
	if (AfxMessageBox(_T("Save the digitizing results before finish?"), 
		MB_YESNO | MB_ICONQUESTION | MB_ICONQUESTION) == IDYES)
		isSave = true;

	if (digMarker.isDigitizing && isModelVisible(&velMod, 0.))
		draw.isNoNodes = FALSE; // nodes was set off avoid too many nodes showing in screen


	int isXInt = cd.coord.isTraceMode();
	CDigitize pDg;

	if (isSave && dig.isDigitizing) {
		if (!dig.isZeltFormat) {
			dig.digName = SetFileExtension(dig.digName, _T("txt"));
			pDg.myDigSaveAs2(&dig, isXInt);
		}
		else {
			// now save for Zelt format
			dig.digName = SetFileExtension(dig.digName, _T("in"));
			pDg.myDigSaveAsZelt(&dig, dig.xShotCache, cd.coord.isMinusXShot);
			//pDg.myDigSaveAsZeltFFID(&dig, dig.xShotCache, cd.coord.isMinusXShot,
			//	head.numTraces, head.traces, head.dist, head.ffid, head.offsets);
		}
		showFileInNotePad(dig.digName);

		if (dig.totCurve == 1 && dig.nPoint[0] > 0 &&
			!dig.isZeltFormat &&
			!digMarker.isDigitizing && 
			digMarker.digName.IsEmpty()) {
			// when it is only 1 curve existing, the user might be doing it for symbols only.
			if (AfxMessageBox(_T("Do you want to treat this (single) curve as symbols."), MB_YESNO | MB_ICONQUESTION | MB_ICONQUESTION) == IDYES) {
				digMarker.digName = dig.digName;
				dig.digName = BLANK;
			}
		}
	}

	if (isSave && digMarker.isDigitizing) {
		digMarker.digName = SetFileExtension(digMarker.digName, _T("txt"));
		pDg.myDigSaveAs2(&digMarker, isXInt);
		showFileInNotePad(dig.digName);
	}

	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	pFrame->statMain.pick = pFrame->statMain.add = pFrame->statMain.move = pFrame->statMain.remove = 0;

	if (!isSave) {
		// if not saved, and the digi file does not exist, we do not want 
		// show the lines/points any more. This is useful when 
		// we assign bitmap coords and the digitized points are no more useful.
		if (dig.isDigitizing && !isFileExistNotDirectory(dig.digName)) {
			dig.freeDigAll();
		}
		else if (digMarker.isDigitizing && !isFileExistNotDirectory(digMarker.digName)) {
			digMarker.freeDigAll();
		}
	}

	dig.isDigitizing = digMarker.isDigitizing = FALSE;

}

void CSeisWideDoc::OnDigitizingChangecurveres()
{
	// for Zelt format only
	//use this routine to update the resolution for the currently digitized curve.
	CDigitize::DIGITIZE *pDig = NULL;
	if (dig.isDigitizing && dig.nPoint != NULL)
		pDig = &dig;
	else if (digMarker.isDigitizing && digMarker.nPoint != NULL)
		pDig = &digMarker;
	else
		return;


	CdlgDigResolution dlg;
	dlg.m_digResolution = pDig->curveVal[pDig->iCurveSel];
	dlg.m_ivray = pDig->ivray[pDig->iCurveSel];
	dlg.m_nCurve = pDig->iCurveSel; // dlg.m_nCurve is actually the curve seq. number starting from 0

	CDigitize pDg;
	CString tStr;
	if (dlg.DoModal() == IDOK)
	{
		pDig->curveVal[pDig->iCurveSel] = dlg.m_digResolution;

		for (int i = 0; i < pDig->totCurve; i++) {
			if (i == pDig->iCurveSel) continue;
			int j = pDig->ivray[i];
			if (j == dlg.m_ivray) {
				// Another curve already is using the same ray code. In this case, we can let the curve 
			}
		}
		pDig->ivray[pDig->iCurveSel] = dlg.m_ivray;
	}
	UpdateAllViews(NULL);
	NotifyChanged();
}

void CSeisWideDoc::OnDigitizingWhereani()
{
	CDigitize::DIGITIZE *pDig = NULL;
	if (dig.isDigitizing && dig.nPoint != NULL)
		pDig = &dig;
	else if (digMarker.isDigitizing && digMarker.nPoint != NULL)
		pDig = &digMarker;
	else
		return;

	TCHAR s[80];
	_stprintf_s(s, _T("You have so far digitized %d points for curve %d for a total of %d curves"), 
		pDig->nPoint[pDig->iCurveSel], pDig->iCurveSel, pDig->totCurve);
	AfxMessageBox(s);
}

void CSeisWideDoc::OnDigitizingSelectCurrent()
{
	//use this routine to select a different curve to activate.
	CDigitize::DIGITIZE *pDig = NULL;
	if (dig.isDigitizing && dig.nPoint != NULL)
		pDig = &dig;
	else if (digMarker.isDigitizing && digMarker.nPoint != NULL)
		pDig = &digMarker;
	else
		return;

	CdlgDigSelectCurrent dlg;
	dlg.m_selectCurrent = pDig->iCurveSel;

	// Now if the last curve has no points digitized, don't count it as total
	if (pDig->nPoint[pDig->totCurve - 1] == 0)
		dlg.m_total = pDig->totCurve - 1;
	else
		dlg.m_total = pDig->totCurve;

	if (dlg.DoModal() == IDOK)
	{
		if (dlg.m_selectCurrent < 0) dlg.m_selectCurrent = 0;
		else if (dlg.m_selectCurrent >= pDig->totCurve) {
			OnDigitizingNewcurve();
		}
		else {
			pDig->iCurveSel = dlg.m_selectCurrent;
		}
	}

	draw.isNodeChanged = TRUE;
	draw.isSameDataDisplay = TRUE;
	UpdateAllViews(NULL);
	NotifyChanged();
}

void CSeisWideDoc::OnDigitizingShiftdigiting()
{
	CDigitize::DIGITIZE *pDig = NULL;
	if (dig.isDigitizing && dig.nPoint != NULL)
		pDig = &dig;
	else if (digMarker.isDigitizing && digMarker.nPoint != NULL)
		pDig = &digMarker;
	else
		return;
	if (pDig->totCurve < 1) return;

	float dx = 0.f, dt = 0.f;
	static float x1 = 0.f;
	static float x2 = 0.f;
	CdlgDigitizeShift dlg;
	dlg.m_x1 = x1;
	dlg.m_x2 = x2;
	if (dlg.DoModal() == IDOK)
	{
		dx = dlg.m_dx;
		dt = dlg.m_dt;
		x1 = dlg.m_x1;
		x2 = dlg.m_x2;
	}
	else return;

	CDigitize pDg;
	if (pDig->totCurve > 0)
		pDg.myDigShift(&dig, dx, dt, x1, x2, pDig->iCurveSel);

	UpdateAllViews(NULL);
}


void CSeisWideDoc::OnDigitizingSplit()
{
	double xSplit = 0.;
	CdlgInputValie dlg;
	CDigitize pDg;

	if (dig.isDigitizing && dig.nPoint != NULL) {
		if (dlg.DoModal() == IDOK) {
			xSplit = (double)dlg.m_value;
			if (pDg.digSplitCurve(&dig, dig.iCurveSel, xSplit)) {
				draw.isSameDataDisplay = TRUE;
				UpdateAllViews(NULL);
				NotifyChanged();
			}
		}
	}
	else if (digMarker.isDigitizing && digMarker.nPoint != NULL) {
		if (dlg.DoModal() == IDOK) {
			xSplit = (double)dlg.m_value;
			if (pDg.digSplitCurve(&digMarker, digMarker.iCurveSel, xSplit)) {
				draw.isSameDataDisplay = TRUE;
				UpdateAllViews(NULL);
				NotifyChanged();
			}
		}
	}
}


void CSeisWideDoc::OnDigitizingChangeerrorbarRedefinesource()
{
	// only Zelt's format can define source position
	if (!dig.isDigitizing || dig.nPoint == NULL || !dig.isZeltFormat) return;
	if (!draw.timeSecName.IsEmpty()) {
		CSegyMeta::segyHeadInit(draw.timeSecName, &head);
		//dig.xShotCache = (float)head.xshotInSegy;
	}
	double xShotOld = dig.xShotCache;
	CDigitize pDg;

	CdlgDigitize dlg1;
	dlg1.m_digName = dig.digName;
	//	dlg.m_digFileFormat = dig.fileFormat;
	dlg1.m_xs = (float)xShotOld;
	dlg1.m_digFileFormat = 1;
	dlg1.m_mode = 1;  //disable some items.
	if (dlg1.DoModal() == IDOK)
	{
		dig.xShotCache = dlg1.m_xs;
	}
	else return;
	delete dlg1;

	// when displaying as distance should the x be shifted according to source
	// when displaying as offset? We still do the same
	for (int i = 0; i < dig.totCurve; i++) {
			for (int j = 0; j < dig.nPoint[i]; j++) {
				dig.x[j][i] += (float)(dig.xShotCache - xShotOld);
			}
	}
	pDg.myDigSaveAsZelt(&dig, dig.xShotCache, cd.coord.isMinusXShot);

	draw.isSameDataDisplay = FALSE;
	UpdateAllViews(NULL);
	NotifyChanged();
}

void CSeisWideDoc::OnDigitizingChangeerrorbarAsBar()
{
	// TODO: Add your command handler code here
	if (!dig.isDigitizing) return;
	dig.zeltBarForm = 0;
	UpdateAllViews(NULL);
	NotifyChanged();

}

void CSeisWideDoc::OnDigitizingChangeerrorbarAscircle()
{ //open circles.
	if (!dig.isDigitizing) return;
	dig.zeltBarForm = 1;
	//	draw.isSameDataDisplay = FALSE;
	UpdateAllViews(NULL);
	NotifyChanged();

}

void CSeisWideDoc::OnDigitizingChangeerrorbarAsfillcircle()
{ //filled circles.
	if (!dig.isDigitizing) return;
	dig.zeltBarForm = 2;
	//	draw.isSameDataDisplay = FALSE;
	UpdateAllViews(NULL);
	NotifyChanged();

}

void CSeisWideDoc::OnDigitizingChangeerrorbarAsstar()
{
	if (!dig.isDigitizing) return;
	dig.zeltBarForm = 3;
	//	draw.isSameDataDisplay = FALSE;
	UpdateAllViews(NULL);
	NotifyChanged();

}


BOOL CSeisWideDoc::rayIntersect(double a, double b, int nx, double xmin, double dx, double *x4, double *z4, double *aBar, float *zCont)
{
	//a routine to calculate intersect point of a curve defined by 
	// zCont[x], where x=xmin, xmin+dx, ...xmin+(nx-1)*dx with dx>0.
	// It intersects with a straight line defined by Z=aX+b.
	// Output the coordinates (x3, z3). aBar is also output for later usage.
	// if return FALSE. no intersecting point exists.

	//if a is infinite (i.e. 99999), then the incident ray is x=b.

	int ix;
	double x1, x2, z1, z2, bBar;

	*x4 = *z4 = 99999.;
	for (ix = 0; ix<nx - 1; ix++)
	{
		x1 = xmin + dx*(double)ix;
		x2 = x1 + dx;
		z1 = zCont[ix];
		z2 = zCont[ix + 1];
		*aBar = (z2 - z1) / (x2 - x1);
		bBar = z1 - *aBar*x1;
		if (fabs(a)>99998.)
		{ //incident ray is x=const=b.
			if (b<x1 || b>x2) continue;
			*x4 = b;
			*z4 = (*aBar)*(*x4) + bBar;
			break;
		}
		else if (fabs(*aBar - a) < 0.00001)
		{  //the two line segments are parallel.
			continue;
		}
		else
		{
			*x4 = -(bBar - b) / (*aBar - a);
			*z4 = a*(*x4) + b;
			if (*x4<x1 || *x4>x2) continue;
			else break;
		}
	}

	//now the intersection point is found.
	if (fabs(*x4 - 99999.) < 0.1 && fabs(*z4 - 99999.) < 0.1)
		return FALSE;
	else
		return TRUE;
}

float CSeisWideDoc::GetContourDepth(float *zContour, int nx, double x0, double xmin, double dx)
{
	//given zContour[ix], ix=0..nx-1, x=xmin+ix*dx, return depth at x0.
	int ix;
	double x;
	for (ix = 0; ix < nx - 1; ix++)
	{
		x = xmin + dx*ix;
		if (x0 >= x && x0 <= (x + dx))
			return (float)(zContour[ix] + (zContour[ix + 1] - zContour[ix])*(x0 - x) / dx);
	}
	AfxMessageBox(_T("Source not inside the model"), MB_ICONQUESTION);
	return 99999.f;
}


void CSeisWideDoc::OnDigitizingMigratelinedrawings()
{
	return;

	//this routine migrates line-drawings.
	if (!dig.isDigitizing)
	{
		AfxMessageBox(_T("Only migrate during digitizing; try start a new digitizing or loading existing digitizing file first"), MB_ICONQUESTION);
		return;
	}

	if (!CheckTime(100)) return;

	//Generate velocity contours.
	int icont, ix, iv, ivRefl, nv, nx, nvLayer[MOD_LAYER_MAX], numTracing, maxTrc, nLayerMig, leftRight, iCurve, iPt, icontRefl;
	double sDepth, theta, thetaDn, thetaDnOld, thetaUp, sinTheta, amin, amax;
	double a, aBar, b, t, t1, t2, t3, tUp, x, x1, x3, x4, xUp, v, v1, v2, dv, z, z3, z4, zUp, temp, xmin, xmax, vminLayer[MOD_LAYER_MAX], vmaxLayer[MOD_LAYER_MAX];
	double oldxArriv1, oldxArriv2, oldtArriv1, oldtArriv2;
	float ***zContour, **tArrival, **angRefl, depthTune[500], depthTune1[500], depthTune2[500], aamin, aamax, xArrivErr, tArrivErr;
	FILE *stream;
	BOOL upToRight, mAppend, rayStop, rayUpStop, rayFound, reflFound;
	CString migName;

	OnDigitizeFinishdigitizing(); //save the points and finish digitizing.
	//MyInitVel();  //discard current (if any) model, initilize given model for velMod.
	if (velMod.ncont > 40)
	{
		AfxMessageBox(_T("Too many layers in the velocity model"), MB_ICONQUESTION);
		return;
	}

	CdlgMigLineDraw dlg;
	dlg.m_velName = velMod.velSecName;
	dlg.m_dv = (velColor.dv > 0.001) ? (float)velColor.dv : 0.1f;
	dlg.m_nLayer = 5;
	dlg.m_sDepth = 4.f;
	dlg.m_dxv = (float)velColor.dxVDesired;
	dlg.m_sDist = (float)tx.xShotRay;
	dlg.m_migName = velMod.velSecName + _T("Mig.txt");

	if (dlg.DoModal() == IDOK)
	{
		aamax = (float)dlg.m_aamax;  //using (float) to cut string length
		aamin = (float)dlg.m_aamin;
		dv = velColor.dv = (float)dlg.m_dv;
		velColor.dxVDesired = (float)dlg.m_dxv;
		maxTrc = dlg.m_maxTrc;
		nLayerMig = dlg.m_nLayer;
		sDepth = (float)dlg.m_sDepth;
		tx.xShotRay = (float)dlg.m_sDist;
		xArrivErr = (float)dlg.m_xErr;
		tArrivErr = (float)dlg.m_tErr;
		velMod.velSecName = dlg.m_velName.Trim();
		migName = dlg.m_migName;
		mAppend = dlg.m_append;
	}
	else return;
	delete dlg;

	CVelMod vm;
	vm.myVelModInterpolDisplay(&velMod, velMod.getXmin(), velMod.getXmax(), draw.distShift, velColor.dxVDesired);
	//calculate velocity interpolation for the whole model based on velMod.

	nx = velMod.grdNx;  //nx was calculated by myWoleVelModInterpol().
	xmin = velMod.xm[0][0];
	xmax = velMod.xm[velMod.nzed[0] - 1][0];

	int ifopenReturned;
	if (mAppend)
		ifopenReturned = _tfopen_s(&stream, migName, _T("a+")); //open for reading and appending
	else
		ifopenReturned = _tfopen_s(&stream, migName, _T("w")); //open for reading and appending
	if (ifopenReturned != 0)
	{
		AfxMessageBox(_T("New mig file could not open"), MB_ICONQUESTION);
		return;
	}

	nv = 0;
	for (icont = 0; icont < velMod.ncont - 1; icont++)
	{
		for (ix = 0; ix < nx; ix++) {
			velMod.vTop[icont][ix] = vm.velModUpdAnisotropy((float)velMod.vTop[icont][ix], velMod.anisotropy[icont]);
			velMod.vBot[icont][ix] = vm.velModUpdAnisotropy((float)velMod.vBot[icont][ix], velMod.anisotropy[icont]);
		}

		//Find the min and max vel for this layer.
		vminLayer[icont] = 99999.;
		for (ix = 0; ix<nx; ix++)
			if (vminLayer[icont]>velMod.vTop[icont][ix]) vminLayer[icont] = velMod.vTop[icont][ix];
		for (ix = 0; ix<nx; ix++)
			if (vminLayer[icont]>velMod.vBot[icont][ix]) vminLayer[icont] = velMod.vBot[icont][ix];
		vmaxLayer[icont] = 0.;
		for (ix = 0; ix < nx; ix++)
			if (vmaxLayer[icont] < velMod.vTop[icont][ix]) vmaxLayer[icont] = velMod.vTop[icont][ix];
		for (ix = 0; ix < nx; ix++)
			if (vmaxLayer[icont] < velMod.vBot[icont][ix]) vmaxLayer[icont] = velMod.vBot[icont][ix];

		nvLayer[icont] = (int)((vmaxLayer[icont] - vminLayer[icont]) / dv + 1.999);
		nv = max(nv, nvLayer[icont]);
		if (nvLayer[icont] < 2) nvLayer[icont] = 2;
	}

	// Now define an array to hold all the vel contours, zContour[icont][iv][ix],
	//where icont=0..velMod.nlayer-1, iv=0..nv-1, ix=0..nx-1. nv is dynamic.
	zContour = (float ***)alloc3float(nx, nv, velMod.ncont - 1); //a small array.
	if (zContour == NULL)
	{
		AfxMessageBox(_T("Unable to allocate memory for zContour array"));
		return;
	}

	//For each velocity contour, calculate for the right depth for each x.
	for (icont = 0; icont < velMod.ncont - 1; icont++)
	{
		//Loop through vel contours for this layer and store zContour[icont][nv][nx].
		for (iv = 0; iv < nvLayer[icont]; iv++)
		{
			v = vminLayer[icont] + iv*dv;

			//Search by interpolation for the curve for v in layer icont.
			for (ix = 0; ix < nx; ix++)
			{
				temp = velMod.vBot[icont][ix] - velMod.vTop[icont][ix];
				if (velMod.grdDepth[icont + 1][ix] < velMod.grdDepth[icont][ix]) a = velMod.grdDepth[icont + 1][ix];
				else if (fabs(temp) < 0.001)
				{
					//const vel, odd fix.
					if (nvLayer[icont] == 2 && iv == 0) a = velMod.grdDepth[icont][ix];
					else if (nvLayer[icont] == 2 && iv == 1) a = velMod.grdDepth[icont + 1][ix];
					else if (fabs(v - velMod.vTop[icont][ix]) <= dv) a = velMod.grdDepth[icont][ix];
					else if (iv <= nvLayer[icont] - 1) a = velMod.grdDepth[icont][ix];
					else a = velMod.grdDepth[icont + 1][ix];
				}
				else
					a = velMod.grdDepth[icont][ix] + (velMod.grdDepth[icont + 1][ix] - velMod.grdDepth[icont][ix])
					*(v - velMod.vTop[icont][ix]) / temp;
				if (a < velMod.grdDepth[icont][ix]) a = velMod.grdDepth[icont][ix];
				if (a > velMod.grdDepth[icont + 1][ix]) a = velMod.grdDepth[icont + 1][ix];
				if (a < 0) a = 0.;
				//		if(a>cd.coord.zmax) a=cd.coord.zmax;
				zContour[icont][iv][ix] = (float)a;
			}
		} //End of loop iv.
	}  //End of loop icont.

	tArrival = (float **)alloc2float(nv, velMod.ncont - 1); //a small array.
	angRefl = (float **)alloc2float(nv, velMod.ncont - 1);

	if (tArrival == NULL || angRefl == NULL)
	{
		free3float(zContour);
		AfxMessageBox(_T("Unable to allocate memory for ray tracing"));
		return;
	}

	for (iCurve = 0; iCurve < dig.totCurve; iCurve++)
	{
		for (iPt = 0; iPt < dig.nPoint[iCurve]; iPt++)
		{ //search for a xArrival and tArrival to match dig.x and dig.t.
			x1 = dig.x[iPt][iCurve];
			t1 = dig.t[iPt][iCurve];
			//(x1,t1) is the observed point.
			if (x1 < tx.xShotRay) leftRight = 0;
			else leftRight = 1;
			reflFound = TRUE;
			for (icontRefl = 0; icontRefl < velMod.ncont - 1; icontRefl++)
				for (ivRefl = 0; ivRefl < nvLayer[icontRefl]; ivRefl++) {
					amin = aamin; //amin and amax will change down a ray to find the correct angle.
					amax = aamax; //but aamin,aamax never change.
					theta = amin; //thetaDn shall be updated while going down.
					numTracing = 1;  //num of ray tracing performed.
					rayFound = TRUE; //indicate successful raytracing.
					temp = GetContourDepth(zContour[icontRefl][ivRefl], nx, (double)tx.xShotRay, xmin, velColor.dxVDesired);
					if (temp < sDepth) continue;
					if (ivRefl == nvLayer[icontRefl] - 1) {
						temp = 1.; //for testing.
					}
					do
					{ //loop to find the correct theta to match  dig.x[iPt][iCurve];
						x = tx.xShotRay;  //ray initially at source position.
						z = sDepth; //ray initially at source depth.
						t = 0.;  // at source the time is 0.
						thetaDn = theta;  //theta doesn't change as ray going down. But thetaDn changes.
						rayStop = FALSE;

						//For each reflector contour [ivRefl][icontRefl], a ray goes thru all layers above.
						// assume const vel within that contour.
						for (icont = 0; icont <= icontRefl; icont++)
							for (iv = 0; iv < nvLayer[icont]; iv++)
							{
								if (rayStop) break;
								if (icont == icontRefl) {
									temp = 1.;
								}

								if (icont == icontRefl && iv > ivRefl) break;

								//only start adding up to x,z,t when contour is below source.
								temp = GetContourDepth(zContour[icont][iv], nx, (double)tx.xShotRay, xmin, velColor.dxVDesired);
								if (temp < sDepth) continue;

								//get the formula for the ray curve Z=aX+b that passes thru point (x, z).
								a = ctan(thetaDn*PIO);
								if (a > 99998.) b = x;
								else {
									if (leftRight == 0) a = -a;
									b = z - a*x;
								}
								// determine (x3,z3) where the ray impinges contour zContour[icont][iv][ix].
								if (!rayIntersect(a, b, nx, xmin, velColor.dxVDesired, &x3, &z3, &aBar, zContour[icont][iv])) { //no intersecting point exist.
									rayStop = TRUE;
									break;
								}

								//v2 is angle of ray after below into the contour
								v2 = vminLayer[icont] + (iv + 0.5)*dv; //v2 is the average vel within the contour
								if (v2 > vmaxLayer[icont]) v2 = vmaxLayer[icont];
								if (iv == 0 && icont == 0) v1 = v2; //source at surface.
								else if (iv == 0) v1 = vmaxLayer[icont - 1];  //ray impinges at top of layer.
								else v1 = v2 - dv;  //ray inside a layer.
								t += sqrt((x3 - x)*(x3 - x) + (z3 - z)*(z3 - z)) / v1;
								x = x3; z = z3;

								sinTheta = v2 / v1*sin(thetaDn*PIO);
								if (fabs(sinTheta) > 0.99999) //rays cannot go down. Do something!!!
								{ //no intersecting point exist.
									rayStop = TRUE;
									break;
								}
								thetaDnOld = thetaDn;  //thetaOld is that before transmission.
								thetaDn = asin(sinTheta)*OPI; //update thetaDn after thru the contour.
							} //end of loop for iv & icont.

						//to trace back to surface for contour ivRefl. first get the reflecting angle.
						if (aBar >= 0) {
							thetaUp = 2.*atan(aBar)*OPI + thetaDnOld; //no change if leftRight changes.
							upToRight = TRUE; //reflects to the right.
						}
						else {
							thetaUp = 2.*atan(fabs(aBar))*OPI - thetaDnOld; //no change if leftRight changes.
							if (thetaUp > 0) upToRight = FALSE; //reflects to the left.
							else {
								upToRight = TRUE; //reflects to the right.
								thetaUp = -thetaUp; //make it positive.
							}
						}
						xUp = x;
						zUp = z;
						tUp = t;
						rayUpStop = FALSE;

						// now back trace.
						//first, trace thru all contours of the same layer above the active one.
						//Need to consider reflecting rays going downwards??? or even upward refl rays 
						// hitting contours deeper than ivRefl which is totally possible ???
						for (iv = ivRefl - 1; iv >= 0; iv--) {
							if (rayStop) break;
							if (upToRight) a = -ctan(thetaUp*PIO); //for reflections should be minus.
							else a = ctan(thetaUp*PIO);
							if (a > 99998.) b = xUp;
							else {
								if (leftRight == 0) a = -a;
								b = zUp - a*xUp;
							}
							if (!rayIntersect(a, b, nx, xmin, velColor.dxVDesired, &x4, &z4, &aBar, &zContour[icontRefl][iv][0])) { //no intersecting point exist.
								rayUpStop = TRUE;
								break;
							}
							v1 = vminLayer[icontRefl] + (iv + 0.5)*dv; //v1 is the average vel within the contour
							if (v1 > vmaxLayer[icontRefl]) v1 = vmaxLayer[icontRefl];
							tUp += sqrt((xUp - x4)*(xUp - x4) + (zUp - z4)*(zUp - z4)) / v1;
							xUp = x4;
							zUp = z4;
							if (iv == 0 && icontRefl == 0) v2 = v1; //ray reach surface.
							else if (iv == 0) v2 = vmaxLayer[icontRefl - 1];  //ray impinges at boundary.
							else v2 = v1 - dv;  //ray inside a layer
							temp = sin(thetaUp*PIO)*v2 / v1;
							if (fabs(temp) > 0.999999) { //no intersecting point exist.
								rayUpStop = TRUE;
								break;
							}
							else
								thetaUp = OPI * asin(temp);
						}
						for (icont = icontRefl - 1; icont >= 0; icont--) { //now loop thru all layers above.
							if (rayStop || rayUpStop) break;
							for (iv = nvLayer[icont] - 1; iv >= 0; iv--) {
								a = -ctan(thetaUp*PIO); //for reflections should be minus.
								if (a > 99998.) b = xUp;
								else {
									if (leftRight == 0) a = -a;
									b = zUp - a*xUp;
								}
								if (!rayIntersect(a, b, nx, xmin, velColor.dxVDesired, &x4, &z4, &aBar, zContour[icont][iv])) { //no intersecting point exist.
									rayUpStop = TRUE;
									break;
								}
								v1 = vminLayer[icont] + (iv + 0.5)*dv; //v1 is the average vel within the contour
								if (v1 > vmaxLayer[icont]) v1 = vmaxLayer[icont];
								tUp += sqrt((xUp - x4)*(xUp - x4) + (zUp - z4)*(zUp - z4)) / v1;
								xUp = x4;
								zUp = z4;
								if (iv == 0 && icont == 0) v2 = v1; //ray reach surface.
								else if (iv == 0) v2 = vmaxLayer[icont - 1];  //ray impinges at boundary.
								else v2 = v1 - dv;  //ray inside a layer
								temp = sin(thetaUp*PIO)*v2 / v1;
								if (fabs(temp) > 0.999999)
								{ //no intersecting point exist.
									rayUpStop = TRUE;
									break;
								}
								else
									thetaUp = OPI * asin(temp);
								if (numTracing == 3) {
									//		_ftprintf_s(stream,"icontRefl,ivRefl,icont,iv,t,x,z=%9d %9d %9d %9d %9.3f %9.3f %9.3f\n",icontRefl,ivRefl,icont,iv,tUp,xUp,zUp);
								}
							} //end of iv loop.
						}  //end of icont loop. Finishing ray tracing for refl contour iv and icont.
						if (numTracing == 1) {
							if (rayStop || rayUpStop) {
								if (leftRight == 0) xUp = -99999.;
								else xUp = 99999.;
							}
							theta = aamax;
							oldxArriv1 = xUp;
							numTracing = 2;
						}
						else if (numTracing == 2) {
							if (rayStop || rayUpStop) {
								if (leftRight == 0) xUp = -99999.;
								else xUp = 99999.;
							}
							oldxArriv2 = xUp;
							theta = (aamax + aamin)*0.5; //assume only trace to the right side.
							numTracing = 3;
						}
						else {
							if (rayStop || rayUpStop) { //the current theta of ray does not reach reflector ivRefl.
								//therefore the amax should be smaller.
								amax = theta;
								if (leftRight == 0) oldxArriv2 = -99999.;
								else oldxArriv2 = 99999.;
							}
							if (oldxArriv1 > oldxArriv2) { //make sure oldxArriv1 is always smaller than oldxArriv2.
								temp = oldxArriv1;
								oldxArriv1 = oldxArriv2;
								oldxArriv2 = temp;
								temp = amin;
								amin = amax;
								amax = temp;
								//now amax can be smaller than amin.
							}
							if (xUp < oldxArriv1) {
								oldxArriv1 = xUp;
								amin = theta;
							}
							else if (xUp > oldxArriv2) {
								oldxArriv2 = xUp;
								amax = theta;
							}
							else if (x1 >= oldxArriv1 && x1 <= xUp) //x1 = dig.x[iPt][iCurve];
							{
								oldxArriv2 = xUp;
								amax = theta;
							}
							else if (x1 >= xUp && x1 <= oldxArriv2) {
								oldxArriv1 = xUp;
								amin = theta;
							}
							else
							{ //no ray exist.
								AfxMessageBox(_T("Should not be here"));
								rayFound = FALSE;
								break; //break the do...while loop.
							}
							theta = (amax + amin)*0.5; //assume only trace to the right side.
							if (numTracing > maxTrc) {
								rayFound = FALSE;
								break; //break the do...while loop.
							}
							numTracing++;
						} //end if for numTracing.
					} while ((fabs(x1 - xUp) > (double)xArrivErr)); //end of do loop for theta.
					if (!rayFound)
						//a proper ray can not be found.
						t = x = z = tArrival[icontRefl][ivRefl] = angRefl[icontRefl][ivRefl] = 99999.f;
					else
					{
						tArrival[icontRefl][ivRefl] = (float)tUp;
						angRefl[icontRefl][ivRefl] = (float)theta;  //save this angle for later use.
						if (angRefl[icontRefl][ivRefl] < 0) { //it happens, do something!
							AfxMessageBox(_T("Incidence angle minus"), MB_ICONQUESTION);
						}
					} //end if statement
					_ftprintf(stream, _T("%9d %9d t,theta,xUp,x1=%9.3f %9.3f %9.3f %9.3f\n"), icontRefl, ivRefl, tArrival[icontRefl][ivRefl], angRefl[icontRefl][ivRefl], xUp, x1);
				} //end ivRefl & icontRefl loop.

			//Find the best [ivRefl, ivRefl+1] in icontRefl to match dig.t.
			//Note that icontRefl must be closest to given value nLayerMig (counting from 1 at surface!).
			// note cases when xArrival[icont][ivRefl]==99999. should break.
			reflFound = FALSE;
			for (icontRefl = nLayerMig - 1; icontRefl < velMod.ncont - 1; icontRefl++)
			{
				for (ivRefl = 0; ivRefl < nvLayer[icontRefl] - 1; ivRefl++)
				{
					temp = GetContourDepth(zContour[icontRefl][ivRefl], nx, (double)tx.xShotRay, xmin, velColor.dxVDesired);
					if (temp < sDepth) continue;
					t2 = tArrival[icontRefl][ivRefl];
					t3 = tArrival[icontRefl][ivRefl + 1];
					//consider cases where angRefl or tArrival is 99999.
					if (fabs(t2 - 99999.) < 0.01) break;
					if (fabs(angRefl[icontRefl][ivRefl] - 99999.) < 0.01) break;
					if ((t1 >= t2 && t1 <= t3) || (t1 >= t3 && t1 <= t2))
					{
						reflFound = TRUE;
						break;
					}
				}
				if (reflFound) break;
			}
			if (!reflFound) continue; //this (x1,t1) cannot be migrated.

			//now fine tune in between [ivRefl, ivRefl+1] to match dig.t.
			//We know that a proper reflector exists!
			//	if(t1<tx.xShotInSegy) ...;
			for (ix = 0; ix < nx; ix++)
			{
				depthTune1[ix] = zContour[icontRefl][ivRefl][ix];
				depthTune2[ix] = zContour[icontRefl][ivRefl + 1][ix];
			}

			oldtArriv1 = tArrival[icontRefl][ivRefl];
			oldtArriv2 = tArrival[icontRefl][ivRefl + 1];
			do
			{ // fine tune loop for depth.
				//first get a new depth array.
				for (ix = 0; ix < nx; ix++)
					depthTune[ix] = (float)(depthTune1[ix] + depthTune2[ix])*0.5f;
				amin = angRefl[icontRefl][ivRefl]; //will change during raytracing to find the correct angle.
				amax = angRefl[icontRefl][ivRefl + 1]; //but aamin,aamax never change.
				theta = amin; //thetaDn shall be updated while going down.
				numTracing = 1;  //Num of raytracing performed: 1: first, 2: second; 3:others.
				rayFound = TRUE; //indicate successful raytracing.
				do
				{ //loop to find the correct theta to match  dig.x[iPt][iCurve];
					x = tx.xShotRay;  //ray initially at source position.
					z = sDepth; //ray initially at source depth.
					t = 0.;  // at source the time is 0.
					thetaDn = theta;  //theta doesn't change as ray going down. But thetaDn changes.
					rayStop = FALSE;

					//raytracing must start from the surface, assuming const vel within that contour.
					for (icont = 0; icont <= icontRefl; icont++)
						for (iv = 0; iv < nvLayer[icont]; iv++)
						{
							if (rayStop) break;

							//only start adding up to x,z,t when contour is below source.
							temp = GetContourDepth(zContour[icont][iv], nx, (double)tx.xShotRay, xmin, velColor.dxVDesired);
							if (temp < sDepth) continue;

							//get the formula for the ray curve Z=aX+b that passes thru point (x, z).
							a = ctan(thetaDn*PIO);
							if (a > 99998.) b = x;
							else
							{
								if (leftRight == 0) a = -a;
								b = z - a*x;
							}

							// determine (x3,z3) where the ray impinges contour zContour[icont][iv][ix].
							if (icont == icontRefl && iv > ivRefl) break;
							else if (icont == icontRefl)
							{
								if (!rayIntersect(a, b, nx, xmin, velColor.dxVDesired, &x3, &z3, &aBar, depthTune))
								{ //no intersecting point exist.
									rayStop = TRUE;
									break;
								}
							}
							else
							{
								if (!rayIntersect(a, b, nx, xmin, velColor.dxVDesired, &x3, &z3, &aBar, zContour[icont][iv]))
								{ //no intersecting point exist.
									rayStop = TRUE;
									break;
								}
							}

							//angle of ray after below into the contour
							v2 = vminLayer[icont] + (iv + 0.5)*dv; //v2 is the average vel within the contour
							if (v2 > vmaxLayer[icont]) v2 = vmaxLayer[icont];
							if (iv == 0 && icont == 0) v1 = v2; //source at surface.
							else if (iv == 0) v1 = vmaxLayer[icont - 1];  //ray impinges at top of layer.
							else v1 = v2 - dv;  //ray inside a layer.
							t += sqrt((x3 - x)*(x3 - x) + (z3 - z)*(z3 - z) / v1);
							x = x3; z = z3;

							sinTheta = v2 / v1*sin(thetaDn*PIO);
							if (sinTheta > 0.99999) //rays cannot go down. Do something!!!
							{ //no intersecting point exist.
								rayStop = TRUE;
								break;
							}
							thetaDnOld = thetaDn;  //thetaOld is that before transmission.
							thetaDn = asin(sinTheta)*OPI; //update thetaDn after thru the contour.
						} //end of loop for iv & icont.

					//to trace back to surface for contour iv. first get the reflecting angle.
					if (aBar >= 0)
					{
						thetaUp = 2.*atan(aBar)*OPI + thetaDnOld; //no change if leftRight changes.
						upToRight = TRUE; //reflects to the right.
					}
					else
					{
						thetaUp = 2.*atan(fabs(aBar))*OPI - thetaDnOld; //no change if leftRight changes.
						if (thetaUp > 0) upToRight = FALSE; //reflects to the left.
						else
						{
							upToRight = TRUE; //reflects to the right.
							thetaUp = -thetaUp; //make it positive.
						}
					}
					xUp = x;
					zUp = z;
					tUp = t;
					rayUpStop = FALSE;

					// now back trace.
					//first, trace thru all contours of the same layer above the active one.
					for (iv = ivRefl; iv >= 0; iv--)
					{
						if (rayStop) break;
						if (upToRight) a = -ctan(thetaUp*PIO); //for reflections should be minus.
						else a = ctan(thetaUp*PIO);
						if (a > 99998.) b = xUp;
						else
						{
							if (leftRight == 0) a = -a;
							b = zUp - a*xUp;
						}
						if (!rayIntersect(a, b, nx, xmin, velColor.dxVDesired, &x4, &x4, &aBar, zContour[icontRefl][iv]))
						{ //no intersecting point exist.
							rayUpStop = TRUE;
							break;
						}
						v1 = vminLayer[icontRefl] + (iv + 0.5)*dv; //v1 is the average vel within the contour
						if (v1 > vmaxLayer[icontRefl]) v1 = vmaxLayer[icontRefl];
						tUp += sqrt((xUp - x4)*(xUp - x4) + (zUp - z4)*(zUp - z4)) / v1;
						xUp = x4;
						zUp = z4;
						if (iv == 0 && icontRefl == 0) v2 = v1; //ray reach surface.
						else if (iv == 0) v2 = vmaxLayer[icontRefl - 1];  //ray impinges at boundary.
						else v2 = v1 - dv;  //ray inside a layer
						temp = sin(thetaUp*PIO)*v2 / v1;
						if (fabs(temp) > 0.999999)
						{ //no intersecting point exist.
							rayUpStop = TRUE;
							break;
						}
						else
							thetaUp = OPI * asin(temp);
					}
					for (icont = icontRefl - 1; icont >= 0; icont--)
					{ //now loop thru all layers above.
						if (rayStop || rayUpStop) break;
						for (iv = nvLayer[icont] - 1; iv >= 0; iv--)
						{
							a = -ctan(thetaUp*PIO); //for reflections should be minus.
							if (a > 99998.) b = xUp;
							else
							{
								if (leftRight == 0) a = -a;
								b = zUp - a*xUp;
							}
							if (!rayIntersect(a, b, nx, xmin, velColor.dxVDesired, &x4, &z4, &aBar, zContour[icont][iv]))
							{ //no intersecting point exist.
								rayUpStop = TRUE;
								break;
							}
							if (iv == nvLayer[icont] - 1) v1 = vmaxLayer[icont + 1]; //icont1 is not the last layer.
							else v1 = vminLayer[icont] + (iv + 0.5)*dv; //v1 is the average vel within the contour
							if (v1 > vmaxLayer[icont]) v1 = vmaxLayer[icont];
							tUp += sqrt((xUp - x4)*(xUp - x4) + (zUp - z4)*(zUp - z4)) / v1;
							xUp = x4;
							zUp = z4;
							if (iv == 0 && icont == 0) v2 = v1; //ray reach surface.
							else if (iv == 0) v2 = vmaxLayer[icont - 1];  //ray impinges at boundary.
							else v2 = v1 - dv;  //ray inside a layer
							temp = sin(thetaUp*PIO)*v2 / v1;
							if (fabs(temp) > 0.999999)
							{ //no intersecting point exist.
								rayUpStop = TRUE;
								break;
							}
							else
								thetaUp = OPI * asin(temp);
						} //end of iv loop.
					}  //end of icont loop. Finishing ray tracing for refl contour iv and icont.
					if (rayStop || rayUpStop)
					{ //the current theta of ray does not reach reflector ivRefl.
						//therefore the amax should be smaller.
						amax = theta;
						if (leftRight == 0) oldxArriv2 = -99999.;
						else oldxArriv2 = 99999.;
					}
					if (oldxArriv1 > oldxArriv2)
					{ //make sure oldxArriv1 is always smaller than oldxArriv2.
						temp = oldxArriv1;
						oldxArriv1 = oldxArriv2;
						oldxArriv2 = temp;
						temp = amin;
						amin = amax;
						amax = temp;
						//now amax can be smaller than amin.
					}
					if (xUp < oldxArriv1)
					{
						oldxArriv1 = xUp;
						amin = theta;
					}
					else if (xUp > oldxArriv2)
					{
						oldxArriv2 = xUp;
						amax = theta;
					}
					else if (x1 >= oldxArriv1 && x1 <= xUp)
					{
						oldxArriv2 = xUp;
						amax = theta;
					}
					else if (x1 >= xUp && x1 <= oldxArriv2)
					{
						oldxArriv1 = xUp;
						amin = theta;
					}
					else
					{ //no ray exist.
						AfxMessageBox(_T("Should not be here"));
						rayFound = FALSE;
						break;
					}
					theta = (amax + amin)*0.5;
					if (numTracing > maxTrc)
					{
						rayFound = FALSE;
						break;
					}
					numTracing++;
				} while (fabs(x1 - xUp) > (double)xArrivErr); //end of fine-tune do loop for theta.
				if (!rayFound)
				{
					//ray can not trace further.
					AfxMessageBox(_T("Programing error: no ray found in fine tuning!"));
					reflFound = FALSE;
					break; //break the do loop.
				}
				else
				{
					if (t1 >= oldtArriv1 && t1 <= tUp)
					{
						oldtArriv2 = tUp;
						for (ix = 0; ix < nx; ix++)
							depthTune2[ix] = depthTune[ix];
					}
					else if (t1 >= tUp && t1 <= oldtArriv2)
					{
						oldtArriv1 = tUp;
						for (ix = 0; ix < nx; ix++)
							depthTune1[ix] = depthTune[ix];
					}
					else
					{ //no ray exist.
						AfxMessageBox(_T("Programing error: no ray found in fine tuning!"));
						reflFound = FALSE;
						break; //break the do loop.
					}
				}
			} while (fabs(t1 - tUp) > (double)tArrivErr); //end do loop for depth fine-tuning.

			//The migrated result for dig.x and dig.t is (x, z).
			if (reflFound) _ftprintf(stream, _T(" %9.3f %9.3f %9d  Migrated x-z from X-T %9.3f %9.3f\n"), x, z, iCurve, x1, t1);
		}  //end of iPt loop.
	} //end of iCurve loop.

	free3float(zContour);
	free2float(tArrival);
	free2float(angRefl);

	fclose(stream);
	showFileInNotePad(migName);
}




void CSeisWideDoc::pltFloodFill(CDC* pDC, CPoint *pPoly, int *lpPts, int np)
{
	if (np > 3)
		pDC->PolyPolygon(&pPoly[0], lpPts, np);
}


BOOL CSeisWideDoc::floodFillArr5Multi(CDC* pDC, int nx, int nt, float **xArr, float *rangeArr, double xminData, double xmaxData, double tminData, double tmaxData,
	CColorHelper::AMPCOLORDYN *ampColorDyn2)
{
//	return TRUE;
	// xminData and xmaxData, tminData and tmaxData are not used
	int actualMBPerPlotPanel = (int)getMemoryAvail();
	// to deal with large memory issues
	if (nt < 2) return FALSE;
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();

	CString tStr;
	double a;
	// bitmaps are always generated with positive ncol and nrow
	a = (xmaxData - xminData) / cd.coord.xWidth() * (double)cd.coord.logicalAxes.Width() / (double)cd.coord.device2Logical;
	int ncol = (int)ceil(a) + 1;
	a = (tmaxData - tminData) / cd.coord.yHeight() * (double)cd.coord.logicalAxes.Height() / (double)cd.coord.device2Logical;
	int nrow = (int)ceil(a) + 1;
	ncol = abs(ncol) + 1;
	nrow = abs(nrow) + 1;
	double actualMBRequired = ncol * nrow * sizeof(float) * OMIL;
	double xmin = cd.coord.xmin;
	double xmax = cd.coord.xmax;
	//double tmin = cd.coord.m_tmin;  // this causes depth section wrong. Please solve this.
	//double tmax = cd.coord.m_tmax;
	double tmin = tminData;
	double tmax = tmaxData; // Here using the complete trace length, it displays correctly, although it's slower

	BOOL isTrueOut;
	if (fabs(actualMBRequired) < actualMBPerPlotPanel)   // actualMBRequired can be minus
		//isTrueOut = CDCHelper::tessellateFill(pDC, nx, nt, xArr, rangeArr,
		//	xmin, xmax, tmin, tmax, ampColorDyn2, &cd, draw.memMaxMB);
		isTrueOut = CDCHelper::floodFillArr9(pDC, nx, nt, xArr, rangeArr,
			xmin, xmax, tmin, tmax, ampColorDyn2, &cd);
	else {
		// now split x axis for plotting
		double xincPlot = (double)actualMBPerPlotPanel / (double)(nrow * 4) * MIL * cd.coord.xWidth()
			/ (double)cd.coord.logicalAxes.Width() * (double)cd.coord.device2Logical;
		if (xincPlot < MINAMP) xincPlot = 1.; // just in case it was not calculated right
		if ((xmax - xmin) / xincPlot > 50.) {
			tStr.Format(_T("Something is wrong, as over 50 panels for plotting. Please do it again."));
			// this situ has happened a lot when the computer sleeps and wake up, and the program hangs like this.
			AfxMessageBox(tStr);
			return FALSE;
		}
		double xminPlot = xmin;
		do {
			if (xminPlot >= xmax) break;
			register double xmaxPlot = xminPlot + xincPlot;
			if (xmaxPlot > xmax) xmaxPlot = xmax;
			CDCHelper::floodFillArr9(pDC, nx, nt, xArr, rangeArr,
				xminPlot, xmaxPlot, tmin, tmax,
				ampColorDyn2, &cd); 
			xminPlot += xincPlot;
			tStr.Format(_T("Finished plotting between %g and %g km"), (float)xminPlot, (float)xmaxPlot);
			pFrame->myCaption(tStr);
		} while (xminPlot < xmax);
		isTrueOut = TRUE;
	}

	return isTrueOut;
}

void CSeisWideDoc::OnProcessingTracereorder()
{
	int trcReverse;

	CString outFile = BLANK;
	CdlgReorganize dlg;
	dlg.m_procNameIn = draw.timeSecName;
	dlg.m_procNameOut = getFileNameAppend(draw.timeSecName, _T("Reorg"));
	if (dlg.DoModal() == IDOK) {
		draw.timeSecName = dlg.m_procNameIn.Trim();
		outFile = dlg.m_procNameOut;
		trcReverse = dlg.m_trcReverse;
	}
	else return;

	if (!isFileExistNotDirectory(draw.timeSecName)) return;
	if (outFile == BLANK) return;
	outFile = SetFileExtension(outFile, _T("sgy"));

	//Begin progress control.
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();

	SegyWrapper sw(draw.timeSecName, true);
	sw.m_isHeadersOnly = false;
	if (CSegyMeta::segyHeadInit(draw.timeSecName, &head) != 1) return;
	int num;
	if (sw.open(&head, 0)) {
		if (sw.headRead.getnx() < 2) return;
		if (trcReverse == 0) {
			sw.reverseTrace();
		}
		else if (trcReverse == 1) {
			sw.sortDistance(0);
		}
		else if (trcReverse == 2) {
			sw.sortDistance(1);
		}
		else if (trcReverse == 3) {
			sw.sortDistance(2);
		}
		else if (trcReverse == 4) {
			for (int i = 1; i < sw.headRead.getnx(); i++) {
				if (sw.headRead.trArr[i].tracl <= sw.headRead.trArr[i - 1].tracl)
					sw.headRead.trArr[i].tracl = sw.headRead.trArr[i - 1].tracl + 1;
			}
		}
		else {
			sw.sortFFID(); // testing.
		}
		// sw.m_f = outFile;
		num = sw.writeDataAll(outFile);
		CString tstr;
		tstr.Format(_T("%d traces are successfully written."), num);
		pFrame->myCaption(tstr);
	} // if sw.open


	cd.coord.trace1 = sw.headRead.trArr[0].tracl;;
	cd.coord.trace2 = sw.headRead.trArr[num - 1].tracl;
	draw.timeSecName = outFile;
	draw.isSameDataDisplay = FALSE; //indicate display has been changed and will re-load all data in OnDraw().
	SetModifiedFlag();
	UpdateAllViews(NULL);
	NotifyChanged();

	//	AfxMessageBox(_T("Succesfully re-organizing traces in increasing ranges!");
}


void CSeisWideDoc::OnModelNewmod()
{

	int ncont;
	CDlgNewModel dlg;

	dlg.m_xmax = (float)cd.coord.xmax;
	dlg.m_xmin = (float)cd.coord.xmin;
	dlg.m_zmax = (float)cd.coord.Y2();
	dlg.m_nLayer = 6;

	if (dlg.DoModal() == IDOK)
	{
		ncont = dlg.m_nLayer + 1;
	}
	else return;

	if (ncont < 1)
	{
		AfxMessageBox(_T("Please specify at least 1 layer"), MB_ICONQUESTION);
		return;
	}

	CVelMod vm;
	vm.setNewMod(&velMod, ncont, dlg.m_xmin, dlg.m_xmax, dlg.m_zmax, 0.004, cd.coord.isTimeDomain());

	cd.coord.xmax = dlg.m_xmax;
	cd.coord.xmin = dlg.m_xmin;
	if (cd.coord.isTimeDomain())
		cd.coord.m_tmax = dlg.m_zmax;
	else
		cd.coord.m_zmax = dlg.m_zmax;

	OnToolbarSaveasv();
	//velMod.velSecOld = BLANK;
	cd.coord.drawmodeOld = cd.coord.drawmode;
	// cd.coord.drawmode = 2;

	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	pFrame->statMain.pick = 1;
	pFrame->statMain.move = 0;
	pFrame->statMain.remove = 0;
	pFrame->statMain.add = 0;

	SetModifiedFlag();
	UpdateAllViews(NULL);
	NotifyChanged();

}
//

void CSeisWideDoc::colBarPos(double v, CPoint p, CPoint p1)
{
	double x1, y1;
	BOOL colVert = FALSE;
	bool isTime = cd.coord.isTimeDomain() == TRUE;

	if (!colVert) {
		x1 = velColor.cxPos + (v - velColor.vmin)*(velColor.vmax - velColor.vmin) / velColor.cxExt;
		p = cd.coord.mm_coord(x1, velColor.cyPos);
		p1 = cd.coord.mm_coord(x1 + velColor.cxExt / 20., velColor.cyPos + velColor.cyExt);
	}
	else {
		y1 = velColor.cyPos + (v - velColor.vmin)*(velColor.vmax - velColor.vmin) / velColor.cyExt;
		p = cd.coord.mm_coord(velColor.cxPos, y1);
		p1 = cd.coord.mm_coord(velColor.cxPos + velColor.cxExt, y1 + velColor.cyExt / 20.);
	}
	return;

}

void CSeisWideDoc::OnModelLoadzeltsmodel()
{
	
	if (cd.coord.drawmode < 0) {
		cd.coord.drawmode = 2;  // for .in format, we must do it in the time or depth domain, otherwise it may crash
		AfxMessageBox(_T("Displayed mode now revised for loading a new model. Please click the same menu again"));
		SetModifiedFlag();
		UpdateAllViews(NULL);
		NotifyChanged();
		return;
	}

	CString tStr;
	CdlgLoadZelt dlg;
	CString zeltName;
	int is4Decimal = 0;

	//	dlg.m_velName = velMod.velSecName;
	dlg.m_is4Decimal = is4Decimal;
	if (dlg.DoModal() == IDOK) {
		zeltName = dlg.m_ZeltName;
		velMod.velSecName = dlg.m_velName.Trim();
		velMod.velSecName = SetFileExtension(velMod.velSecName, _T("vxml"));
		is4Decimal = dlg.m_is4Decimal;
	}
	else return;

	int  i, j;
	BOOL isSuc = FALSE;
	CVelMod vm;

	// note: an ill-formatted .in file or a wrong selection of format can easily cause the program to freeze.
	// So we must be very cautious here.
		tStr = getLineFirst(zeltName);
		i = tStr.Find('.', 0);
		if (i < 0) return;
		j = tStr.Find(' ', i);
		if (j < 0) {
			j = tStr.Find('\r', i);
		}
		if (j > i) {
			// found a decimal.
			int delta = j - i - 1; // delta is the number of decimals as calculated from file
			if (delta == 4 && is4Decimal != 0) {
				if (AfxMessageBox(_T("First line seems to contain 4 decimals. Is this true?"), MB_YESNO | MB_ICONINFORMATION| MB_ICONQUESTION) == IDYES)
					is4Decimal = 0;
			}
			else
				if (delta == 3 && is4Decimal != 1) {
					if (AfxMessageBox(_T("First line seems to contain 3 decimals. Is this true?"), MB_YESNO | MB_ICONINFORMATION| MB_ICONQUESTION) == IDYES)
						is4Decimal = 1;
				}
			if (delta == 2 && is4Decimal != 2) {
				if (AfxMessageBox(_T("First line seems to contain 2 decimals. Is this true?"), MB_YESNO | MB_ICONINFORMATION| MB_ICONQUESTION) == IDYES)
					is4Decimal = 2;
			}
		}

		if (is4Decimal == 0)
			isSuc = vm.loadModelZelt4(&velMod, zeltName);
		else if (is4Decimal == 1)
			isSuc = vm.loadModelZelt3(&velMod, zeltName);
		else
			isSuc = vm.loadModelZelt2(&velMod, zeltName);
	//}

	if (!isSuc) {
		tStr.Format(_T("Sorry, Loading failed."));
		AfxMessageBox(tStr);
		return;
	}

	//// final fix up for some
	//	if ( fabs(velMod.xmax - velMod.xmin) < 0.00001 )  
	vm.formatCalcVelLimits(&velMod);
	vm.myModel_Depth2TWTT(&velMod, velColor.dz);
	vm.saveModelAs(&velMod, velMod.velSecName, velColor.dz, FALSE, 0);

	OnToolbarSavev();
	cd.coord.xmax = (float)velMod.getXmax();
	cd.coord.xmin = velMod.getXmin();
	cd.coord.m_zmin = velMod.zmin;
	cd.coord.m_zmax = velMod.zmax;

	cd.coord.drawmodeOld = cd.coord.drawmode;
	cd.coord.drawmode = 2;
	//draw.isSameDataDisplay = FALSE; //indicate display has been changed and will re-load all data in OnDraw().
	SetModifiedFlag();
	UpdateAllViews(NULL);
	NotifyChanged();


}

void CSeisWideDoc::OnModelingLoadreidsmodel()
{
	// return; //designing in progress.

	CdlgLoadReid dlg;
	CString reidName;
// 	TCHAR *jpfile;

	if (dlg.DoModal() == IDOK) {
		reidName = dlg.m_reidName;
		velMod.velSecName = dlg.m_velName.Trim();
		velMod.velSecName = SetFileExtension(velMod.velSecName, _T("vxml"));
	}
	else {
		return;
	}

	if (CVelMod::LoadReidsmodel(&velMod, reidName)) {
		OnToolbarSavev();
		cd.coord.xmax = velMod.getXmax();	//problem: double cd.coord.xmax is not 3.2 even if float xmax is 3.2.
		cd.coord.m_zmax = velMod.zmax;
		cd.coord.drawmodeOld = cd.coord.drawmode;
		cd.coord.drawmode = 2;
		SetModifiedFlag();
		UpdateAllViews(NULL);
		NotifyChanged();
	}
	else
		AfxMessageBox(_T("Failed to load reid model."), MB_ICONQUESTION);

}

void CSeisWideDoc::processingNormMulti(HEAD_READ *headRead, BOOL isNorm, float normValue, BOOL isMultiple, float exponentValue, float multiplyValue)
{
	if (isNorm)	{
		//apply normalization.
		for (int nxStore = 0; nxStore < headRead->getnx(); nxStore++) {
			register double temp = 0.;
			for (int it = 0; it < headRead->getns(); it++)
				if (temp < fabs(headRead->trArr[nxStore].data[it]))
					temp = fabs(headRead->trArr[nxStore].data[it]);
			if (temp > MINAMP){
				temp = normValue / temp;
				for (int it = 0; it < headRead->getns(); it++)
					headRead->trArr[nxStore].data[it] *= (float)(temp);
			}
		}
	}

	if (isMultiple) {
		for (int nxStore = 0; nxStore < headRead->getnx(); nxStore++) {
			if (multiplyValue != 1.f)	{
				for (int it = 0; it < headRead->getns(); it++)
					headRead->trArr[nxStore].data[it] *= multiplyValue;
			}
			if (exponentValue != 1.f)	{
				for (int it = 0; it < headRead->getns(); it++)
					headRead->trArr[nxStore].data[it] =
					(float)pow((double)headRead->trArr[nxStore].data[it], (double)exponentValue);
			}
		}
	}
}


/* Credits:
*  main\attributes_parameter_estimation\suattributes.c
*	CWP: Jack Cohen
*      CWP: John Stockwell (added freq and unwrap features)
*	UGM (Geophysics Students): Agung Wiyono
*           email:aakanjas@gmail.com (others)
*	CSM: Kylee Brown and Steven Rennolet, Senior Design,
*	     updates to instanteous phase, instantaneous frequency,
*	     first time derivative of the envelope, second time derivative
*	     of the envelope, instantaneous quality factor, and thin bed
*	     indicator
*
*
* Algorithm:
*	c(t) = hilbert_tranform_kernel(t) convolved with data(t)
*
*  amp(t) = sqrt( c.re^2(t) + c.im^2(t))
*  phase(t) = arctan( c.im(t)/c.re(t))
*  freq(t) = d(phase)/dt
*
* Reference:
*  Taner, M. T., Koehler, A. F., and  Sheriff R. E.   "Complex seismic trace
*      analysis", Geophysics,  vol.44, p. 1041-1063, 1979
*  Chopra, S. and K.  Marfurt, 2005, A historical perspective, Geophysics,
*      vol. 70, no. 5, p.3SO-295SO, Society of Exploration Geophysicists.
*  Barnes, A. E, 1992, The calculation of instantaneous frequency and
*      instantaneous bandwidth, Geophysics, vol. 57, no. 11, p. 1520-1524,
*      Society of Exploration Geophysicists.
*
* Trace header fields accessed: ns, trid
* Trace header fields modified: d1, trid

*/
void CSeisWideDoc::processingHilbertNorm(HEAD_READ *headRead, BOOL isHilbert, BOOL isTranspose, BOOL isHilbertMix)
{
	// if multiplyValue==1.0f, then do not multiple
	// process for transposed hilbert transform
	CString tstr;
	float *transpose = NULL;
	double *ampl = NULL;
	double *phase = NULL;
	double *omega = NULL;
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	if (isHilbert && isTranspose) {
		tstr.Format(_T("Performing transposed Hilbert transform."), headRead->getnx());
		pFrame->myCaption(tstr);
		if (transpose == NULL) transpose = (float *)ealloc1float((size_t)(headRead->getnx()));
		if (ampl == NULL) ampl = (double *)ealloc1double((size_t)(headRead->getnx()));
		if (phase == NULL) phase = (double *)ealloc1double((size_t)(headRead->getnx()));
		if (omega == NULL) omega = (double *)ealloc1double((size_t)(headRead->getnx()));
		for (int it = 0; it < headRead->getns(); it++) {
			if (it / 100 * 100 == it) {
				tstr.Format(_T("F%d...."), it);
				pFrame->myCaption(tstr);
			}
			for (int ix = 0; ix < headRead->getnx(); ix++) {
				transpose[ix] = headRead->trArr[ix].data[it];
			}
			hilbertTransform(&transpose[0], ampl, phase, omega, headRead->getnx(), 64);
			for (int ix = 0; ix < headRead->getnx(); ix++) {
				headRead->trArr[ix].data[it] = (float)ampl[ix];
				if (isHilbertMix)
					headRead->trArr[ix].data[it] *= (float)(ampl[ix] * phase[ix]);
			}
		}
	}
	else if (isHilbert) {
		// bool hilbertTransform(double* x, double* ampl, double* phase, double *omega, int npt, int lfilt = 64)
		tstr.Format(_T("Performing Hilbert transform."), headRead->getnx());
		pFrame->myCaption(tstr);
		if (ampl == NULL) ampl = (double *)ealloc1double((size_t)(headRead->getns()));
		if (phase == NULL) phase = (double *)ealloc1double((size_t)(headRead->getns()));
		if (omega == NULL) omega = (double *)ealloc1double((size_t)(headRead->getns()));
		for (int ix = 0; ix < headRead->getnx(); ix++) {
			if (ix / 100 * 100 == ix) {
				tstr.Format(_T("F%d...."), ix);
				pFrame->myCaption(tstr);
			}
			hilbertTransform(&headRead->trArr[ix].data[0], ampl, phase, omega, headRead->getns(), 64);
			for (int it = 0; it < headRead->getns(); it++) {
				headRead->trArr[ix].data[it] = (float)ampl[it];
				if (isHilbertMix)
					headRead->trArr[ix].data[it] *= (float)(ampl[it] * phase[it]);
			}
		}
	}
	if (transpose != NULL) free1float(transpose);
	if (ampl != NULL) free1double(ampl);
	if (phase != NULL) free1double(phase);
	if (omega != NULL) free1double(omega);
	transpose = NULL;
	ampl = NULL;
	phase = NULL;
	omega = NULL;


}


// not used
bool processingFilterFreqDomain(float **traces, int nx, float dt, int nt,
	double f1, double f2, double f3, double f4,
	double ta, double tb, int num_tfilter, bool zerophase)
{
	CString tstr;
	int locut = 1;		/* flag for low cut filtering		*/
	int hicut = 1;		/* flag for high cut filtering		*/

	// BOOL zerophase=pFrame->psei->zerophase;		/* flag for zero phase filtering	*/
	float *fData = NULL; // for frequency filter only
	float nyq = (float)(0.5 / dt);
	if (f1 <= 0.f) f2 = f1 = 0.00001f;
	if (f3 > nyq) f4 = f3 = nyq;
	int nsIn = nt;
	fData = (float *)ealloc1float((size_t)(nsIn));
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	if (traces == NULL) {
		pFrame->myCaption(_T("Insufficient memory available"));
		return false;
	}

	if (locut) {
		if (f1 <= 0.)  f1 = .10f * nyq;
		if (f2 <= f1)  f2 = f1 + 1.f;
	}
	if (hicut) {
		if (f4 > nyq)  f4 = nyq;
		if (f3 > f4)  f3 = f4 - 1.f;
	}

	int npoleslo;		/* poles in low cut filter		*/
	int npoleshi;		/* poles in high cut filter		*/
	float f3dblo;		/* 3 db point of low cut filter		*/
	float f3dbhi;		/* 3 db point of high cut filter	*/

	/* Normalize frequencies to [0, 0.5] for bfdesign */
	f1 *= (float)dt;
	f2 *= (float)dt;
	f4 *= (float)dt;
	f3 *= (float)dt;

	float a1;		/* amp at f1			*/
	float a2;		/* amp at f2			*/
	float a3;		/* amp at f3			*/
	float a4;		/* amp at f4			*/
	a1 = .05f;
	a2 = .95f;
	a3 = .95f;
	a4 = .05f;
	/* Adapt user frequencies if zerophase selected */
	if (zerophase) {
		a1 = (float)sqrt(a1);
		a2 = (float)sqrt(a2);
		a4 = (float)sqrt(a4);
		a3 = (float)sqrt(a3);
	}

	/* Use bdesign to make low and high cut filters */
	if (locut) bfdesign((float)f2, a2, (float)f1, a1, &npoleslo, &f3dblo);
	if (hicut) bfdesign((float)f3, a3, (float)f4, a4, &npoleshi, &f3dbhi);
	// end for freq filtering only


	int i;
	for (int nxStore = 0; nxStore < nx; nxStore++) {
		memset((void *)fData, (int) '\0', sizeof(float)*nsIn);

		if (locut) {
			bfhighpass(npoleslo, f3dblo, nsIn, fData, fData);
			if (zerophase) {
				for (i = 0; i < nsIn / 2; ++i) { /* reverse trace in place */
					register float tmp = fData[i];
					fData[i] = fData[nsIn - 1 - i];
					fData[nsIn - 1 - i] = tmp;
				}
				bfhighpass(npoleslo, f3dblo, nsIn, fData, fData);
				for (i = 0; i < nsIn / 2; ++i) { /* flip trace back */
					register float tmp = fData[i];
					fData[i] = fData[nsIn - 1 - i];
					fData[nsIn - 1 - i] = tmp;
				}
			} // if zerophase
		} // if locut

		if (hicut) {
			bflowpass(npoleshi, f3dbhi, nsIn, fData, fData);
			if (zerophase) {
				for (i = 0; i < nsIn / 2; ++i) { /* reverse trace */
					register float tmp = fData[i];
					fData[i] = fData[nsIn - 1 - i];
					fData[nsIn - 1 - i] = tmp;
				}
				bflowpass(npoleshi, f3dbhi, nsIn, fData, fData);
				for (i = 0; i < nsIn / 2; ++i) { /* flip trace back */
					register float tmp = fData[i];
					fData[i] = fData[nsIn - 1 - i];
					fData[nsIn - 1 - i] = tmp;
				}
			} // if zerophase
		} // if hicut

		memcpy((void *)&traces[nxStore][0], (void *)&fData[0], sizeof(float)*nsIn);
		if (nxStore / 10 * 10 == nxStore) {
			tstr.Format(_T("F%d...."), nxStore);
			pFrame->myCaption(tstr);
		}
	} // for nxStore

	free1float(fData);
	return true;
}


// this will only access  int nx, float dt, int nt  from *headRead
bool CSeisWideDoc::processingFilterFreqDomain(HEAD_READ *headRead,
	double f1, double f2, double f3, double f4,
	double ta, double tb, int num_tfilter, bool zerophase)
{
	CString tstr;
	int locut = 1;		/* flag for low cut filtering		*/
	int hicut = 1;		/* flag for high cut filtering		*/

	// BOOL zerophase=pFrame->psei->zerophase;		/* flag for zero phase filtering	*/
	double dt = headRead->getdt();
	float *fData = NULL; // for frequency filter only
	double nyq = 0.5 / dt;
	if (f1 <= 0.f) f2 = f1 = 0.00001f;
	if (f3 > nyq) f4 = f3 = nyq;
	int nsIn = headRead->getns();
	fData = (float *)ealloc1float((size_t)(nsIn));
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	if (fData == NULL) {
		pFrame->myCaption(_T("Insufficient memory available"));
		return false;
	}

	if (locut) {
		if (f1 <= 0.)  f1 = .1f * nyq;
		if (f2 <= f1)  f2 = f1 + 1.f;
	}
	if (hicut) {
		if (f4 > nyq)  f4 = nyq;
		if (f3 > f4)  f3 = f4 - 1.f;
	}

	int npoleslo;		/* poles in low cut filter		*/
	int npoleshi;		/* poles in high cut filter		*/
	float f3dblo;		/* 3 db point of low cut filter		*/
	float f3dbhi;		/* 3 db point of high cut filter	*/

	/* Normalize frequencies to [0, 0.5] for bfdesign */
	f1 *= dt;
	f2 *= dt;
	f4 *= dt;
	f3 *= dt;

	float a1;		/* amp at f1			*/
	float a2;		/* amp at f2			*/
	float a3;		/* amp at f3			*/
	float a4;		/* amp at f4			*/
	a1 = .05f;
	a2 = .95f;
	a3 = .95f;
	a4 = .05f;
	/* Adapt user frequencies if zerophase selected */
	if (zerophase) {
		a1 = (float)sqrt(a1);
		a2 = (float)sqrt(a2);
		a4 = (float)sqrt(a4);
		a3 = (float)sqrt(a3);
	}

	/* Use bdesign to make low and high cut filters */
	if (locut) bfdesign((float)f2, a2, (float)f1, a1, &npoleslo, &f3dblo);
	if (hicut) bfdesign((float)f3, a3, (float)f4, a4, &npoleshi, &f3dbhi);
	// end for freq filtering only


	int i;
	for (int nxStore = 0; nxStore < headRead->getnx(); nxStore++) {
		//	memset((void *)fData, (int) '\0', sizeof(float)*nsIn);
		//	memcpy((void *)&headRead->trArr[nxStore].data[0], (void *)&tData[0], sizeof(float)*nsIn);
		memcpy(fData, (void *)&headRead->trArr[nxStore].data[0], sizeof(float)*nsIn);
		if (locut) {
			bfhighpass(npoleslo, f3dblo, nsIn, fData, fData);
			if (zerophase) {
				for (i = 0; i < nsIn / 2; ++i) { /* reverse trace in place */
					register float tmp = fData[i];
					fData[i] = fData[nsIn - 1 - i];
					fData[nsIn - 1 - i] = tmp;
				}
				bfhighpass(npoleslo, f3dblo, nsIn, fData, fData);
				for (i = 0; i < nsIn / 2; ++i) { /* flip trace back */
					register float tmp = fData[i];
					fData[i] = fData[nsIn - 1 - i];
					fData[nsIn - 1 - i] = tmp;
				}
			} // if zerophase
		} // if locut

		if (hicut) {
			bflowpass(npoleshi, f3dbhi, nsIn, fData, fData);
			if (zerophase) {
				for (i = 0; i < nsIn / 2; ++i) { /* reverse trace */
					register float tmp = fData[i];
					fData[i] = fData[nsIn - 1 - i];
					fData[nsIn - 1 - i] = tmp;
				}
				bflowpass(npoleshi, f3dbhi, nsIn, fData, fData);
				for (i = 0; i < nsIn / 2; ++i) { /* flip trace back */
					register float tmp = fData[i];
					fData[i] = fData[nsIn - 1 - i];
					fData[nsIn - 1 - i] = tmp;
				}
			} // if zerophase
		} // if hicut

		memcpy((void *)&headRead->trArr[nxStore].data[0], (void *)&fData[0], sizeof(float)*nsIn);
		if (nxStore / 10 * 10 == nxStore) {
			tstr.Format(_T("F%d...."), nxStore);
			pFrame->myCaption(tstr);
		}
	} // for nxStore

	free1float(fData);
	return true;
}


bool CSeisWideDoc::processingFilterTimeDomain(HEAD_READ *headRead, double f1a, double f2a)
{
	double dt = headRead->getdt();
	int ns = headRead->getns();
	double ons = 1./headRead->getns();
	double a, b, c0, c1, c2, d1, d2;
	int i;
	float *tData = (float *)ealloc1float((size_t)ns);
	if (tData == NULL) {
		return false;
	}
	double nyq = 0.5 / dt;
	if (f1a <= 0.f) f1a = 0.00001f;
	if (f2a > nyq) f2a = nyq;

	a = tan(PI*f1a*dt);
	b = tan(PI*f2a*dt);
	c0 = -b / (1. + a) / (1. + b);
	c1 = 0.;
	c2 = -c0;
	d1 = ((1. + a)*(1. - b) + (1. - a)*(1. + b)) / ((1. + a)*(1. + b));
	d2 = -((1. - a)*(1. - b)) / ((1. + a)*(1. + b));

	for (int nxStore = 0; nxStore < headRead->getnx(); nxStore++) {
		// debias 
		register double temp = 0.;
		for (i = 0; i<ns; i++)
			temp += headRead->trArr[nxStore].data[i];
		if (fabs(temp)>MINAMP){
			temp *= (double)ons;
			for (i = 0; i < ns; i++) headRead->trArr[nxStore].data[i] -= (float)temp;
		}

		tData[0] = (float)(c0*headRead->trArr[nxStore].data[0]);
		tData[1] = (float)(c0*headRead->trArr[nxStore].data[1] + c1*headRead->trArr[nxStore].data[0] + d1*tData[0]);
		for (i = 2; i < ns; i++) {
			tData[i] = (float)(c0*headRead->trArr[nxStore].data[i] +
				c1*headRead->trArr[nxStore].data[i - 1] +
				c2*headRead->trArr[nxStore].data[i - 2] +
				d1*tData[i - 1] + d2*tData[i - 2]);
		}

		memcpy((void *)&headRead->trArr[nxStore].data[0], (void *)&tData[0], sizeof(float)*ns);
	} // for nxStore
	free1float(tData);
	return true;
}


bool CSeisWideDoc::processingFilterTimeDomain(HEAD_READ *headRead,
	double f1a, double f2a,
	double f1b, double f2b, double ta, double tb)
{
	CString tstr;
	double odt = 1. / headRead->getdt();
	int nsIn = headRead->getns();
	int i;
	float *tData = (float *)ealloc1float((size_t)(nsIn));
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	if (tData == NULL) {
		pFrame->myCaption(_T("Insufficient memory available"));
		return false;
	}

	// f1b, f2b and ta, tb are used only in isTimeVaryingFilter mode
	for (int nxStore = 0; nxStore < headRead->getnx(); nxStore++) {
		// debias 
		register double temp = 0.;
		for (i = 0; i<nsIn; i++)
			temp += headRead->trArr[nxStore].data[i];
		if (fabs(temp)>MINAMP){
			temp /= (double)nsIn;
			for (i = 0; i < nsIn; i++) headRead->trArr[nxStore].data[i] -= (float)temp;
		}

		register float aDelay = headRead->trArr[nxStore].getTraceDelay();
		register int ita = (int)floor((ta - aDelay) * odt);
		register int itb = (int)ceil((tb - aDelay) * odt) + 1;
		register double aRatioA = (f1b - f1a) / (double)(itb - ita);
		register double aRatioB = (f2b - f2a) / (double)(itb - ita);

		// prepare for time varying filter
		register double a, b, c0, c1, c2, d1, d2;

		// set defaults for all samples at <=ita
		a = tan(PI*f1a*headRead->getdt());
		b = tan(PI*f2a*headRead->getdt());
		c0 = -b / (1. + a) / (1. + b);
		c1 = 0.;
		c2 = -c0;
		d1 = ((1. + a)*(1. - b) + (1. - a)*(1. + b)) / ((1. + a)*(1. + b));
		d2 = -((1. - a)*(1. - b)) / ((1. + a)*(1. + b));

		tData[0] = (float)(c0*headRead->trArr[nxStore].data[0]);
		tData[1] = (float)(c0*headRead->trArr[nxStore].data[1] + c1*headRead->trArr[nxStore].data[0] + d1*tData[0]);
		for (i = 2; i<nsIn; i++) {
			if (i>ita && i < itb) {
				register double f1 = f1a + (float)((i - ita) *  aRatioA);
				register double f2 = f2a + (float)((i - ita) *  aRatioB);
				a = tan(PI*f1*head.dtFile);
				b = tan(PI*f2*head.dtFile);
				c0 = -b / (1. + a) / (1. + b);
				c1 = 0.;
				c2 = -c0;
				d1 = ((1. + a)*(1. - b) + (1. - a)*(1. + b)) / ((1. + a)*(1. + b));
				d2 = -((1. - a)*(1. - b)) / ((1. + a)*(1. + b));
			}
			// if at >itb, a,b, c0,c1,c2, d1,d2 will not change for the current trace

			tData[i] = (float)(c0*headRead->trArr[nxStore].data[i] +
				c1*headRead->trArr[nxStore].data[i - 1] +
				c2*headRead->trArr[nxStore].data[i - 2] +
				d1*tData[i - 1] + d2*tData[i - 2]);
		} // for i

		memcpy((void *)&headRead->trArr[nxStore].data[0], (void *)&tData[0], sizeof(float)*nsIn);
	} // for nxStore
	free1float(tData);
	return true;
}

void CSeisWideDoc::OnProcessingDatareductionandfilter()
{
	CString outFile = BLANK;

	CString tstr;
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();

	static BOOL isNorm = FALSE;
	static BOOL isMultiply = FALSE;
	static float multiplyValue = 1.0f; // not effecting in display, but can be useful when merging 2 segy files et al.
	static float exponentValue = 0.6f;
	float obsDepth = 0.f;  // do not make this static since we do not want to make the same correction again.

	static BOOL isHilbert = FALSE;
	static BOOL isTranspose = FALSE;
	static BOOL isHilbertMix = TRUE;


	if (pFrame->psei->freq1s >= pFrame->psei->freq2s) pFrame->psei->freq1s = pFrame->psei->freq2s - 1.f;  // we need to keep f2s since time filter will only use f2s, f3s
	if (pFrame->psei->freq4s <= pFrame->psei->freq3s) pFrame->psei->freq4s = pFrame->psei->freq3s + 1.f;  // we need to keep f3s since time filter will only use f2s, f3s


	CdlgFilter1 dlg;

	CString secNameIn = cd.coord.isTimeDomain() ? draw.timeSecName : draw.depthSecName;
	dlg.m_nameIn = secNameIn;
	dlg.m_nameOut = getFileNameAppend(dlg.m_nameIn, _T("F"));
	dlg.m_nameOut = SetFileExtension(dlg.m_nameOut, _T("sgy"));
	dlg.m_filter = pFrame->psei->yesFilterT;
	dlg.m_f1 = pFrame->psei->f1a;
	dlg.m_f2 = pFrame->psei->f2a;
	dlg.m_ta = pFrame->psei->ta;
	dlg.m_f1b = 0.f;
	dlg.m_f2b = 0.f;
	dlg.m_tb = pFrame->psei->tb;

	dlg.m_filterF = pFrame->psei->yesFilterF;
	dlg.m_zerophase = pFrame->psei->zerophase;
	dlg.m_ff0 = pFrame->psei->freq1s;
	dlg.m_ff1 = pFrame->psei->freq2s;
	dlg.m_ff2 = pFrame->psei->freq3s;
	dlg.m_ff3 = pFrame->psei->freq4s;
	dlg.m_norm = isNorm;
	dlg.m_normValue = pFrame->psei->normValue;
	dlg.m_multiply = isMultiply;
	dlg.m_multiplyValue = multiplyValue;
	dlg.m_basePower = exponentValue;

	dlg.m_isHilbert = isHilbert;
	dlg.m_isTranspose = isTranspose;
	dlg.m_isMixAmpPhase = isHilbertMix;
	dlg.m_numTFilter = pFrame->psei->num_tfilter;

	BOOL isLimitTime;
	dlg.m_isLimitTime = FALSE;
	//float tminOut = 0.f;
	//float tmaxOut = 0.f;
	dlg.m_tmin = (float)cd.coord.Y1();
	dlg.m_tmax = (float)cd.coord.Y2();
	dlg.m_isIEEE_Floats = FALSE;


	draw.isNodeChanged = FALSE;
	if (dlg.DoModal() == IDOK) {
		secNameIn = dlg.m_nameIn.Trim();
		outFile = dlg.m_nameOut;
		pFrame->psei->yesFilterT = dlg.m_filter == TRUE;
		pFrame->psei->num_tfilter = dlg.m_numTFilter;
		pFrame->psei->yesFilterF = dlg.m_filterF == TRUE;
		pFrame->psei->zerophase = dlg.m_zerophase == TRUE;
		if (pFrame->psei->yesFilterF)
		{
			// filtering in frequency domain
			pFrame->psei->freq1s = dlg.m_ff0;
			pFrame->psei->freq2s = dlg.m_ff1;
			pFrame->psei->freq3s = dlg.m_ff2;
			pFrame->psei->freq4s = dlg.m_ff3;
		}
		else {
			// filtering in time domain
			pFrame->psei->f1a = dlg.m_f1;
			pFrame->psei->f2a = dlg.m_f2;
			pFrame->psei->f1b = dlg.m_f1b;
			pFrame->psei->f2b = dlg.m_f2b;
			if (pFrame->psei->f1b == 0.f) pFrame->psei->f1b = pFrame->psei->f1a;
			if (pFrame->psei->f2b == 0.f) pFrame->psei->f1b = pFrame->psei->f1b;
			pFrame->psei->ta = dlg.m_ta;
			pFrame->psei->tb = dlg.m_tb;
		}

		isNorm = dlg.m_norm;
		pFrame->psei->normValue = dlg.m_normValue;
		isMultiply = dlg.m_multiply;
		multiplyValue = dlg.m_multiplyValue;
		exponentValue = dlg.m_basePower;
		isHilbert = dlg.m_isHilbert;
		isTranspose = dlg.m_isTranspose;
		isHilbertMix = dlg.m_isMixAmpPhase;
		isLimitTime = dlg.m_isLimitTime;
		cd.coord.setY1(dlg.m_tmin);
		cd.coord.setY2(dlg.m_tmax);
	//	pFrame->statMain.gIsIBMFloatSegy2 = !dlg.m_isIEEE_Floats;
	}
	else {
		return;
	}



	if (pFrame->psei->yesFilterT) {
		if (pFrame->psei->f1a >= pFrame->psei->f2a) {
			AfxMessageBox(_T(" f1a>=f2a. Please correct this."), MB_ICONQUESTION);
			return;
		}
		if (pFrame->psei->f1b == 0.f || pFrame->psei->f2b == 0.f) {
			pFrame->psei->f1b = pFrame->psei->f1a;
			pFrame->psei->f2b = pFrame->psei->f2a;
		}
	}

	if (pFrame->psei->yesFilterF && (pFrame->psei->freq1s >= pFrame->psei->freq2s || pFrame->psei->freq2s >= pFrame->psei->freq3s || pFrame->psei->freq3s >= pFrame->psei->freq4s)) {
		AfxMessageBox(_T(" f1>=f2 or f2>=f3 or f3>=f4. Please correct this."), MB_ICONQUESTION);
		return;
	}


	if (!CSegyMeta::segyHeadInit(secNameIn, &head)) {
		tstr.Format(_T("Valid input file cannot be initialized"));
		AfxMessageBox(tstr, MB_ICONQUESTION);
		return;
	}
	SegyWrapperEx sw(secNameIn, cd.coord.X1(), cd.coord.X2(), 0., 0., cd.coord.drawmode);
	sw.m_dxMin = sw.m_dyMin = 0.; // read all traces
	draw.red.clone(&sw.red2);
	if (!sw.openDistance(!cd.coord.isDistanceDisplay, head.numTraces, &head)) {
		tstr.Format(_T("Valid input file cannot be read properly"));
		pFrame->myCaption(tstr);
		return;
	}

	tstr.Format(_T("Loaded segy with %d traces. Processing..."), sw.headRead.getnx());
	pFrame->myCaption(tstr);

	processingHilbertNorm(&(sw.headRead), isHilbert, isTranspose, isHilbertMix);
	processingNormMulti(&(sw.headRead), isNorm, pFrame->psei->normValue, isMultiply, exponentValue, multiplyValue);

	if (pFrame->psei->yesFilterT) {
		bool isTimeVaryingFilter = (pFrame->psei->tb != 0.f && pFrame->psei->ta != pFrame->psei->tb && (pFrame->psei->f1a != pFrame->psei->f1b || pFrame->psei->f2a != pFrame->psei->f2b));
		for (int n = 0; n < pFrame->psei->num_tfilter; n++) {
			if (isTimeVaryingFilter) {
				processingFilterTimeDomain(&(sw.headRead),
					pFrame->psei->f1a, pFrame->psei->f2a,
					pFrame->psei->f1b, pFrame->psei->f2b, pFrame->psei->ta, pFrame->psei->tb);
			}
			else {
				processingFilterTimeDomain(&(sw.headRead), pFrame->psei->f1a, pFrame->psei->f2a);
			}
		}

	} // if  yesFilterT
	else if (pFrame->psei->yesFilterF) {
		processingFilterFreqDomain(&(sw.headRead),
			pFrame->psei->freq1s, pFrame->psei->freq2s, pFrame->psei->freq3s, pFrame->psei->freq4s,
			pFrame->psei->ta, pFrame->psei->tb,
			pFrame->psei->num_tfilter, pFrame->psei->zerophase);
	} // freq filter


	// now do the writing 
	if (isHilbert)
		outFile = getFileNameAppend(secNameIn, _T("_Hilt"));


	tstr.Format(_T("Saving..."));
	pFrame->myCaption(tstr);

	if (isLimitTime) {
		if (SegyWrapper::saveToSegyFile(&(sw.headRead), outFile, 
			cd.coord.drawmode, &draw.red, cd.coord.Y1(), cd.coord.Y2(), 
			head.ascHead, !dlg.m_isIEEE_Floats)) {
			if (cd.coord.isTimeDomain())
				draw.timeSecName = outFile;
		}
	}
	else {
		if (SegyWrapper::saveToSegyFile(&(sw.headRead), outFile,
			head.ascHead, !dlg.m_isIEEE_Floats)) {
			if (cd.coord.isTimeDomain())
				draw.timeSecName = outFile;
		}
	}
	if (!dlg.m_isIEEE_Floats) {
		// if IBM floating is enforced, the sw.headRead should not be used anymore since
		// it is already in IBM floating point values
		SegyWrapper::freeSegyArray(&sw.headRead);
	}
	OnToolbarRefreshAll(); // need to do it at the last line
}

void CSeisWideDoc::OnProcessingDatanormalize()
{
	CString tstr;
	if (!isFileExistNotDirectory(draw.timeSecName)) return;
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	SegyWrapper sw(draw.timeSecName);
	if (CSegyMeta::segyHeadInit(draw.timeSecName, &head) == 1) {
		if (!sw.open(&head, 0)) {
			tstr.Format(_T("Valid input file cannot be opened"));
			AfxMessageBox(tstr, MB_ICONQUESTION);
			return;
		}
	}
	tstr.Format(_T("Loaded segy with %d traces."), sw.headRead.getnx());
	pFrame->myCaption(tstr);
	CString outfile = getFileNameAppend(draw.timeSecName, _T("Norm"));

	int i;
	int ns = sw.headRead.getns();
	for (int nxStore = 0; nxStore < sw.headRead.getnx(); nxStore++) {
		float aMax = getMaxValueAbsolute(&sw.headRead.trArr[nxStore].data[0], ns);
		if (aMax > MINAMP){
			aMax = 1000.f / aMax;
			for (i = 0; i < ns; i++)
				sw.headRead.trArr[nxStore].data[i] *= aMax;
		}

		//if (bhout.format == 5) {
		//	//sw.headRead.trArr[nxStore].idistopt = 8;
		//	float_to_ibm((int *)&sw.headRead.trArr[nxStore].data[0], (int *)&sw.headRead.trArr[nxStore].data[0], (int)bhout.hns); // we always output as floating pt
		//}

		//fileout.Write(&sw.headRead.trArr[nxStore], 240);
		//fileout.Write(&sw.headRead.trArr[nxStore].data[0], bhout.hns*sizeof(float));
		if (nxStore / 10 * 10 == nxStore) {
			tstr.Format(_T("A%d...."), nxStore);
			pFrame->myCaption(tstr);
		}
	} // for nxStore
	//fileout.Close();

	tstr.Format(_T("Writing..."), outfile);
	pFrame->myCaption(tstr);
	sw.writeDataAll();

	tstr.Format(_T("Finished normalization for %d traces. Load the new data?"), sw.headRead.getnx());
	//	myCaption(tstr);
	if (AfxMessageBox((tstr), MB_YESNO | MB_ICONQUESTION | MB_ICONQUESTION) == IDYES) {
		draw.timeSecName = outfile;
		UpdateAllViews(NULL);
		NotifyChanged();
	}

}


void CSeisWideDoc::OnProcessingLateralshift()
{
	// shift segy data in distance/offset and time
	static double refKm = 0.;
	static int intOffset = 1;
	int shot1, shot2;

	CString tStr;
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	double refSec = 0.;
	// when I make refSec variable static, it get the decimal points of refKm in the release version,
	// although the debug version of SeisWide works normally. Not sure  why?
	//tStr.Format(_T("refSec: %f"), refSec);
	//pFrame->myCaption(tStr);


	CdlgLatShift dlg;
	dlg.m_refName = draw.timeSecName;
	dlg.m_refKm = refKm;
	dlg.m_refSec = 0.;
	dlg.m_offset = intOffset;
	dlg.m_shot1 = 0;
	dlg.m_shot2 = 0;
	if (dlg.DoModal() == IDOK) {
		draw.timeSecName = dlg.m_refName.Trim();
		refKm = dlg.m_refKm;
		refSec = dlg.m_refSec;
		intOffset = dlg.m_offset;
		shot1 = dlg.m_shot1;
		shot2 = dlg.m_shot2;
	}
	else return;
	delete dlg;

	if (!isFileExistNotDirectory(draw.timeSecName)) return;

	if (refKm != 0. || refSec != 0.) {
		bool isHeaderOnly = !head.isUnixFile && (head.formatFile == 1 || head.formatFile == 5);
		CSegyMeta::segyHeadInit(draw.timeSecName, &head);
		SegyWrapper sw(draw.timeSecName, isHeaderOnly, 0);

		sw.m_isHeadersOnly = false;  // must read the complete data file if in unix format!!!
		if (sw.open(&head, 0)) {
			int nx = sw.headRead.getnx();
			for (int ix = 0; ix < nx; ix++) {
				segydynamic *ptr = &sw.headRead.trArr[ix];
				//if (ptr->tracl == 1619) {
				//	int sdfsd = 1;
				//}
				if ((shot1 != 0 || shot2 != 0) && shot2 >= shot1) {
					if (ptr->tracl<shot1 || ptr->tracl>shot2) continue; // exclude revision for this trace
				}
				if (fabs(refKm) > 0.0001f) {
					if (intOffset == 0) {
						ptr->setOffset(ptr->getOffset() + (float)refKm);
					}
					else if (intOffset == 1) {
						ptr->setDistance(ptr->getDistance() + (float)refKm);
					}
					else {
						ptr->setOffset(ptr->getOffset() + (float)refKm);
						ptr->setDistance(ptr->getDistance() + (float)refKm);
					}
				}
				float a = ptr->getTraceDelay();
				float aa = sw.headRead.trArr[ix].getTraceDelay();
				ptr->setTraceDelayF(ptr->getTraceDelay() + (float)refSec);
				float b = ptr->getTraceDelay();
				float c = b + (float)refSec;

			}


			if (sw.writeDataAll(draw.timeSecName) > 0) {
				pFrame->myCaption(_T("Success in updating a trace header."));
			}
			else
				pFrame->myCaption(_T("failed in updating a trace header."));
		}
	} // if (refKm
	 
	if (cd.coord.isTimeDomain()) {
		draw.isSegyKeyXShift = TRUE;
		draw.segyKeyXShift = 0.f;
		pFrame->myCaption(_T("Left/right arrow keys will start shifting segy"));
	//	SetModifiedFlag();
		UpdateAllViews(NULL);
		NotifyChanged();
	}
}

void CSeisWideDoc::myModelingRaytrace(bool isForceDlg)
{
	CString tStr;
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	CString txPath = getWorkingPathSlash();

	bool isPrompted = false;
	if (isForceDlg 
		|| draw.isRaytracePrompt
		|| !isFileExistNotDirectory(velMod.velSecName) 
		|| !isFileExistNotDirectory(draw.rayName)) {
		CdlgRaytrace1 dlg;
		dlg.m_rayTracing = draw.rayName;
		dlg.m_velName = velMod.velSecName;

		dlg.tmax = (float)cd.coord.m_tmax;
		dlg.tmin = (float)cd.coord.m_tmin;
		double vred = draw.red.getVred(); //rvred == 0. ? 0. : 1. / draw.red.rvred;
		dlg.vred = (float)vred;
		dlg.xmax = (float)velMod.getXmax();
		dlg.xmin = (float)velMod.getXmin();
		dlg.xshot = (float)tx.xShotRay;
		dlg.zshot = (float)draw.red.obsDepth;
		dlg.zmax = (float)cd.coord.m_zmax;
		dlg.zmin = (float)cd.coord.m_zmin;
		dlg.m_velName = velMod.velSecName;
		dlg.m_floatName = velMod.flFloatName;
		dlg.timeSecName = draw.timeSecName;
		dlg.m_txName = draw.txRaytraceName;
		dlg.m_kmShift = draw.red.gunDepth;
		dlg.m_isPrompt = draw.isRaytracePrompt;
		if (dlg.DoModal() == IDOK) {
			draw.rayName = dlg.m_rayTracing;
			velMod.velSecName = dlg.m_velName.Trim();
			velMod.flFloatName = dlg.m_floatName;
			draw.txRaytraceName = dlg.m_txName;
			draw.timeSecName = dlg.timeSecName.Trim();
			draw.red.obsDepth = dlg.zshot;
			draw.red.gunDepth = dlg.m_kmShift;

			// only if here, the DOC is modified
			SetModifiedFlag();
		}
		else return;
		draw.isRaytracePrompt = dlg.m_isPrompt;
		isPrompted = isForceDlg ? true : draw.isRaytracePrompt == TRUE;
	}
	 
	SetCurrentDirectory(txPath);

	if (!isFileExistNotDirectory(draw.rayName)) {
		AfxMessageBox(_T("Input ray parameter file cann't be found."), MB_ICONQUESTION);
			return;
	} // if
	if (!isFileExistNotDirectory(velMod.velSecName)) {
		AfxMessageBox(_T("Input velocity file cann't be found."), MB_ICONQUESTION);
		return;
	} // if

	// copy r.in, Note: if file does not exist, getFileModifiedTime() may return 0
	CString rinFile = txPath + _T("r.in");
	if (!isSameFileSizeTime(draw.rayName, rinFile)) {
		if (!CVelMod::mySaveRInFile(draw.rayName, rinFile, !draw.isRaytracePrompt)) {
			AfxMessageBox(_T("Input ray parameter file cann't be copied to r.in in the working directory. It can happen if r.in is locked by some process, or the working directory is read-only. If r.in already exists, I will continue without updating r.in."), MB_ICONQUESTION);
			if (!isFileExistNotDirectory(rinFile))
				return;
		}
	} // if


	// copy v.bin
	CString vbinFile = txPath + _T("v.bin");
	if (!isSameFileSizeTime(velMod.velSecName, vbinFile)) {
		if (!isFileExistNotDirectory(velMod.velSecName)) {
			AfxMessageBox(_T("The model ") + velMod.velSecName + _T(" is not found"), MB_ICONQUESTION);
			return; // static function
		}
		CVelMod::VELMOD velMod2;
		CVelMod vm;
		velMod2.velSecName = velMod.velSecName;
		if (!vm.loadInitVel(&velMod2, velMod2.velSecName, velColor.dz, tStr)) {
			AfxMessageBox(tStr, MB_ICONQUESTION);
			return;
		}
		if (draw.red.gunDepth != 0.) {
			for (int icont = 1; icont < velMod2.ncont; icont++) {
				for (int j = 0; j < velMod2.nzed[icont]; j++) {
					velMod2.zm[j][icont] -= draw.red.gunDepth;
				}
			} // for icont
		}
		BOOL isTrue = vm.saveModelAs(&velMod2, vbinFile, velColor.dz, FALSE, TRUE);
		//vm.velModFreeArrays(&velMod2);
		if (!isTrue) {
			tStr.Format(_T("Output velocity file cann't be copied to v.bin in the working directory. It can happen when %s directory is not writable, or when raytracing failed causing v.bin locked and you may need to manually kill myRayInvr.exe with Windows' Task Manager."), txPath);
			AfxMessageBox(tStr, MB_ICONQUESTION);
			return;
		}
	} // if



	// now deals with floating reflectors. We need to save as f.in format.
	CString finFile = txPath + _T("f.in"); // optional
	if (isFileExistNotDirectory(velMod.flFloatName)
		&& getFileModifiedTime(finFile) != getFileModifiedTime(velMod.flFloatName)) {
		CVelMod::myLoadFloatReflectors(&velMod);
		CVelMod::mySaveFloatReflectorsIn(&velMod, finFile);
	}


	// now copy tx.in file
	CString txinFile = txPath + _T("tx.in"); // optional
	if (isFileExistNotDirectory(draw.txRaytraceName)
		&& getFileModifiedTime(txinFile) != getFileModifiedTime(draw.txRaytraceName)) {
		CVelMod::mySaveTXInFile(draw.txRaytraceName, txinFile);
	}


	// now start to do real raytracing 
	pFrame->statMain.myCursor(true);

	DeleteFile(_T("tx.out"));
	DeleteFile(_T("rPath.out"));
	DeleteFile(_T("r1.out"));

	CString progPath = getSeisWideParaPath() + _T("\\myRayinvr.exe");
	CString exeNameQuoted = addQuotes(progPath);

	//Do not refresh screen in any way until raytracing finished. Otherwise, 
	// it may refresh screen while raytracing is running!
	draw.isSameDataDisplay = TRUE;

	PROCESS_INFORMATION proc_i = myUnicodeProcess(exeNameQuoted, 
		txPath, 
		isPrompted);  // info returned from CreateProcess

	//WaitForInputIdle
	if (WaitForSingleObject(proc_i.hProcess, 50000) == WAIT_TIMEOUT) {
		// wait for 30 sec, which is 30000 msec here
		pFrame->myCaption(_T("Time-out in raytracing"));
	}
	else {
		if (draw.red.gunDepth != 0.) {
			raypaths.rayFileName = _T("rPath.out");
			if (isFileExistNotDirectory(raypaths.rayFileName) &&
				CRayHelper::loadRayPathFromFile(&raypaths)) {
				// let's correct for gunDepth
				for (int count = 0; count < raypaths.getTotCurve(); count++) {
					for (int j = 0; j < raypaths.npts[count]; j++)
						raypaths.zr[count][j] += draw.red.gunDepth;
				} // for count
				CRayHelper::saveRayPath(&raypaths);
			}
		}

		
		if (cd.coord.drawmode != 9)
			draw.isRayShowing = TRUE;	//Time section will be drawn.
		// note: we do not want to enforce raypath in TWTT domain since it is very costly in CPU
		pFrame->statMain.myCursor(false);

		pFrame->myCaption(_T("Raytracing successful. Use arrows to navigate source, Cntl+Arrow to move pseudo-well."));

		UpdateAllViews(NULL);
		//NotifyChanged();

		// try to refresh the previous windows
		this->myUpdateAllFramesExcept(this);
	} // else	
	CloseHandle(proc_i.hProcess);
	CloseHandle(proc_i.hThread);


}

void CSeisWideDoc::OnModelingRaypath()
{
	// disable this routine -- Oct. 20, 2003, by Deping
	return;

	if (AfxMessageBox(_T("This will do raytracing using old DOS display. Do you want to use Windows display instead?"), MB_YESNO | MB_ICONINFORMATION) == IDYES) {
		OnModelingRaytrace();
		return;
	}

	//	return;
	// _searchenv( searchfile, envvar, pathbuffer );

	if (AfxMessageBox(_T("Do you want to perform raytracing first (Choose Yes if you haven't done so after last velocity change)?"), MB_YESNO | MB_ICONINFORMATION) == IDYES)
		OnModelingRaytrace();

	//make tx.out file in the same directory as velMod.velSecName.
	CString name = velMod.velSecName, txPath;
	int pathLen = name.ReverseFind('\\');
	if (pathLen > (-1))
		SetCurrentDirectory(name.Left(pathLen));

	TCHAR curDir[_MAX_PATH];
	GetCurrentDirectory(_MAX_PATH, curDir);
	_tcscat_s(curDir, _T("\0"));

	name = m_strPathName;
	int nPathLength = GetModuleFileName(NULL, name.GetBuffer(_MAX_PATH), _MAX_PATH);
	name.ReleaseBuffer();

	CString progPath = name.Left(nPathLength - 12);
	progPath += _T("p.out");
	if (!CopyFile(_T("p.out"), progPath, FALSE))
	{
		AfxMessageBox(_T("p.out file in working directory cann't be copied to program install directory"), MB_ICONQUESTION);
		return;
	}

	SetCurrentDirectory(name.Left(nPathLength - 12));

	if (_tsystem(_T("Rayplt.bat")) == -1)
		AfxMessageBox(_T("Cannot run Rayplt.bat program to plot the rays"), MB_ICONQUESTION);
	else
	{
		progPath = _T(" This raypath graphics is saved as test.cgm file in ") + name.Left(nPathLength - 12) + _T(" directory. To read/modify it, you could use a Lotus Software, CorelDraw, or CGM readers from Corel.com; Other softwares may not import properly.");
		progPath += _T("\n Alternatively, you can get PostScipt plot files by running separate executables (see extra downloads from http://foflg.net/seisweb).");
		AfxMessageBox(progPath);
	}

	SetCurrentDirectory(curDir);
	//draw.isSameDataDisplay = FALSE; //indicate display has been changed and will re-load all data in OnDraw().
	// SetModifiedFlag();
	UpdateAllViews(NULL);
	NotifyChanged();
}

void CSeisWideDoc::OnViewSegyinfo()
{
	static BOOL isAuto = FALSE;
	CdlgSegyInfo dlg;

	dlg.m_timeSecName = draw.timeSecName;
	dlg.m_xShift = draw.distShift;
	dlg.m_isAuto = isAuto;
	if (!isAuto) {
		INT_PTR isTrue = dlg.DoModal();
		if (isTrue == IDOK) {
			isAuto = dlg.m_isAuto;
			if (draw.timeSecName != dlg.m_timeSecName) {
				draw.timeSecName = dlg.m_timeSecName;
				UpdateAllViews(NULL);
				NotifyChanged();
			}
		}
	}
	else {
		// since we do not show dialog box, we directly dump trace header info. This can save user's time
		dlg.m_isAuto = isAuto; // tell the dlg that no physical box is shown on screen
		dlg.OnButton8DumpMoreTraceInfo();
	}
}


void CSeisWideDoc::OnEditLabelOutside()
{
	draw.isNoLableOutside = !draw.isNoLableOutside;
	//if(draw.isNoLableOutside != TRUE)draw.isNoLableOutside=TRUE;
	//else draw.isNoLableOutside=FALSE;
	draw.isNodeChanged = TRUE;
	UpdateAllViews(NULL);
	NotifyChanged();


}

void CSeisWideDoc::OnEditTuneupNoboundary()
{
	//if(draw.isNoBoundary != TRUE)draw.isNoBoundary=TRUE;
	//else draw.isNoBoundary=FALSE;
	draw.isNoBoundary = !draw.isNoBoundary;
	//	draw.isNoNodes = draw.isNoBoundary;
	draw.isNodeChanged = TRUE;

	//	draw.isSameDataDisplay = FALSE; //indicate display has been changed and will re-load all data in OnDraw().
	//	SetModifiedFlag();
	UpdateAllViews(NULL);
	NotifyChanged();

}

void CSeisWideDoc::OnEditTuneupNocolormap()
{
	draw.isNoColorMap = !draw.isNoColorMap;
	draw.isNodeChanged = TRUE;

	//if (cd.coord.drawmode == 2 || cd.coord.drawmode == 4) draw.isSameDataDisplay = FALSE; 
	// note: I do not have a special case for simple refresh in ondraw() in cd.coord.drawmode==4, so I need to re-calculate all for this case
	UpdateAllViews(NULL);
}

void CSeisWideDoc::OnEditTuneupObspositions()
{
	//if(!draw.isNoOBSPos)draw.isNoOBSPos=TRUE;
	//else draw.isNoOBSPos=FALSE;
	draw.isNoOBSPos = !draw.isNoOBSPos;
	draw.isNodeChanged = TRUE;

	// draw.isSameDataDisplay = FALSE; //indicate display has been changed and will re-load all data in OnDraw().
	//	SetModifiedFlag();
	UpdateAllViews(NULL);
	NotifyChanged();

}

void CSeisWideDoc::OnEditDisplaytuneupFillareaonce()
{
	areaFill.isFillSmall = !areaFill.isFillSmall;
	draw.isSameDataDisplay = FALSE;
	UpdateAllViews(NULL);
	NotifyChanged();

}

void CSeisWideDoc::OnEditDisplaytuneupBigmodelnodes()
{
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	if (pFrame->statMain.bigNodes == 3) pFrame->statMain.bigNodes = 1;
	else if (pFrame->statMain.bigNodes == 2) pFrame->statMain.bigNodes = 3;
	else if (pFrame->statMain.bigNodes == 1) pFrame->statMain.bigNodes = 2;
	else pFrame->statMain.bigNodes = 1;
	//	draw.isSameDataDisplay = FALSE; //indicate display has been changed and will re-load all data in OnDraw().
	UpdateAllViews(NULL);
	NotifyChanged();

}

void CSeisWideDoc::OnEditDisplaytuneupChangcolorttcurves()
{
	draw.TTCurveColor++;
	if (draw.TTCurveColor > 4) draw.TTCurveColor = 0;
	else if (draw.TTCurveColor < 0) draw.TTCurveColor = 0;

	//	draw.isSameDataDisplay = FALSE; //indicate display has been changed and will re-load all data in OnDraw().
	UpdateAllViews(NULL);
	NotifyChanged();

}

void CSeisWideDoc::OnEditDisplaytuneupRemovettoverlay()
{
	draw.isRayShowing = !draw.isRayShowing;

	//	if(para.traveltime) para.traveltime = FALSE;
	//	else para.traveltime = TRUE;

	//if (!isTimeDomain())
	//	draw.isSameDataDisplay = FALSE; //indicate display has been changed and will re-load all data in OnDraw().
	UpdateAllViews(NULL);
	NotifyChanged();

}

void CSeisWideDoc::OnEditImagestretchmode()
{
	// TODO: Add your command handler code here
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	pFrame->statMain.isStretchMode = !pFrame->statMain.isStretchMode;
	draw.isSameDataDisplay = FALSE;
	UpdateAllViews(NULL);
	NotifyChanged();
}




float CSeisWideDoc::getDepthAtSeafloor(float dist)
{
	long icont, j;
	float depth = -1.f;
	if (velMod.ncont < 1) return depth;

	// this is the seafloor
	// icont = (velMod.vf[0][1][0]>1.55) ?  1  :  2;
	icont = (velMod.vf[0][1][0] > 1.55 || velMod.vf[0][1][1] > 1.55) ? 1 : 2;
	// here, if only 1 water layer exists, icont=1. If the second layer has a V<=1.55 at the top
	//  we should have icont=2

	for (j = 1; j < velMod.nzed[icont]; j++) {
		if (dist < velMod.xm[0][icont]) {
			depth = velMod.zm[0][icont];
			break;
		}
		else if (dist >= velMod.xm[j - 1][icont] && dist <= velMod.xm[j][icont]) {
			if (fabs(velMod.xm[j][icont] - velMod.xm[j - 1][icont]) < 0.00001f)
				depth = velMod.zm[j][icont];
			else
				depth = velMod.zm[j - 1][icont] + (dist - velMod.xm[j - 1][icont])*
				(velMod.zm[j][icont] - velMod.zm[j - 1][icont]) / (velMod.xm[j][icont] - velMod.xm[j - 1][icont]);
			break;
		}
		else if (dist > velMod.xm[velMod.nzed[icont] - 1][icont]) {
			depth = velMod.xm[velMod.nzed[icont] - 1][icont];
			break;
		}
	}
	return depth;
}


void CSeisWideDoc::OnProcessingTimeDepthDrawings()
{
	// this  will convert line drawings from time to depth
	BOOL error_nmax = FALSE, error_lmax = FALSE, firstTim = TRUE, textErr = FALSE;
	//TCHAR line[MAXLINE];
	//FILE *ifh1;  /* Input file handle */
	FILE *stream;
	int i, j;
	//float x1,t1;

	if (!cd.coord.isModelingMode()) {
		AfxMessageBox(_T("Please display a valid model before continue."), MB_ICONQUESTION);
		return;
	}

	CString t;
	bool isTime2Depth;
	int isTrue;
	t.Format(_T("Convert between time and depth domains. Yes=Time to depth. No=Depth to Time."));
	isTrue = AfxMessageBox(t, MB_YESNO | MB_ICONINFORMATION);
	if (isTrue == IDYES)
		isTime2Depth = true;
	else if (isTrue == IDNO)
		isTime2Depth = false;
	else return;


	CDigitize pDg;
	if (!isFileExistNotDirectory(dig.digName) ||
		!pDg.myDigitizingLoadTXTUnix2(&dig) ||
		dig.totCurve < 1) {
		AfxMessageBox(_T("Valid distance-TWTT pair not loaded."), MB_ICONQUESTION);
		return;
	}

	CString outFile = dig.digName +
		(isTime2Depth ? _T(".ConvertedDepth.txt") : _T(".ConvertedTWTT.txt"));
	if (_tfopen_s(&stream, outFile, _T("w")) != 0) return;
	//FILE *streamQM;
	//if (_tfopen_s(&streamQM, dig.digName + _T(".QingmuDepth.txt"), _T("w") ) != 0) return;
	//_ftprintf_s(streamQM,_T("#Sonobuoy 34-1\n"));
	//_ftprintf_s(streamQM,_T("#Comparison of Qingmu's formula with wide-angle model\n"));
	//_ftprintf_s(streamQM,_T("#z = (float)(-0.0578892255+2.067082*(t - tsf)+0.363685727*(t - tsf)*(t - tsf) );\n"));
	//_ftprintf_s(streamQM,_T("#  where t-tsf is one-way time below seafloor. z is the depth below seafloor. Below, *Depth_qm* will be computed depth plus seafloor depth\n"));
	//_ftprintf_s(streamQM,_T("#    Dist   *Depth_qm*  *Depth_Mod(km)*   Bound_No   TWTT_Picked(s) TWTT_seafl(s) Depth_seafl(s)\n"));

	CVelMod vm;
	int nWork = (int)(dig.getYmax() / velColor.dz + 2);
	double *twtt = (double *)ealloc1double((size_t)nWork);
	for (i = 0; i < dig.totCurve; i++)
		for (j = 0; j < dig.nPoint[i]; j++) {
			register float x = dig.x[j][i];
			register float y = dig.t[j][i];
			register double yout;
			if (isTime2Depth) {
				yout = vm.my2WayTime2Depth2(&velMod, x, y, velColor.dz, twtt, nWork);
			}
			else {
				yout = vm.myDepth2Time2Way(&velMod, x, y, velColor.dz, twtt, nWork);
			}
			_ftprintf_s(stream, _T(" %9.3f %9.3f %9d\n"), dig.x[j][i], yout, i + 1);

			//float zsf = getDepthAtSeafloor(dig.x[j][i]);
			//float tsf = 4.f * zsf / (velMod.vf[0][0][0] + velMod.vf[0][0][1]);  // assumes constant water vel
			//float dqm = (float)(-0.0578892255+2.067082*(t - tsf)/2.+0.363685727*(t - tsf)*(t - tsf)/4. );
			//_ftprintf_s(streamQM," %9.3f %9.3f  %9.3f       %9d  twtt=%9.3f tsf=%9.3f zsf=%9.3f\n",dig.x[j][i], dqm+zsf, z, i+1, t, tsf, zsf);
		}
	free1double(twtt);
	fclose(stream);
	//fclose( streamQM );


	t = _T("Input time data are successfully converted and saved to the same directory as:\n") +
		dig.digName + _T("\n") +
		"using the current velocity model. Showing it in notepad first?";
	dig.digName = outFile;

	if ((AfxMessageBox(t, MB_YESNO | MB_ICONINFORMATION) == IDYES)) {
		showFileInNotePad(outFile);
	}
	if (isTime2Depth)
		cd.coord.drawmode = 3;
	else
		cd.coord.drawmode = 0;
	UpdateAllViews(NULL);
	NotifyChanged();
}


BOOL CSeisWideDoc::MyLoadDistTwttDrawings4John(CString sgyName, CString lstpcName, CString digName)
{
	// this will load John's CMP-TWTT ascii file inName, compare with 
	// draw.timeSecName or draw.depthSecName segy file to obtain distance information, 
	// and store to global variables: dig.x[][]  dig.t[][] struct, 
	// as well as saving to local file digName 


	CString tStr;
	tStr.Format(_T("Loading/long processing file %s ......"), lstpcName);
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	pFrame->myCaption(tStr);
	CStringArray *lst = getLinesFromFile(lstpcName);

	if (lst->GetSize() < 1) return FALSE;

	float *lst_twtt = (float *)ealloc1float(lst->GetSize());
	float *lst_fcmp = (float *)ealloc1float(lst->GetSize());
	int *lst_curve = (int *)ealloc1int(lst->GetSize());

	float f3;
	double d3;
	int i2, i3, i4;
	int i, ii = 0, j, np;
	int lst_size = 0;
	CString stmp;
	TCHAR ch[256];

	// skip the first 2 lines
	for (i = 2; i < lst->GetSize(); i++) {
		// if ( _stscanf_s(lst->ElementAt(i).Trim(), "%16E%16E%3d%3d%f%f%f%d%lf%d%s",&d1, &d2, &lst_curve[ii],&i2,&lst_twtt[ii], &lst_fcmp[ii],   &f3, &i3, &d3, &i4, stmp) == 0 ) continue;
		if (_stscanf_s(lst->ElementAt(i).Mid(32), _T("%d%d%f%f%f%d%lf%d%s"), &lst_curve[ii], &i2, &lst_twtt[ii], &lst_fcmp[ii], &f3, &i3, &d3, &i4, ch, 256) == 0) continue;
		stmp = CString(ch, (int)_tcslen(ch)).Trim();
		if (sgyName.Find(stmp) >= 0) {
			lst_twtt[ii] *= 0.001f;  // convert to seconds
			ii++;
		}
	} // for i
	//lst_twtt[2800];
	lst->RemoveAll();
	delete lst;
	lst_size = ii;

	if (lst_size == 0) {
		// no points are read in. Let's exit this routine
		free1int(lst_curve);
		free1float(lst_twtt);
		free1float(lst_fcmp);
		//draw.isSameNodeDisplay = FALSE;
		pFrame->myCaption(_T("No data read in. The last column must match: ") + sgyName);
		return FALSE;
	}


	// calculate how many curves exist
	int max_curves = 0;
	for (j = 1; j < lst_size; j++) {
		if (lst_curve[j] != lst_curve[j - 1]) max_curves++;
	} // for j

	int max_points = head.numTraces;


	CDigitize pDg;
	CDigitize::DIGITIZE dig2;
	dig2.initDigitizeArray(max_points, max_curves);
	dig2.isZeltFormat = FALSE;  // we only allow plain text format

	// start assigning for dig.xxx struct
	for (j = 0; j < max_curves; j++) dig2.nPoint[j] = 0;
	dig2.totCurve = 1;
	dig2.iCurveSel = 0;

	/*
	...........................lst_curve...lst_ftwtt..lst_fcmp.....................................
	-6.34595099E+05  7.36724142E+05  2 14  4167.92    112.00    112.00    1 3.4028235E+38 2 lsl0914
	-6.34573900E+05  7.36711017E+05  2 14  4168.53    114.00    114.00    2 3.4028235E+38 2 lsl0914
	......
	-6.12287107E+05  7.11329916E+05  2 14  4147.33   2860.00   2860.00 1375 3.4028235E+38 2 lsl0914
	-6.12273682E+05  7.11308910E+05  2 14  4146.00   2862.00   2862.00 1376 3.4028235E+38 2 lsl0914
	-6.12221643E+05  7.11223842E+05  3 14  4129.45   2870.00   2870.00 1380 3.4028235E+38 2 lsl0914
	-6.12208772E+05  7.11202488E+05  3 14  4128.90   2872.00   2872.00 1381 3.4028235E+38 2 lsl0914
	......
	-6.34531503E+05  7.36684767E+05 25 14  4540.44    118.00    118.00    4 3.4028235E+38 2 lsl0914
	-6.34510304E+05  7.36671642E+05 25 14  4540.49    120.00    120.00    5 3.4028235E+38 2 lsl0914
	-6.34491477E+05  7.36655309E+05 25 14  4538.72    122.00    122.00    6 3.4028235E+38 2 lsl0914
	......
	-6.11556226E+05  7.08250887E+05 28 14  4576.01   3130.00   3130.00 1510 3.4028235E+38 2 lsl0914
	-6.11567083E+05  7.08231818E+05 28 14  4575.33   3132.00   3132.00 1511 3.4028235E+38 2 lsl0914
	-6.11577940E+05  7.08212750E+05 28 14  4574.46   3134.00   3134.00 1512 3.4028235E+38 2 lsl0914
	*/
	int ic;
	for (j = 0; j < lst_size; j++) {
		ic = dig2.iCurveSel;
		np = dig2.nPoint[ic];  // total number of points for the current curve

		// now loop thru the segy traces to match the corresponding cmp[] in order to find the correct model distance dist[]
		for (i = 0; i < head.numTraces; i++) {
			if (head.cdp[i] == (int)myRound(lst_fcmp[j])) {
				// make sure the num points do not exceed limit of dig2
				// in our case, max_points = numTraces
				if (np >= max_points - 1)  break;

				if (np > 1) {
					if ((j>0 && lst_fcmp[j] < lst_fcmp[j - 1]) ||
						head.dist[i] < dig2.x[np - 1][ic] ||
						(j>0 && lst_curve[j] != lst_curve[j - 1]))
					{

						if (ic >= max_curves - 1) continue;  // max num of curves reached

						dig2.iCurveSel++;
						ic = dig2.iCurveSel; // iCurve updated already
						np = dig2.nPoint[ic] = 0;
						dig2.totCurve = ic + 1;
					} // if
				} // if np>1
				dig2.x[np][ic] = head.dist[i];
				dig2.t[np][ic] = lst_twtt[j];
				dig2.nPoint[ic]++;
				np = dig2.nPoint[ic];  // total number of points for the current curve updated

				// we stop for this lst_fcmp[] anyway by breaking
				break;
			} // if
		} // for i
	} // for j

	// now we need to append dig2  to dig
	if (dig.nPoint == NULL) {
		dig.initDigitizeArray(max_points, dig2.totCurve);
		dig.isZeltFormat = FALSE;
		dig.totCurve = dig2.totCurve;
		for (int j = 0; j < dig.totCurve; j++)
		{
			dig.nPoint[j] = dig2.nPoint[j];
		}
		for (ic = 0; ic < dig.totCurve; ic++) {
			for (int ip = 0; ip < dig.nPoint[ic]; ip++) {
				dig.x[ip][ic] = dig2.x[ip][ic];
				dig.t[ip][ic] = dig2.t[ip][ic];
			}
		}
	} // if dig.nPoint
	else {
		// first backup dig  to dig3
		CDigitize::DIGITIZE dig3;
		dig3.initDigitizeArray(dig.digPointMax, dig.digLayerMax);
		dig3.totCurve = dig.totCurve;
		for (int j = 0; j < dig.totCurve; j++)
		{
			dig3.nPoint[j] = dig.nPoint[j];
		}
		for (ic = 0; ic < dig.totCurve; ic++) {
			for (int ip = 0; ip < dig.nPoint[ic]; ip++) {
				dig3.x[ip][ic] = dig.x[ip][ic];
				dig3.t[ip][ic] = dig.t[ip][ic];
			}
		}

		// re-define dig  and  append dig3 followed by dig2    to   dig
		dig.initDigitizeArray(MAX(dig3.digPointMax, dig2.digPointMax), dig3.digLayerMax + dig2.digLayerMax);
		dig.totCurve = dig3.totCurve + dig2.totCurve;
		for (int j = 0; j < dig3.totCurve; j++)
		{
			dig.nPoint[j] = dig3.nPoint[j];
		}
		for (int j = 0; j < dig3.totCurve; j++)
		{
			dig.nPoint[j] = dig3.nPoint[j];
		}
		for (ic = 0; ic < dig3.totCurve; ic++) {
			for (int ip = 0; ip < dig3.nPoint[ic]; ip++) {
				dig.x[ip][ic] = dig3.x[ip][ic];
				dig.t[ip][ic] = dig3.t[ip][ic];
			}
		}

		// append dig2 to  dig
		int cMax = dig3.totCurve;
		for (int j = 0; j < dig2.totCurve; j++)
		{
			dig.nPoint[j + cMax] = dig2.nPoint[j];
		}
		for (int j = 0; j < dig2.totCurve; j++)
		{
			dig.nPoint[j + cMax] = dig2.nPoint[j];
		}
		for (ic = 0; ic < dig2.totCurve; ic++) {
			for (int ip = 0; ip < dig2.nPoint[ic]; ip++) {
				dig.x[ip][ic + cMax] = dig2.x[ip][ic];
				dig.t[ip][ic + cMax] = dig2.t[ip][ic];
			}
		}

		dig3.freeDigAll();
	}
	dig2.freeDigAll();


	free1int(lst_curve);
	free1float(lst_twtt);
	free1float(lst_fcmp);
	// showFileInNotePad(latLongName + _T(".dist.txt");

	return TRUE;
}


BOOL CSeisWideDoc::MyLoadDistTwttDrawings4John(CString inName)
{
	// DEPRECIATED!!!!
	// this will load John's CMP-TWTT ascii file inName, compare with 
	// draw.timeSecName or draw.depthSecName segy file to obtain distance information, 
	// and store to global variables: dig.x[][]  dig.t[][] struct, as well as saving to file dig.digName 

	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	CStringArray *lst = getLinesFromFile(inName);
	if (lst->GetSize() < 1) return FALSE;

	float *lst_twtt = (float *)ealloc1float(lst->GetSize());
	float *lst_fcmp = (float *)ealloc1float(lst->GetSize());
	int *lst_curve = (int *)ealloc1int(lst->GetSize());

	float f3;
	double d3;
	int i2, i3, i4;
	int i, ii = 0, j, np;
	int lst_size = 0;
	CString stmp;
	TCHAR ch[256];

	CString fileSegy;
	if (isFileExistNotDirectory(draw.timeSecName))  {
		fileSegy = draw.timeSecName;
	}
	else {
		fileSegy = draw.depthSecName;
	}

	// skip the first 2 lines
	for (i = 2; i < lst->GetSize(); i++) {
		if (_stscanf_s(lst->ElementAt(i).Mid(32), _T("%d%d%f%f%f%d%lf%d%s"), &lst_curve[ii], &i2, &lst_twtt[ii], &lst_fcmp[ii], &f3, &i3, &d3, &i4, ch, 256) == 0) continue;
		stmp = CString(ch, (int)_tcslen(ch)).Trim();
		if (fileSegy.Find(stmp) >= 0) {
			lst_twtt[ii] *= 0.001f;  // convert to seconds
			ii++;
		}
	} // for i
	//lst_twtt[2800];
	lst->RemoveAll();
	delete lst;
	lst_size = ii;

	if (lst_size == 0) {
		// no points are read in. Let's exit this routine
		free1int(lst_curve);
		free1float(lst_twtt);
		free1float(lst_fcmp);
		//draw.isSameNodeDisplay = FALSE;
		pFrame->myCaption(_T("No data read in. The last column must match: ") + fileSegy);
		return FALSE;
	}


	// dig.digName	= getFileNameTemp( getFileNameAppend(fileSegy, "_lst"), "txt" );
	dig.digName = GetFileNameAppendExt(fileSegy, _T("_lst"), _T("txt"));

	// calculate how many curves exist
	int max_curves = 0;
	for (j = 1; j < lst_size; j++) {
		if (lst_curve[j] != lst_curve[j - 1]) max_curves++;
	} // for j
	dig.initDigitizeArray(head.numTraces, max_curves);
	dig.isZeltFormat = FALSE;  // we only allow plain text format

	// start assigning for dig.xxx struct
	for (j = 0; j < max_curves; j++) dig.nPoint[j] = 0;
	dig.totCurve = 1;
	dig.iCurveSel = 0;

	/*
	...........................lst_curve...lst_ftwtt..lst_fcmp.....................................
	-6.34595099E+05  7.36724142E+05  2 14  4167.92    112.00    112.00    1 3.4028235E+38 2 lsl0914
	-6.34573900E+05  7.36711017E+05  2 14  4168.53    114.00    114.00    2 3.4028235E+38 2 lsl0914
	......
	-6.12287107E+05  7.11329916E+05  2 14  4147.33   2860.00   2860.00 1375 3.4028235E+38 2 lsl0914
	-6.12273682E+05  7.11308910E+05  2 14  4146.00   2862.00   2862.00 1376 3.4028235E+38 2 lsl0914
	-6.12221643E+05  7.11223842E+05  3 14  4129.45   2870.00   2870.00 1380 3.4028235E+38 2 lsl0914
	-6.12208772E+05  7.11202488E+05  3 14  4128.90   2872.00   2872.00 1381 3.4028235E+38 2 lsl0914
	......
	-6.34531503E+05  7.36684767E+05 25 14  4540.44    118.00    118.00    4 3.4028235E+38 2 lsl0914
	-6.34510304E+05  7.36671642E+05 25 14  4540.49    120.00    120.00    5 3.4028235E+38 2 lsl0914
	-6.34491477E+05  7.36655309E+05 25 14  4538.72    122.00    122.00    6 3.4028235E+38 2 lsl0914
	......
	-6.11556226E+05  7.08250887E+05 28 14  4576.01   3130.00   3130.00 1510 3.4028235E+38 2 lsl0914
	-6.11567083E+05  7.08231818E+05 28 14  4575.33   3132.00   3132.00 1511 3.4028235E+38 2 lsl0914
	-6.11577940E+05  7.08212750E+05 28 14  4574.46   3134.00   3134.00 1512 3.4028235E+38 2 lsl0914
	*/
	for (j = 0; j < lst_size; j++) {
		np = dig.nPoint[dig.iCurveSel];  // total number of points for the current curve

		// now loop thru the segy traces to match the corresponding cmp[] in order to find the correct model distance dist[]
		for (i = 0; i < head.numTraces; i++) {
			if (head.cdp[i] == (int)myRound(lst_fcmp[j])) {
				if (
					np >= head.numTraces - 1 ||
					(dig.nPoint[dig.iCurveSel] > 0 && j>0 && lst_fcmp[j] < lst_fcmp[j - 1]) ||
					(np>0 && head.dist[i] < dig.x[np - 1][dig.iCurveSel]) ||
					(dig.nPoint[dig.iCurveSel] > 0 && j > 0 && lst_curve[j] != lst_curve[j - 1])
					) {
					dig.iCurveSel++;
					np = dig.nPoint[dig.iCurveSel] = 0;
					dig.totCurve = dig.iCurveSel + 1;
				} // if
				dig.x[np][dig.iCurveSel] = head.dist[i];
				dig.t[np][dig.iCurveSel] = lst_twtt[j];
				dig.nPoint[dig.iCurveSel]++;

				// we stop for this lst_fcmp[] anyway by breaking
				break;
			} // if
		} // for i
	} // for j

	CDigitize pDg;
	dig.isSortedX = dig.isSortedY = FALSE;
	int isXInt = cd.coord.isTraceMode();
	pDg.myDigSaveAs2(&dig, isXInt);

	free1int(lst_curve);
	free1float(lst_twtt);
	free1float(lst_fcmp);
	return TRUE;
}



// called by showDigLineDraw()
BOOL CSeisWideDoc::drawLineDrawing(CDC * pDC)
{
	if (draw.isNoBoundary || draw.isNoColorMap) return FALSE;

	// RULE: if dig.digName is not empty, we will load from this file. 
	// If it is empty, we will not load, but will use &dig if it contains anything
	CDigitize pDg;
	if (!dig.isDigitizing && dig.isZeltFormat) {
		// if not digitizing in Zelt format, it means we are hiding the dense Zelt display 
		// bars, then we do not need to show anything here
		return TRUE;
	}
	else if (dig.isDigitizing && dig.isZeltFormat) {
		return myShowDigitize(pDC, &dig, false, !this->isHalfOffsetMode());
	}
	else {
		pDg.myDigitizingLoadTXTUnix2(&dig);
		if (dig.totCurve < 1 || dig.nPoint == NULL) return FALSE;  // this avoids program crash
		if (dig.isDigitizing) {
			return myShowDigitize(pDC, &dig, false, !this->isHalfOffsetMode());
		}
	}

	drawFloatReflectors(pDC); // draws floating reflectors.

	long i, j;
	CPoint *plt;
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	bool isReduceNeeded = cd.coord.isTimeDomain() && cd.coord.drawmode != 10;
	int lineThicikess = (int)myRound(20.0* pFrame->statMain.thicknessLines);


	// label specific
	LOGFONT logFontNum;
	pDC->GetCurrentFont()->GetLogFont(&logFontNum);
	float xyRatio = (float)logFontNum.lfWidth / (float)logFontNum.lfHeight;
	int numWidth = (LONG)myRound(pFrame->statMain.fLabelDistance3 * cd.coord.device2Logical * cd.coord.getDefDisplayAdjust(pDC) * 6.);
	int numHeight = (LONG)(numWidth / xyRatio);

	logFontNum.lfHeight = (int)numHeight;
	logFontNum.lfWidth = (int)numWidth;
	logFontNum.lfEscapement = 0;
	logFontNum.lfOrientation = 0;
	logFontNum.lfWeight = FW_NORMAL;
	logFontNum.lfWeight = FW_BOLD;
	logFontNum.lfItalic = 0;
	logFontNum.lfUnderline = 0;
	logFontNum.lfStrikeOut = 0;
	logFontNum.lfCharSet = ANSI_CHARSET;
	logFontNum.lfOutPrecision = OUT_DEFAULT_PRECIS;
	logFontNum.lfClipPrecision = CLIP_DEFAULT_PRECIS;
	logFontNum.lfQuality = DEFAULT_QUALITY;
	logFontNum.lfPitchAndFamily = FF_SWISS;
	_tcscpy_s(logFontNum.lfFaceName, _T("Arial"));
	CFont fontN;
	fontN.CreateFontIndirect(&logFontNum);
	CFont* oldFont = pDC->SelectObject(&fontN);

	CDigitize::DIGITIZE dig3;
	CDigitize::myClipReducePoints4(&dig, &dig3, &cd.coord, &draw.red, tx.xShotRay, false);

	CPen* pOldPen = pDC->GetCurrentPen();

	bool isTime = cd.coord.isTimeDomain() == TRUE;
	plt = (CPoint *)alloc1CPoint(dig3.digPointMax);
	if (plt == NULL) {
		pFrame->myCaption(_T("Memory un-available 9"));
		return FALSE;
	}
	CPen aPenSelected(PS_SOLID, lineThicikess*8, RGB(255, 120, 0));

	for (i = 0; i < dig3.totCurve; i++) {
		register int n = dig3.nPoint[i];
		for (j = 0; j < n; j++) {
			plt[j] = cd.coord.mm_coord(dig3.x[j][i], dig3.t[j][i]);
		}

		int ind = i;
		while (ind >= lineColors.NUM_LINECOLORS)
			ind -= lineColors.NUM_LINECOLORS;
		COLORREF rgb = RGB(lineColors.r[ind],
			lineColors.g[ind],
			lineColors.b[ind]);
		CPen aBluePen(PS_SOLID, lineThicikess*3, rgb);

		if (n > 1) {
			//if (i==dig3.iCurveSel)
			//	pDC->SelectObject(&aPenSelected);
			//else
				pDC->SelectObject(&aBluePen);
			pDC->Polyline(plt, n);
		}

		// !draw.isNoLabelInSide is not affecting here since we have  dig.isLabelShow 
		if (!draw.isNoLabelInSide && n > 1 && i<n) {
			// now we plot the label for this curve
			COLORREF oldColor = pDC->SetTextColor(rgb);
			pDC->TextOut((int)(plt[n - 1].x), (int)(plt[n - 1].y - numHeight*0.5), dig.getLabelString(i));
			pDC->SetTextColor(oldColor);
		}
	} // for i
	free1CPoint(plt);

	dig3.freeDigAll();

	if (pOldPen)
		pDC->SelectObject(pOldPen);

	pDC->SelectObject(oldFont);
	fontN.DeleteObject();
	return TRUE;
}

void CSeisWideDoc::DrawMarkers(CDC* pDC)
{
	if (draw.isNoBoundary) return;
	//	if (draw.isNoNodes) return;
	// for draw Markers, even if no nodes desired, the markers have to be drawn 
	// otherwise they are not markers.

	if (draw.isNoNodes) {
		// in this case, we want to reduce the OBS marker sizes
		// dPlt /= 2;
		return;
	}

	if (isFileExistNotDirectory(digMarker.digName)) {
		CDigitize pDg;
		pDg.myDigitizingLoadTXTUnix2(&digMarker);
	}

	bool isTime = cd.coord.isTimeDomain() == TRUE;
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	int dPlt = (int)(cd.coord.getPenThicknessNormal() * 2 * pFrame->statMain.fLabelDistance3);
	int j, k;
	double xpos, ypos;

	CString tstr;
	CPen* pOldPen = pDC->GetCurrentPen();

	if (!draw.isNoNodes && isModelVisible(&velMod, 0.) && isFileExistNotDirectory(draw.rayName)) {
		CVelMod vm;
		bool isTime = cd.coord.isTimeDomain() == TRUE;
		CStringArray *sArr = new CStringArray();
		CStringArray *sArrZ = new CStringArray();
		CStringArray* sArrName = new CStringArray();
		INT_PTR nx = 0, nz = 0, nName=0;
		if (loadParam(draw.rayName, _T("xshot"), sArr)) {
			nx = sArr->GetCount();
		} // if loadParam
		if (loadParam(draw.rayName, _T("zshot"), sArrZ)) {
			nz = sArrZ->GetCount();
		} // if loadParam
		if (loadParam(draw.rayName, _T("#NAME"), sArrName)) {
			nName = sArrName->GetCount();
		} // if loadParam
		if (nx == nz) {
			int aThick = (int)(pFrame->statMain.thicknessLines * 2.+.5);
			if (aThick > 3) aThick = 3;
			CPen redPen(PS_SOLID, aThick, RED);
			//CBrush brush;
			//brush.CreateSolidBrush(BLUE);
//			pOldBrush = pDC->SelectObject(&brush);
			pOldPen = pDC->SelectObject(&redPen);
			int dPltX = (int)(dPlt * 2);
			int dPltY = (int)(dPlt * 1.7);


			TRIVERTEX vertex[3];
			vertex[0].x = 150;
			vertex[0].y = 0;
			vertex[0].Red = 0xff00;
			vertex[0].Green = 0x8000;
			vertex[0].Blue = 0x0000;
			vertex[0].Alpha = 0x0000;

			vertex[1].x = 0;
			vertex[1].y = 150;
			vertex[1].Red = 0x9000;
			vertex[1].Green = 0x0000;
			vertex[1].Blue = 0x9000;
			vertex[1].Alpha = 0x0000;

			vertex[2].x = 300;
			vertex[2].y = 150;
			vertex[2].Red = 0x9000;
			vertex[2].Green = 0x0000;
			vertex[2].Blue = 0x9000;
			vertex[2].Alpha = 0x0000;

			// Create a GRADIENT_TRIANGLE structure that
			// references the TRIVERTEX vertices.
			GRADIENT_TRIANGLE gTriangle;
			//gTriangle[0] = { 0, 1, 2 };
			//gTriangle[1] = { 1, 2, 3 };
			gTriangle.Vertex1 = 0;
			gTriangle.Vertex2 = 1;
			gTriangle.Vertex3 = 2;

			CPoint pint[3];

			if (isTime) {
				int nz = (int)(velMod.zmax / velColor.dz);
				double *twtt = (double *)ealloc1double(nz + 2);
				for (j = 0; j < nx; j++) {
					xpos = StringToFloat(sArr->GetAt(j));
					ypos = StringToFloat(sArrZ->GetAt(j));  // ypos is in km depth
					if (isTime)
						ypos = vm.myDepth2Time2Way(&velMod, xpos, ypos, velColor.dz, twtt, nz + 2);  // ypos is now in TWTT
					if (!cd.coord.isVisibleOrNot(xpos, ypos)) {
						// make another try to let it show up
						ypos = cd.coord.Y1() - cd.coord.yHeight() * 0.01;
					}

					register CPoint p = cd.coord.mm_coord(xpos, ypos);
					if (p.x - dPlt < cd.coord.logicalAxes.left || p.x + dPlt>cd.coord.logicalAxes.right)
						continue;

					if (cd.coord.isVisibleOrNot(xpos, ypos)) {
						//pDC->SelectObject(&brush);

						if (draw.isCopying) {
							// why bother: because the clipboard seems not supporting the shaded triangle
							pint[0].x = p.x - dPlt;
							pint[0].y = p.y - dPlt;
							pint[1].x = p.x + dPlt;
							pint[1].y = p.y - dPlt;
							pint[2].x = p.x;
							pint[2].y = p.y + dPlt;
							pDC->Polygon(pint, 3);
						}
						else {
							// Draw a shaded triangle.
							vertex[0].x = p.x - dPlt;
							vertex[0].y = p.y - dPlt;
							vertex[1].x = p.x + dPlt;
							vertex[1].y = p.y - dPlt;
							vertex[2].x = p.x;
							vertex[2].y = p.y + dPlt;
							pDC->GradientFill(vertex, 3, &gTriangle, 1, GRADIENT_FILL_TRIANGLE);
						}
						if (j < nName)
							pDC->TextOut(p.x - dPlt, p.y - dPlt, sArrName->GetAt(j));
					}
					else {
						// when the OBS is not visible in model, we plot it using another symbol!
						pDC->Ellipse(p.x - dPlt, cd.coord.viewLogicalTotal.top, p.x + dPlt, cd.coord.viewLogicalTotal.top + dPlt/2);
						if (j < nName)
							pDC->TextOut(p.x - dPlt, cd.coord.viewLogicalTotal.top, sArrName->GetAt(j));
					}
				} // for j
				free1double(twtt);
			}
			else {
				for (j = 0; j < nx; j++) {
					xpos = StringToFloat(sArr->GetAt(j));
					ypos = StringToFloat(sArrZ->GetAt(j));  // ypos is in km depth
					if (!cd.coord.isVisibleOrNot(xpos, ypos)) {
						// make another try to let it show up
						ypos = cd.coord.Y1() - cd.coord.yHeight() * 0.01;
					}
					register CPoint p = cd.coord.mm_coord(xpos, ypos);
					if (p.x - dPlt < cd.coord.logicalAxes.left || p.x + dPlt>cd.coord.logicalAxes.right)
						continue;


					if (cd.coord.isVisibleOrNot(xpos, ypos)) {
						//pOldBrush = pDC->SelectObject(&brush);

						if (draw.isCopying) {
							// why bother: because the clipboard seems not supporting the shaded triangle
							pint[0].x = p.x - dPlt;
							pint[0].y = p.y - dPlt;
							pint[1].x = p.x + dPlt;
							pint[1].y = p.y - dPlt;
							pint[2].x = p.x;
							pint[2].y = p.y + dPlt;
							pDC->Polygon(pint, 3);

						}
						else {
							// Draw a shaded triangle.
						// Draw a shaded triangle.
							vertex[0].x = p.x - dPlt;
							vertex[0].y = p.y - dPlt;
							vertex[1].x = p.x + dPlt;
							vertex[1].y = p.y - dPlt;
							vertex[2].x = p.x;
							vertex[2].y = p.y + dPlt;
							pDC->GradientFill(vertex, 3, &gTriangle, 1, GRADIENT_FILL_TRIANGLE);
						}
						if (j < nName) 
							pDC->TextOut(p.x - dPlt, p.y - dPlt, sArrName->GetAt(j));
					}
					else {
						// when the OBS is not visible in model, we plot it using another symbol!
						pDC->Ellipse(p.x - dPlt, cd.coord.viewLogicalTotal.top, p.x + dPlt, cd.coord.viewLogicalTotal.top + dPlt / 2);
						if (j < nName)
							pDC->TextOut(p.x - dPlt, cd.coord.viewLogicalTotal.top, sArrName->GetAt(j));
					}
				} // for j
			}
			pDC->SelectObject(pOldPen);
//			pDC->SelectObject(pOldBrush);
		} // if nx

		sArr->RemoveAll();
		sArrZ->RemoveAll();
		sArrName->RemoveAll();
		delete sArr;
		delete sArrZ;
		delete sArrName;
	}

	CBrush* pOldBrush;

	dPlt = (int)(dPlt*pFrame->statMain.thicknessLines);
	if (digMarker.isDigitizing && !draw.isNoLabelInSide) {
		myShowDigitize(pDC, &digMarker, true, !this->isHalfOffsetMode());
		return;
	}

	if (digMarker.totCurve>0) {
			CPoint *pltV = (CPoint *)alloc1CPoint(digMarker.digPointMax);

			CDigitize::DIGITIZE dig3;
			// note: digMarker usually does not have the most up-to-date values of
			//		transformations, so we have to set before clipping
			digMarker.transIsRevYAxis = dig.transIsRevYAxis;
			digMarker.transXMultFactor = dig.transXMultFactor;
			digMarker.transXShift = dig.transXShift;
			digMarker.transYMultFactor = dig.transYMultFactor;
			digMarker.transYShift = dig.transYShift;
			CDigitize::myClipReducePoints4(&digMarker, &dig3, &cd.coord, &draw.red, tx.xShotRay, false);




			CBrush brush;
			brush.CreateSolidBrush(GREEN);
			pOldBrush = pDC->SelectObject(&brush);
			//pOldPen = pDC->SelectObject(&redPen);

			int lineThicikess = (int)myRound(30.0* pFrame->statMain.thicknessLines);
			//CPen aPenSelected(PS_SOLID, lineThicikess * 8, RGB(255, 120, 0));
			for (k = 0; k < dig3.totCurve; k++) {
				int ind = k;
				while (ind >= lineColors.NUM_LINECOLORS)
					ind -= lineColors.NUM_LINECOLORS;
				//COLORREF rgb = RGB(lineColors.r[ind],
				//	lineColors.g[ind],
				//	lineColors.b[ind]);
				CPen aBluePen(PS_DASH, lineThicikess, BLACK);
				//if (k == digMarker.iCurveSel)
				//	pDC->SelectObject(&aPenSelected);
				//else

				register int n = dig3.nPoint[k];
				for (j = 0; j < n; j++) {
					pltV[j] = cd.coord.mm_coord(dig3.x[j][k], dig3.t[j][k]);
				} // for j

				pDC->SelectObject(&aBluePen);
				n = CCoords::myClipPoints2b(n, 2 * dig3.digPointMax, pltV, &cd);
				pDC->Polyline(pltV, n);

				if (digMarker.totCurve == 1) {
					// only if there is 1 curve in total, we draw actual symbols, which may represent 
					// observed gravity values for example. 
					// If there are >1 curves, drawing the symbols are strange to appear.
					for (j = 0; j < n; j++)
						pDC->Ellipse(
							pltV[j].x - dPlt,
							pltV[j].y - dPlt,
							pltV[j].x + dPlt,
							pltV[j].y + dPlt
						);
				} // if
			} // for k
			pDC->SelectObject(pOldBrush);

			brush.DeleteObject(); // this will be done automatically even if you do not do it here
			free1CPoint(pltV);
			dig3.freeDigAll();
	} // if
	pDC->SelectObject(pOldPen);
	pDC->SelectObject(pOldPen);





	// the following should be later simplified using myLoadDigFile() function!!!
	return;
}



void CSeisWideDoc::OnProcessingCheckmodelintegrity()
{
	// TODO: Add your command handler code here
	//	if(cd.coord.drawmode < 2 || cd.coord.drawmode>4) 
	//	{
	//		AfxMessageBox(_T("Please show the model first", MB_OK|MB_ICONEXCLAMATION);
	//		return;
	//	}
	if (!checkModelError(velMod.velSecName))
	{
		AfxMessageBox(_T("There are boundary overlaps in the currently active model; Raytracing this model may hang up the raytracing program"), MB_ICONQUESTION);
		// CString newName = velMod.velSecName + _T(".tempErrInfo.txt";

		//CString newName = GetFileNameAppendExt(velMod.velSecName, _T(".tempErrInfo", _T("txt");
		//showFileInNotePad(newName);
		return;
	}
	else AfxMessageBox(_T("No errors found"), MB_ICONQUESTION);

}

//
//void CSeisWideDoc::ClipModelDepreciated(float cmMin, float cmMax)
//{
//	// **************NOT USED *****************
//	return;
//
//	if (velMod.velSecName.IsEmpty())
//	{
//		AfxMessageBox(_T(" Please save your current model before clipping"));
//		return;
//	}
//
//	if (cmMin<velMod.xm[0][0] || cmMax>velMod.xm[velMod.nzed[0] - 1][0])
//	{
//		AfxMessageBox(_T(" Please clip, not extend the model"));
//		return;
//	}
//	int icont, j, k, k1, k2, n;
//	float x[500], z[500];
//
//	//clip a model between distance cmMin and cmMax.
//	for (icont = 0; icont < velMod.ncont; icont++)
//	{
//		for (j = 0; j < velMod.nzed[icont]; j++)
//		{
//			if (velMod.xm[j][icont] < cmMin) continue;
//			else
//			{
//				k1 = j;
//				break;
//			}
//		}
//		for (j = velMod.nzed[icont] - 1; j >= 0; j--)
//		{
//			if (velMod.xm[j][icont] > cmMax) continue;
//			else
//			{
//				k2 = j;
//				break;
//			}
//		}
//
//		if (velMod.xm[k1][icont] != cmMin)
//		{
//			x[0] = cmMin;
//			z[0] = velMod.zm[k1 - 1][icont] +
//				(velMod.zm[k1][icont] - velMod.zm[k1 - 1][icont])*
//				(x[0] - velMod.xm[k1 - 1][icont])
//				/ (velMod.xm[k1][icont] - velMod.xm[k1 - 1][icont]);
//			for (j = k1; j <= k2; j++)
//			{
//				x[j - k1 + 1] = velMod.xm[j][icont];
//				z[j - k1 + 1] = velMod.zm[j][icont];
//			}
//			n = k2 - k1 + 2;
//		}
//		else
//		{
//			for (j = k1; j <= k2; j++)
//			{
//				x[j - k1] = velMod.xm[j][icont];
//				z[j - k1] = velMod.zm[j][icont];
//			}
//			n = k2 - k1 + 1;
//		}
//
//		if (velMod.xm[k2][icont] != cmMax)
//		{ //need change.
//			n++;
//			z[n - 1] = velMod.zm[k2][icont] +
//				(velMod.zm[k2 + 1][icont] - velMod.zm[k2][icont])*
//				(cmMax - velMod.xm[k2][icont])
//				/ (velMod.xm[k2 + 1][icont] - velMod.xm[k2][icont]);
//			x[n - 1] = cmMax;
//		}
//
//		velMod.nzed[icont] = n;
//		for (j = 0; j < n; j++)
//		{
//			velMod.xm[j][icont] = x[j];
//			velMod.zm[j][icont] = z[j];
//		}
//	}  // End of clipping boundaries.
//
//	//clip vel nodes between distance cmMin and cmMax.
//	for (k = 0; k < 2; k++)
//	{
//		for (icont = 0; icont < velMod.ncont - 1; icont++)
//		{
//			for (j = 0; j < velMod.nvel[icont][k]; j++)
//			{
//				if (velMod.xvel[j][icont][k] < cmMin) continue;
//				else
//				{
//					k1 = j;
//					break;
//				}
//			}
//			for (j = velMod.nvel[icont][k] - 1; j >= 0; j--)
//			{
//				if (velMod.xvel[j][icont][k] > cmMax) continue;
//				else
//				{
//					k2 = j;
//					break;
//				}
//			}
//
//			if (velMod.xvel[k1][icont][k] != cmMin)
//			{
//				x[0] = cmMin;
//				//here z[0] is the velocity value.
//				z[0] = velMod.vf[k1 - 1][icont][k] +
//					(velMod.vf[k1][icont][k] - velMod.vf[k1 - 1][icont][k])*
//					(x[0] - velMod.xvel[k1 - 1][icont][k])
//					/ (velMod.xvel[k1][icont][k] - velMod.xvel[k1 - 1][icont][k]);
//				for (j = k1; j <= k2; j++)
//				{
//					x[j - k1 + 1] = velMod.xvel[j][icont][k];
//					z[j - k1 + 1] = velMod.vf[j][icont][k];
//				}
//				n = k2 - k1 + 2;
//			}
//			else
//			{
//				for (j = k1; j <= k2; j++)
//				{
//					x[j - k1] = velMod.xvel[j][icont][k];
//					z[j - k1] = velMod.vf[j][icont][k];
//				}
//				n = k2 - k1 + 1;
//			}
//
//			if (velMod.xvel[k2][icont][k] != cmMax)
//			{ //need change.
//				n++;
//				x[n - 1] = cmMax;
//				z[n - 1] = velMod.vf[k2][icont][k] +
//					(velMod.vf[k2 + 1][icont][k] - velMod.vf[k2][icont][k])*
//					(cmMax - velMod.xvel[k2][icont][k])
//					/ (velMod.xvel[k2 + 1][icont][k] - velMod.xvel[k2][icont][k]);
//			}
//
//			velMod.nvel[icont][k] = n;
//			for (j = 0; j < n; j++)
//			{
//				velMod.xvel[j][icont][k] = x[j];
//				velMod.vf[j][icont][k] = z[j];
//			}
//		}  // End of clipping vel nodes.
//	}
//
//	cd.coord.xmin = cmMin;
//	cd.coord.xmax = cmMax;
//	velMod.xmin = cmMin;
//	velMod.xmax = cmMax;
//}

void CSeisWideDoc::OnToolbarResizemod()
{
	if (!cd.coord.isModelingMode()) {
		AfxMessageBox(_T(" Please show a model on the screen for editing"), MB_ICONQUESTION);
		return;
	}
	CdlgModelResize dlg;
	dlg.m_xmin = (float)cd.coord.xmin;
	dlg.m_xmax = (float)cd.coord.xmax;

	if (dlg.DoModal() == IDOK) {
		CVelMod vm;
		vm.ClipModelXmin(&velMod, dlg.m_xmin, cd.coord.isTimeDomain());
		vm.ClipModelXmax(&velMod, dlg.m_xmax, cd.coord.isTimeDomain());
	}
	else return;

	OnToolbarSaveasv();
	//	velMod.velSecOld = BLANK;	//refresh velocity.
	//	draw.isSameDataDisplay = FALSE; //indicate display has been changed and will re-load all data in OnDraw().
	SetModifiedFlag();
	UpdateAllViews(NULL);
	NotifyChanged();
}

void CSeisWideDoc::OnDigitizeUndopoint()
{
	CDigitize::DIGITIZE *pDig = NULL;
	if (dig.isDigitizing && dig.nPoint != NULL)
		pDig = &dig;
	else if (digMarker.isDigitizing && digMarker.nPoint != NULL)
		pDig = &digMarker;
	else
		return;

	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	if (pDig->nPoint[pDig->iCurveSel] > 0) {
		pDig->nPoint[pDig->iCurveSel] --;
		pFrame->myCaption(_T(" Your lastly-digitized point has been removed; Refresh screen to show the removal"));
	}
	else AfxMessageBox(_T(" No points to undo"), MB_ICONQUESTION);
	//myDigSaveAs(dig.digName);
	draw.isSameDataDisplay = TRUE; //indicate display has been changed and will re-load all data in OnDraw().
	draw.isNodeChanged = TRUE;
	UpdateAllViews(NULL);
	NotifyChanged();
}

BOOL CSeisWideDoc::CheckTime(long daySet)
{
	// Now I allow unlimited usage.....Deping,June 16, 2002!
	return TRUE;


	//	CTime t( 1997, 3, 19, 22, 15, 0 ); // 10:15PM March 19, 1997
	ULONGLONG nSize, nDays, nDays1;
	short FirstTime = 0;                           /* size of string */
	CTime curTime = CTime::GetCurrentTime();
	CTime t, t1;

	CString WinSeis, WinSeisLast;

	TCHAR lpszSystemInfo[MAX_PATH];   /* buffer for concat'd. str. */
	nSize = GetSystemDirectory(lpszSystemInfo, MAX_PATH);
	_tcscat_s(lpszSystemInfo, _T("\\Winseidp.dll"));
	WinSeis = lpszSystemInfo;

	nSize = GetSystemDirectory(lpszSystemInfo, MAX_PATH);
	_tcscat_s(lpszSystemInfo, _T("\\chssmcd0.dll"));
	WinSeisLast = lpszSystemInfo;

	//Test if the file exists.
	CFileStatus status;
	extern CFile cfile;
	BOOL initFileStatus = CFile::GetStatus(WinSeis, status); // static function
	BOOL initFileStatus1 = CFile::GetStatus(WinSeisLast, status); // static function
	if (!initFileStatus && initFileStatus1) {	//this means chssmcd0.dll exists, but Winseidp.dll does not.
		//somebody must have deleted Winseidp.dll file.
	//	AfxMessageBox(_T("Entering into trial version due to usage expiration; you'll need to get an updated copy to perform time-depth conversion and migration (http://foflg.net/seisweb)!  All other functionality is still available"));
		return FALSE;
	}

	if (!initFileStatus || status.m_ctime <= 0 || status.m_size < 0) {	//if here then the file does not exist. Should not happen.
		return TRUE;
	}

	if (!initFileStatus1 || status.m_ctime <= 0 || status.m_size < 0) {	//if here then the file does not exist. Should not happen.
		return TRUE;
	}


	//If here then the two files all exist.
	CFile file;
	if (!file.Open(WinSeis, CFile::modeRead | CFile::typeBinary | CFile::shareDenyNone)) {
		return FALSE;
	}
	file.Seek(4 * 4, CFile::begin); //skip 4 records.
	file.Read(&t, 4);
	file.Close();

	CFile file1;
	if (!file.Open(WinSeisLast, CFile::modeRead | CFile::typeBinary | CFile::shareDenyNone)) {
		return FALSE;
	}
	file1.Seek(4 * 4, CFile::begin); //skip 4 records.
	file1.Read(&t1, 4);
	file1.Close();

	//t is first run, t1 is last run, curTime is this run.
	//note that t and t1 are the time in the 4th line of each file.
	CTimeSpan timeSpan1 = curTime - t1;
	nDays1 = timeSpan1.GetDays();
	CTimeSpan timeSpan = curTime - t;
	nDays = timeSpan.GetDays();
	if (nDays1 < 0 || nDays<0 || nDays>daySet) {
		return FALSE;
	}
	else return TRUE;
}


void CSeisWideDoc::OnProcessingAppendasegyfile()
{
	int totShot = 0, lastTrc, lastCDP;
	int i, numsamp2, len2; // actual numsample for the 2nd segy file.
	int numTracesIns = 0;
	CString inFile = BLANK, inFile2 = BLANK;
	CString str;
	BOOL yesFilter = FALSE, reNumCDP;
	CdlgSegyAppend dlg;

	dlg.m_1stName = draw.timeSecName;
	dlg.m_traces_insert = 0;


	draw.isNodeChanged = FALSE;
	if (dlg.DoModal() == IDOK) {
		reNumCDP = dlg.m_reNumCDP;
		inFile = dlg.m_1stName;
		inFile2 = dlg.m_2ndName;
		numTracesIns = dlg.m_traces_insert;
	}
	else {
		return;
	}

	if (!isFileExistNotDirectory(inFile)) return;
	if (inFile2 == BLANK) return;
	if (inFile2 == inFile) {
		AfxMessageBox(_T("Output file name is the same as the input file name!"), MB_ICONQUESTION);
		return;
	}
	CFile file;
	if (!file.Open(inFile, CFile::modeReadWrite | CFile::typeBinary)) {
		return;
	}
	UINT bytesRead = file.Read(head.ascHead, 3200L);
	if (bytesRead < 3200)
		AfxMessageBox(_T("Ascii section header read wrong"), MB_ICONQUESTION);

	bhed bh;
	segy tr;
	file.Read(&bh, 400L);
	if (IsUnix(bh.format)) {
		file.Close();
		AfxMessageBox(_T("Sorry, please convert to PC format (small-endian) before continue."), MB_ICONQUESTION);
		return;
	}
	if (bytesRead < 400)
		AfxMessageBox(_T("Binary section header read wrong"), MB_ICONQUESTION);
	//The following numbers have to be recalculated everytime,
	//because plotting the depth section will change these numbers.
	int numsamp = (int)bh.hns;
	int len = bh.getTraceLenBytes();
	short iDatForm = bh.format;
	if (bh.hdt == 0) bh.hdt = bh.dto;
	int tpp = bh.hdt;
	file.SeekToEnd();
	file.Seek(-len, CFile::current);
	file.Read(&tr, len);
	lastTrc = tr.tracl;
	lastCDP = tr.cdp;
	ULONGLONG bytes = file.SeekToEnd();

	CFile file2;
	if (!file2.Open(inFile2, CFile::modeRead | CFile::typeBinary)) {
		file.Close();
		return;
	}

	//For progress control, need to know the last bytes no.
	ULONGLONG curBytesRead, totBytesRead = file2.GetLength();
	file2.Seek(0, CFile::begin);

	bytesRead = file2.Read(head.ascHead, 3200L);
	if (bytesRead < 3200) {
		AfxMessageBox(_T("Ascii section header for 2nd file read wrong"), MB_ICONQUESTION);
		file.Close();
		file2.Close();
		return;
	}
	bytesRead = file2.Read(&bh, 400L);
	if (IsUnix(bh.format)) {
		file.Close();
		file2.Close();
		AfxMessageBox(_T("Sorry, please convert to PC format (small-endian) before continue."), MB_ICONQUESTION);
		return;
	}
	if (bytesRead < 400) {
		AfxMessageBox(_T("Binary section header for 2nd file read wrong"), MB_ICONQUESTION);
		file.Close();
		file2.Close();
		return;
	}
	numsamp2 = (int)bh.hns;
	if (tpp != bh.hdt || numsamp != numsamp2 || iDatForm != bh.format) {
		CStringArray strArr;
		str.Format(_T("Sample rates are (microsec): %d   %d"), tpp, bh.hdt);
		strArr.Add(str);
		str.Format(_T("Num of samples: %d   %d"), numsamp, numsamp2);
		strArr.Add(str);
		str.Format(_T("These accounts for trace length (sec): %f   %f"), numsamp*tpp * OMIL, numsamp2*bh.hdt / MIL);
		strArr.Add(str);

		str.Format(_T("First file: %s"), inFile);
		strArr.Add(str);
		strArr.Add(CSegyMeta::segyFormatToString(iDatForm));

		str.Format(_T("Second file: %s"), inFile2);
		strArr.Add(str);
		strArr.Add(CSegyMeta::segyFormatToString(bh.format));

		if (iDatForm != bh.format)
			str.Format(_T("Please run data reduction routine and then run routine this again."));
		else
			str.Format(_T("Please run re-sample routine and then run routine this again."));
		strArr.Add(str);

		showStringArrayToFile(&strArr);
		strArr.RemoveAll();
		file.Close();
		file2.Close();
		return;
	}
	if (iDatForm != bh.format)  {
		AfxMessageBox(_T("Data format in 2nd file is different from the 1st file"));
		file.Close();
		file2.Close();
		return;
	}
	if (iDatForm != 3)
		len2 = numsamp2 * 4 + 240;
	else
		len2 = numsamp2 * 2 + 240;

	str.Format(_T("The last trace of first segy file is %d . Continue ?"), lastTrc);
	if (AfxMessageBox(str, MB_YESNO | MB_ICONQUESTION | MB_ICONQUESTION) != IDYES) {
		file.Close();
		file2.Close();
		return;
	}


	totShot = head.numTraces;

	if (numTracesIns > 0) {
		memset((void *)&tr.dat.data[0], (int) '\0', len - 240);
		tr.trid = 2; // mark as dead trace
		for (i = 0; i < numTracesIns; i++) {
			tr.tracl++;
			tr.fldr++;
			tr.cdp++;
			file.Write(&tr, len);
			totShot++;
		} // for i
		file.Flush();
	}
	lastTrc = tr.tracl;
	lastCDP = tr.cdp;

	//Begin progress control.
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	ASSERT(pFrame);
	ASSERT_KINDOF(CMainFrame, pFrame);
	pFrame->BeginProgress();

	// NOTE: here in reading/writing, we do not convert between IBM and IEEE float at all, since no processing involved.
	while (file2.Read(&tr, len) == (UINT)len2) {
		curBytesRead = file2.Seek(0, CFile::current);
		int iPos = (int)((double)curBytesRead / (double)totBytesRead*100.);
		if (iPos < 0)iPos = 0;
		if (iPos > 100)iPos = 100;
		pFrame->SetProgress(iPos);

		//All trc numbers in 2nd file will be renumbered.
		lastTrc++;
		tr.tracl = lastTrc;  // trace must be re-numbered
		if (reNumCDP) {
			lastCDP++;
			tr.cdp = lastCDP;
		}
		if (numsamp2 < numsamp) { // pad with zero if too short in trace length.
			for (i = numsamp2; i < numsamp; i++) {
				if (iDatForm == 1) tr.dat.data[i] = 0.f;
				else if (iDatForm == 2) tr.dat.dataint[i] = 0;
				else if (iDatForm == 3) tr.dat.datashort[i] = 0;
			} // for i
		}

		tr.ns = (unsigned short)numsamp;  // to be safe
		file.Write(&tr, len);
		file.Flush();
		totShot++;
	}
	pFrame->EndProgress();

	if (totShot > 0) {
		CSegyMeta::setSegyTotalTrace(&file, totShot);
		str.Format(_T("Succesfully appended %d traces incl. %d blank ones"), totShot, numTracesIns);
		pFrame->myCaption(str);
	}
	else
		AfxMessageBox(_T("Not even one trace appended!"), MB_ICONQUESTION);

	file.Close();
	file2.Close();
}

BOOL CSeisWideDoc::reduction2TrcHeader(float vred)
{
	double rrv, range;
//	segy tr;

	if (!isFileExistNotDirectory(draw.timeSecName))
		return FALSE;

	if (fabs(vred) < MINAMP) rrv = 0.;
	else rrv = 1. / vred;

	CString tstr;
	if (!isFileExistNotDirectory(draw.timeSecName)) return FALSE;
	SegyWrapper sw(draw.timeSecName, false);
	if (CSegyMeta::segyHeadInit(draw.timeSecName, &head) != 1) 
		return FALSE;
	if (!sw.open(&head, 0)) {
		tstr.Format(_T("Input file cannot be opened"));
		AfxMessageBox(tstr, MB_ICONQUESTION);
		return FALSE;
	}
	tstr.Format(_T("Loaded segy with %d traces."), sw.headRead.getnx());
	for (int nxStore = 0; nxStore < sw.headRead.getnx(); nxStore++) {
		range = sw.headRead.trArr[nxStore].getOffset(); //actual range in km.
		sw.headRead.trArr[nxStore].setTraceDelayF(
			sw.headRead.trArr[nxStore].getTraceDelay() + fabs(range) * rrv);
	} // for nxStore
	sw.writeDataAll(draw.timeSecName);

	return TRUE;

}

void CSeisWideDoc::OnProcessingReducemanual()
{
	if (!isFileExistNotDirectory(draw.timeSecName)) {
		AfxMessageBox(_T("Please display a segy data first"), MB_OK | MB_ICONINFORMATION);
		return;
	}

	CdlgVred dlg;
	dlg.m_vred = 0.f;
	dlg.m_timeSecName = draw.timeSecName;
	//	_stprintf(s, _T("Your data has a reduction velocity %d (m/s) written at byte 46-47 in binary section header. Is the data already reduced by this velocity?", ssmic.iv);
	//	if(AfxMessageBox(s, MB_YESNO |MB_ICONINFORMATION) == IDYES)
	if (dlg.DoModal() == IDOK) {
		if (reduction2TrcHeader(dlg.m_vred)) {
		//	draw.isSameDataDisplay = FALSE; //indicate display has been changed and will re-load all data in OnDraw().
		//	SetModifiedFlag();
			UpdateAllViews(NULL);
			NotifyChanged();
		}
	}
}
//
//void CSeisWideDoc::OnViewSegypreview()
//{
//	AfxMessageBox(_T("This view is under construction"));
//	return;
//	cd.coord.drawmodeOld = cd.coord.drawmode;
//	cd.coord.drawmode = 5;	//Time section will be drawn.
//
//	// if(!myParas()) return;
//	CdlgSegyPreview dlg;
//	dlg.m_clip = (float)para.clip;
//	dlg.m_faceDown = cd.coord.isFaceUp;
//	if (fabs(para.fillOff) > 10.) para.fillOff = 0.1;
//	dlg.m_fillOff = (float)para.fillOff;
//	dlg.m_gain = (float)para.gain;
//	dlg.m_shot1 = cd.coord.trace1;
//	dlg.m_shot2 = cd.coord.trace2;
//	dlg.m_timeSecTitle = draw.plotTitle;
//	dlg.m_tmax = (float)cd.coord.tmax;
//	dlg.m_tmin = (float)cd.coord.tmin;
//	dlg.m_tTick = (float)cd.coord.tTick;
//	dlg.m_wiggle = para.wiggle;
//
//	if (dlg.DoModal() == IDOK)
//	{
//		para.clip = dlg.m_clip;
//		cd.coord.isFaceUp = dlg.m_faceDown != 0;
//		para.fillOff = dlg.m_fillOff;
//		para.gain = dlg.m_gain;
//		cd.coord.trace1 = dlg.m_shot1;
//		cd.coord.trace2 = dlg.m_shot2;
//		draw.plotTitle = dlg.m_timeSecTitle;
//		cd.coord.tmax = dlg.m_tmax;
//		cd.coord.tmin = dlg.m_tmin;
//		cd.coord.tTick = dlg.m_tTick;
//		para.wiggle = dlg.m_wiggle;
//	}
//	else return;
//
//	SetModifiedFlag();
//	draw.isSameDataDisplay = FALSE;
//	UpdateAllViews(NULL);
//	NotifyChanged();
//
//}


void CSeisWideDoc::OnModelingExtractvzcurve()
{
	long icont;
//	double dist;
	static double subbasementVel2 = 4.699f;
	static double subbasementDepth_static = -1.f;

	if (!cd.coord.isModelingMode()) {
		AfxMessageBox(_T("Please display the model before extracting a V-Z curve"), MB_ICONQUESTION);
		return;
	}

	CSegyMeta::segyHeadInit(draw.timeSecName, &head);
	CRayHelper::setXShotAll(head.xshotInSegy, draw.rayName, &tx);

	velMod.wells[0].wellDist = myFloat(velMod.wells[0].wellDist, 3);
	CdlgVZCurve dlg;
	dlg.m_xShot = (float)velMod.wells[0].wellDist;
	dlg.m_basementVel = (float)myFloat(subbasementVel2, 3);
	dlg.m_basementDepth = (float)myFloat(subbasementDepth_static, 3);
	if (dlg.DoModal() == IDOK) {
		if (velMod.wells[0].wellDist != dlg.m_xShot) {
			velMod.wells[0].wellDist = dlg.m_xShot;
			velMod.wells[0].wellLatLong[0] =
				velMod.wells[0].wellLatLong[1] =
				ERRORVAL;
		}
		// we do not use float3() since it may change user's preference
		subbasementVel2 = dlg.m_basementVel;
		subbasementDepth_static = dlg.m_basementDepth;
	}
	else
		return;

	double offset = fabs(
		cd.coord.getOffsetFromXVal(velMod.wells[0].wellDist, tx.xShotRay)
		);  // we only need the absolute value of offset here!

	FILE *stream;
	//CString outName = velMod.velSecName + _T(".tmpVZCurve";
	CString outName = GetFileNameAppendExt(velMod.velSecName, _T(".tmpVZCurve"), _T("txt"));
	if (_tfopen_s(&stream, outName, _T("w+")) != 0) {
		AfxMessageBox(_T("Could not open a temporary file"), MB_ICONQUESTION);
		return;
	}
	 
	CVelMod vm;
	if (cd.coord.isTimeDomain())
		vm.myModel_TWTT2Depth(&velMod, velColor.dz);

	CVelMod::VELMOD_X modXOrig;
	modXOrig.dist = velMod.wells[0].wellDist;
	velMod.m_isConvert = true;
	vm.initModX(&velMod, &modXOrig, cd.coord.isTimeDomain() == TRUE, false, velColor.dz);
	// vm.getZModFromZ(&velMod, &modXOrig, false);

	CVelMod::VELMOD_X modX;
	modX.dist = velMod.wells[0].wellDist;
	vm.initModX(&velMod, &modX, cd.coord.isTimeDomain() == TRUE, true, velColor.dz);
	//int numWaterLayers = NUM_WATER_LAYER;
	double waterDepth = modX.getWaterDepth();

	_ftprintf_s(stream, _T("# Model: %s\n"), (LPCTSTR)velMod.velSecName);
	_ftprintf_s(stream, _T("# Reflection data: %s\n"), (LPCTSTR)draw.timeSecName);
	_ftprintf_s(stream, _T("# Station information\n"));
	_ftprintf_s(stream, _T("#   Water depth (TWTT, s): %6.3f\n"), modX.getWaterTwtt());
	_ftprintf_s(stream, _T("#   Water depth (km): %6.3f\n"), waterDepth);
	_ftprintf_s(stream, _T("#   Water velocity at surface (km/s): %6.3f\n"), modX.vTop[0]);
	_ftprintf_s(stream, _T("#   Water velocity at seafloor (km/s): %6.3f\n"), modX.getWaterVelBot());
	SegyWrapper sw(draw.timeSecName, true);
	if (CSegyMeta::segyHeadInit(draw.timeSecName, &head) == 1) {
		if (sw.open(&head, 0) && sw.headRead.getnx() > 1) {
			if (fabs(draw.distShift) > MIL) draw.distShift = 0.f;
			int ix = sw.getClosestTrcIndexAtDistance(velMod.wells[0].wellDist + draw.distShift);
			if (ix >= 0) {
				int gx = sw.headRead.trArr[ix].gx;
				int gy = sw.headRead.trArr[ix].gy;
				_ftprintf_s(stream, _T("#   Nearest shotpoint (FFID) in refl data: %d\n"), sw.headRead.trArr[ix].fldr);
				_ftprintf_s(stream, _T("#   Longitude, Latitude at FFID (arc value assumed at trace headers): %11.6f, %11.6f\n"), (float)gx / 360000.0f, (float)gy / 360000.0f);
			}
		}
	}
	// _ftprintf_s(stream,_T("#   Model distance (km): %7.3f\n"),(float)dist);


	// 1. print out RMS numbers; they may need this more?
	float *VrmsTopMod = (float *)ealloc1float(velMod.ncont);
	float *VrmsBotMod = (float *)ealloc1float(velMod.ncont);
	vm.getVelocityRmsMod(&modX, velColor.dz, velMod.wells[0].wellDist, modX.timeMod, VrmsTopMod, VrmsBotMod);



	int iBasement = 0;  // starting layer number for basement
	double basementDepth; // depth for the starting layer for basement
	if (subbasementDepth_static < 0.f) {
		// must calculate basement depth and layer index
		for (icont = 1; icont < velMod.ncont - 1; icont++) {
			if (modX.vTop[icont] >= subbasementVel2 - 0.001) {   //  why  -0.001 ? This way, the exact number of user input included
				iBasement = icont;
				break;
			}
		}
		basementDepth = modX.depthMod[iBasement];
	}
	else  {
		// user fixed basement depth
		basementDepth = subbasementDepth_static;
		for (icont = 0; icont < velMod.ncont - 1; icont++) {
			if (modX.depthMod[icont] <= basementDepth && modX.depthMod[icont + 1] >= basementDepth) {
				iBasement = icont;
				break;
			}
		}
	}



	// 2. print out at decimal scales
	_ftprintf_s(stream, _T("#Pseudo-well at Model Distance %7.3f (offset %7.3f km; V4 marker at %7.3f km)(Params: %7.3f km/s; %7.3f km)\n"),
		(float)velMod.wells[0].wellDist, (float)offset, basementDepth, subbasementVel2, subbasementDepth_static);
	_ftprintf_s(stream, _T("#TWT    VEL    DEPTH   VRMS  DBSF  DBBS (sec-km/s-km-km-km)\n"));

	CString velSecNameProcessed = velMod.velSecName;
	velSecNameProcessed.Replace(SPACE, _T("_")); // we really do not want any spaces inside this string
	int indDrive = velSecNameProcessed.Find(_T(":\\"));
	if (indDrive > 0) {
		// we do not want the drive letter to appear as well
		velSecNameProcessed = velSecNameProcessed.Mid(indDrive + 2);
	}
	velSecNameProcessed.TrimRight(_T(".bin"));

	for (icont = 0; icont < velMod.ncont - 1; icont++) {
		float tz = (float)modX.timeMod[icont];
		float zz = (float)modX.depthMod[icont];
		if (icont > 0) {
			tz += 0.01f;
			zz += 0.01f;
		}
		_ftprintf_s(stream, _T("%6.3f %6.3f %6.3f %6.3f"), tz, modX.vTop[icont], zz, VrmsTopMod[icont]);
		_ftprintf_s(stream, _T(" %6.3f"), (zz - waterDepth) > 0 ? zz - waterDepth : 0.0f);
		_ftprintf_s(stream, _T(" %6.3f"), (zz - basementDepth) > 0 ? zz - basementDepth : 0.0f);
		_ftprintf_s(stream, _T("  %2d"), icont + 1);
		_ftprintf_s(stream, _T("      %s  "), (LPCTSTR)velSecNameProcessed);
		_ftprintf_s(stream, _T("\n"));

		tz = (float)modX.timeMod[icont + 1];
		zz = (float)modX.depthMod[icont + 1];
		if (tz - modX.timeMod[icont] < 0.01f) {
			tz = (float)modX.timeMod[icont] + 0.01f;
			zz = (float)modX.depthMod[icont] + 0.01f;
		}
		_ftprintf_s(stream, _T("%6.3f %6.3f %6.3f %6.3f"), tz, modX.vBot[icont], zz, VrmsBotMod[icont]);
		_ftprintf_s(stream, _T(" %6.3f"), (zz - waterDepth) > 0 ? zz - waterDepth : 0.0f);
		_ftprintf_s(stream, _T(" %6.3f"), (zz - basementDepth) > 0 ? zz - basementDepth : 0.0f);
		_ftprintf_s(stream, _T("  %2d"), icont + 1);
		_ftprintf_s(stream, _T("      %s  "), (LPCTSTR)velSecNameProcessed);
		_ftprintf_s(stream, _T("\n"));
	}
	_ftprintf_s(stream, _T("\n"));




	_ftprintf_s(stream, _T("# Note: the following are average velocities at the centre of each layer.\n"));
	_ftprintf_s(stream, _T("# Time (msbsf), Depth (mbsf), Layer velocity (km/s), 1=(observed refraction; 2=From reflection event)\n"));
	double avgTwttBsf;
	double avgDepthBsf;
	double avgVel;
	for (icont = 1; icont < velMod.ncont - 1; icont++) {
		avgTwttBsf = (modX.timeMod[icont] + modX.timeMod[icont + 1])*0.5 - modX.getWaterTwtt();
		avgDepthBsf = (modX.depthMod[icont] + modX.depthMod[icont + 1])*0.5 - modX.getWaterDepth();
		avgVel = (modX.vTop[icont] + modX.vBot[icont]) * 0.5;
		int fsdf = (int)myRound(avgDepthBsf*1000.);
		_ftprintf_s(stream, _T("%5d  %5d  %5d  "), (int)myRound(avgTwttBsf*1000.), (int)myRound(avgDepthBsf*1000.), (int)myRound(avgVel*1000.));
		_ftprintf_s(stream, _T("\n"));
	}
	_ftprintf_s(stream, _T("#\n"));




	if (iBasement > 0) {
		_ftprintf_s(stream, _T("#\n# Note: the following line is for areal mapping of velocities, can be put to mapping softwares (e.g. surfer et al.).\n"));
		_ftprintf_s(stream, _T("#   Water depth %11.6f km;  %s\n"), modX.getWaterDepth(), (LPCTSTR)velMod.velSecName);
		_ftprintf_s(stream, _T("#   Layer boundaries below basement with velocity greater than %8.3f km/s; You may manually change unreliable values to zero.\n"), subbasementVel2);
		_ftprintf_s(stream, _T("#   Vel(km/s) Depth(km) DBB(km)\n"));

		_ftprintf_s(stream, _T("   %6.3f    %6.3f    %6.3f  \n"), modX.vBot[iBasement - 1], modX.depthMod[iBasement], 0.0);
		for (icont = iBasement; icont < velMod.ncont - 1; icont++) {
			_ftprintf_s(stream, _T("   %6.3f    %6.3f    %6.3f  \n"), modX.vTop[icont], modX.depthMod[icont] + 0.01, modX.depthMod[icont] - basementDepth + 0.01);
			_ftprintf_s(stream, _T("   %6.3f    %6.3f    %6.3f  \n"), modX.vBot[icont], modX.depthMod[icont + 1], modX.depthMod[icont + 1] - basementDepth);
		}

		_ftprintf_s(stream, _T("  \n\n"));

		_ftprintf_s(stream, _T("#   Vel(km/s) DBB(km)\n"));
		for (icont = iBasement; icont < velMod.ncont - 1; icont++) {
			_ftprintf_s(stream, _T("   %6.3f    %6.3f"), modX.vTop[icont], modX.depthMod[icont] - basementDepth + 0.01);
			_ftprintf_s(stream, _T("      %s\n"), (LPCTSTR)velSecNameProcessed);
			_ftprintf_s(stream, _T("   %6.3f    %6.3f"), modX.vBot[icont], modX.depthMod[icont + 1] - basementDepth);
			_ftprintf_s(stream, _T("      %s\n"), (LPCTSTR)velSecNameProcessed);
		}
	} // if iBasement







	_ftprintf_s(stream, _T("#\n#At model distance %7.3f; %s\n"), (float)velMod.wells[0].wellDist, (LPCTSTR)velMod.velSecName);
	// _ftprintf_s(stream,_T("#Vrefr-intv   Twtt  msbsf  mbsf   Depth  Vrms\n"));
	_ftprintf_s(stream, _T("#  Depth(m) Twtt(s) Intv-FM RMSvel TWTTbsf Depthbsf (Note: Velocity unit here is m/s)\n"));
	for (icont = 0; icont < velMod.ncont - 1; icont++) {
		//	_ftprintf_s(stream,_T("       %4d  %5d  %5d  %5d  %5d  %4d"), 
		//if (icont == velMod.ncontMaxConstrained)
		//	_ftprintf_s(stream, _T("\n#Following values need confirmation\n"));
		if (icont + 1 == velMod.ncontMaxConstrained && !velMod.isVelBelowValid)
			_ftprintf_s(stream, _T("\n#Following values need confirmation\n"));

		_ftprintf_s(stream, _T("       %5d  %5d  %5d  %5d  %5d  %5d"),
			(int)myRound(1000.f* modX.depthMod[icont]) + ((icont>0) ? 10 : 0),
			(int)myRound(1000.f* modX.timeMod[icont]) + ((icont > 0) ? 10 : 0),
			(int)myRound(1000.f* modX.vTop[icont]),
			(int)myRound(1000.f* VrmsTopMod[icont]),
			(int)myRound(1000.f* (modX.timeMod[icont] - modX.getWaterTwtt())) + ((icont > 0) ? 10 : 0),
			(int)myRound(1000.f* (modX.depthMod[icont] - modX.getWaterDepth())) + ((icont > 0) ? 10 : 0)
			);
		_ftprintf_s(stream, _T("\n"));

		if (icont+1 == velMod.ncontMaxConstrained && velMod.isVelBelowValid)
			_ftprintf_s(stream, _T("\n#Following values need confirmation\n"));

		_ftprintf_s(stream, _T("       %5d  %5d  %5d  %5d  %5d  %5d"),
			(int)myRound(1000.f* modX.depthMod[icont + 1]),
			(int)myRound(1000.f* modX.timeMod[icont + 1]),
			(int)myRound(1000.f* modX.vBot[icont]),
			(int)myRound(1000.f* VrmsBotMod[icont]),
			(int)myRound(1000.f* (modX.timeMod[icont + 1] - modX.getWaterTwtt())),
			(int)myRound(1000.f* (modX.depthMod[icont + 1] - modX.getWaterDepth()))
			);
		_ftprintf_s(stream, _T("\n"));
	}
	free1float(VrmsTopMod);
	free1float(VrmsBotMod);
	_ftprintf_s(stream, _T("\n"));


	_ftprintf_s(stream, _T("#VEL    DBEPTH-BV4 MODEL\n"));
	for (icont = 0; icont < velMod.ncont - 1; icont++) {
		float zz = (float)modX.depthMod[icont];
		if (icont > 0) {
			zz += 0.01f;
		}
		_ftprintf_s(stream, _T("%6.3f"), modX.vTop[icont]);
		_ftprintf_s(stream, _T("     %6.3f  "), (zz - basementDepth) > 0 ? zz - basementDepth : 0.0f);
		_ftprintf_s(stream, _T("\n"));

		zz = (float)modX.depthMod[icont + 1];
		if (zz - modX.depthMod[icont] < 0.01f) {
			zz = (float)modX.depthMod[icont] + 0.01f;
		}
		_ftprintf_s(stream, _T("%6.3f"), modX.vBot[icont]);
		_ftprintf_s(stream, _T("     %6.3f  "), (zz - basementDepth) > 0 ? zz - basementDepth : 0.0f);
		_ftprintf_s(stream, _T("\n"));
	}


	_ftprintf_s(stream, 
		_T("#\n#Tbsf-Zbsf-V-Vh at Model Distance %7.3f (units: ms-m-m/s; Tbsf=TWTT in sec below seafloor, or 2nd boundary; zbsf=depth in m below seafloor):\n#  %s\n"), 
		(float)velMod.wells[0].wellDist,
		(LPCTSTR)velMod.velSecName);
	for (icont = 1; icont < velMod.ncont - 1; icont++) {
		register int itest = (int)myRound(1000.f*modX.vTop[icont]);
		_ftprintf_s(stream, _T("%4d  %4d  %4d"), (int)myRound(1000.f*(modX.timeMod[icont] - modX.getWaterTwtt())),
			(int)myRound(1000.f*(modX.depthMod[icont] - modX.getWaterDepth())), itest);
		_ftprintf_s(stream, _T("\n"));
		itest = (int)myRound(1000.f*modX.vBot[icont]);
		_ftprintf_s(stream, _T("%4d  %4d  %4d"), (int)myRound(1000.f*(modX.timeMod[icont + 1] - modX.getWaterTwtt())),
			(int)myRound(1000.f*(modX.depthMod[icont + 1] - modX.getWaterDepth())), itest);
		_ftprintf_s(stream, _T("\n"));
	}




	
	//basementDepth = modX.depthMod[iBasement]; // already computed but repeat here for clarity only
	//waterDepth = modX.depthMod[numWaterLayers];// already computed but repeat here for clarity only
	double basementTime = modX.timeMod[iBasement];
	double waterTime = modX.getWaterTwtt();

	_ftprintf_s(stream, _T("\n# %s\n# Model Distance %7.3g km\n"), (LPCTSTR)velMod.velSecName, (float)velMod.wells[0].wellDist);

	// try to find the lon/lat for the location
	double lat = velMod.wells[0].wellLatLong[0];
	double lon = velMod.wells[0].wellLatLong[1];
	if (lon == ERRORVAL &&  isFloatEqual(velMod.wells[0].wellDist, velMod.deploys[0].deployDist)) {
		// try a simple fixup
		lat = velMod.deploys[0].deployLatLong[0];
		lon = velMod.deploys[0].deployLatLong[1];
	}
	_ftprintf_s(stream, _T("# lon, lat: %9.5f  %9.5f\n"), lon, lat);
	_ftprintf_s(stream, _T("# TWT(s)  Depth(km) sub-seafloor, using 2ms as interval in time, and above basement velocity of %7.3g km/s:\n"), subbasementVel2);
	vm.initModX(&velMod, &modX, cd.coord.isTimeDomain() == TRUE, true, 0.002);
	long nt = (long)ceil(basementTime / 0.002) + 1;
	float *zTrc = (float*)ealloc1(nt, sizeof(float));
	vm.getZtFromTMod(&modX, nt, 0.002, zTrc);
	for (int j = 0; j < nt; j++) {
		if (zTrc[j] < waterDepth) continue;
		if (zTrc[j] > basementDepth) break;
		if (j*0.002 - waterTime < 0.002) continue; // we want to avoid very small TWT values
		_ftprintf_s(stream, _T("%6.3f"), (float)(j*0.002 - waterTime));
		_ftprintf_s(stream, _T("   %7.4f"), (float)(zTrc[j] - waterDepth));
		_ftprintf_s(stream, _T("\n"));
	}
	free1float(zTrc);








	if (!velMod.isGrdInitialised)
		vm.myVelModInterpolDisplay(&velMod, velMod.getXmin(), velMod.getXmax(), draw.distShift, velColor.dxVDesired);

	_ftprintf_s(stream, _T("\n\n#X-Z-V Dump of Model color gridding below. \n#All control points on the top and bottom boundaries within each layer will be dumped separately, layer by layer. \n#Anisotropy not included. Maybe useful for contouring in other programs.\n"));
	for (icont = 0; icont < velMod.ncont - 1; icont++) {
		for (int ix = 0; ix < velMod.grdNx; ix++) {
			float x = (float)(velMod.getXmin() + ix * velColor.dxVDesired);
			_ftprintf_s(stream, _T("%10.4f %10.4f %10.4f\n"), x, velMod.grdDepth[icont][ix], velMod.vTop[icont][ix]);
		}
		for (int ix = 0; ix < velMod.grdNx; ix++) {
			float x = (float)(velMod.getXmin() + ix * velColor.dxVDesired);
			_ftprintf_s(stream, _T("%10.4f %10.4f %10.4f\n"), x, velMod.grdDepth[icont + 1][ix], velMod.vBot[icont][ix]);
		}
	}


	if (stream != NULL) fclose(stream);
	showFileInNotePad(outName);
}

void CSeisWideDoc::OnModelingExtractlayerinfor()
{
	long icont, j;
	int mode; //boundary or vel mode; different from cd.coord.drawmode.
	static float xx1 = 0.f, xx2 = 0.f, yy1 = 0.f, yy2 = 0.f;
	if (cd.coord.drawmode < 2 || cd.coord.drawmode>4) {
		AfxMessageBox(_T("Please display the model before extracting layer information"), MB_ICONQUESTION);
		return;
	}
	CdlgTablizeLayer dlg;
	dlg.m_x1 = xx1;
	dlg.m_x2 = xx2;
	dlg.m_y1 = yy1;
	dlg.m_y2 = yy2;
	if (draw.nodeMode == 1) dlg.m_mode = 0;	//boundary mode.
	else dlg.m_mode = 1;	//vel mode.

	if (draw.isTopBound) dlg.m_top = 0; //unfortunately they are defined reverse.
	else dlg.m_top = 1;
	dlg.m_layerNum = draw.iLayerFocus;

	if (dlg.DoModal() == IDOK) {
		xx1 = xx1 = dlg.m_x1;
		xx2 = xx2 = dlg.m_x2;
		yy1 = yy1 = dlg.m_y1;
		yy2 = yy2 = dlg.m_y2;
		mode = dlg.m_mode;
		draw.isTopBound = dlg.m_top == 0; //temoporily use a reversed iTopBound.
	}
	else return;
	if (xx1 == 0 && xx2 == 0 && yy1 == 0 && yy2 == 0) {
		AfxMessageBox(_T("Please specify spacial coordinate system for the model for text dumping"), MB_ICONQUESTION);
		draw.isTopBound = !draw.isTopBound; //reverse back to normal.
		return;
	}

	//start writing nodes into file.
	double temp, xRange;
	FILE *stream;
	//CString outName = velMod.velSecName + _T(".ModelXYVDump.txt";
	CString outName = GetFileNameAppendExt(velMod.velSecName, _T(".ModelXYVDump"), _T("txt"));
	if (_tfopen_s(&stream, outName, _T("w+")) != 0)
	{
		AfxMessageBox(_T("Could not open a temporary file"), MB_ICONQUESTION);
		fclose(stream);
		return;
	}

	xRange = velMod.getXmax() - velMod.getXmin();
	if (xRange < MINAMP)
	{
		AfxMessageBox(_T("The xmax and xmin of the model are too close to each other"), MB_ICONQUESTION);
		fclose(stream);
		return;
	}
	xRange = 1. / xRange;

	CString sTemp;
	sTemp.Format(_T("%s\n Ascii dump: X, Y, Z in km for layer number %d"), velMod.velSecName, draw.iLayerFocus);
	if (mode != 1) { //boundary mode.
		_ftprintf_s(stream, _T("%s\n"), (LPCTSTR)sTemp);
		icont = draw.iLayerFocus;
		for (j = 0; j < velMod.nzed[icont]; j++) {
			temp = (velMod.xm[j][icont] - velMod.getXmin())*xRange;
			_ftprintf_s(stream, _T(" %9.3f %9.3f %9.3f\n"),
				(float)((xx2 - xx1)*temp + xx1),
				(float)((yy2 - yy1)*temp + yy1),
				(float)velMod.zm[j][icont]);
		}
	}
	else { //velocity mode.
		if (!draw.isTopBound)
			_ftprintf_s(stream, _T("%s; For top of the layer\n"), (LPCTSTR)sTemp);
		else
			_ftprintf_s(stream, _T("%s; For bottom of the layer\n"), (LPCTSTR)sTemp);

		icont = draw.iLayerFocus;
		for (j = 0; j < velMod.nvel[icont][!draw.isTopBound]; j++) {
			temp = (velMod.xvel[j][icont][!draw.isTopBound] - velMod.getXmin())*xRange;
			_ftprintf_s(stream, _T(" %9.3f %9.3f %9.3f\n"), (float)((xx2 - xx1)*temp + xx1), (float)((yy2 - yy1)*temp + yy1), velMod.vf[j][icont][!draw.isTopBound]);
		}
	}

	fclose(stream);
	draw.isTopBound = !draw.isTopBound; //reverse back to normal.

	showFileInNotePad(outName);
}

void CSeisWideDoc::OnProcessingMigps()
{
	AfxMessageBox(_T("PS migration routines not working in this version"), MB_ICONQUESTION);
	return;
}

void CSeisWideDoc::OnProcessingPc2unixbatch()
{
	//Initilize.
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	CString inFile = BLANK, outFile = BLANK;
	bhed bh;
	segy tr;

	//short *i2buf;
	//i2buf = (short *)&tr;

	//int *i2int;
	//i2int = (int *)&i2buf[0];
	//float *trcdat;
	//trcdat = (float *)&i2buf[120];
	//short *i2short;
	//i2short = (short *)&i2buf[120];

	//Openfiles.
	CFileDialog dlg(TRUE, _T("sgy; SEG"), _T("*.sgy"),
		OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT | OFN_ALLOWMULTISELECT | OFN_EXPLORER,
		_T("Input Segy File (*.sgy)|*.sgy|"));

	TCHAR* buff = (TCHAR*)alloc1(65535, sizeof(TCHAR));
	buff[0] = '\0';
	dlg.m_ofn.lpstrTitle = _T("Select all files for batch conversion");
	dlg.m_ofn.lpstrFile = buff;
	dlg.m_ofn.nMaxFile = 65535;//sizeof(buff);


	POSITION Position;

	if (dlg.DoModal() == IDOK) {
		Position = dlg.GetStartPosition();
		while (Position) {
			inFile = dlg.GetNextPathName(Position);
			outFile = getFileNameAppend(inFile, _T("U"));
			if (!isFileExistNotDirectory(inFile)) continue;
			CFile file;
			if (!file.Open(inFile, CFile::modeRead | CFile::typeBinary | CFile::shareDenyNone)) {
				continue;
			}

			if (outFile == BLANK) return;

			//For progress control, need to know the last bytes no.
			ULONGLONG curBytesRead, totBytesRead = file.GetLength();
			file.Seek(0, CFile::begin);
			//Begin progress control.
			pFrame->BeginProgress();

			UINT bytesRead = file.Read(head.ascHead, 3200L);
			if (bytesRead < 3200)
				AfxMessageBox(_T("Ascii section header read wrong"), MB_ICONQUESTION);
			file.Read(&bh, 400L);
			if (bytesRead < 400)
				AfxMessageBox(_T("Binary section header read wrong"), MB_ICONQUESTION);
			//The following numbers have to be recalculated everytime,
			//because plotting the depth section will change these numbers.
			int numsamp = bh.hns; // (unsigned short)i2buf[10];
			int len = bh.format == 3 ? numsamp * 2 + 240 : numsamp * 4 + 240;
//			short iDatForm = i2buf[12];
			int formatOrig = bh.format;
			if (formatOrig == 5) bh.format = 1; // We set the format to 1 in case of floating point data

			CFile file2;
			if (!file2.Open(outFile, CFile::modeWrite | CFile::modeCreate | CFile::typeBinary)) {
				file.Close();
				continue;
			}

			asc2ebc(head.ascHead, 3200);
			file2.Write(head.ascHead, 3200L);

			SwapTapeHeader((bhed *)&bh);
			file2.Write(&bh, 400L);


			ULONGLONG byteFileEnd = file.SeekToEnd();
			file.Seek(3600L, CFile::begin);

//			int itemp;
			while (file.Read(&tr, len) == (UINT)len) {
				if (formatOrig == 5) {
					float_to_ibm((int *)tr.dat.data, (int *)tr.dat.data, (int)numsamp);
				}
				//else if (formatOrig == 1) {
				//	ibm_to_float((int *)tr.dat.data, (int *)tr.dat.data, (int)numsamp);
				//	float_to_ibm((int *)tr.dat.data, (int *)tr.dat.data, (int)numsamp);
				//}
				// now convert small to big endians
				SwapN(&tr.dat, formatOrig, numsamp);

				SwapTraceHeader(true, false, false, &tr);

				// note: since I do not convert between IBM and IEEE during reading, 
				// I do not convert during writing here!!!
				file2.Write(&tr, len);

				// testing
			//	if (tr.tracl == 19300) {
					//int fsd = 1;
			//		ibm_to_float((int *)tr.dat.data, (int *)tr.dat.data, (int)numsamp);
					//SwapTraceHeader(&tr);
					//SwapN(&tr, formatOrig);
			//	}

				curBytesRead = file.Seek(0, CFile::current);
				int iPos = (int)((double)curBytesRead / (double)totBytesRead*100.);
				if (iPos < 0)iPos = 0;
				if (iPos > 100)iPos = 100;
				pFrame->SetProgress(iPos);
			}
			file.Close();
			file2.Close();
			pFrame->EndProgress();


		} //end the while file POSITION loop.
	} //end dlg.DoModal function.
	free1(buff);

}


void CSeisWideDoc::OnProcessingUnix2pcbatch()
{
	// this routine converts input data file in segy format (see segy.h file for definition) 
	// from big-endian to small-endian or Intel platform. It must consider input data in the 
	// formats of short integer, long integer, and floating point. See file suSwapByte.c for
	// routines of conversion.

	// A segy file contains an 3200-byte ascii section header, 400-byte binary section header, 
	// and many traces. Each trace is mapped in the struct "segy" which contains 240-byte 
	// binary header followed by data chunk.
	short *i2buf;
	long k;
	long *i4buf;
	segy tr;
	bhed bh;
	BOOL isUnix = FALSE;
	BOOL isOffsetMM = FALSE;
	BOOL isSwapIEEE_IBM = FALSE;
	BOOL isResetZero = FALSE;
	CString tStr;

	BOOL isDeadTrcExist, isUseReducedTime, GSCformat, trcRenum;
	static BOOL isConvertEbc2Ascii = FALSE;
	CString inFile = BLANK, outFile = BLANK;

	i2buf = (short *)&tr;
	i4buf = (long *)&i2buf[0];

	CdlgUnix2PC dlg0;
	dlg0.m_isConvertEbc2Ascii = isConvertEbc2Ascii;
	if (dlg0.DoModal() == IDOK)
	{
		isConvertEbc2Ascii = dlg0.m_isConvertEbc2Ascii;
		isDeadTrcExist = dlg0.m_isDeadTrcExisting;
		isUseReducedTime = dlg0.m_useReducedTime;
		isResetZero = dlg0.m_isResetZero;
		GSCformat = dlg0.m_gsca;
		trcRenum = dlg0.m_reNum;
		isOffsetMM = dlg0.m_isOffsetMM;
		isSwapIEEE_IBM = dlg0.m_isSwapIEEE_IBM;
	}
	else return;

	CFileDialog dlg(TRUE, _T("sgy; SEG; segy"), _T("*.sgy; *.SEG; *.segy"),
		OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT | OFN_ALLOWMULTISELECT | OFN_EXPLORER,
		_T("Input Segy File (*.sgy;*.SEG; *.segy)|*.sgy; *.SEG; *.segy|"));

	TCHAR* buff = (TCHAR*)alloc1(65535, sizeof(TCHAR));
	buff[0] = '\0';
	dlg.m_ofn.lpstrTitle = _T("Select all files for conversion in batch");
	dlg.m_ofn.lpstrFile = buff;
	dlg.m_ofn.nMaxFile = 65535;//sizeof(buff);

	//Begin progress control.
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	ASSERT(pFrame);
	ASSERT_KINDOF(CMainFrame, pFrame);
	pFrame->BeginProgress();


	POSITION Position;

	int count = 0;
	if (dlg.DoModal() == IDOK) {
		Position = dlg.GetStartPosition();
		while (Position) {
			inFile = dlg.GetNextPathName(Position);
			CString tempStr = inFile;
			tempStr.MakeLower();
			// must make it lower case before comparing, in case some file has extension
			// like ".Sgy" or ".sGY".
			// outFile = GetFileNameAppendExt(inFile, _T("PC"), _T("sgy")); // this puts the output to the temp folder
			outFile = getFileNameAppend(inFile, _T("PC"));  
			if (outFile == BLANK) {
				free1(buff);
				return;
			}

			if (!isFileExistNotDirectory(inFile)) continue;
			CFile file;
			if (!file.Open(inFile, CFile::modeRead | CFile::typeBinary | CFile::shareDenyNone)) {
				continue;
			}

			//For progress control, need to know the last bytes no.
			ULONGLONG curBytesRead, totBytesRead = file.GetLength();
			file.Seek(0, CFile::begin);

			register UINT bytesRead = file.Read(head.ascHead, 3200L);
			if (bytesRead < 3200) {
				file.Close();
				pFrame->myCaption(_T("File ") + inFile + _T(" Ascii section header read wrong"));
				continue;
			}
			file.Read(&bh, 400L);
			if (bytesRead < 400) {
				file.Close();
				pFrame->myCaption(_T("File ") + inFile + _T(" Binary section header read wrong"));
				continue;
			}


			isUnix = IsUnix(bh.format);
			if (!isUnix) {
				tStr.Format(_T("Header of input file %s indicates %d as format. Are you sure it is unix format?"), inFile, bh.format);
				int id = AfxMessageBox(tStr, MB_YESNO | MB_ICONINFORMATION | MB_ICONQUESTION);
				if (id == IDNO) continue;
				else isUnix = TRUE;
			}

			if (isUnix) {
				SwapTapeHeader(&bh);
			}

			if (bh.format == 0) {
				tStr.Format(_T("Data format marked as 0. Is it floating point? If No, it is assumed to be short integer format"));
				int id = AfxMessageBox(tStr, MB_YESNO | MB_ICONINFORMATION | MB_ICONQUESTION);
				if (id == IDYES) bh.format = 1;
				else bh.format = 3;
			}

			if (isSwapIEEE_IBM) {
				if (bh.format == 1)
					bh.format = 5;
				else if (bh.format == 5)
					bh.format = 1;
			}


			int numsamp = bh.hns;
			int len;
			if (bh.format == 1 || bh.format == 2)
				len = numsamp * 4 + 240;
			else if (bh.format == 3)
				len = numsamp * 2 + 240;
			else if (bh.format == 4) {
				file.Close();
				pFrame->myCaption(_T("File ") + inFile + _T(" Data in 4-byte fixed point w/gain code is not supported in SeisWide; Try using NSCU in UNIX to convert"));
				continue;
			}
			else if (bh.format == 5)
				len = numsamp * 4 + 240;
			else {
				file.Close();
				pFrame->myCaption(_T("File ") + inFile + _T(" has unknown format"));
				continue;
			}
			if (bh.hdt == 0) bh.hdt = bh.dto;
			int tpp = bh.hdt;
			ULONGLONG byteFileEnd = file.SeekToEnd();
			file.Seek(3600L, CFile::begin);

			CFile file2;
			if (!file2.Open(outFile, CFile::modeWrite | CFile::modeCreate | CFile::typeBinary)) {
				file.Close();
				continue;
			}

			if (isConvertEbc2Ascii) ebc2asc(head.ascHead, 3200L);
			file2.Write(head.ascHead, 3200L);
			file2.Write(&bh, 400L);

			bool isTraceNumberFix = false;
			unsigned short numOld = 0;
			k = 0;
			while (file.Read(&tr, len) == (UINT)len) {
				k++; //trace counter

				if (isUnix) {
					SwapTraceHeader(false, isUseReducedTime, isDeadTrcExist, &tr);
					SwapN(&tr.dat, bh.format, numsamp);
				}

				if (GSCformat) {
					double aDelay = 0.001 * (i4buf[45] + i4buf[52]);
					tr.setTraceDelayF(aDelay);
				}
				if (isResetZero)
					tr.setTraceDelayF(0.0);

				if (trcRenum || tr.tracl <= 0) tr.tracl = k;
				if (numOld>0 && abs(tr.tracl - numOld) > 1)
					tr.tracl = numOld + 1; // abandon the original tr.tracl field since it can cause problem for me.
				numOld = tr.tracl;

				if (isDeadTrcExist) {
					tr.trid = 1;  // mark it as always valid trace
				}

				if (isOffsetMM) {
					register double offset = tr.offset * 0.000001;
					tr.setOffset((float)offset);  // here offset must be in km
				}

				file2.Write(&tr, len);

				curBytesRead = file.Seek(0, CFile::current);
				int iPos = (int)((double)curBytesRead / (double)totBytesRead*100.);
				if (iPos < 0)iPos = 0;
				if (iPos > 100)iPos = 100;
				pFrame->SetProgress(iPos);
			} //end the while Read loop.
			file.Close();
			file2.Close();
			count++;

		} //end the while file POSITION loop.
	} //end dlg.DoModal function.
	free1(buff);

	pFrame->EndProgress();

	if (GSCformat) {
		AfxMessageBox(_T("Please note: for GSC segy that uses azymuth for the signs of trace offset, set them by running 'Processing|Reverse Signs'"), MB_ICONQUESTION);
	}

	//static bool isPromptLoc = true;
	//if (isPromptLoc) {
	//	isPromptLoc = false;
		tStr.Format(_T("See the same folder for %d converted files."), count);
		AfxMessageBox(tStr, MB_ICONQUESTION);
	//}
}





BOOL CSeisWideDoc::KdmigGeneral(FILE* jpfp, CFile* file2, BOOL useExist, BOOL preStack, BOOL appendOutput)
{
	/* Copyright (c) Colorado School of Mines, 1996.*/
	/* All rights reserved.                       */

	/* SUKDMIG2D: $Revision: 1.9 $ ; $Date: 1996/01/25 22:01:33 $	*/

	/*********************** self documentation **********************/
	char *sdoc[] = {
		" 									",
		"SUKDMIG2D - Kirchhoff Depth Migration of 2D poststack/prestack data	",
		" 									",
		"    sukdmig2d  infile=  outfile=  [parameters] 			",
		"									",
		" Required parameters:							",
		" infile=stdin		file for input seismic traces			",
		" outfile=stdout	file for common offset migration output  	",
		" ttfile		file for input traveltime tables		",
		"   The following 9 parameters describe traveltime tables:		",
		" fzt 			first depth sample in traveltime table		",
		" nzt 			number of depth samples in traveltime table	",
		" dzt			depth interval in traveltime table		",
		" fxt			first lateral sample in traveltime table	",
		" nxt			number of lateral samples in traveltime table	",
		" dxt			lateral interval in traveltime table		",
		" fs 			x-coordinate of first source			",
		" ns 			number of sources				",
		" ds 			x-coordinate increment of sources		",
		"									",
		" Optional Parameters:							",
		" dt= or from header (dt) 	time sampling interval of input data	",
		" ft= or from header (ft) 	first time sample of input data	",
		" dxm= or from header (d2) 	sampling interval of midpoints 		",
		" fzo=fzt                z-coordinate of first point in output trace 	",
		" dzo=0.2*dzt		vertical spacing of output trace 		",
		" nzo=5*(nzt-1)+1 	number of points in output trace		",
		" fxo=fxt                x-coordinate of first output trace 		",
		" dxo=0.5*dxt		horizontal spacing of output trace 		",
		" nxo=2*(nxt-1)+1  	number of output traces 			",
		" off0=0               	first offest in output 				",
		" doff=99999		offset increment in output 			",
		" noff=1       		number of offsets in output 			",
		" fmax=0.25/dt		frequency-highcut for input traces		",
		" offmax=99999		maximum absolute offset allowed in migration 	",
		" aperx=nxt*dxt/2  	migration lateral aperature 			",
		" angmax=60		migration angle aperature from vertical 	",
		" v0=1500(m/s)		reference velocity value at surface		",
		" dvz=0.0  		reference velocity vertical gradient		",
		" ls=1	                flag for line source				",
		" ntr=100000		maximum number of input traces to be migrated	",
		" npv=0			flag of computing quantities for velocity analysis",
		"   ...if npv>0 specify the following three files:			",
		" tvfile=tvfile		input file of traveltime variation tables	",
		"			tv[ns][nxt][nzt]				",
		"									",
		" Notes:								",
		" 1. Traveltime tables were generated by program rayt2d (or other ones)	",
		"    on relatively coarse grids, with dimension ns*nxt*nzt. In the	",
		"    migration process, traveltimes are interpolated into shot/gephone 	",
		"    positions and output grids.					",
		" 2. Input seismic traces must be SU format and can be any type of 	",
		"    gathers (common shot, common offset, common CDP, and so on).	",
		" 3. Migrated traces are output in CDP gathers if velocity analysis	",
		"    is required, with dimension nxo*noff*nzo.  			",
		" 4. If the offset value of an input trace is not in the offset array 	",
		"    of output, the nearest one in the array is chosen. 		",
		" 5. Memory requirement for this program is about			",
		"    	[ns*nxt*nzt+noff*nxo*nzo+4*nr*nzt+5*nxt*nzt+npa*(2*ns*nxt*nzt   ",
		"	+noff*nxo*nzo+4*nxt*nzt)]*4 bytes				",
		"    where nr = 1+min(nxt*dxt,0.5*offmax+aperx)/dxo. 			",
		" 6. Amplitudes are computed using the reference velocity profile, v(z),",
		"    specified by the parameters v0= and dvz=.				",
		" 7. Input traces must specify source and receiver positions via the header",
		"    fields tr.sx and tr.gx. Offset is computed automatically.		",
		"									",
		NULL };
	/*
	* Author:  Zhenyue Liu, 03/01/95,  Colorado School of Mines
	*
	* Trace header fields accessed: ns, dt, delrt, d2
	* Trace header fields used in input and has to be modified in output: sx, gx
	*
	* For KD migration, all you need to do with the pre-stack data:
	* assign sx and gx fields to each trace.
	*/

	/**************** end self doc ***********************************/

	/* segy trace */
	segy tr, tro;

	int 	nt, ntRay, nxv, nzv, nzt, nxt, nzo, nxo, noff, nr, ix, iz, ixo, izo, j, io;
	int 	ls, jtr, ktr, mtmax, ek, npv;
	float   ft, fxv, fzv, fzt, fxt, fs, fzo, fxo, off0, dt, dtRay, dxv, dzv, dzt, dxt, dzo, dxo, doff, dxm, ds,
		ext, ezt, ezo, exo, scal, x;
	float v0, dvz, fmax, angmax, offmax, rmax, sx, gx;
	float ***mig, **tb, **pb, **cs0b, **angb, **tsum, **tt, **t1, *v;
	float **tvsum = NULL, ***mig1 = NULL, **cssum = NULL; // initilize to NULL to avoid compiler warning
	BOOL useOnDemand = FALSE;

	Geo2d geo2dv, geo2dt;
	CString inF, outF;


	// Deping's notes: 
	// (1) this routine is called by OnProcessingKdmigsimple() or OnProcessingKdmigPost(),
	//     which invokes dialog boxes for parameters. No dialog boxes are called here.
	// (2) Those dialog boxes MUST handle parameters like:
	//		draw.timeSecName, velMod.velSecName, draw.depthSecName, cd.coord.xmin, cd.coord.xmax, 
	//		cd.coord.zmin, velColor.dz, cd.coord.zmax, and struct kd...
	// (3) if useExist is true, skip raytracing. If preStack is true, a pre-stack case.
	// (4) if appendOutput=TRUE, output data will be appended to existing one: for  
	//	   migration of several sections, this is useful.
	inF = draw.timeSecName;
	outF = draw.depthSecName;
	if (kd.ek) ek = 1;
	else ek = 0;


	//All parameters are entered in km, but this routine only uses m.
	ds = (float)(kd.ds*1000.);
	dxm = 1000.f*kd.dxm;

	off0 = 1000.f*kd.off0;
	doff = 99999.f;
	noff = 1;
	offmax = 1000.f*kd.offmax;
	ls = kd.ls;
	fmax = kd.fmax;
	angmax = kd.angmax;

	if (kd.dt < 0.0000001f)kd.dt = 0.008f;
	dtRay = kd.dt;
	ntRay = (int)(kd.tmaxRay / kd.dt + 1.5f);

	npv = 0; //do not do velocity analysis.

	if (kd.aperx < kd.dxo) kd.aperx = kd.dxo;

	fxo = 1000.f*((float)cd.coord.xmin - kd.aperx);
	fzo = (float)cd.coord.m_zmin*1000.f;
	dxo = 1000.f*kd.dxo;
	dzo = 1000.f*(float)velColor.dz;
	nxo = (int)((cd.coord.xmax - cd.coord.xmin + 2.*kd.aperx) / kd.dxo + 0.9999);
	nzo = (int)((cd.coord.m_zmax - cd.coord.m_zmin) / velColor.dz + 0.9999);
	exo = fxo + (nxo - 1)*dxo;
	ezo = fzo + (nzo - 1)*dzo;

	fxt = 1000.f*((float)cd.coord.xmin - kd.aperx);
	fzt = (float)cd.coord.m_zmin*1000.f;
	dxt = 1000.f*kd.dxt;
	dzt = 1000.f*kd.dzt;  if (dzt < dzo) dzt = dzo; // this can be coarser than velColor.dz
	nxt = (int)((cd.coord.xmax - cd.coord.xmin + 2.*kd.aperx)*1000.f / dxt + 0.9999);
	nzt = (int)((cd.coord.m_zmax - cd.coord.m_zmin)*1000.f / dzt + 0.9999);
	ext = fxt + (nxt - 1)*dxt;
	ezt = fzt + (nzt - 1)*dzt;

	//be careful to get raytracing wide enough to cover all output areas.
	fxv = fxo;
	fzv = 0.f; 	//Found that raytracing requires fzv<=0 
	dxv = kd.dxv * 1000;
	dzv = 1000.f*kd.dzv;	//depth increment for vel model.
	nxv = (int)((exo - fxv) / dxv + 2.f); //this should come last.
	nzv = (int)((ezo - fzv) / dzv + 2.f);

	fs = kd.fs*1000.f;

	// some defaults

	// velMod.velSecName is already loaded in calling routine.
	if (kd.v0 < 0.00001f)
		v0 = 1000.f*velMod.vf[0][0][0];
	else
		v0 = 1000.f*kd.v0;
	if (kd.dvz < 0.000000001f)
	{
		if ((velMod.zm[0][1] - velMod.zm[0][0])>0.00001f)
			dvz = (velMod.vf[0][0][1] - velMod.vf[0][0][0]) /
			(velMod.zm[0][1] - velMod.zm[0][0]);
		else
			dvz = 0.f;
	}
	else
		dvz = kd.dvz;	//vertical gradient.

	v = (float *)alloc1float(nxv*nzv);
	//must be in km for GetVelGrid().
	if (!CVelMod::GetVelGrid((float)(0.001f*fxv), nxv, 0.001f*dxv,
		0.001f*fzv, nzv, 0.001f*dzv, v, &velMod))
	{
		AfxMessageBox(_T("Gridding of input velocity file had problem"), MB_ICONQUESTION);
		free1float(v);
		return FALSE;
	}
	// Note v[] is now in meters.

	// set traveltime tabel parameters
	geo2dv.nx = nxv;		geo2dv.fx = fxv;
	geo2dv.dx = dxv;		geo2dv.odx = 1.0f / dxv;
	geo2dv.nz = nzv;		geo2dv.fz = fzv;
	geo2dv.dz = dzv;		geo2dv.odz = 1.0f / dzv;

	// note that the complete section needs nxo*nzo floats.
	geo2dt.nx = nxt;	geo2dt.fx = fxt;
	geo2dt.dx = dxt;	geo2dt.odx = 1.0f / dxt;
	geo2dt.nz = nzt;	geo2dt.fz = fzt;
	geo2dt.dz = dzt;	geo2dt.odz = 1.0f / dzt;


	if (!useExist && !useOnDemand)
	{
		kd.ns = Lius2draytracingMod(v, geo2dv, geo2dt, ntRay, dtRay, fs, ds,
			kd.aperx*1000.f, kd.fa, kd.na, kd.da, kd.amin, kd.amax, kd.fac, kd.sourceDepth*1000.f, (int)ek, (int)npv, jpfp, _T(".tempMigRayParaSrc"));
		if (kd.ns == 0)
		{
			free1float(v);
			fclose(jpfp);
			AfxMessageBox(_T("Unable to perform raytracing"), MB_ICONQUESTION);
			return FALSE;
		}
		else {
			// now calculate raytracing for receivers. The receivers can at a different depth from the source
			_ftprintf_s(jpfp, _T("Finished raytracing for the sources. The receivers can at a different depth from the source.\n"));
			kd.ns = Lius2draytracingMod(v, geo2dv, geo2dt, ntRay, dtRay, fs, ds,
				kd.aperx*1000.f, kd.fa, kd.na, kd.da, kd.amin, kd.amax, kd.fac, 0.f, (int)ek, (int)npv, jpfp, _T(".tempMigRayParaRec"));
			_ftprintf_s(jpfp, _T("Finished raytracing for the receivers.\n"));
			fflush(jpfp);
		}
	}
	if (!useOnDemand) free1float(v);

	CFile file;
	if (!file.Open(inF, CFile::modeRead | CFile::typeBinary | CFile::shareDenyNone)) {
		free1float(v);
		fclose(jpfp);
		return FALSE;
	}

	UINT bytesRead = file.Read(head.ascHead, 3200L);
	if (bytesRead < 3200)
		AfxMessageBox(_T("Ascii section header read wrong"), MB_ICONQUESTION);
	if (!appendOutput) file2->Write(head.ascHead, 3200L);

	short *i2buf;
	i2buf = (short *)&tr;
	float *trcdat;
	trcdat = (float *)&i2buf[120];

	bytesRead = file.Read(i2buf, 400L);
	if (bytesRead < 400)
		AfxMessageBox(_T("Binary section header read wrong"), MB_ICONQUESTION);
	int numsamp = (unsigned short)i2buf[10];
	//BOOL dataInt;
	int len;
	int dformatIn = i2buf[12];
	if (dformatIn == 1) {
		//dataInt = FALSE;
		len = numsamp * 4 + 240;
	}
	else if (dformatIn == 3)  {
		//dataInt = TRUE;
		len = numsamp * 2 + 240;
	}
	else {
		AfxMessageBox(_T("Sorry, only floating point is supported"), MB_ICONQUESTION);
		file.Close();
		return FALSE;
	}
	int tpp = (unsigned short)i2buf[8];
	nt = numsamp;
	dt = (float)(((double)tpp) / (double)MIL);

	//assign section headers, same as in ViewConv().
	i2buf[10] = (unsigned short)nzo; // numsamp;
	i2buf[11] = i2buf[10];
	i2buf[12] = 1;
	i2buf[8] = (unsigned short)(dzo * 1000);	//Sampling rate in micro sec;
	i2buf[9] = i2buf[8];
	if (!appendOutput) file2->Write(i2buf, 400L);

	//determine initial time.
	while (file.Read(&tr, len) == (UINT)len)
	{
		if (tr.trid != 2) //dead traces.
			ft = tr.getTraceDelay(); //tr.delrt is i2buf[54]. Use t1 field????
		break;
	}

	mtmax = (int)(2 * dxm*sin(angmax*PIO) / (v0*dt));
	if (mtmax < 1) mtmax = 1;
	if (fmax > (0.25f / dt)) fmax = 0.25f / dt;

	_ftprintf_s(jpfp, _T("\n"));
	_ftprintf_s(jpfp, _T(" Migration parameters\n"));
	_ftprintf_s(jpfp, _T(" ================\n"));
	_ftprintf_s(jpfp, _T(" nzt=%d fzt=%g dzt=%g\n"), nzt, fzt, dzt);
	_ftprintf_s(jpfp, _T(" nxt=%d fxt=%g dxt=%g\n"), nxt, fxt, dxt);
	_ftprintf_s(jpfp, _T(" \n"));
	_ftprintf_s(jpfp, _T(" nzo=%d fzo=%g dzo=%g\n"), nzo, fzo, dzo);
	_ftprintf_s(jpfp, _T(" nxo=%d fxo=%g dxo=%g\n"), nxo, fxo, dxo);
	_ftprintf_s(jpfp, _T(" \n"));

	//	rmax = (float)MAX(es-fxt,ext-fs);
	rmax = ext;
	rmax = (float)MIN(rmax, 0.5*offmax + kd.aperx*1000.f);
	nr = 2 + (int)(rmax / dxo);
	_ftprintf_s(jpfp, _T(" nt=%d ft=%g dt=%g \n"), nt, ft, dt);
	_ftprintf_s(jpfp, _T(" dxm=%g fmax=%g\n"), dxm, fmax);
	_ftprintf_s(jpfp, _T(" off0=%g offmax=%g\n"), off0, offmax);
	_ftprintf_s(jpfp, _T(" v0=%g dvz=%g \n"), v0, dvz);
	_ftprintf_s(jpfp, _T(" aperx=%g angmax=%g\n"), kd.aperx*1000.f, angmax);
	_ftprintf_s(jpfp, _T(" ls=%d npv=%d\n"), ls, npv);
	_ftprintf_s(jpfp, _T(" ================\n"));
	fflush(jpfp);
	// Finish initializing local parameters.

	// compute reference traveltime and slowness  
	tb = (float **)ealloc2float(nzt, nr);
	if (tb == NULL)
	{
		free2float(tb);
		free1float(v);
		file.Close();
		return FALSE;
	}
	pb = (float **)ealloc2float(nzt, nr);
	if (pb == NULL)
	{
		free2float(tb);
		free2float(pb);
		free1float(v);
		file.Close();
		return FALSE;
	}
	cs0b = (float **)ealloc2float(nzt, nr);
	if (cs0b == NULL)
	{
		free2float(tb);
		free2float(pb);
		free2float(cs0b);
		free1float(v);
		file.Close();
		return FALSE;
	}
	angb = (float **)ealloc2float(nzt, nr);
	if (angb == NULL)
	{
		free2float(tb);
		free2float(pb);
		free2float(cs0b);
		free2float(angb);
		free1float(v);
		file.Close();
		return FALSE;
	}
	timeb(nr, nzt, dxo, dzt, fzt, dvz, v0, tb, pb, cs0b, angb);

	tsum = (float **)ealloc2float(nzt, nxt);
	if (tsum == NULL)
	{
		free2float(tb);
		free2float(pb);
		free2float(cs0b);
		free2float(angb);
		free2float(tsum);
		free1float(v);
		file.Close();
		return FALSE;
	}

	int iError = 0;
	int trac0 = 1;	//firat trace number in one migration loop.
	// int nAperx = (int)(aperx/dxo); only useful for post-stack.

	mig = (float ***)ealloc3float(nzo, nxo, 1);
	if (mig == NULL)
	{
		free2float(tb);
		free2float(pb);
		free2float(cs0b);
		free2float(angb);
		free2float(tsum);
		free3float(mig);
		free1float(v);
		file.Close();
		return FALSE;
	}
	mig1 = ealloc3float(1, 1, 1);

	_ftprintf_s(jpfp, _T(" start migration \n"));
	fflush(jpfp);

	jtr = 1;
	ktr = 0;
	memset((void *)mig[0][0], (int) '\0', nxo*nzo*sizeof(float));

	//For progress control, need to know the last bytes no.
	ULONGLONG curBytesRead, totBytesRead = file.GetLength();
	//Begin progress control.
	CMainFrame* pFrame =
		(CMainFrame*)AfxGetMainWnd();
	ASSERT(pFrame);
	ASSERT_KINDOF(CMainFrame, pFrame);
	pFrame->BeginProgress();

	file.Seek(3600, CFile::begin);
	file.Read(&tr, 240); // read the data here.
	CFile fileRaySrc(_T(".tempMigRayParaSrc"), CFile::modeRead | CFile::typeBinary);
	CFile fileRayRec(_T(".tempMigRayParaRec"), CFile::modeRead | CFile::typeBinary);
	long nnxzt = nxt*nzt*sizeof(float);
	float as, res, sxOld = MIL, *t;
	int is;
	do {
		if (tr.trid == 2)
		{
			file.Seek(len - 240, CFile::current);
			continue;	//dead traces.
		}
		ft = tr.getTraceDelay(); //tr.delrt is i2buf[54]. Use t1 field???
		if (preStack)
		{
			sx = (float)tr.sx;
			gx = (float)tr.gx;
		}
		else sx = gx = tr.getDistance();

		/* determine offset index	*/
		io = (int)((gx - sx - off0) / doff + 0.5);
		if (io < 0) io = 0;
		if (io >= noff) io = noff - 1;

		if (MIN(sx, gx) >= fxt && MAX(sx, gx) <= ext
			&& fabs(gx - sx) <= offmax)
		{ //     migrate this trace	
			if (file.Read(&tr.dat.data, len - 240) != (UINT)(len - 240)) continue; // read the data here.
			if (dformatIn == 3) {
				for (j = 0; j < numsamp; j++)
					tro.dat.data[j] = i2buf[120 + j];  //here two bytes data is converted to 4 bytes.
				for (j = 0; j < numsamp; j++)
					tr.dat.data[j] = tro.dat.data[j];
			}
			else if (dformatIn == 2) {
				for (j = 0; j < numsamp; j++)
					tr.dat.data[j] = (float)tro.dat.dataint[j];
			}
			else if (dformatIn == 1) {
				// floating point needs to convert from iBM to IEEE
				ibm_to_float((int *)tr.dat.data, (int *)tr.dat.data, (int)numsamp);
			}

			t1 = (float **)ealloc2float(nzt, nxt);
			tt = (float **)ealloc2float(nzt, nxt);
			if (t1 == NULL || tt == NULL)
			{
				AfxMessageBox(_T("memory shortage"));
				free2float(tb);
				free2float(pb);
				free2float(cs0b);
				free2float(angb);
				free2float(tt);
				free2float(tsum);
				free3float(mig);
				free1float(v);
				file.Close();
				return FALSE;
			}

			if (!useOnDemand)
			{
				// this will interpolate between travel-time table already calculated
				as = (sx - fs) / ds;
				is = (int)as;
				if (is == kd.ns - 1) is = kd.ns - 2;
				if (is < 0) is = 0;
				fileRaySrc.Seek(is*nnxzt, CFile::begin);
				for (ix = 0; ix < nxt; ix++) {
					fileRaySrc.Read((void *)tt[ix], nzt*sizeof(float));
				}
				UINT numRead = 0;
				for (ix = 0; ix < nxt; ix++) {
					numRead = fileRaySrc.Read((void *)t1[ix], nzt*sizeof(float));
				}
				if (numRead == nzt*sizeof(float)) {
					// this would mean the second round of reading is done correctly
					res = as - is;
					if (res <= 0.01f) res = 0.f;
					if (res >= 0.99f) res = 1.0;
					for (ix = 0; ix < nxt; ix++)
					{
						for (iz = 0; iz < nzt; iz++)
							tt[ix][iz] = (1.f - res)*tt[ix][iz] + res*t1[ix][iz];
					}
				}
				else {
					// this would mean the second round of reading is NOT done correctly
					// let's only use the previous reading and shift a little by (sx-fs)
					int tShift = (int)myRound((sx - fs) / dxt);
					for (iz = 0; iz < nzt; iz++) {
						for (ix = 0; ix < nxt; ix++)
						{
							int iShifted = ix - tShift;
							if (iShifted >= 0 && iShifted < nxt)
								t1[ix][iz] = tt[iShifted][iz];
							else
								t1[ix][iz] = 99999.f;
						}
						for (ix = 0; ix < nxt; ix++)
						{
							tt[ix][iz] = t1[ix][iz];
						}
					}
				}
				resit(nxt, fxt, dxt, nzt, nr, dxo, tb, tt, sx); // compute traveltime residueal

				as = (gx - fs) / ds;
				is = (int)as;
				if (is == kd.ns - 1) is = kd.ns - 2;
				if (is < 0) is = 0;
				fileRayRec.Seek(is*nnxzt, CFile::begin);
				for (ix = 0; ix < nxt; ix++)
					fileRayRec.Read((void *)tsum[ix], nzt*sizeof(float));
				numRead = 0;
				for (ix = 0; ix < nxt; ix++)
					numRead = fileRayRec.Read((void *)t1[ix], nzt*sizeof(float));
				if (numRead == nzt*sizeof(float)) {
					// this would mean the second round of reading is done correctly
					res = as - is;
					if (res <= 0.01f) res = 0.f;
					if (res >= 0.99f) res = 1.0;
					for (ix = 0; ix < nxt; ix++)
					{
						for (iz = 0; iz < nzt; iz++)
							tsum[ix][iz] = (1.f - res)*tsum[ix][iz] + res*t1[ix][iz];
					}
				}
				else {
					// this would mean the second round of reading is NOT done correctly
					// let's only use the previous reading and shift a little by (gx-fs)
					int tShift = (int)myRound((gx - fs) / dxt);
					for (iz = 0; iz < nzt; iz++) {
						for (ix = 0; ix < nxt; ix++)
						{
							int iShifted = ix - tShift;
							if (iShifted >= 0 && iShifted < nxt)
								t1[ix][iz] = tsum[iShifted][iz];
							else
								t1[ix][iz] = 99999.f;
						}
						for (ix = 0; ix < nxt; ix++)
						{
							tsum[ix][iz] = t1[ix][iz];
						}
					}
				}
				resit(nxt, fxt, dxt, nzt, nr, dxo, tb, tsum, gx); // compute traveltime residueal
			}
			else
			{
				// use on demand: call Lius2draytracingSimple() to raytrace for sx and gx.
				// should be changed to make it work.
				t = (float *)alloc1float(nxo*nzo);
				if (fabs(sx - sxOld) > 0.0001)
				{ // re-calculate only if sx is different from sxOld.
					if (!Lius2draytracingSingle(v, geo2dv, geo2dt, ntRay, dtRay, sx, t,
						kd.aperx*1000.f, kd.fa, kd.na, kd.da, kd.amin, kd.amax, kd.fac, kd.sourceDepth, (int)ek,
						(int)npv, jpfp))
					{
						_ftprintf_s(jpfp, _T("   Raytracing failed when raytracing a source at %g (m)\n"), sx);
						continue;
					}
					for (ix = 0; ix < nxo; ix++)
						memcpy((void *)tt[ix], &t[ix*nzo], nzo*sizeof(float));
					sxOld = sx; // save for the next round.
				}

				if (fabs(gx - sx) > 0.0001)
				{
					if (!Lius2draytracingSingle(v, geo2dv, geo2dt, ntRay, dtRay, gx, t,
						kd.aperx*1000.f, kd.fa, kd.na, kd.da, kd.amin, kd.amax, kd.fac, kd.sourceDepth, (int)ek,
						(int)npv, jpfp))
					{
						_ftprintf_s(jpfp, _T("   Raytracing failed when raytracing a receiver at %g (m)\n"), gx);
						continue;
					}
					for (ix = 0; ix < nxo; ix++)
						memcpy((void *)tsum[ix], &t[ix*nzo], nzo*sizeof(float));
				}
				else
				{
					for (ix = 0; ix < nxo; ix++)
						memcpy((void *)tsum[ix], (const void *)tt[ix], nzo*sizeof(float));
				}
				free1float(t);
			} // end of  use on demand

			free2float(t1);
			_ftprintf_s(jpfp, _T(" Finish raytracing for sx=%g and gx=%g."), sx, gx);
			for (ix = 0; ix < nxt; ix++)
				for (iz = 0; iz < nzt; iz++)
					tsum[ix][iz] += tt[ix][iz];

			free2float(tt);

			// mig[0][][] is a 3-D array.
			mig2d(tr.dat.data, nt, ft, dt, sx, gx, mig[io], kd.aperx*1000.f,
				nxo, fxo, dxo, nzo, fzo, dzo,
				ls, mtmax, dxm, fmax, angmax,
				tb, pb, cs0b, angb, nr, tsum, nzt, fzt, dzt, nxt, fxt, dxt,
				npv, cssum, tvsum, mig1[io]);

			ktr++;
			_ftprintf_s(jpfp, _T(" Success migrating this trace: %d\n"), jtr);
		}
		else
		{
			file.Seek(len - 240, CFile::current);
			_ftprintf_s(jpfp, _T(" Skip trace %d: sx=%d gx=%d (m)\n"), jtr, (int)sx, (int)gx);
		}
		fflush(jpfp);
		jtr++;

		curBytesRead = file.Seek(0, CFile::current);
		int iPos = (int)((double)curBytesRead / (double)totBytesRead*100.);
		if (iPos < 0)iPos = 0;
		if (iPos > 100)iPos = 100;
		pFrame->SetProgress(iPos);

		//	if (ktr == 3) break; // testing
	} while (file.Read(&tr, 240) == 240);

	if (useOnDemand) free1float(v);
	file.Close();
	free2float(tsum);
	free2float(pb);
	free2float(tb);
	free2float(cs0b);
	free2float(angb);
	fileRaySrc.Close();
	fileRayRec.Close();
	_ftprintf_s(jpfp, _T(" migrated %d traces in total\n"), ktr);

	memset((void *)&tro, (int) '\0', 240);
	tro.ns = nzo;
	tro.cmp.df[0] = dzo;
	tro.dt = (unsigned short)(dzo * 1000);	//Sampling rate in micro sec, or cm.
	tro.delrt = 0;
	tro.delrtEx = (int)fzo;
	tro.cmp.df[1] = fzo;
	tro.cmp.df[2] = dxo;
	tro.trid = 1;

	scal = (float)(4 / sqrt(PI)*dxm / v0);
	ktr = 1;
	//	if (appendOutput) file2.SeekToEnd();
	for (ixo = 0; ixo < nxo; ixo++)
	{
		x = fxo + (ixo*dxo);
		x *= 0.001f;
		if (x < cd.coord.xmin) continue;
		if (x >= cd.coord.xmax) break;
		// mig[0][][] is a 3-D array.
		memcpy((void *)tro.dat.data, (const void *)mig[0][ixo], nzo*sizeof(float));
		//	tro.f2 = fxo;
		tro.offset = (int)off0;
		tro.tracr = tro.tracl = trac0 + ktr;
		ktr++;
		tro.setDistance(fxo + ixo*dxo);

		tro.cdpt = 1;

		for (izo = 0; izo < nzo; ++izo) tro.dat.data[izo] *= scal;

		//	memcpy((void*) &i2buf, (void*)&tro, nzo*sizeof(float)+240); 
		file2->Write(&tro, nzo*sizeof(float) + 240);
	}

	_ftprintf_s(jpfp, _T(" \n"));
	_ftprintf_s(jpfp, _T(" output done\n"));
	fclose(jpfp);

	free3float(mig);
	free3float(mig1);
	_heapmin();

	pFrame->EndProgress();

	//	if (isFileExistNotDirectory(kd.migLog))
	//		showFileInNotePad(kd.migLog);

	return TRUE;
}
//
//void CSeisWideDoc::OnProcessingKdmigsimple()
//{
//	if (head.isUnixFile) {
//		CString tStr;
//		tStr.Format(_T("Sorry, this routine only deals with PC format."));
//		AfxMessageBox(tStr, MB_ICONQUESTION);
//		return;
//	}
//	int 	nxv, nzv, nzo, nxo, nr, ns;
//	float   fxv, fzv, fzo, fxo, dt, dzv, ezo, exo, rmax, temp, xmin, xmax;
//	TCHAR *jpfile;
//	BOOL useExist, appendOutput = FALSE;
//	FILE *jpfp;
//	CString tempStr;
//
//	CdlgKdmig dlg;
//	dlg.m_timeSecName = draw.timeSecName;
//	dlg.m_velSecName = velMod.velSecName;
//	dlg.m_depthSecName = draw.depthSecName;
//	dlg.m_ek = kd.ek;
//	dlg.m_amax = kd.amax;
//	dlg.m_amin = kd.amin;
//	dlg.m_angmax = kd.angmax;
//	dlg.m_da = kd.da;
//	dlg.m_dt = kd.dt;	//dt for raytracing, not for output mig
//	dlg.m_dxt = (kd.dxt < kd.dxo) ? kd.dxo*4.f : kd.dxt;
//	dlg.m_dzt = (float)((kd.dzt < velColor.dz) ? velColor.dz*4.f : kd.dzt);
//
//	dlg.m_dxv = kd.dxv = (float)((cd.coord.xmax - cd.coord.xmin)*0.01);
//	dlg.m_dzv = kd.dzv = (float)((cd.coord.m_zmax - cd.coord.m_zmin)*0.01); //dzv is depth increment for model gridding.
//	dlg.m_dvz = kd.dvz;	//dvz is vertical gradient.
//	dlg.m_dxm = kd.dxm;
//	dlg.m_dxo = kd.dxo;
//
//	dlg.m_fs = (float)((kd.fs<0 || kd.fs>99999.f) ? cd.coord.xmin : kd.fs);
//	dlg.m_dxs = kd.ds;
//	dlg.m_srcDepth = (kd.sourceDepth<0 || kd.sourceDepth>99999.f) ? 0 : kd.sourceDepth;
//
//	dlg.m_dzo = (float)velColor.dz; //use existing velColor.dz
//	dlg.m_fa = kd.fa;
//	dlg.m_fac = kd.fac;
//	dlg.m_fxo = (float)cd.coord.xmin;	//equals to cd.coord.xmin
//	dlg.m_xmax = (float)cd.coord.xmax;
//	dlg.m_fzo = (float)cd.coord.m_zmin;
//	dlg.m_zmax = (float)cd.coord.m_zmax;
//	dlg.m_na = kd.na;
//	dlg.m_tmaxRay = kd.tmaxRay;
//	dlg.m_off0 = kd.off0;
//	if (kd.offmax < 0.00001f) kd.offmax = 99999.f;
//	dlg.m_offmax = kd.offmax;
//	dlg.m_v0 = kd.v0;
//	dlg.m_fmax = kd.fmax;
//	dlg.m_ls = kd.ls;
//	dlg.m_aperx = kd.aperx;
//	dlg.m_memMax = kd.memMax;
//
//	if (dlg.DoModal() == IDOK)
//	{
//		draw.timeSecName = dlg.m_timeSecName.Trim();
//		velMod.velSecName = dlg.m_velSecName.Trim();
//
//		dlg.m_depthSecName = SetFileExtension(dlg.m_depthSecName, _T("sgy"));
//
//
//		draw.depthSecName = dlg.m_depthSecName;
//		kd.ek = dlg.m_ek;  //ek does not exist in this routine, instead kd.ek is used.
//		kd.amax = dlg.m_amax; // max angle used during raytracing (0-180)
//		kd.amin = dlg.m_amin; // min angle used during raytracing (0-180)
//		kd.angmax = dlg.m_angmax;  // migration angle aperture from vertical: default 60.
//		kd.da = dlg.m_da;
//		kd.fa = dlg.m_fa;
//		kd.na = dlg.m_na;
//		kd.fac = dlg.m_fac;  if (kd.fac < 0.000001) kd.fac = 0.01f;
//		kd.aperx = dlg.m_aperx;
//		kd.dxm = dlg.m_dxm;
//
//		kd.fs = dlg.m_fs;
//		kd.ds = dlg.m_dxs;
//		kd.sourceDepth = dlg.m_srcDepth;  // testing for a OBS
//
//		cd.coord.xmin = dlg.m_fxo;
//		kd.dxo = dlg.m_dxo;
//		cd.coord.xmax = dlg.m_xmax;
//		cd.coord.m_zmin = dlg.m_fzo;
//		velColor.dz = dlg.m_dzo;
//		cd.coord.m_zmax = dlg.m_zmax;
//		kd.off0 = dlg.m_off0;
//		kd.offmax = dlg.m_offmax;
//		kd.v0 = dlg.m_v0;
//		kd.dvz = dlg.m_dvz;
//		kd.fmax = dlg.m_fmax;
//		kd.ls = dlg.m_ls;
//		kd.memMax = dlg.m_memMax;
//
//		kd.tmaxRay = dlg.m_tmaxRay;
//		kd.dt = dlg.m_dt;	//kd.dt, dtRay are for raytracing, not for output mig
//		kd.dxt = dlg.m_dxt;
//		kd.dzt = dlg.m_dzt;
//
//		kd.dxv = dlg.m_dxv;
//		kd.dzv = dlg.m_dzv;
//
//		useExist = dlg.m_useExist;
//	}
//	else
//	{
//		return;
//	}
//	delete dlg;
//
//	if (!CheckTime(200))
//	{
//		return;
//	}
//	if (velMod.velSecName.IsEmpty())
//	{
//		AfxMessageBox(_T("Please specify a velocity name in .bin format"), MB_ICONQUESTION);
//		return;
//	}
//	//if(velMod.velSecOld != velMod.velSecName)
//	//{
//	//	if(!velMod.velSecName.IsEmpty())
//	//	{
//	//		if(!MyInitVel()) return;
//	//		else velMod.velSecOld = velMod.velSecName;
//	//	}
//	//}
//	//	OnToolbarSavev(); //save velocity file first, in case people ...
//
//	if (draw.timeSecName.IsEmpty() || draw.depthSecName.IsEmpty())
//	{
//		AfxMessageBox(_T("Please specify an input/output file name"), MB_ICONQUESTION);
//		return;
//	}
//
//	//	kd.fs = cd.coord.xmin;
//	//	kd.fs = 4.196f;  // test for a OBS location
//
//	//All parameters are entered in km, but this routine only uses m.
//	fxo = (float)cd.coord.xmin*1000.f - kd.aperx*1000.f;
//	nxo = (int)((cd.coord.xmax - cd.coord.xmin + 2.*kd.aperx) / kd.dxo + 0.9999);
//	ns = (int)((cd.coord.xmax - cd.coord.xmin + 2.*kd.aperx) / kd.ds + 0.9999);
//	nzo = (int)((cd.coord.m_zmax - cd.coord.m_zmin) / velColor.dz + 0.9999);
//	if (kd.aperx < kd.dxo) kd.aperx = kd.dxo;
//
//	exo = fxo + (nxo - 1)*kd.dxo*1000.f;
//	fzo = (float)cd.coord.m_zmin*1000.f;
//	ezo = (float)(fzo + (nzo - 1)*velColor.dz*1000.);
//
//	//be careful to get raytracing wide enough to cover all output areas.
//	fxv = fxo;
//	nxv = (int)((exo - fxv) / kd.dxv / 1000.f + 2.f); //this should come last.
//	fzv = 0.f; 	//Found that raytracing requires fzv<=0 
//	dzv = 1000.f*kd.dzv;	//depth increment for vel model.
//	nzv = (int)((ezo - fzv) / kd.dzv / 1000.f + 2.f);
//
//
//	CFile file;
//	if (!file.Open(draw.timeSecName, CFile::modeRead | CFile::typeBinary | CFile::shareDenyNone)) {
//		return;
//	}
//	UINT bytesRead = file.Read(head.ascHead, 3200L);
//	if (bytesRead < 3200)
//		AfxMessageBox(_T("Ascii section header read wrong"), MB_ICONQUESTION);
//
//	segy tr;
//	short *i2buf;
//	i2buf = (short *)&tr;
//	float *trcdat;
//	trcdat = (float *)&i2buf[120];
//
//	bytesRead = file.Read(i2buf, 400L);
//	if (bytesRead < 400)
//		AfxMessageBox(_T("Binary section header read wrong"), MB_ICONQUESTION);
//	file.Close();
//	int numsamp = (unsigned short)i2buf[10];
//	int len;
//	if (i2buf[12] != 3)
//		len = numsamp * 4 + 240;
//	else
//		len = numsamp * 2 + 240;
//	int tpp = (unsigned short)i2buf[8];
//	dt = (float)(((double)tpp) / (double)MIL);
//
//	rmax = exo;
//	rmax = (float)MIN(rmax, 0.5*kd.offmax*1000.f + kd.aperx*1000.f);
//	nr = 2 + (int)(rmax / kd.dxo / 1000.f);
//	// Finish initializing local parameters.
//
//	//	kd.migLog = velMod.velSecName + _T(".MigData.Log";
//	kd.migLog = GetFileNameAppendExt(velMod.velSecName, _T(".MigData.Log"), _T("txt"));
//	jpfile = kd.migLog.GetBuffer(kd.migLog.GetLength());
//	_tfopen_s(&jpfp, jpfile, _T("w"));
//	kd.migLog.ReleaseBuffer();
//
//	_ftprintf_s(jpfp, _T("\n"));
//	_ftprintf_s(jpfp, _T(" Migration parameters\n"));
//	_ftprintf_s(jpfp, _T(" ================\n"));
//	_ftprintf_s(jpfp, _T(" nzo=%d fzo=%g dzo=%d\n"), nzo, fzo, (int)(velColor.dz*1000.f));
//	_ftprintf_s(jpfp, _T(" nxo=%d fxo=%g dxo=%d\n"), nxo, fxo, (int)(kd.dxo*1000.f));
//	_ftprintf_s(jpfp, _T(" \n"));
//	_ftprintf_s(jpfp, _T(" offmax=%d\n"), (int)(kd.offmax*1000.f));
//	_ftprintf_s(jpfp, _T(" aperx=%d \n"), (int)(kd.aperx*1000.f));
//	_ftprintf_s(jpfp, _T(" ================\n"));
//	fflush(jpfp);
//
//	//Determine space allocation for holding migration output data.
//	// Each output segy sample occupies 4 bytes,
//	// plus 2 time tables since a raytracing table is calculated for each (X,Z) sample.
//	// major 2D arrays:
//	// v, vxx, vxz, vzz: nvx*nvz.
//	// t, ov2, s, tt, tsum, mig: nxo*nzo.
//	// tb, pb, cs0b, angb: nzo*nr.
//	int nnv = 4 * 4 * nxv*nzv;
//	int nno = 7 * 4 * nxo*nzo;
//	int nnr = 4 * 4 * nr*nzo;
//	_ftprintf_s(jpfp, _T(" Required memory is made up by 4*nvx*nvz floats: %d bytes,\n"), nnv);
//	_ftprintf_s(jpfp, _T("   7*nxo*nzo floats: %d bytes, \n"), nno);
//	_ftprintf_s(jpfp, _T("   and 4*nr*nzo floats: %d bytes, where nr=MIN(ext, 0.5*offmax+aperx)/dxo = %d.\n"), nnr, nr);
//	temp = (float)((nnv + nno + nnr) / (double)MIL);
//	_ftprintf_s(jpfp, _T("   Therefore, this operation requires a total memory of %d mb.\n"), (int)temp);
//	if (kd.memMax < temp)
//	{
//		tempStr.Format(_T("Total memory required to migrate the section at once is %d mb, which is greater than specified %d mb. Divide into smaller sections?"), (int)temp, (int)kd.memMax);
//		if (AfxMessageBox(tempStr, MB_YESNO | MB_ICONQUESTION) != IDYES)
//		{
//			fclose(jpfp);
//			showFileInNotePad(kd.migLog);
//			return;
//		}
//	}
//
//	//	int nxoR = (int)(kd.memMax*MIL/(float)(4.*nzo));
//	/*
//	"    	[7*nxo*nzo+4*nr*nzt+npa*7*nxo*nzo]*4 bytes				",
//	"    where nr = 1+min(nxt*dxt,0.5*offmax+aperx)/dxo. 			",
//	*/
//
//	fxo = xmin = (float)cd.coord.xmin;
//	xmax = (float)cd.coord.xmax;
//	nxo = (int)((kd.memMax*MIL - nnv - nnr) / (7.*4.*nzo));
//	int nzt = (int)((cd.coord.m_zmax - cd.coord.m_zmin) / kd.dzt + 0.9999);
//	int nxt = (int)((cd.coord.xmax - cd.coord.xmin + 2.*kd.aperx) / kd.dxt + 0.9999);
//
//	double dwFreeSpace = getFreeSpace(velMod.velSecName);
//
//	//check free disk space for raytracing
//	double bytesNeededRay = (double)((double)ns*(double)nzt*(double)nxt*sizeof(float) / (double)MIL);
//	double bytesNeededOutput = (double)((double)nzo*(double)nxo*sizeof(float) / (double)MIL);
//	double bytesTotal = bytesNeededRay + bytesNeededOutput + 50.;
//
//	_ftprintf_s(jpfp, _T("\n For disk space\n  Space needed to hold raytracing results (mb)=%d \n"), (long)bytesNeededRay);
//	_ftprintf_s(jpfp, _T("  Free space in the current working drive (mb):%d\n"), (long)dwFreeSpace);
//	_ftprintf_s(jpfp, _T("  MBytes Needed for storing output file=%d \n"), (long)bytesNeededOutput);
//
//	_ftprintf_s(jpfp, _T("     Space needed for raytracing is calculated from:\n"));
//	_ftprintf_s(jpfp, _T("       ns:%d; nxt:%d; nzt:%d\n"), ns, nxt, nzt);
//
//	tempStr.Format(_T("Raytracing results will occupy %d mb temporary space. Continue?"), (int)bytesTotal);
//	if (AfxMessageBox(tempStr, MB_YESNO | MB_ICONQUESTION) != IDYES)
//	{
//		fclose(jpfp);
//		showFileInNotePad(kd.migLog);
//		return;
//	}
//
//	CFile file2;
//	if (!file2.Open(draw.depthSecName, CFile::modeCreate | CFile::modeWrite | CFile::typeBinary)) {
//		fclose(jpfp);
//		return;
//	}
//
//
//	// BOOL CSeisWideDoc::KdmigGeneral(jpfp, file2, useExist, preStack, appendOutput)
//	// (3) if useExist is true, skip raytracing. If preStack is true, a pre-stack case.
//	// (4) if appendOutput=TRUE, output data will be appended to existing one: for  
//	//	   migration of several sections, this is useful.
//	while (fxo < xmax)
//	{
//		cd.coord.xmin = fxo;
//		cd.coord.xmax = fxo + (nxo - 1)*kd.dxo;
//		if (cd.coord.xmax > xmax) cd.coord.xmax = xmax;
//		KdmigGeneral(jpfp, &file2, useExist, TRUE, appendOutput);
//		useExist = FALSE;
//		appendOutput = TRUE; // next time will append output segy file.
//		fxo = (float)cd.coord.xmax;
//	}
//
//	cd.coord.xmin = xmin;
//	cd.coord.xmax = xmax;
//	file2.Close();
//	fclose(jpfp);
//
//	//Auto change mode to display both.
//	cd.coord.drawmodeOld = cd.coord.drawmode;
//	cd.coord.drawmode = 3;	//Both velocity color and depth sections will be drawn.
//
//	draw.isSameDataDisplay = FALSE; //indicate display has been changed and will re-load all data in OnDraw().
//	SetModifiedFlag();
//	UpdateAllViews(NULL);
//	NotifyChanged();
//
//}

void CSeisWideDoc::OnProcessingKdmigpost()
{
	if (head.isUnixFile) {
		CString tStr;
		tStr.Format(_T("Sorry, this routine only deals with PC format."));
		AfxMessageBox(tStr, MB_ICONQUESTION);
		return;
	}

	int 	nxv, nzv, nzo, nxo, nr, ns;
	float   fxv, fzv, fzo, fxo, dzv, ezo, exo, rmax, temp, xmin, xmax;
	TCHAR *jpfile;
	BOOL useExist, appendOutput = FALSE;
	FILE *jpfp;
	CString tempStr;

	CdlgKDMigPost dlg;
	dlg.m_timeSecName = draw.timeSecName;
	dlg.m_velSecName = velMod.velSecName;
	dlg.m_depthSecName = draw.depthSecName;
	dlg.m_ek = kd.ek;
	dlg.m_amax = kd.amax;
	dlg.m_amin = kd.amin;
	dlg.m_angmax = kd.angmax;
	dlg.m_da = kd.da;
	dlg.m_dt = kd.dt;	//dt for raytracing, not for output mig
	dlg.m_dxt = (kd.dxt < kd.dxo) ? kd.dxo*4.f : kd.dxt;
	dlg.m_dzt = (float)((kd.dzt < velColor.dz) ? velColor.dz*4.f : kd.dzt);

	dlg.m_dxv = kd.dxv = (float)((cd.coord.xmax - cd.coord.xmin)*0.01);
	dlg.m_dzv = kd.dzv = (float)((cd.coord.m_zmax - cd.coord.m_zmin)*0.01); //dzv is depth increment for model gridding.
	dlg.m_dvz = kd.dvz;	//dvz is vertical gradient.
	dlg.m_dxo = kd.dxo;
	dlg.m_dxs = (kd.ds < 0.00001f) ? (kd.dxo*2.f) : kd.ds;
	dlg.m_dzo = (float)velColor.dz; //use existing velColor.dz
	dlg.m_fa = kd.fa;
	dlg.m_fac = kd.fac;
	dlg.m_fxo = (float)cd.coord.xmin;	//equals to cd.coord.xmin
	dlg.m_xmax = (float)cd.coord.xmax;
	dlg.m_fzo = (float)cd.coord.m_zmin;
	dlg.m_zmax = (float)cd.coord.m_zmax;
	dlg.m_na = kd.na;
	dlg.m_tmaxRay = kd.tmaxRay;
	dlg.m_v0 = kd.v0;
	dlg.m_fmax = kd.fmax;
	dlg.m_ls = kd.ls;
	dlg.m_aperx = kd.aperx;
	dlg.m_memMax = kd.memMax;

	if (dlg.DoModal() == IDOK) {
		draw.timeSecName = dlg.m_timeSecName.Trim();
		velMod.velSecName = dlg.m_velSecName.Trim();

		dlg.m_depthSecName = SetFileExtension(dlg.m_depthSecName, _T("sgy"));

		draw.depthSecName = dlg.m_depthSecName;
		kd.ek = dlg.m_ek;  //ek does not exist in this routine, instead kd.ek is used.
		kd.amax = dlg.m_amax;
		kd.amin = dlg.m_amin;
		kd.angmax = dlg.m_angmax;
		kd.da = dlg.m_da;
		kd.fa = dlg.m_fa;
		kd.na = dlg.m_na;
		kd.fac = dlg.m_fac;
		kd.aperx = dlg.m_aperx;
		kd.ds = dlg.m_dxs;

		cd.coord.xmin = dlg.m_fxo;
		kd.dxo = dlg.m_dxo;
		cd.coord.xmax = dlg.m_xmax;
		cd.coord.m_zmin = dlg.m_fzo;
		velColor.dz = dlg.m_dzo;
		cd.coord.m_zmax = dlg.m_zmax;
		kd.v0 = dlg.m_v0;
		kd.dvz = dlg.m_dvz;
		kd.fmax = dlg.m_fmax;
		kd.ls = dlg.m_ls;
		kd.memMax = dlg.m_memMax;

		kd.tmaxRay = dlg.m_tmaxRay;
		kd.dt = dlg.m_dt;	//kd.dt, dtRay are for raytracing, not for output mig
		kd.dxt = dlg.m_dxt;
		kd.dzt = dlg.m_dzt;

		kd.dxv = dlg.m_dxv;
		kd.dzv = dlg.m_dzv;

		useExist = dlg.m_useExist;
	}
	else {
		return;
	}

	kd.off0 = 0.f;	//not really used in post-stack.
	kd.doff = 999999.f;	//not really used in post-stack
	kd.offmax = 0.f;	//not really used in post-stack.
	kd.dxm = kd.dxo;
	if (kd.dt < 0.0000001f)kd.dt = 0.008f;

	kd.sourceDepth = 0.f;  // for the water depth of source/receivers in meters
	kd.fs = (float)cd.coord.xmin;

	if (!CheckTime(200)) {
		return;
	}
	if (velMod.velSecName.IsEmpty()) {
		AfxMessageBox(_T("Please specify a velocity name in .bin format"), MB_ICONQUESTION);
		return;
	}
	OnToolbarSavev(); //save velocity file first, in case people ...

	if (draw.timeSecName.IsEmpty() || draw.depthSecName.IsEmpty()) {
		AfxMessageBox(_T("Please specify an input/output file name"), MB_ICONQUESTION);
		return;
	}

	//All parameters are entered in km, but this routine only uses m.
	fxo = (float)cd.coord.xmin*1000.f - kd.aperx*1000.f;
	nxo = (int)((cd.coord.xmax - cd.coord.xmin + 2.*kd.aperx) / kd.dxo + 0.9999);
	ns = (int)((cd.coord.xmax - cd.coord.xmin + 2.*kd.aperx) / kd.ds + 0.9999);
	nzo = (int)((cd.coord.m_zmax - cd.coord.m_zmin) / velColor.dz + 0.9999);
	if (kd.aperx < kd.dxo) kd.aperx = kd.dxo;

	exo = fxo + (nxo - 1)*kd.dxo*1000.f;
	fzo = (float)cd.coord.m_zmin*1000.f;
	ezo = (float)(fzo + (nzo - 1)*velColor.dz*1000.);

	//be careful to get raytracing wide enough to cover all output areas.
	fxv = fxo;
	nxv = (int)((exo - fxv) / kd.dxv / 1000.f + 2.f); //this should come last.
	fzv = 0.f; 	//Found that raytracing requires fzv<=0 
	dzv = 1000.f*kd.dzv;	//depth increment for vel model.
	nzv = (int)((ezo - fzv) / kd.dzv / 1000.f + 2.f);

	CFile file;
	if (!file.Open(draw.timeSecName, CFile::modeRead | CFile::typeBinary | CFile::shareDenyNone)) {
		return;
	}
	UINT bytesRead = file.Read(head.ascHead, 3200L);
	if (bytesRead < 3200)
		AfxMessageBox(_T("Ascii section header read wrong"), MB_ICONQUESTION);

	segy tr;
	short *i2buf;
	i2buf = (short *)&tr;
	float *trcdat;
	trcdat = (float *)&i2buf[120];

	bytesRead = file.Read(i2buf, 400L);
	if (bytesRead < 400)
		AfxMessageBox(_T("Binary section header read wrong"), MB_ICONQUESTION);
	file.Close();
	int numsamp = (unsigned short)i2buf[10];
	int len;
	if (i2buf[12] != 3)
		len = numsamp * 4 + 240;
	else
		len = numsamp * 2 + 240;
	int tpp = (unsigned short)i2buf[8];
	float dt = (float)(((double)tpp) / (double)MIL);

	rmax = exo;
	rmax = (float)MIN(rmax, kd.aperx*1000.f);
	nr = 2 + (int)(rmax / kd.dxo / 1000.f);
	// Finish initializing local parameters.

	//	kd.migLog = velMod.velSecName + _T(".MigData.Log";
	kd.migLog = GetFileNameAppendExt(velMod.velSecName, _T(".MigData.Log"), _T("txt"));
	jpfile = kd.migLog.GetBuffer(kd.migLog.GetLength());
	_tfopen_s(&jpfp, jpfile, _T("w"));
	kd.migLog.ReleaseBuffer();

	_ftprintf_s(jpfp, _T("\n"));
	_ftprintf_s(jpfp, _T(" Migration parameters\n"));
	_ftprintf_s(jpfp, _T(" ================\n"));
	_ftprintf_s(jpfp, _T(" nzo=%d fzo=%g dzo=%d\n"), nzo, fzo, (int)(velColor.dz*1000.f));
	_ftprintf_s(jpfp, _T(" nxo=%d fxo=%g dxo=%d\n"), nxo, fxo, (int)(kd.dxo*1000.f));
	_ftprintf_s(jpfp, _T(" \n"));
	_ftprintf_s(jpfp, _T(" aperx=%d \n"), (int)(kd.aperx*1000.f));
	_ftprintf_s(jpfp, _T(" ================\n"));
	fflush(jpfp);

	//Determine space allocation for holding migration output data.
	// Each output segy sample occupies 4 bytes,
	// plus 2 time tables since a raytracing table is calculated for each (X,Z) sample.
	// major 2D arrays:
	// v, vxx, vxz, vzz: nvx*nvz.
	// t, ov2, s, tt, tsum, mig: nxo*nzo.
	// tb, pb, cs0b, angb: nzo*nr.
	int nnv = 4 * 4 * nxv*nzv;
	int nno = 7 * 4 * nxo*nzo;
	int nnr = 4 * 4 * nr*nzo;
	_ftprintf_s(jpfp, _T(" Required memory is made up by 4*nvx*nvz floats: %d bytes,\n"), nnv);
	_ftprintf_s(jpfp, _T("   7*nxo*nzo floats: %d bytes, \n"), nno);
	_ftprintf_s(jpfp, _T("   and 4*nr*nzo floats: %d bytes, where nr=MIN(ext, aperx)/dxo = %d.\n"), nnr, nr);
	temp = (float)((double)(nnv + nno + nnr) / (double)MIL);
	_ftprintf_s(jpfp, _T("   Therefore, this operation requires a total memory of %d mb.\n"), (int)temp);
	if (kd.memMax < temp)
	{
		fclose(jpfp);
		CString tempStr;
		tempStr.Format(_T("Total memory required to migrate the section at once is %d mb, which is greater than specified %d mb. Divide into smaller sections?"), (int)temp, (int)kd.memMax);
		if (AfxMessageBox(tempStr, MB_YESNO | MB_ICONQUESTION) != IDYES)
		{
			showFileInNotePad(kd.migLog);
			return;
		}
	}

	//	int nxoR = (int)(kd.memMax*MIL/(float)(4.*nzo));
	/*
	"    	[7*nxo*nzo+4*nr*nzt+npa*7*nxo*nzo]*4 bytes				",
	"    where nr = 1+min(nxt*dxt,0.5*offmax+aperx)/dxo. 			",
	*/

	fxo = xmin = (float)cd.coord.xmin;
	xmax = (float)cd.coord.xmax;
	nxo = (int)((kd.memMax*MIL - nnv - nnr) / (7.*4.*nzo));
	int nzt = (int)((cd.coord.m_zmax - cd.coord.m_zmin) / kd.dzt + 0.9999);
	int nxt = (int)((cd.coord.xmax - cd.coord.xmin + 2.*kd.aperx) / kd.dxt + 0.9999);

	// handle the drive free space label
	//	char szBuffer[ 250 ];

	double dwFreeSpace = getFreeSpace(velMod.velSecName);

	//check free disk space for raytracing
	double bytesNeededRay = (double)((double)ns*(double)nzt*(double)nxt*sizeof(float) / (double)MIL);
	double bytesNeededOutput = (double)((double)nzo*(double)nxo*sizeof(float) / (double)MIL);
	double bytesTotal = bytesNeededRay + bytesNeededOutput + 50.;

	_ftprintf_s(jpfp, _T("\n For disk space\n  Space needed to hold raytracing results (mb)=%d \n"), (long)bytesNeededRay);
	_ftprintf_s(jpfp, _T("  Free space in the current working drive (mb):%d\n"), (long)dwFreeSpace);
	_ftprintf_s(jpfp, _T("  MBytes Needed for storing output file=%d \n"), (long)bytesNeededOutput);

	_ftprintf_s(jpfp, _T("     Space needed for raytracing is calculated from:\n"));
	_ftprintf_s(jpfp, _T("       ns:%d; nxt:%d; nzt:%d\n"), ns, nxt, nzt);

	if (bytesTotal > dwFreeSpace)
	{
		tempStr.Format(_T("Raytracing results will occupy %d mb temporary space. Please free %d mbytes more disk space for storing raytracing and migration results in the directory where the velocity model resides; otherwise, increase  dxs or dxo, or decrease memMax."), (int)bytesTotal, (int)(bytesTotal - dwFreeSpace));
		AfxMessageBox(tempStr);
		fclose(jpfp);
		showFileInNotePad(kd.migLog);
		return;
	}
	else
	{
		tempStr.Format(_T("Raytracing results will occupy %d mb temporary space. Continue?"), (int)bytesTotal);
		if (AfxMessageBox(tempStr, MB_YESNO | MB_ICONQUESTION) != IDYES)
		{
			fclose(jpfp);
			showFileInNotePad(kd.migLog);
			return;
		}
	}

	CFile file2;
	if (!file2.Open(draw.depthSecName, CFile::modeCreate | CFile::modeWrite | CFile::typeBinary)) {
		fclose(jpfp);
		return;
	}


	// BOOL CSeisWideDoc::KdmigGeneral(jpfp, file2, useExist, preStack, appendOutput)
	// (3) if useExist is true, skip raytracing. If preStack is true, a pre-stack case.
	// (4) if appendOutput=TRUE, output data will be appended to existing one: for  
	//	   migration of several sections, this is useful.
	while (fxo < xmax)
	{
		cd.coord.xmin = fxo;
		cd.coord.xmax = fxo + (nxo - 1)*kd.dxo;
		if (cd.coord.xmax > xmax) cd.coord.xmax = xmax;
		KdmigGeneral(jpfp, &file2, useExist, FALSE, appendOutput);
		useExist = FALSE;
		appendOutput = TRUE; // next time will append output segy file.
		fxo = (float)cd.coord.xmax;
	}

	cd.coord.xmin = xmin;
	cd.coord.xmax = xmax;
	file2.Close();
	fclose(jpfp);

	//Auto change mode to display both.
	cd.coord.drawmodeOld = cd.coord.drawmode;
	cd.coord.drawmode = 3;	//Both velocity color and depth sections will be drawn.

	draw.isSameDataDisplay = FALSE; //indicate display has been changed and will re-load all data in OnDraw().
	SetModifiedFlag();
	UpdateAllViews(NULL);
	NotifyChanged();

}


void CSeisWideDoc::OnSonobuoyLinearKm()
{
	if ((cd.coord.drawmode != 0 && cd.coord.drawmode != 6 && cd.coord.drawmode != 7)) {
		return;
	}
	if (dig.totCurve < 1 && digMarker.totCurve == 1) {
		digMarker.copyDig(&dig);
	}
	if (!dig.isDigitizing || (cd.coord.drawmode == 0 && cd.coord.isDistanceDisplay)) {
		AfxMessageBox(_T("Assigning offsets from direct water wave assuming constant water. To use it, first digitize 1 segment only for the water wave. Remember to correct for airgun delay first."), MB_ICONQUESTION);
		return;
	}
	int nDig = dig.nPoint[0];
	if (nDig < 2) {
		AfxMessageBox(_T(" Please select >1 points on the water wave to obtain distance"), MB_ICONQUESTION);
		return;
	}


	int i;

	BOOL isUnix = false;
	bhed bh;
	segy tr;
	float xOfTrace, range;

	static float buoyDepth = 0.06f; // this value is the one GSCA used, in km
	static float srcDepth = 0.011f;
	//	static float gunDelay = 0.00f; // these values are the ones GSCA used, in km, sec


	//	short i2buf[40000];
	//	trcdat = (float *) &i2buf[120];
	CdlgSonobouy dlg;
	dlg.m_vred = draw.red.waterVelocityAboveObs;
	dlg.m_buoydepth = buoyDepth;
	dlg.m_srcDepth = srcDepth;
	//	dlg.m_gunDelay = gunDelay;
	if (dlg.DoModal() == IDOK) {
		draw.red.waterVelocityAboveObs = dlg.m_vred;
		buoyDepth = dlg.m_buoydepth;
		srcDepth = dlg.m_srcDepth;
		//	gunDelay = dlg.m_gunDelay;
	}
	else return;

	CString tStr;
	CFile file;
	if (!file.Open(draw.timeSecName, CFile::modeReadWrite | CFile::typeBinary)) {
		return;
	}

	ULONGLONG bytesRead = file.Seek(3200L, CFile::begin);
	if (bytesRead < 3200L) {
		file.Close();
		AfxMessageBox(_T("Ascii section header read wrong"), MB_ICONQUESTION);
		return;
	}

	bytesRead = file.Read(&bh, 400L);
	if (isUnix = IsUnix(bh.format)) SwapTapeHeader(&bh);
	if (isUnix) {
		AfxMessageBox(_T("Please convert to PC format first."), MB_ICONQUESTION);
		file.Close();
		return;
	}
	if (bytesRead < 400 || !IsFormatValid(bh.format)) {
		AfxMessageBox(_T("Binary section header read wrong"), MB_ICONQUESTION);
		file.Close();
		return;
	}

	// get some parameters from the tape header
	int len = (bh.format == 3) ? (2 * bh.hns) : 4 * bh.hns;
	len += 240;
	int numsamp = bh.hns;

	//For progress control, need to know the last bytes no.
	ULONGLONG curBytesRead, totBytesRead = file.GetLength();
	file.Seek(3600, CFile::begin);

	//Begin progress control.
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	pFrame->BeginProgress();

	cd.coord.xmin = MIL;
	cd.coord.xmax = -MIL;

	while (file.Read(&tr, 240) == 240) {
		curBytesRead = file.Seek(0, CFile::current);
		int iPos = (int)((double)curBytesRead / (double)totBytesRead*100.);
		if (iPos < 0)iPos = 0;
		if (iPos > 100)iPos = 100;
		pFrame->SetProgress(iPos);

		//if (tr.trid == 2) //dead traces.
		//{
		//	file.Seek(len - 240, CFile::current);
		//	continue;
		//}

		xOfTrace = (cd.coord.drawmode == 6) ? (float)tr.tracl : tr.getOffset();

		//note: //range is time in sec first
		//		dig.x[][0] is actually digitized shot number
		//		dig.t[][0] is digitized time in sec.
		if (xOfTrace<dig.x[0][0])
			range = dig.t[0][0] + (dig.t[1][0] - dig.t[0][0]) / (dig.x[1][0] - dig.x[0][0])*(xOfTrace - dig.x[0][0]);
		else if (xOfTrace>dig.x[nDig - 1][0])
			range = dig.t[nDig - 2][0] +
			(dig.t[nDig - 1][0] - dig.t[nDig - 2][0]) /
			(dig.x[nDig - 1][0] - dig.x[nDig - 2][0])*
			(xOfTrace - dig.x[nDig - 2][0]);
		else {
			for (i = 0; i < nDig - 1; i++) {
				if (dig.x[i + 1][0] < dig.x[i][0]) {
					pFrame->EndProgress();
					file.Close();
					AfxMessageBox(_T("Error: digitized points must run from left to right monotonically with trace number"), MB_ICONQUESTION);
					return;
				}
				if (xOfTrace >= dig.x[i][0] && xOfTrace <= dig.x[i + 1][0]) {
					if (dig.x[i][0] != dig.x[i + 1][0])
						range = dig.t[i][0] + (dig.t[i + 1][0] - dig.t[i][0])
						/ (dig.x[i + 1][0] - dig.x[i][0])*(xOfTrace - dig.x[i][0]);
					else
						range = dig.t[i][0];
					break;
				}
			}
		}

		//convert time to range in km.
		range *= draw.red.waterVelocityAboveObs;

		double a = range*range - (buoyDepth - srcDepth)*(buoyDepth - srcDepth);
		if (a > 0.) {
			range = (float)sqrt(a);
		}
		else {
			range = 0.0f;  // this can not happen here
		}

		if (cd.coord.xmin > range) cd.coord.xmin = range;
		if (cd.coord.xmax < range) cd.coord.xmax = range;

		tr.setOffset(range);
		//setTraceDelayF(&tr, getTraceDelay(&tr) - gunDelay);

		file.Seek(-240, CFile::current);
		file.Write(&tr, 240);
		file.Seek(len - 240, CFile::current);
	}
	file.Close();
	pFrame->EndProgress();

	//dig.isDigitizing = FALSE;
	//dig.digName = BLANK; // this remove the digitize info for the .SEI  project file only.

	//cd.coord.xmin = (float)((int)(cd.coord.xmin*0.1)*10.);
	//cd.coord.xmax = (float)((int)(cd.coord.xmax*0.1+0.99)*10.);
	//cd.coord.drawmodeOld = cd.coord.drawmode;
	//cd.coord.drawmode = 0;

	tStr.Format(_T("Offset information is assigned successfully. Last trace is assigned offset %f km"), range);
	// myCaption(_T("Offset information is assigned successfully. If you do raytracing, you need to assign source position and distance information (use Processing | Design Source/Receiver Distance)."));
	AfxMessageBox(tStr, MB_ICONQUESTION);


	//draw.isSameDataDisplay = FALSE; //indicate display has been changed and will re-load all data in OnDraw().
	SetModifiedFlag();
	UpdateAllViews(NULL);
	NotifyChanged();
}

void CSeisWideDoc::extraSerialize()
{
	velColor.vminR = 0;
	velColor.vminG = 0;
	velColor.vminB = 255;
	velColor.vmidR = 0;
	velColor.vmidG = 200;
	velColor.vmidB = 20;
	velColor.vmaxR = 255;
	velColor.vmaxG = 0;
	velColor.vmaxB = 51;

	velColor.cxExt = 8.;
	velColor.cxPos = 2.;
	velColor.cyExt = .5;
	velColor.cyPos = 2.;
	velColor.vmid2 = 5.;
	velColor.vmid3 = 6.5;
	velColor.vmid4 = 7.7;
	velColor.vmidB2 = 0;
	velColor.vmidB3 = 100;
	velColor.vmidB4 = 50;
	velColor.vmidG2 = 255;
	velColor.vmidG3 = 200;
	velColor.vmidG4 = 50;
	velColor.vmidR2 = 255;
	velColor.vmidR3 = 200;
	velColor.vmidR4 = 200;
	velColor.dv1 = .1;

}


void CSeisWideDoc::OnToolbarRefresh2()
{
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	CSeisWideApp* pSeiApp = (CSeisWideApp*)AfxGetApp();
	draw.isNodeChanged = TRUE;
	if (pSeiApp->statWin.getShiftPressed()) this->getRaycodeColor(0, TRUE);  // this will clear the already calculated color array
	//	draw.isSameDataDisplay = FALSE;
	//	if(velMod.ncont >= 2) OnToolbarSavev() ;
	//	velMod.velSecOld = BLANK;	//this line is added to re-initialize vel model, in case the model is changed by other docs.
	if (cd.coord.drawmode == 2 || cd.coord.drawmode == 4) {
		// in velocity colormap or contour mode, the screen does not refresh the model, so we need to force it.
		// but in moode=3, it is handled separately.
		//draw.isSameDataDisplay = FALSE;
	}

	// must delete some transient files before closing 
	//CString aName = getFileNameSubdir(draw.timeSecName, _T("rms"), _T("RmsHyperbolas.txt"), FALSE);
	//if (!aName.IsEmpty()) {
	//	if (dig.digName == aName && isFileExistNotDirectory(aName)) {
	//		CDigitize pDg;
	//		dig.freeDigAll();
	//		if (!DeleteFile(aName)) {
	//			pFrame->myCaption(_T("Failed to clean up a temporary file"));
	//		}
	//	}
	//}

	draw.tmpDxdyDrawn = 0.0f; // this value should now be set to zero

	// try to refresh the previous window
	// this->myUpdatePrevFrame();

	UpdateAllViews(NULL);
	NotifyChanged();
}

void CSeisWideDoc::OnToolbarRefreshAll()
{
	draw.isNodeChanged = TRUE;
	draw.isSameDataDisplay = FALSE;

	CSeisWideApp* pSeiApp = (CSeisWideApp*)AfxGetApp();
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	if (pSeiApp->statWin.getShiftPressed()) this->getRaycodeColor(0, TRUE);  // this will clear the already calculated color array
	// try to refresh the previous window
	this->myUpdatePrevFrame();

	// we must save the model changes before Refresh All, otherwise, it may load the model again from disk and we lose any editing changes
	//if (isModelDisplayed())
	//	myModelSaveAs(velMod.velSecName);
	draw.tmpDxdyDrawn = 0.0f; // this value should now be set to zero

	UpdateAllViews(NULL);
	NotifyChanged();

	// TESTING follows:
	//this->SetTitle(this->GetPathName() + _T(" - ") + draw.timeSecName);
}

void CSeisWideDoc::OnProcessingLatlongtodistance()
{
	static float aDist = ERRORVAL;
	static CString aLatlong;
	static BOOL isLonglat = TRUE;
	//static BOOL isOutputlatlong = true;
	static BOOL isDistanceInline = TRUE;

	CdlgLatLong dlg;
	dlg.m_latLongMulti = aLatlong;
	dlg.m_isLonglat = isLonglat;
	dlg.m_isDistanceInline = isDistanceInline;

	if (dlg.DoModal() == IDOK) {
		aLatlong = dlg.m_latLongMulti;
		isLonglat = dlg.m_isLonglat;
		isDistanceInline = dlg.m_isDistanceInline;
	}
	else {
		return;
	}


	//******************
	//******************
	int pos = 0;
	int count = 0;
	int i = 0;
	CString comments;


	aLatlong.Replace(TAB, SPACE);
	aLatlong.TrimLeft();
	aLatlong.TrimRight();
	CString a, tStr;
	double f;
	double flon1;
	double flat1;
	double flon2;
	double flat2;
	double distTotal = 0.;
	CStringArray latLongArray; // to parse input strig
	CStringArray outArray;  // to hold all outputs
	CStringArray lineArr;  // to parse each line in input string

	if (isFileExistNotDirectory(aLatlong))
		getLinesFromFile(&latLongArray, aLatlong, false, 0);
	else
		SplitStringArr(aLatlong, _T("\n"), &latLongArray, false);


	if (latLongArray.GetSize() > 0) {
		a = latLongArray.ElementAt(0);
		SplitStringArr(a, SPACE, &lineArr, false);
		bool is4NumberPerLine = lineArr.GetSize() > 3;

		for (i = 0; i < latLongArray.GetSize(); i++) {
			a = latLongArray.ElementAt(i);
			a.Trim();
			if (a.GetLength() < 2) continue;
			SplitStringArr(a, SPACE, &lineArr, false);
			if (lineArr.GetSize() < 3) continue;

			// if here, the data is valid
			tStr = lineArr.ElementAt(0);
			flat1 = StringToFloat(tStr);
			tStr = lineArr.ElementAt(1);
			flon1 = StringToFloat(tStr);
			if (is4NumberPerLine) {
				flat2 = StringToFloat(lineArr.ElementAt(2));
				flon2 = StringToFloat(lineArr.ElementAt(3));
				if (isLonglat) {
					// swap
					f = flon1;
					flon1 = flat1;
					flat1 = f;

					f = flon2;
					flon2 = flat2;
					flat2 = f;
				}
				aDist = (float)calcDist(flon2, flat2, flon1, flat1);
				tStr.Format(_T("%8.5f"), (float)aDist);
				outArray.Add(tStr);
			}
			else {
				pos = a.FindOneOf(_T(" \t"));
				tStr = a.Mid(pos + 1);  // include any third or fourth collumns
				tStr.Trim();	// t may still contain extra spaces
				pos = tStr.FindOneOf(_T(" \t"));
				if (pos < 0) {
					comments = BLANK;
				}
				else {
					// we will ignore any strings in the third or fourth collumns
					comments = tStr.Mid(pos);
				}

				if (isLonglat) {
					// swap
					f = flon1;
					flon1 = flat1;
					flat1 = f;
				}

				if (i == 0) {
					flon2 = flon1;
					flat2 = flat1;
				}

				aDist = (float)calcDist(flon2, flat2, flon1, flat1);
				distTotal = (isDistanceInline) ? distTotal + aDist : aDist;
				tStr.Format(_T("%8.5f  %s"), (float)distTotal, comments);
				outArray.Add(tStr);

				if (isDistanceInline) {
					flon2 = flon1;
					flat2 = flat1;
				}
			}
		} // for i

		isLonglat = FALSE;

		if (isFileExistNotDirectory(aLatlong)) {
			showStringArrayToFile(&outArray);
		}
		else {
			aLatlong = BLANK;
			for (i = 0; i < outArray.GetSize(); i++) {
				aLatlong += outArray.ElementAt(i) + CARRAGE;
			}
		}

	} // if

	latLongArray.RemoveAll();
	lineArr.RemoveAll();
	outArray.RemoveAll();
	OnProcessingLatlongtodistance();
}

BOOL CSeisWideDoc::checkModelError(CString name)
{
	//Autoly check if any errors exist in the velocity model.

	//name: input velocity file name in .bin format
	//parameters used: papa.xmin, cd.coord.xmax, velColor.dxV.
	// if(!MyInitVel(name)) return FALSE;

	if (!isFileExistNotDirectory(name)) {
		AfxMessageBox(_T("No model to check!"), MB_ICONQUESTION);
		return FALSE;
	}


	CString tStr = CVelMod::checkModelError(&velMod);
	//End of checking vel errors.
	if (!tStr.IsEmpty()) {
		CString newName = name + _T(".tempErrInfo.txt");
		showStringInFile(tStr, newName);
		return FALSE;
	}
	return TRUE;
}


void CSeisWideDoc::OnProcessingRawtosegy()
{
	// simulate raw DOBS data to output segy. Left-over code from old work. Now it is disabled, until you want it.

	short i2buf[400], chan = 2, n, nf = 0;
	long i, j, tsiz, nSize, sampIndex = 0;
	BOOL firstTrc = TRUE, fileEnd = FALSE;
	CString inFile = BLANK, outFile = BLANK, inFiles[999], newName, newName0, t;
	char ascHead[415];
	datafile binHead;
	// segy tro,tro2,tro3,tro4;
	segydynamic trDyn, trDyn2, trDyn3, trDyn4;
	trDyn.data = NULL;
	trDyn2.data = NULL;
	trDyn3.data = NULL;
	trDyn4.data = NULL;
	double deltaT;


	int nYear, nMonth, nDay, nHour, nMin, nSec;
	WORD trcIndex = 0;
	short nbyts[4];  //used for 3-4 byte conversion.
	// short fbyts[4];
	unsigned short m1 = 4095, m2 = 255;        /* bit masks for use in bit manipulation */
	unsigned short m3 = 15, m5 = 61440, m6 = 2048;
	/* m1=0000 1111 1111 1111
	m2=0000 0000 1111 1111
	m3=0000 0000 0000 1111
	m5=1111 0000 0000 0000
	m6=0000 1000 0000 0000
	*/


	//open a temporary text file for notepad.
	TCHAR lpszSystemInfo[MAX_PATH];   // buffer for concat'd. str.
	nSize = GetTempPath(MAX_PATH, lpszSystemInfo);
	FILE *stream;
	newName = CString(lpszSystemInfo) + _T(".tempAsciiHeader.txt");
	if (_tfopen_s(&stream, newName, _T("w")) != 0)
	{
		AfxMessageBox(_T("Can not open a temporaty file to hold the ascii header"), MB_ICONQUESTION);
		return;
	}

	//Open file dialog.
	CFileDialog dlg(TRUE, BLANK, _T("*.*"),
		OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT | OFN_ALLOWMULTISELECT | OFN_EXPLORER,
		_T("Input Data Files (*.*)|*.*|"));
	TCHAR* buff = (TCHAR*)alloc1(65535, sizeof(TCHAR));
	buff[0] = '\0';
	dlg.m_ofn.lpstrTitle = _T("Select as many DOBS raw data files as you want to convert");
	dlg.m_ofn.lpstrFile = buff;
	dlg.m_ofn.nMaxFile = 65535;//sizeof(buff);


	POSITION Position;
	CTime timeRec0, timeRec;

	if (dlg.DoModal() == IDOK) {

		Position = dlg.GetStartPosition();
		while (Position) {
			inFile = dlg.GetNextPathName(Position);
			if (!inFile.IsEmpty()) {
				inFiles[nf] = inFile;
				nf++;
			}
		}
	} //end dlg.DoModal function.
	else {
		fclose(stream);
		free1(buff);
		return;
	}
	free1(buff);

	//now reorganize these files sequentially.
	if (nf > 999) {
		fclose(stream);
		AfxMessageBox(_T("How come there are >999 files selected???"), MB_ICONQUESTION);
		return;
	}
	short indexF[999];
	for (n = 0; n < nf; n++) {
		TCHAR s[3];
		t = inFiles[n].Right(3);
		for (i = 0; i < 3; i++) s[i] = t.GetAt(i);
		indexF[n] = _tstoi(&s[0]);
	}
	for (n = 0; n < nf - 1; n++) {
		for (i = n + 1; i<nf; i++) {
			if (indexF[n]>indexF[i]) {
				t = inFiles[i];				j = indexF[i];
				inFiles[i] = inFiles[n];	indexF[i] = indexF[n];
				inFiles[n] = t;				indexF[n] = (short)j;
			}
		}
	}


	//new file dialog.
	CFileDialog dlgOut(FALSE, BLANK, _T("*.sgy"),
		OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT | OFN_EXPLORER,
		_T("Output Data Files (*.sgy)|*.sgy|"));
	dlgOut.m_ofn.lpstrTitle = _T("Select the output segy file");
	if (dlgOut.DoModal() == IDOK)
		newName0 = dlgOut.GetPathName();
	else {
		fclose(stream);
		return;
	}

	CFile fileOut1(getFileNameAppend(newName0, _T("ch1")), CFile::modeCreate | CFile::modeWrite | CFile::typeBinary);
	CFile fileOut2(getFileNameAppend(newName0, _T("ch2")), CFile::modeCreate | CFile::modeWrite | CFile::typeBinary);
	CFile fileOut3(getFileNameAppend(newName0, _T("ch3")), CFile::modeCreate | CFile::modeWrite | CFile::typeBinary);
	CFile fileOut4(getFileNameAppend(newName0, _T("ch4")), CFile::modeCreate | CFile::modeWrite | CFile::typeBinary);

	for (n = 0; n < nf; n++) {
		CFile file;
		if (!file.Open(inFiles[n], CFile::modeRead | CFile::typeBinary | CFile::shareDenyNone)) {
			continue;
		}

		tsiz = sizeof(binHead);
		UINT bytesRead = file.Read(&binHead, 97);
		if (bytesRead < 97) {
			fclose(stream);
			fileOut1.Close();
			fileOut2.Close();
			fileOut3.Close();
			fileOut4.Close();
			AfxMessageBox(_T("File ") + inFile + _T(" binary section header read wrong"), MB_ICONQUESTION);
			return;
		}
		//	binHead.freq *= (float)(4./3.);  //actual sampling rate is greater by 4/3.
		bytesRead = file.Read(ascHead, 415);
		if (bytesRead < 415) {
			fclose(stream);
			fileOut1.Close();
			fileOut2.Close();
			fileOut3.Close();
			fileOut4.Close();
			AfxMessageBox(_T("File ") + inFile + _T(" ascii section header read wrong"), MB_ICONQUESTION);
			return;
		}
		_ftprintf_s(stream, _T("\n\nDump of the ascii header for file %s"), (LPCTSTR)inFiles[n]);
		_ftprintf_s(stream, _T("\n This data file will write traces starting from #%d \n"), trcIndex + 1);
		for (i = 0; i < 415; i++)
			_ftprintf_s(stream, _T("%c"), ascHead[i]);

		//need to decode the begining time of this datafile.xxx .
		//date info starts at ascHead[96-].


		nDay = atoi(&ascHead[96]);
		t.Format(_T("%.3s"), &ascHead[99]);
		nYear = atoi(&ascHead[103]) + 1900;
		nHour = atoi(&ascHead[106]);
		nMin = atoi(&ascHead[109]);
		nSec = atoi(&ascHead[112]);
		if (t == _T("Jan")) nMonth = 1;
		else if (t == _T("Feb")) nMonth = 2;
		else if (t == _T("Mar")) nMonth = 3;
		else if (t == _T("Apr")) nMonth = 4;
		else if (t == _T("May")) nMonth = 5;
		else if (t == _T("Jun")) nMonth = 6;
		else if (t == _T("Jul")) nMonth = 7;
		else if (t == _T("Aug")) nMonth = 8;
		else if (t == _T("Sep")) nMonth = 9;
		else if (t == _T("Oct")) nMonth = 10;
		else if (t == _T("Nov")) nMonth = 11;
		else if (t == _T("Dec")) nMonth = 12;
		else {
			AfxMessageBox(_T("Month not recognizable"), MB_ICONQUESTION);
			fclose(stream);
			fileOut1.Close();
			fileOut2.Close();
			fileOut3.Close();
			fileOut4.Close();
			return;
		}
		CTime timeRec(nYear, nMonth, nDay, nHour, nMin, nSec, 0);
		//this is the start recording time for this current file.

		if (firstTrc) {
			fileOut1.Write(ascHead, 415);
			fileOut2.Write(ascHead, 415);
			fileOut3.Write(ascHead, 415);
			fileOut4.Write(ascHead, 415);

			fileOut1.Seek(3200L, CFile::begin);
			fileOut2.Seek(3200L, CFile::begin);
			fileOut3.Seek(3200L, CFile::begin);
			fileOut4.Seek(3200L, CFile::begin);
			//assign section headers.
			memset((void *)&i2buf, (int) '\0', sizeof(i2buf));
			memset((void *)&trDyn, (int) '\0', sizeof(segydynamic));

			i2buf[10] = (unsigned short)(60.*binHead.freq + 1); // numsamp;
			i2buf[11] = i2buf[10];
			i2buf[12] = 1;
			i2buf[8] = (unsigned short)(MIL / binHead.freq);	//Sampling rate;
			i2buf[9] = i2buf[8];
			fileOut1.Write(i2buf, 400L);
			fileOut2.Write(i2buf, 400L);
			fileOut3.Write(i2buf, 400L);
			fileOut4.Write(i2buf, 400L);

			trDyn.dt = i2buf[8];
			trDyn.ns = i2buf[10];
			trDyn.cmp.df[0] = (float)(MIL / binHead.freq);
			trDyn.delrt = 0;
			trDyn.delrtEx = 0;  // delay recording time.
			trDyn.trid = 1;
			trDyn.data = (float *)ealloc1float(trDyn.ns);
			trDyn2.data = (float *)ealloc1float(trDyn.ns);
			trDyn3.data = (float *)ealloc1float(trDyn.ns);
			trDyn4.data = (float *)ealloc1float(trDyn.ns);

			timeRec0 = timeRec;
		}

		/* what's the time difference in sec at sampIndex (the last dat file)*/
		if (firstTrc) { deltaT = 0.f; firstTrc = FALSE; }
		else
		{
			CTimeSpan timeSpan1 = timeRec - timeRec0;
			deltaT = (float)timeSpan1.GetTotalSeconds();
			deltaT -= (trcIndex*trDyn.ns + sampIndex - 1) / binHead.freq;
			if (deltaT < 0) {
				//	AfxMessageBox(_T("Problems ");
				if (deltaT > 0) _ftprintf_s(stream, _T("\n Problem of recording time with datafile.%3d"), n);
				continue;
			}
		}
		//now fill up the rest of tro.dat.data buffer.
		if (deltaT > 0) _ftprintf_s(stream, _T("\n Data gap is %f long"), deltaT);
		_ftprintf_s(stream, _T("\n Sampling frequency is %f Hz"), binHead.freq);
		while (deltaT > 0)
		{
			if (deltaT*binHead.freq <= trDyn.ns - sampIndex)
			{ //the gap is now smaller and should fill in this trace only.
				while (deltaT > 0)
				{
					trDyn.data[sampIndex] = 0.f;
					sampIndex++;
					deltaT -= 1.f / binHead.freq;
				}
				break;
			}
			else
			{ //the gap is long enough to cover the whole trace.
				while (sampIndex < trDyn.ns)
				{
					trDyn.data[sampIndex] = 0.f;
					sampIndex++;
					deltaT -= 1.f / binHead.freq;
				}
				//mark dead trace.
				trDyn.trid = 2;
				trDyn.tracr = trDyn.tracl = trcIndex;
				trDyn.offset = trcIndex * 150 - 150000;

				// output as IBM float by default
				float_to_ibm((int *)&trDyn.data[0], (int *)&trDyn.data[0], (int)trDyn.ns);

				fileOut1.Write(&trDyn, trDyn.ns * 4 + 240);
				fileOut2.Write(&trDyn, trDyn.ns * 4 + 240);
				fileOut3.Write(&trDyn, trDyn.ns * 4 + 240);
				fileOut4.Write(&trDyn, trDyn.ns * 4 + 240);
				fileOut1.Flush();
				fileOut2.Flush();
				fileOut3.Flush();
				fileOut4.Flush();
				sampIndex = 0;
				trDyn.trid = 1;
				trcIndex++;
			}
		}


		//now construct segy traces: I want 300 km, 150 m apart, 60 sec length for 
		//each trace, total 2000 traces, simulate an airgun experiment.
		while (file.Read(nbyts, 8) == 8)
		{
			trDyn.data[sampIndex] = (float)(nbyts[0] - 2048);
			trDyn2.data[sampIndex] = (float)(nbyts[1] - 2048);
			trDyn3.data[sampIndex] = (float)(nbyts[2] - 2048);
			trDyn4.data[sampIndex] = (float)(nbyts[3] - 2048);
			sampIndex++;

			if (sampIndex == trDyn.ns)
			{  //here means a trace is finished, advance to next trace.
			   //the last few bits as just read in need to wrap.

			   //but what's the time for the next trace? exactly 60 sec after.
				trDyn.tracr = trDyn.tracl = trcIndex;
				trDyn.offset = trcIndex * 150 - 150000;

				// output as IBM float by default
				float_to_ibm((int *)&trDyn.data[0], (int *)&trDyn.data[0], (int)trDyn.ns);
				float_to_ibm((int *)&trDyn2.data[0], (int *)&trDyn2.data[0], (int)trDyn.ns);
				float_to_ibm((int *)&trDyn3.data[0], (int *)&trDyn3.data[0], (int)trDyn.ns);
				float_to_ibm((int *)&trDyn4.data[0], (int *)&trDyn4.data[0], (int)trDyn.ns);

				fileOut1.Write(&trDyn, 240); fileOut1.Write(&trDyn.data, trDyn.ns * 4);
				fileOut2.Write(&trDyn, 240); fileOut2.Write(&trDyn2.data, trDyn.ns * 4);
				fileOut3.Write(&trDyn, 240); fileOut3.Write(&trDyn3.data, trDyn.ns * 4);
				fileOut4.Write(&trDyn, 240); fileOut4.Write(&trDyn4.data, trDyn.ns * 4);
				fileOut1.Flush();
				fileOut2.Flush();
				fileOut3.Flush();
				fileOut4.Flush();
				sampIndex = 0;
				trcIndex++;
			}
		}  //end while loop for fileEnd.
	} //end the while file loop.

	fclose(stream);
	//fileOut1.Seek(3212L, CFile::begin);
	//fileOut2.Seek(3212L, CFile::begin);
	//fileOut3.Seek(3212L, CFile::begin);
	//fileOut4.Seek(3212L, CFile::begin);
	//fileOut1.Write(&trcIndex, 2);
	//fileOut2.Write(&trcIndex, 2);
	//fileOut3.Write(&trcIndex, 2);
	//fileOut4.Write(&trcIndex, 2);
	CSegyMeta::setSegyTotalTrace(&fileOut1, trcIndex);
	CSegyMeta::setSegyTotalTrace(&fileOut2, trcIndex);
	CSegyMeta::setSegyTotalTrace(&fileOut3, trcIndex);
	CSegyMeta::setSegyTotalTrace(&fileOut4, trcIndex);

	fileOut1.Close();
	fileOut2.Close();
	fileOut3.Close();
	fileOut4.Close();
	if (trDyn.data != NULL) free1float(trDyn.data);
	if (trDyn2.data != NULL) free1float(trDyn2.data);
	if (trDyn3.data != NULL) free1float(trDyn3.data);
	if (trDyn4.data != NULL) free1float(trDyn4.data);

	showFileInNotePad(newName);


}

void CSeisWideDoc::OnViewTraceanalysis()
{

	CString theString(_T("SeisGraf.exe "));
	if (!myProcessSimple(theString))
		AfxMessageBox(_T("Not able to load SeisGraf.exe"), MB_ICONQUESTION);

}


//
//void CSeisWideDoc::OnProcessingDumpdistance()
//{
//	AfxMessageBox(_T("Not tested: this routine will dump ascii numbers from the current segy file on screen. You put all your desired FFIDs (or shot points) in a text file and let the program compute the corresdponding CDPs for you. Assume CDPs increase monotonically with trace numbers, and input FFIDs ordered the same way as the segy file. Useful for gravity and magnetic modeling."));
//	
//	if (!isTimeDomain()) {
//		AfxMessageBox(_T("Please display the time section first"));
//		return;
//	}
//
//	CString name;
//	segy tr;
//	bhed hd;
//	FILE *ifh1, *stream;  /* file handles */
//	TCHAR line[MAXLINE];
//	long len, FFID, ffidOld;
//	ULONGLONG len1;  // to hold seek position
//	float out, distOld;
//
//	//new file dialog.
//	CFileDialog dlg(TRUE, _T(""), _T("*.*"),
//		OFN_HIDEREADONLY | OFN_EXPLORER,
//		_T("Ascii Input FFID File (*.*)|*.*|"));
//	dlg.m_ofn.lpstrTitle = _T("Each shot number in one line please");
//	if (dlg.DoModal() == IDOK)
//		name = dlg.GetPathName();
//	else
//		return;
//
//	//now start this routine.
//
//	CFile file;
//	if (!file.Open(draw.timeSecName, CFile::modeRead | CFile::typeBinary)) {
//		return;
//	}
//	file.Seek(3200L, CFile::begin);
//	file.Read(&hd, 400L);
//	if (hd.format != 3)
//		len = hd.hns * 4 + 240;
//	else
//		len = hd.hns * 2 + 240;
//
//	if (_tfopen_s(&ifh1, name, _T("r")) != 0) {
//		AfxMessageBox(_T("Error opening input table"));
//		return;
//	}
//
//	if (_tfopen_s(&stream, name + _T(".output.txt"), _T("w")) != 0) {
//		AfxMessageBox(_T("New file cannot be opened"));
//		return;
//	}
//	_ftprintf_s(stream, _T(" Ascii Dump of segy info\n FFIDs and Distance in km\n"));
//
//	long i = 0;
//	file.Read(&tr, 240);
//	ffidOld = tr.fldr;
//	distOld = getDistance(&tr);
//	file.Seek(-240, CFile::current);
//	while (_fgetts(line, MAXLINE, ifh1) != NULL) {
//		if (_tcslen(line) < 2) continue;
//		if (line[0] == '#') continue; // we do not need comment lines
//		_stscanf_s(line, _T("%d"), &FFID);
//
//		//now look in segy file for proper trace that has this FFID or tr.fldr  .
//		while (file.Read(&tr, 240) != NULL) {
//			len1 = file.Seek(len - 240, CFile::current);
//			if (tr.trid == 2) continue; //dead traces.
//			if (tr.fldr >= 9980) i = 9980;
//			if (i == 9980)
//			{
//				long ii = i;
//			}
//			if (tr.fldr < FFID)
//			{
//				ffidOld = tr.fldr;
//				distOld = getDistance(&tr);
//				continue;
//			}
//			else if (tr.fldr > FFID)
//			{
//				//I should interpolate betrwwn FFIDs.
//				if (FFID < ffidOld)
//				{
//					// here the FFIDs gets smaller than previous, odd, fix!
//					while (file.Read(&tr, 240) != NULL)
//					{
//						file.Seek(len - 240, CFile::current);
//						if (tr.fldr == FFID) break;
//					}
//					if (tr.fldr != FFID)
//					{ //if no suitable FFID found, go back.
//						file.Seek(len1 - len, CFile::begin);
//						file.Read(&tr, 240);
//						file.Seek(len - 240, CFile::current);
//						out = ERRORVAL;
//					}
//					else if (tr.fldr == ffidOld) out = (float)distOld;
//					else {
//						out = (float)(distOld + (getDistance(&tr) - distOld)*(FFID - ffidOld) / (double)(tr.fldr - ffidOld));
//					}
//				}
//				else
//					if (tr.fldr == ffidOld) out = (float)distOld;
//					else {
//						out = (float)(distOld + (getDistance(&tr) - distOld)*(FFID - ffidOld) / (double)(tr.fldr - ffidOld));
//					}
//			}
//			else
//				out = getDistance(&tr);
//
//			_ftprintf_s(stream, _T(" %d %f\n"), FFID, out*0.001f);
//			ffidOld = tr.fldr;
//			distOld = getDistance(&tr);
//			break;
//		}
//	}
//
//	file.Close();
//	fclose(ifh1);
//	fclose(stream);
//
//	AfxMessageBox(_T("Ascii dumping has been completed. Check the output file carefully for possible errors. Fix any numbers like -9999."));
//
//	showFileInNotePad(name + _T(".output.txt"));
//}



// This routine is later found to have problems. So we cannot use it. Apr. 20, 2020
void CSeisWideDoc::OnModelingDenblocks_Test()
{
	//OnModelingDenblocksFortran();
	//return;
	static float gravDC_shift_global = 0.f;
	static float depthModelMax_global = 41.f;

	long icont, j;
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();

	//	if (velColor.dz<0.004) velColor.dz = 0.004;  //make sure it doesn't overflow.
	//	long nzmax = (long)myRound(cd.coord.zmax / velColor.dz);  //note: y is time in sec. nzmax is max num of pnts in depth.
	// double weightAtX, weightAtXAbs, depthCorr;
	// double velRef[9], denRef[9];
	double x1, x2, z1, z2, z3, z4, v1, v2, x, rho;

	if (!cd.coord.isModelingMode()) {
		AfxMessageBox(_T("Please show a velocity model before converting to density outputs"), MB_ICONQUESTION);
		return;
	}


	int pathLen = velMod.velSecName.ReverseFind('\\');
	if (pathLen > (-1)) SetCurrentDirectory(velMod.velSecName.Left(pathLen));

	BOOL isSaveBlocks = FALSE;
	CString tStr;
	tStr = getWorkingPathSlash() + _T("vel2den.txt");
	CFileStatus status;
	BOOL initFileStatus = CFile::GetStatus(tStr, status); // static function

	if (velMod.isDenPrompt) {
		CdlgVel2Den1 dlg;
		if (initFileStatus) {
			FILE *fp;
			if (_tfopen_s(&fp, tStr, _T("r")) != 0) return;
			_ftscanf_s(fp, _T("%f %f"), &dlg.m_v1, &dlg.m_d1);
			_ftscanf_s(fp, _T("%f %f"), &dlg.m_v2, &dlg.m_d2);
			_ftscanf_s(fp, _T("%f %f"), &dlg.m_v3, &dlg.m_d3);
			_ftscanf_s(fp, _T("%f %f"), &dlg.m_v4, &dlg.m_d4);
			_ftscanf_s(fp, _T("%f %f"), &dlg.m_v5, &dlg.m_d5);
			_ftscanf_s(fp, _T("%f %f"), &dlg.m_v6, &dlg.m_d6);
			_ftscanf_s(fp, _T("%f %f"), &dlg.m_v7, &dlg.m_d7);
			_ftscanf_s(fp, _T("%f %f"), &dlg.m_v8, &dlg.m_d8);
			_ftscanf_s(fp, _T("%f %f"), &dlg.m_v9, &dlg.m_d9);
			fclose(fp);  //must close before return.
		}


		dlg.m_denMax = (float)velMod.denMax;
		dlg.m_gravDC = gravDC_shift_global;
		dlg.m_depthMax = depthModelMax_global;
		if (dlg.DoModal() == IDOK) {
			velMod.velRef[0] = dlg.m_v1;  velMod.denRef[0] = dlg.m_d1;
			velMod.velRef[1] = dlg.m_v2;  velMod.denRef[1] = dlg.m_d2;
			velMod.velRef[2] = dlg.m_v3;  velMod.denRef[2] = dlg.m_d3;
			velMod.velRef[3] = dlg.m_v4;  velMod.denRef[3] = dlg.m_d4;
			velMod.velRef[4] = dlg.m_v5;  velMod.denRef[4] = dlg.m_d5;
			velMod.velRef[5] = dlg.m_v6;  velMod.denRef[5] = dlg.m_d6;
			velMod.velRef[6] = dlg.m_v7;  velMod.denRef[6] = dlg.m_d7;
			velMod.velRef[7] = dlg.m_v8;  velMod.denRef[7] = dlg.m_d8;
			velMod.velRef[8] = dlg.m_v9;  velMod.denRef[8] = dlg.m_d9;
			isSaveBlocks = dlg.m_isSaveBlocks;
			velMod.denMax = dlg.m_denMax;
			gravDC_shift_global = dlg.m_gravDC;
			depthModelMax_global = dlg.m_depthMax;
		}
		else {
			return;
		}

		FILE *fp;
		if (_tfopen_s(&fp, tStr, _T("w")) == 0) {
			// it will be ok if it cannot write anything here
			for (j = 0; j < 9; j++) _ftprintf_s(fp, _T("%8.3f %8.3f\n"),
				velMod.velRef[j], velMod.denRef[j]);
		}
		fclose(fp);
	} // if

	if (depthModelMax_global != 0.f) {
		// check and fix if the last boundary is deeper than depthModelMax_global
		icont = velMod.ncont - 1;
		for (j = 0; j < velMod.nzed[icont] - 1; j++) {
			if (velMod.zm[j][icont] > depthModelMax_global) {
				AfxMessageBox(_T("One or more points are below maximum depth for gravity modeling. Please fix and then redo."), MB_ICONQUESTION);
				return;
			}
		}

		if (velMod.zm[0][icont] < depthModelMax_global) {
			// add another layer at the base to match depthModelMax_global
			velMod.xm[0][icont + 1] = (float)velMod.getXmin();
			velMod.xm[1][icont + 1] = (float)velMod.getXmax();
			velMod.zm[0][icont + 1] = depthModelMax_global;
			velMod.zm[1][icont + 1] = depthModelMax_global;
			velMod.tm[0][icont + 1] = ERRORVAL;
			velMod.tm[1][icont + 1] = ERRORVAL;
			velMod.nzed[icont + 1] = 2;

			// note: the last horizon is not associated with any velocity
			velMod.xvel[0][icont][0] = (float)velMod.getXmin();
			velMod.xvel[1][icont][0] = (float)velMod.getXmax();
			velMod.vf[0][icont][0] = 8.1f;
			velMod.vf[1][icont][0] = 8.1f;
			velMod.nvel[icont][0] = 2;

			velMod.xvel[0][icont][1] = (float)velMod.getXmin();
			velMod.xvel[1][icont][1] = (float)velMod.getXmax();
			velMod.vf[0][icont][1] = 8.1f;
			velMod.vf[1][icont][1] = 8.1f;
			velMod.nvel[icont][1] = 2;

			velMod.ncont++;
			AfxMessageBox(_T("An extra layer is added at the bottom for gravity modeling."), MB_ICONQUESTION);
		} // if
	} // if


	velMod.isDenPrompt = false;  // only prompt once. Do not prompt any more for this CDocument

	CVelMod vm;
	CStringArray *sArrayN = new CStringArray();
	float *xx = ealloc1float(MOD_POINTS_MAX * 4);
	float *zz = ealloc1float(MOD_POINTS_MAX * 4);
	int countBlocks = 0;
	// double denMax = 0.;  // all densities will be deducted this value before passing to gz_poly() function
	for (icont = 0; icont < velMod.ncont - 1; icont++) {
		//create layer-extension to the left.
		v1 = velMod.vf[0][icont][0];
		v2 = velMod.vf[0][icont][1];
		rho = v2rho((v1 + v2) * 0.5, velMod.velRef, velMod.denRef);

		countBlocks++;
		tStr.Format(_T("%9.3f %9.3f %5d %10.4f"), -9999.f, velMod.zm[0][icont], countBlocks, rho);
		sArrayN->Add(tStr);
		tStr.Format(_T("%9.3f %9.3f %5d %10.4f"), (float)velMod.getXmin(), velMod.zm[0][icont], countBlocks, rho);
		sArrayN->Add(tStr);
		tStr.Format(_T("%9.3f %9.3f %5d %10.4f"), (float)velMod.getXmin(), velMod.zm[0][icont + 1], countBlocks, rho);
		sArrayN->Add(tStr);
		tStr.Format(_T("%9.3f %9.3f %5d %10.4f"), -9999.f, velMod.zm[0][icont + 1], countBlocks, rho);
		sArrayN->Add(tStr);

		x1 = x2 = (float)velMod.getXmin();
		//CString tStr2;
		//create the polygons for each layer.
		//*****x1***********x2******* with range at depth[icont]
		//**********range************
		//***************************
		//**x3*********************x4 with range at depth[icont+1]
		do
		{
			//first, find a block boundary for x2.
			for (j = 1; j < velMod.nvel[icont][0]; j++) {
				x = velMod.xvel[j][icont][0];
				if (x2 > x) continue;
				else if (fabs(x2 - velMod.xvel[j][icont][0]) < 0.00001) continue;
				else break;
			} //now x is the next candidate for block boundary.
			for (j = 1; j<velMod.nvel[icont][1]; j++) {
				if (x2 > velMod.xvel[j][icont][1]) continue;
				else if (fabs(x2 - velMod.xvel[j][icont][1]) < 0.00001) continue;

				//now velMod.xvel[j][1] is the another candidate for block boundary.
				// we need to choose one.
				x1 = x2;
				x2 = MIN(x, velMod.xvel[j][icont][1]);
				break;
			}

			double vAvg = vm.getAvgVelAtDistRange(&velMod, x1, x2, icont);
			rho = v2rho(vAvg, velMod.velRef, velMod.denRef);
			//	if (denMax < rho) denMax = rho;

			//depths of the 4 corners?
			for (j = 0; j < velMod.nzed[icont] - 1; j++) {
				x = velMod.xm[j][icont];
				if (x1 >= x && x1 <= velMod.xm[j + 1][icont]) {
					z1 = velMod.zm[j][icont] + (velMod.zm[j + 1][icont] - velMod.zm[j][icont])*
						(x1 - x) / (velMod.xm[j + 1][icont] - x);
					break;
				}
				else continue;
			}
			for (j = 0; j < velMod.nzed[icont] - 1; j++) {
				x = velMod.xm[j][icont];
				if (x2 >= x && x2 <= velMod.xm[j + 1][icont]) {
					z2 = velMod.zm[j][icont] + (velMod.zm[j + 1][icont] - velMod.zm[j][icont])*
						(x2 - x) / (velMod.xm[j + 1][icont] - x);
					break;
				}
				else continue;
			}

			for (j = 0; j < velMod.nzed[icont + 1] - 1; j++) {
				x = velMod.xm[j][icont + 1];
				if (x2 >= x && x2 <= velMod.xm[j + 1][icont + 1]) {
					z3 = velMod.zm[j][icont + 1] + (velMod.zm[j + 1][icont + 1] - velMod.zm[j][icont + 1])*
						(x2 - x) / (velMod.xm[j + 1][icont + 1] - x);
					break;
				}
				else continue;
			}

			for (j = 0; j < velMod.nzed[icont + 1] - 1; j++) {
				x = velMod.xm[j][icont + 1];
				if (x1 >= x && x1 <= velMod.xm[j + 1][icont + 1]) {
					z4 = velMod.zm[j][icont + 1] +
						(velMod.zm[j + 1][icont + 1] - velMod.zm[j][icont + 1])*
						(x1 - x) / (velMod.xm[j + 1][icont + 1] - x);
					break;
				}
				else continue;
			}

			//find out how many points, not writing now.
			register long nn = 0;
			for (j = 0; j < velMod.nzed[icont]; j++) {
				x = velMod.xm[j][icont];
				if (x <= x1) continue;
				if (x >= x2) break;
				nn++;
			}
			for (j = velMod.nzed[icont + 1] - 1; j >= 0; j--) {
				x = velMod.xm[j][icont + 1];
				if (x <= x1 || x >= x2) continue;
				nn++;
			}
			nn += 4;  //4 extra points.


			register int count = 0;
			xx[count] = (float)x1;
			zz[count] = (float)z1;
			count++;
			for (j = 0; j < velMod.nzed[icont]; j++) {
				x = velMod.xm[j][icont];
				if (x <= x1) continue;
				if (x >= x2) break;
				xx[count] = velMod.xm[j][icont];
				zz[count] = velMod.zm[j][icont];
				count++;
			}
			xx[count] = (float)x2;
			zz[count] = (float)z2;
			count++;
			xx[count] = (float)x2;
			zz[count] = (float)z3;
			count++;
			for (j = velMod.nzed[icont + 1] - 1; j >= 0; j--) {
				x = velMod.xm[j][icont + 1];
				if (x <= x1 || x >= x2) continue;
				xx[count] = velMod.xm[j][icont + 1];
				zz[count] = velMod.zm[j][icont + 1];
				count++;
			}
			xx[count] = (float)x1;
			zz[count] = (float)z4;
			count++;
			// NOTE: by now, count must be equal to nn, otherwise we have a problem

			if (count == nn) {
				countBlocks++;
				for (j = 0; j < count; j++) {
					tStr.Format(_T("%9.3f %9.3f %5d %10.4f"), xx[j], zz[j], countBlocks, rho);
					sArrayN->Add(tStr);
				}
			}
		} while ((x2 - velMod.getXmax()) < -0.00001);

		//create layer extension to the right.
		v1 = velMod.vf[velMod.nvel[icont][0] - 1][icont][0];
		v2 = velMod.vf[velMod.nvel[icont][1] - 1][icont][1];
		rho = v2rho((v1 + v2) * 0.5, velMod.velRef, velMod.denRef);
		// if (denMax < rho) denMax = rho;

		countBlocks++;
		tStr.Format(_T("%9.3f %9.3f %5d %10.4f"), (float)velMod.getXmax(),
			velMod.zm[velMod.nzed[icont] - 1][icont], countBlocks, rho);
		sArrayN->Add(tStr);
		tStr.Format(_T("%9.3f %9.3f %5d %10.4f"), 9999.f,
			velMod.zm[velMod.nzed[icont] - 1][icont], countBlocks, rho);
		sArrayN->Add(tStr);
		tStr.Format(_T("%9.3f %9.3f %5d %10.4f"), 9999.f,
			velMod.zm[velMod.nzed[icont + 1] - 1][icont + 1],
			countBlocks, rho);
		sArrayN->Add(tStr);
		tStr.Format(_T("%9.3f %9.3f %5d %10.4f"), (float)velMod.getXmax(),
			velMod.zm[velMod.nzed[icont + 1] - 1][icont + 1],
			countBlocks, rho);
		sArrayN->Add(tStr);
	} // for icont


	free1float(xx);
	free1float(zz);


	if (isSaveBlocks)
		saveStringArrayToFile(sArrayN, getWorkingPathSlash() + _T("gmod.extra.txt"));



	// now create memory blocks to store all the gravity blocks
	CDigitize pDg;
	CDigitize::DIGITIZE dig2;
	dig2.isZeltFormat = FALSE;
	dig2.totCurve = 0;  // we start from 0 here
	if (pDg.myDigitizingLoadTXT4Col(&dig2, sArrayN)) {
		int nstn = 100;
		double *xs;
		if (digMarker.totCurve > 0) {
			nstn = digMarker.nPoint[0];
			xs = ealloc1double(nstn);
			for (int is = 0; is < nstn; is++) {
				xs[is] = digMarker.x[is][0];
			}
		}
		else {
			xs = ealloc1double(nstn);
			double dx = (cd.coord.xmax - cd.coord.xmin) / (double)nstn;
			xs[0] = cd.coord.xmin;
			for (int is = 1; is < nstn; is++) {
				xs[is] = xs[is - 1] + dx;
			}
		}

		double *zs = ealloc1double(nstn);
		double *grav_z = ealloc1double(nstn);
		double *xv = ealloc1double(dig2.digPointMax);
		double *zv = ealloc1double(dig2.digPointMax);
		double *xvTmp = (double *)ealloc1double(dig2.digPointMax);
		double *zvTmp = (double *)ealloc1double(dig2.digPointMax);

		memset(zs, (int)'\0', nstn * sizeof(double));
		memset(grav_z, (int)'\0', nstn * sizeof(double));

		int blocksRead = dig2.totCurve;
		if (blocksRead != countBlocks) {
			int iProblem = 1;  // debug
		}

		for (int ic = 0; ic < dig2.totCurve; ic++) {
			register int nvert = dig2.nPoint[ic];
			for (register int iv = 0; iv < nvert; iv++) {
				xv[iv] = dig2.x[iv][ic];
				zv[iv] = dig2.t[iv][ic];
			}
			
			register double den = dig2.curveVal[ic];
			gz_poly(xs, zs, nstn, xv, zv, xvTmp, zvTmp, nvert, den - velMod.denMax, grav_z, false);
		}

		// remove the DC shift from grav_Z[]
		double grav_dc = (gravDC_shift_global != 0.f) ?
			gravDC_shift_global
			:
			getMedianValue(grav_z, nstn);

		if (grav_dc != 0.) {
			for (int is = 0; is < nstn; is++)
				grav_z[is] -= grav_dc;
		}

		dig.initDigitizeArray(nstn, 1);
		for (int is = 0; is < nstn; is++) {
			dig.x[is][0] = (float)xs[is];
			dig.t[is][0] = (float)grav_z[is];
		}
		dig.nPoint[0] = nstn;
		dig.totCurve = 1;
		dig.digName = GetFileNameAppendExt(velMod.velSecName, _T("_Gravmod"), _T("txt"));
		dig.isSortedX = TRUE;
		pDg.myDigSaveAs2(&dig, false);
		dig.strComment.Format(_T("# Computed gravity curve (DC shifted by %g mGal; density below %g km assumed %g gm/cm**3; ) \n# from velocity model %s"),
			grav_dc, depthModelMax_global, velMod.denMax, velMod.velSecName);


		free1double(xv);
		free1double(zv);
		free1double(xvTmp);
		free1double(zvTmp);
		free1double(xs);
		free1double(zs);
		free1double(grav_z);
	}
	dig2.freeDigAll();
	sArrayN->RemoveAll();
	delete sArrayN;
	sArrayN = NULL;

	// tStr.Format(_T("Gravity recomputed; DC shifted by %g mGal; density underneath assumed %g gm/cm**3"), grav_dc, velMod.denMax);
	pFrame->myCaption(dig.strComment);


	// now, placing the &dig to screen; this needs some transformation
//	float amin = pDg.getDigYMin(&dig);
	float amin = dig.getDigYMin();
	float amax = dig.getDigYMax();
	dig.transIsRevYAxis = !cd.coord.isFaceUp;
	if (dig.transYMultFactor == 0.f) {
		dig.transYMultFactor = (amax - amin == 0.f) ?
			1.f : 0.25f * (float)fabs(cd.coord.yHeight()) / (amax - amin);
	}
	if (dig.transYShift == 0.f) {
		if (dig.transIsRevYAxis)
			dig.transYShift = (float)cd.coord.Y2() - (amax - amin) * dig.transYMultFactor;
		else
			dig.transYShift = (float)cd.coord.Y1() + (amax - amin) * dig.transYMultFactor;
	}


	UpdateAllViews(NULL);
	NotifyChanged();
}

BOOL CSeisWideDoc::convVelocity2Density()
{
	// it uses fortran program to plot density blocks diagram using PS format
	long icont, j, jj;
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();

	if (velColor.dz < 0.004) velColor.dz = 0.004;  //make sure it doesn't overflow.
	long nzmax = (long)ceil(cd.coord.m_zmax / velColor.dz) + 1;  //note: y is time in sec. nzmax is max num of pnts in depth.
	double x1, x2, z1, z2, z3, z4, v1, v2, v3, v4, x, rho, velRef[14], denRef[14], weightAtX, weightAtXAbs, depthCorr;
	float xmin, xmax;
	float f1, f2;
	CString tStr;

	FILE* fp;
	CFileStatus status;
	BOOL initFileStatus = CFile::GetStatus(_T("vel2den.txt"), status); // static function
	int velDenLen = 0;

	if (!initFileStatus) {
		CdlgVel2Den dlg;
		if (dlg.DoModal() == IDOK)
		{
			velRef[0] = dlg.m_v1;  denRef[0] = dlg.m_d1;
			velRef[1] = dlg.m_v2;  denRef[1] = dlg.m_d2;
			velRef[2] = dlg.m_v3;  denRef[2] = dlg.m_d3;
			velRef[3] = dlg.m_v4;  denRef[3] = dlg.m_d4;
			velRef[4] = dlg.m_v5;  denRef[4] = dlg.m_d5;
			velRef[5] = dlg.m_v6;  denRef[5] = dlg.m_d6;
			velRef[6] = dlg.m_v7;  denRef[6] = dlg.m_d7;
			velRef[7] = dlg.m_v8;  denRef[7] = dlg.m_d8;
			velRef[8] = dlg.m_v9;  denRef[8] = dlg.m_d9;
		}
		else return FALSE;
		delete dlg;
		if (_tfopen_s(&fp, _T("vel2den.txt"), _T("w")) != 0) return FALSE;
	}

	//read in the numbers in the file.
		if (_tfopen_s(&fp, _T("vel2den.txt"), _T("r+")) != 0) return FALSE;
		CdlgVel2Den1 dlg;
		int res = 0;
		for (j = 0; j < 14; j++) {
			res = _ftscanf_s(fp, _T("%f %f"), &f1, &f2);
			if (res != 0 && res != EOF) {
				velRef[j] = f1;
				denRef[j] = f2;
				velDenLen++;
			}
			else {
				velRef[j] = 0.f;
				denRef[j] = 0.f;
			}
		}

		dlg.m_v1 = (float)velRef[0];  dlg.m_d1 = (float)denRef[0];
		dlg.m_v2 = (float)velRef[1];  dlg.m_d2 = (float)denRef[1];
		dlg.m_v3 = (float)velRef[2];  dlg.m_d3 = (float)denRef[2];
		dlg.m_v4 = (float)velRef[3];  dlg.m_d4 = (float)denRef[3];
		dlg.m_v5 = (float)velRef[4];  dlg.m_d5 = (float)denRef[4];
		dlg.m_v6 = (float)velRef[5];  dlg.m_d6 = (float)denRef[5];
		dlg.m_v7 = (float)velRef[6];  dlg.m_d7 = (float)denRef[6];
		dlg.m_v8 = (float)velRef[7];  dlg.m_d8 = (float)denRef[7];
		dlg.m_v9 = (float)velRef[8];  dlg.m_d9 = (float)denRef[8];
		dlg.m_denMax = (float)velMod.denMax;
		dlg.m_gravDC = 0.;
		dlg.m_depthMax = 60.;
		if (dlg.DoModal() == IDOK)
		{
			velRef[0] = dlg.m_v1;  denRef[0] = dlg.m_d1;
			velRef[1] = dlg.m_v2;  denRef[1] = dlg.m_d2;
			velRef[2] = dlg.m_v3;  denRef[2] = dlg.m_d3;
			velRef[3] = dlg.m_v4;  denRef[3] = dlg.m_d4;
			velRef[4] = dlg.m_v5;  denRef[4] = dlg.m_d5;
			velRef[5] = dlg.m_v6;  denRef[5] = dlg.m_d6;
			velRef[6] = dlg.m_v7;  denRef[6] = dlg.m_d7;
			velRef[7] = dlg.m_v8;  denRef[7] = dlg.m_d8;
			velRef[8] = dlg.m_v9;  denRef[8] = dlg.m_d9;
		}
		else {
			fclose(fp);  //must close before return.
			return FALSE;
		}
		delete dlg;
		rewind(fp);


	for (j = 0; j < 9; j++) _ftprintf_s(fp, _T("%8.3f %8.3f\n"), velRef[j], denRef[j]);
	fclose(fp);

	if (velDenLen > 9)
		AfxMessageBox(_T("The vel2den.txt file contains >9 records (max 14). However, the GUI here only displays the first 9 records. After clicking OK, the GUI will only update the first 9 lines, with the rest un-changed."));

	CString fnameVelden_corr = _T("vel2den_corr.txt");
	CStringArray* arr_corr = getLinesFromFile(fnameVelden_corr, false);

	CStringArray* sArray = new CStringArray();


	xmin = (float)velMod.getXmin();
	xmax = (float)velMod.getXmax();
	sArray->Add(_T("#This file contains extra model parameters calculated for alternative plots of gravity blocks, and is not needed for gravity modeling program."));
	sArray->Add(_T("#Fourth collumn is isostatic depth (in km) corrected for sediment loading if you selected a boundary (z) for datum beforhand"));
	sArray->Add(_T("#       assuming densities are 3.25 and 1.03 for asthenosphere (Ra) and water (Rw)"));
	sArray->Add(_T("#       The formula is [Ra*z-Sum(den*dz)] / (Ra-Rw). Useful for obtaining subsidence history."));
	sArray->Add(_T("#       You can narrow down the display xmin and xmax for a finer calculation grid."));
	sArray->Add(_T("#       The units for weights are density multiplied by depth in km, for a depth collumn of the whole model. \n"));
	sArray->Add(_T("#DISTANCE(km)  WEIGHT(relative)  WEIGHT(absolute)  DEPTH(isostatically corrected) "));
	//calculate for isostacy at a number of x points.
	x = xmin;
	while (x <= xmax) {
		depthCorr = -9999.;
		weightAtX = 0.;
		weightAtXAbs = 0.;
		for (icont = 0; icont < velMod.ncont - 1; icont++) {
			v1 = v2 = -9999.0;
			for (j = 0; j < velMod.nvel[icont][0] - 1; j++) {
				x1 = velMod.xvel[j][icont][0];
				if (x >= x1 && x <= velMod.xvel[j + 1][icont][0]) {
					v1 = velMod.vf[j][icont][0] + (velMod.vf[j + 1][icont][0] - velMod.vf[j][icont][0]) *
						(x - x1) / (velMod.xvel[j + 1][icont][0] - x1);
					break;
				}
				else continue;
			}
			for (j = 0; j < velMod.nvel[icont][1] - 1; j++) {
				x1 = velMod.xvel[j][icont][1];
				if (x >= x1 && x <= velMod.xvel[j + 1][icont][1]) {
					v2 = velMod.vf[j][icont][1] + (velMod.vf[j + 1][icont][1] - velMod.vf[j][icont][1]) *
						(x - x1) / (velMod.xvel[j + 1][icont][1] - x1);
					break;
				}
				else continue;
			}
			if (fabs(v1 + 9999.0) < 0.1 || fabs(v2 + 9999.0) < 0.1) {
				pFrame->myCaption(_T("Cannot get a correct velocity for isostacy balancing"));
				continue;
			}
			rho = v2rho_corr((v1 + v2) * .5, x, icont + 1, arr_corr);
			if (rho < 0.)
				rho = v2rho((v1 + v2) / 2., velRef, denRef, velDenLen); //average density computed.

			z1 = z2 = -9999.0;
			for (j = 0; j < velMod.nzed[icont] - 1; j++) {
				x1 = velMod.xm[j][icont];
				if (x >= x1 && x <= velMod.xm[j + 1][icont]) {
					z1 = velMod.zm[j][icont] + (velMod.zm[j + 1][icont] - velMod.zm[j][icont]) *
						(x - x1) / (velMod.xm[j + 1][icont] - x1);
					break;
				}
				else continue;
			}
			for (j = 0; j < velMod.nzed[icont + 1] - 1; j++) {
				x1 = velMod.xm[j][icont + 1];
				if (x >= x1 && x <= velMod.xm[j + 1][icont + 1]) {
					z2 = velMod.zm[j][icont + 1] + (velMod.zm[j + 1][icont + 1] - velMod.zm[j][icont + 1]) *
						(x - x1) / (velMod.xm[j + 1][icont + 1] - x1);
					break;
				}
				else continue;
			}
			if (fabs(z1 + 9999.0) < 0.1 || fabs(z2 + 9999.0) < 0.1) {
				pFrame->myCaption(_T("Cannot get a correct depth for isostacy balancing"));
				break;
			}
			if (z1 > z2) {
				pFrame->myCaption(_T("boundary problem for isostacy balancing"));
				break;
			}
			weightAtX += (rho - 3.0) * (z2 - z1);
			weightAtXAbs += rho * (z2 - z1);

			//compute for sediment isostasy correction
			if (draw.nodeMode == 1 && icont == draw.iLayerFocus - 1) //boundary mode.
				depthCorr = (3.25 * z2 - weightAtXAbs) / (3.25 - 1.03);
			else if (draw.nodeMode == 2 && icont == draw.iLayerFocus) //velocity mode.
				depthCorr = (3.25 * z2 - weightAtXAbs) / (3.25 - 1.03);

		} //end of isostacy calcualation for one x
		tStr.Format(_T("%7.2f %7.2f %7.2f %7.3f"), x, weightAtX, weightAtXAbs, depthCorr);
		sArray->Add(tStr);
		x = x + (xmax - xmin) * 0.02;
	}
	//end of isostacy section.


	CVelMod vm;
	CStringArray* gModArray = new CStringArray();

	sArray->Add(_T("#DENSITY  DISTANCE(km)  DEPTH(km)"));
	for (icont = 0; icont < velMod.ncont - 1; icont++) {
		//create layer-extension to the left.
		v1 = velMod.vf[0][icont][0];
		v2 = velMod.vf[1][icont][0];
		v3 = velMod.vf[0][icont][1];
		v4 = velMod.vf[1][icont][1];
		rho = v2rho((v1 + v2 + v3 + v4) / 4., velRef, denRef, velDenLen);

		tStr.Format(_T("%9.3f %9.3f %9.3f"), rho, -9999.f, velMod.zm[0][icont]);
		sArray->Add(tStr);
		tStr.Format(_T("%9.3f %9.3f %9.3f"), rho, xmin, velMod.zm[0][icont]);
		sArray->Add(tStr);
		tStr.Format(_T("%9.3f %9.3f %9.3f"), rho, xmin, velMod.zm[0][icont + 1]);
		sArray->Add(tStr);
		tStr.Format(_T("%9.3f %9.3f %9.3f"), rho, -9999.f, velMod.zm[0][icont + 1]);
		sArray->Add(tStr);

		tStr.Format(_T("%2d%3d%7.4f%7.4f"), icont + 1, 4, rho, rho);
		gModArray->Add(tStr);
		tStr.Format(_T("%9.3f%9.3f%9.3f%9.3f%9.3f%9.3f%9.3f%9.3f"), -999.f, velMod.zm[0][icont],
			xmin, velMod.zm[0][icont],
			xmin, velMod.zm[0][icont + 1],
			-999.f, velMod.zm[0][icont + 1]);
		gModArray->Add(tStr);

		x1 = x2 = xmin;
		CString tStr2;
		//create the polygons for each layer.
		//*****x1***********x2******* with range at depth[icont]
		//**********range************
		//***************************
		//**x3*********************x4 with range at depth[icont+1]
		do
		{
			//first, find a block boundary for x2.
			for (j = 1; j < velMod.nvel[icont][0]; j++) {
				x = velMod.xvel[j][icont][0];
				if (x2 > x) continue;
				else if (fabs(x2 - velMod.xvel[j][icont][0]) < 0.00001) continue;
				else break;
			} //now x is the next candidate for block boundary.
			for (j = 1; j < velMod.nvel[icont][1]; j++) {
				if (x2 > velMod.xvel[j][icont][1]) continue;
				else if (fabs(x2 - velMod.xvel[j][icont][1]) < 0.00001) continue;

				//now velMod.xvel[j][1] is the another candidate for block boundary.
				// we need to choose one.
				x1 = x2;
				x2 = MIN(x, velMod.xvel[j][icont][1]);
				break;
			}

			double vAvg = vm.getAvgVelAtDistRange(&velMod, x1, x2, icont);
			rho = v2rho_corr(vAvg, (x1 + x2) * .5, icont + 1, arr_corr);
			if (rho < 0.)
				rho = v2rho(vAvg, velRef, denRef, velDenLen);

			//depths of the 4 corners?
			for (j = 0; j < velMod.nzed[icont] - 1; j++) {
				x = velMod.xm[j][icont];
				if (x1 >= x && x1 <= velMod.xm[j + 1][icont]) {
					z1 = velMod.zm[j][icont] + (velMod.zm[j + 1][icont] - velMod.zm[j][icont]) *
						(x1 - x) / (velMod.xm[j + 1][icont] - x);
					break;
				}
				else continue;
			}
			for (j = 0; j < velMod.nzed[icont] - 1; j++) {
				x = velMod.xm[j][icont];
				if (x2 >= x && x2 <= velMod.xm[j + 1][icont]) {
					z2 = velMod.zm[j][icont] + (velMod.zm[j + 1][icont] - velMod.zm[j][icont]) *
						(x2 - x) / (velMod.xm[j + 1][icont] - x);
					break;
				}
				else continue;
			}

			for (j = 0; j < velMod.nzed[icont + 1] - 1; j++) {
				x = velMod.xm[j][icont + 1];
				if (x2 >= x && x2 <= velMod.xm[j + 1][icont + 1]) {
					z3 = velMod.zm[j][icont + 1] + (velMod.zm[j + 1][icont + 1] - velMod.zm[j][icont + 1]) *
						(x2 - x) / (velMod.xm[j + 1][icont + 1] - x);
					break;
				}
				else continue;
			}

			for (j = 0; j < velMod.nzed[icont + 1] - 1; j++) {
				x = velMod.xm[j][icont + 1];
				if (x1 >= x && x1 <= velMod.xm[j + 1][icont + 1]) {
					z4 = velMod.zm[j][icont + 1] +
						(velMod.zm[j + 1][icont + 1] - velMod.zm[j][icont + 1]) *
						(x1 - x) / (velMod.xm[j + 1][icont + 1] - x);
					break;
				}
				else continue;
			}

			//find out how many points, not writing now.
			long nn = 0;
			for (j = 0; j < velMod.nzed[icont]; j++) {
				x = velMod.xm[j][icont];
				if (x <= x1) continue;
				if (x >= x2) break;
				nn++;
			}
			for (j = velMod.nzed[icont + 1] - 1; j >= 0; j--) {
				x = velMod.xm[j][icont + 1];
				if (x <= x1 || x >= x2) continue;
				nn++;
			}
			nn += 4;  //4 extra points.


			float* xx = ealloc1float(nn);
			float* zz = ealloc1float(nn);
			int count = 0;
			xx[count] = (float)x1;
			zz[count] = (float)z1;
			count++;
			for (j = 0; j < velMod.nzed[icont]; j++) {
				x = velMod.xm[j][icont];
				if (x <= x1) continue;
				if (x >= x2) break;
				xx[count] = velMod.xm[j][icont];
				zz[count] = velMod.zm[j][icont];
				count++;
			}
			xx[count] = (float)x2;
			zz[count] = (float)z2;
			count++;
			xx[count] = (float)x2;
			zz[count] = (float)z3;
			count++;
			for (j = velMod.nzed[icont + 1] - 1; j >= 0; j--) {
				x = velMod.xm[j][icont + 1];
				if (x <= x1 || x >= x2) continue;
				xx[count] = velMod.xm[j][icont + 1];
				zz[count] = velMod.zm[j][icont + 1];
				count++;
			}
			xx[count] = (float)x1;
			zz[count] = (float)z4;
			count++;
			// NOTE: by now, count must be equal to nn, otherwise we have a problem

			if (count == nn) {
				for (j = 0; j < count; j++) {
					tStr.Format(_T("%9.3f %9.3f %9.3f"), rho, xx[j], zz[j]);
					sArray->Add(tStr);
				}
			}
			free1float(xx);
			free1float(zz);


			tStr.Format(_T("%2d%3d%7.4f%7.4f"), icont + 1, nn, rho, rho);
			gModArray->Add(tStr);

			tStr.Format(_T("%9.3f%9.3f"), x1, z1);
			jj = 1;  //now 1 point is written to tStr.
			for (j = 0; j < velMod.nzed[icont]; j++) {
				x = velMod.xm[j][icont];
				if (x <= x1) continue;
				if (x >= x2) break;
				tStr2.Format(_T("%9.3f%9.3f"), velMod.xm[j][icont], velMod.zm[j][icont]);
				tStr += tStr2;
				if (jj == 4) {
					jj = 0;
					gModArray->Add(tStr);
					tStr.Format(_T(""));  // reset it
				}
				else {
					jj++;
				}
			} // for
			tStr2.Format(_T("%9.3f%9.3f"), x2, z2);
			tStr += tStr2;
			if (jj == 4) {
				jj = 0;
				gModArray->Add(tStr);
				tStr.Format(_T(""));
			}
			else {
				jj++;
			}

			tStr2.Format(_T("%9.3f%9.3f"), x2, z3);
			tStr += tStr2;
			if (jj == 4) {
				jj = 0;
				gModArray->Add(tStr);
				tStr.Format(_T(""));
			}
			else {
				jj++;
			}

			for (j = velMod.nzed[icont + 1] - 1; j >= 0; j--)
			{
				x = velMod.xm[j][icont + 1];
				if (x <= x1 || x >= x2) continue;
				tStr2.Format(_T("%9.3f%9.3f"), velMod.xm[j][icont + 1], velMod.zm[j][icont + 1]);
				tStr += tStr2;
				if (jj == 4) {
					jj = 0;
					gModArray->Add(tStr);
					tStr.Format(_T(""));
				}
				else {
					jj++;
				}
			}

			// last point
			tStr2.Format(_T("%9.3f%9.3f"), x1, z4);
			tStr += tStr2;
			gModArray->Add(tStr);
		} while ((x2 - xmax) < -0.00001);

		//create layer extension to the right.
		v1 = velMod.vf[velMod.nvel[icont][0] - 2][icont][0];
		v2 = velMod.vf[velMod.nvel[icont][0] - 1][icont][0];
		v3 = velMod.vf[velMod.nvel[icont][1] - 1][icont][1];
		v4 = velMod.vf[velMod.nvel[icont][1] - 2][icont][1];
		rho = v2rho((v1 + v2 + v3 + v4) / 4., velRef, denRef, velDenLen);


		tStr.Format(_T("%9.3f %9.3f %9.3f"), rho, xmax, velMod.zm[velMod.nzed[icont] - 1][icont]);
		sArray->Add(tStr);
		tStr.Format(_T("%9.3f %9.3f %9.3f"), rho, 9999.f, velMod.zm[velMod.nzed[icont] - 1][icont]);
		sArray->Add(tStr);
		tStr.Format(_T("%9.3f %9.3f %9.3f"), rho, 9999.f, velMod.zm[velMod.nzed[icont + 1] - 1][icont + 1]);
		sArray->Add(tStr);
		tStr.Format(_T("%9.3f %9.3f %9.3f"), rho, xmax, velMod.zm[velMod.nzed[icont + 1] - 1][icont + 1]);
		sArray->Add(tStr);

		tStr.Format(_T("%2d%3d%7.4f%7.4f"), icont + 1, 4, rho, rho);
		gModArray->Add(tStr);
		tStr.Format(_T("%9.3f%9.3f%9.3f%9.3f%9.3f%9.3f%9.3f%9.3f"), xmax, velMod.zm[velMod.nzed[icont] - 1][icont],
			999.f, velMod.zm[velMod.nzed[icont] - 1][icont],
			999.f, velMod.zm[velMod.nzed[icont + 1] - 1][icont + 1],
			xmax, velMod.zm[velMod.nzed[icont + 1] - 1][icont + 1]);
		gModArray->Add(tStr);
	}



	bool isTrue;
	CString workPathSlash = getWorkingPathSlash();
	CString strGmodExtra = workPathSlash + _T("g.mod.extra");
	saveStringArrayToFile(sArray, strGmodExtra);
	sArray->RemoveAll();
	delete sArray;
	sArray = NULL;

	tStr = workPathSlash + _T("\\g.mod");
	isTrue = saveStringArrayToFile(gModArray, tStr);
	gModArray->RemoveAll();
	delete gModArray;
	gModArray = NULL;

	if (arr_corr) {
		arr_corr->RemoveAll();
		delete arr_corr;
	}
	CDigitize pDg;
	dig.digName = digMarker.digName;
	if (pDg.myDigitizingLoadTXTUnix2(&dig, FALSE) &&
		dig.totCurve == 1) {
		// if this marker is correct, we try to generate r.in, run gravmod.exe, and extrat calculated gravity from g.out and put results to  dig.digName 

		CString cFile = workPathSlash + _T("g.in");
		if (!isFileExistNotDirectory(cFile)) {
			CStringArray* sArray3 = new CStringArray();
			sArray3->Add(_T("  &pltpar"));
			sArray3->Add(_T("          icol=1, iseg=0, imod=2, igrav=1, isigma0=0,"));
			sArray3->Add(_T("          irmdc=1, idata=1, ilab=2, idump=0, "));
			sArray3->Add(_T("          nsmth=0, nevery=2,"));
			sArray3->Add(_T("          xsdata=0., dsmax=.2,"));
			sArray3->Add(_T("          symht=1., numht=2.0, isymb=2,"));
			sArray3->Add(_T("  &end"));
			sArray3->Add(_T("  &axepar "));
			tStr.Format(_T("          xmin=%f, xmax=%f, xmm=200., ntickx=25, "), velMod.getXmin(), velMod.getXmax());
			sArray3->Add(tStr);
			tStr.Format(_T("          xtmin=%f, xtmax=%f, xmm=200.,"), velMod.getXmin(), velMod.getXmax());
			sArray3->Add(tStr);
			tStr.Format(_T("          zmin=0.0, zmax=%f, zmm=100.,"), cd.coord.m_zmax);
			sArray3->Add(tStr);
			tStr.Format(_T("          gmin=-50.0, gmax=50, gmm=35., ntickg=1,"));
			sArray3->Add(tStr);
			sArray3->Add(_T("          albht=3., xorig=15., yorig=15.,"));
			sArray3->Add(_T("  &end"));
			sArray3->Add(_T("  &grvpar"));
			sArray3->Add(_T("          polys=500, den0=3.1,"));
			tStr.Format(_T("          first=%f, last=%f, spacng=4.,"), velMod.getXmin() - 200., velMod.getXmax() + 200.);
			sArray3->Add(tStr);
			sArray3->Add(_T("          pincl=-1, pomit=-1,"));
			sArray3->Add(_T("  &end"));

			isTrue = saveStringArrayToFile(sArray3, cFile);
			sArray3->RemoveAll();
			delete sArray3;
			sArray3 = NULL;
		} // if
	}
	return isTrue;
}

void CSeisWideDoc::OnModelingGravitymodelingDenplot()
{
	// it uses fortran program to plot density blocks diagram using PS format
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();

	if (velColor.dz<0.004) velColor.dz = 0.004;  //make sure it doesn't overflow.
	long nzmax = (long)ceil(cd.coord.m_zmax / velColor.dz) + 1;  //note: y is time in sec. nzmax is max num of pnts in depth.
	CString tStr;

	if (!cd.coord.isModelingMode()) {
		AfxMessageBox(_T("Please show a velocity model before converting to density outputs"), MB_ICONQUESTION);
		return;
	}


	CString workPathSlash = getWorkingPathSlash();
	if (!isFileExistNotDirectory(digMarker.digName)) {
		tStr = _T("To use GRAVMOD.exe to compute for gravity modeling, \n1. Create/Edit a file with observed distance-gravity pairs (X Y free format) in current folder.\n");
		tStr += _T("\n2 Select this file name as marker in Seiswide. \n3. Re-run this routine. The current folder will be shown after clicking OK.");
		AfxMessageBox(tStr, MB_ICONQUESTION);
		ShellExecute(NULL, _T("explore"), workPathSlash, NULL, NULL, SW_SHOWDEFAULT);
		return;
	}

	SetCurrentDirectory(workPathSlash);

	//CString bFile = _T("g.obs");
	//if (!CopyFile(digMarker.digName, bFile, FALSE)) {
	//	// if copying failed, we assume no need to copy, so just continue
	//} // if CopyFile

	//  // need to format the g.obs file to remove any comment lines
	//// otherwise the fortran preogram will fail.
	//CStringArray* arr = getLinesFromFile(bFile, false);
	//if (!saveStringArrayToFile(arr, bFile)) {
	//	return;  // this should not happen
	//}
		
	CFileStatus status;
	BOOL initFileStatus = CFile::GetStatus(_T("g.mod"), status); // static function
	BOOL isTrue = TRUE;
	if (!initFileStatus)
		isTrue = convVelocity2Density();

	if (isTrue) {
			// now we want to run the gravMod program
			// SetCurrentDirectory(progPath);
			//myProcessSimple(progPath+ _T("\\gravMod.exe"));
	//		CString txPath = getWorkingPathSlash();
			CString progPath = getSeisWideParaPath() + _T("\\others\\psGravmod\\gravExample\\gravMod.exe");
			CString exeNameQuoted = addQuotes(progPath);
			if (!isFileExistNotDirectory(exeNameQuoted)) {
				AfxMessageBox(_T("Failed to locate gravMod.exe program."), MB_ICONQUESTION);
				isTrue = false;
			}
			else {
				PROCESS_INFORMATION proc_i = myUnicodeProcess(exeNameQuoted, workPathSlash, TRUE);  // info returned from CreateProcess
				if (WaitForSingleObject(proc_i.hProcess, INFINITE) == WAIT_TIMEOUT) {
					AfxMessageBox(_T("Failed due to time-out"), MB_ICONQUESTION);
				} // else	
				CloseHandle(proc_i.hProcess);
				CloseHandle(proc_i.hThread);
				tStr = _T("g.ps is the postscript output with density plot (first page) and gravity curve (second page). \rModify g.in to update plot scales. The folder will be shown once after clicking OK.");
				AfxMessageBox(tStr, MB_ICONQUESTION);
				static bool isFirst = true;
				if (isFirst) {
					ShellExecute(NULL, _T("explore"), workPathSlash, NULL, NULL, SW_SHOWDEFAULT);
					isFirst = false;
				}
			}
	}
}


void CSeisWideDoc::OnModelingSubsidence()
{
	CString tStr;
	tStr.Format(_T("Perform isostatic depth correction for stripping sediment loading.\n First, digitize 1 segment z(x). All sediments above it will be stripped.\n Assume densities 3.25 and 1.03 for asthenosphere (Ra) and water (Rw),\n final depth deduction is [Sum(den*dz) - Rw*z]/(Ra-Rw)."));
	AfxMessageBox(tStr, MB_ICONQUESTION);

	if (!dig.isDigitizing || dig.nPoint[0] < 2) {
		// the user is not digitizing. 
		tStr.Format(_T("Pleaser digitize 1 segment with >= 2 points."));
		AfxMessageBox(tStr, MB_ICONQUESTION);
		return;
	}
	if (!cd.coord.isModelingMode() && cd.coord.isTimeDomain())
	{
		AfxMessageBox(_T("Please show a velocity model in depth domain before converting to density outputs"), MB_ICONQUESTION);
		return;
	}

	long icont, icont2, j, j2;

	if (velColor.dz < 0.004) velColor.dz = 0.004;  //make sure it doesn't overflow.
	long nzmax = (long)ceil(cd.coord.Y2() / velColor.dz) + 1;  //note: y is time in sec. nzmax is max num of pnts in depth.
	double z1, z2, v1, v2, x, rho, velRef[9], denRef[9], weightDig, dz;



	FILE *fp;
	setCurrentPathAs(velMod.velSecName);
	//CFileStatus status;
	//BOOL initFileStatus = CFile::GetStatus( _T("vel2den.txt"), status ); // static function
	if (!isFileExistNotDirectory(_T("vel2den.txt"))) {
		CdlgVel2Den dlg;
		if (dlg.DoModal() == IDOK)
		{
			velRef[0] = dlg.m_v1;  denRef[0] = dlg.m_d1;
			velRef[1] = dlg.m_v2;  denRef[1] = dlg.m_d2;
			velRef[2] = dlg.m_v3;  denRef[2] = dlg.m_d3;
			velRef[3] = dlg.m_v4;  denRef[3] = dlg.m_d4;
			velRef[4] = dlg.m_v5;  denRef[4] = dlg.m_d5;
			velRef[5] = dlg.m_v6;  denRef[5] = dlg.m_d6;
			velRef[6] = dlg.m_v7;  denRef[6] = dlg.m_d7;
			velRef[7] = dlg.m_v8;  denRef[7] = dlg.m_d8;
			velRef[8] = dlg.m_v9;  denRef[8] = dlg.m_d9;
		}
		else return;
		delete dlg;
		if (_tfopen_s(&fp, _T("vel2den.txt"), _T("w")) != 0) return;
	}
	else {
		//read in the numbers in the file.
		if (_tfopen_s(&fp, _T("vel2den.txt"), _T("r+")) != 0) return;
		CdlgVel2Den1 dlg;
		_ftscanf_s(fp, _T("%f %f"), &dlg.m_v1, &dlg.m_d1);
		_ftscanf_s(fp, _T("%f %f"), &dlg.m_v2, &dlg.m_d2);
		_ftscanf_s(fp, _T("%f %f"), &dlg.m_v3, &dlg.m_d3);
		_ftscanf_s(fp, _T("%f %f"), &dlg.m_v4, &dlg.m_d4);
		_ftscanf_s(fp, _T("%f %f"), &dlg.m_v5, &dlg.m_d5);
		_ftscanf_s(fp, _T("%f %f"), &dlg.m_v6, &dlg.m_d6);
		_ftscanf_s(fp, _T("%f %f"), &dlg.m_v7, &dlg.m_d7);
		_ftscanf_s(fp, _T("%f %f"), &dlg.m_v8, &dlg.m_d8);
		_ftscanf_s(fp, _T("%f %f"), &dlg.m_v9, &dlg.m_d9);
		if (dlg.DoModal() == IDOK) {
			velRef[0] = dlg.m_v1;  denRef[0] = dlg.m_d1;
			velRef[1] = dlg.m_v2;  denRef[1] = dlg.m_d2;
			velRef[2] = dlg.m_v3;  denRef[2] = dlg.m_d3;
			velRef[3] = dlg.m_v4;  denRef[3] = dlg.m_d4;
			velRef[4] = dlg.m_v5;  denRef[4] = dlg.m_d5;
			velRef[5] = dlg.m_v6;  denRef[5] = dlg.m_d6;
			velRef[6] = dlg.m_v7;  denRef[6] = dlg.m_d7;
			velRef[7] = dlg.m_v8;  denRef[7] = dlg.m_d8;
			velRef[8] = dlg.m_v9;  denRef[8] = dlg.m_d9;
		}
		else {
			fclose(fp);  //must close before return.
			return;
		}
		delete dlg;
		rewind(fp);
	}

	for (j = 0; j < 9; j++) _ftprintf_s(fp, _T("%8.3f %8.3f\n"), velRef[j], denRef[j]);
	fclose(fp);



	/*
	float xmin, xmax;
	double weightAtX;
	FILE *stream;
	CString newName = _T("g_mod.txt";
	if( _tfopen_s(&stream, newName, _T("w") ) != 0 )
	{
	AfxMessageBox( _T("Can not open a file to hold the output" );
	return;
	}
	xmin = (float)cd.coord.xmin;
	xmax = (float)cd.coord.xmax;
	_ftprintf_s(stream, "First three collumns are Distance (km), relative [thickness*(den-3)], total [thickness*den] weights (in 100kg/cm^2) \n");
	_ftprintf_s(stream, "Fourth collumn is isostatic depth (in km) corrected for sediment loading for a selected boundary (at depth z)\n");
	_ftprintf_s(stream, "       assuming densities are 3.25 and 1.03 for asthenosphere (Ra) and water (Rw)\n");
	_ftprintf_s(stream, "       The formula is [Ra*z-Sum(den*dz)] / (Ra-Rw). Useful for obtaining subsidence history. \n");
	_ftprintf_s(stream, "       You can narrow down the display xmin and xmax for a finer calculation grid. \n");

	//calculate for isostacy at a number of x points.
	x = xmin;
	while (x<=xmax)
	{
	getVZCurveAtDist((float)x, &depth[0], &vTop[0], &vBot[0], true);  // apply anisotropy automatically as long as it exists for the layer!
	depthCorr = -99999.;
	weightAtX = 0.;
	weightAtXAbs = 0.;
	for (icont=0; icont<velMod.nlayer; icont++)
	{
	v1 = vTop[icont]; v2 = vBot[icont];
	rho = v2rho((v1+v2)/2., velRef, denRef); //average density computed.
	z1 = depth[icont]; z2 = depth[icont+1];
	weightAtX += (rho-3.0)*(z2-z1);
	weightAtXAbs += rho*(z2-z1);

	//compute for sediment isostasy correction
	if (icont==draw.iLayerFocus-1) //boundary mode.
	depthCorr = (3.25*z2-weightAtXAbs)/(3.25-1.03);
	//else if (draw.nodes==2 && icont==draw.iLayerFocus) //velocity mode.
	//	depthCorr = (3.25*z2-weightAtXAbs)/(3.25-1.03);

	} //end of isostacy calcualation for one x
	_ftprintf_s(stream, _T("%7.2f %7.2f %7.2f %7.3f\n", x, weightAtX, weightAtXAbs, depthCorr);
	x = x+(xmax-xmin)*0.01;
	}
	//end of isostacy section.
	fclose( stream );

	draw.isSameNodeDisplay = FALSE;
	//	AfxMessageBox(_T("This model is succesfully converted to density \nWith density blocks bordered by vertical boundaries only at velocity nodes of layers. \nYou should modify the density of each block to fit observed gravity.");
	showFileInNotePad(newName);
	*/



	//calculate for isostacy for all model boundaries below draw.iLayerFocus.
	CVelMod vm;
	CVelMod::VELMOD modNew;
	//vm.velModSetArrays(&modNew);

	CVelMod::VELMOD_X modX;

	int boundaryCut = 0;

	double zDig;
	CDigitize pDg;
	pDg.myDigSortX2(&dig, cd.coord.xmin, cd.coord.xmax);
	int np = dig.nPoint[0];
	for (icont2 = velMod.ncont - 1; icont2 >= 0; icont2--) {
		bool isBoundaryUseful = false;
		for (j2 = 0; j2 < velMod.nzed[icont2]; j2++) {
			x = velMod.xm[j2][icont2];
			modX.dist = x;
			vm.initModX(&velMod, &modX, cd.coord.isTimeDomain() == TRUE, true, velColor.dz);
			// apply anisotropy automatically as long as it exists for the layer!

			// need to get the zDig (the digitized curve depth) at x
			zDig = -99999.;
			if (x <= dig.x[0][0]) zDig = dig.t[0][0];
			else if (x >= dig.x[np - 1][0]) zDig = dig.t[np - 1][0];
			else {
				for (int i = 0; i<np - 1; i++) {
					if (x > dig.x[i][0] && x <= dig.x[i + 1][0]) {
						zDig = (dig.x[i + 1][0] - dig.x[i][0]) == 0.f ? dig.t[i][0] :
							dig.t[i][0] + (dig.t[i + 1][0] - dig.t[i][0]) * (x - dig.x[i][0]) / (dig.x[i + 1][0] - dig.x[i][0]);
						break;
					}
				} // for
			}


			dz = -99999.;  // the amount of depth correction
			weightDig = 0.;  // total weight at depth on the digitized curve 
			for (icont = 0; icont<velMod.ncont; icont++) {
				z1 = modX.depthMod[icont];
				z2 = modX.depthMod[icont + 1];
				if (z1 >= zDig) {
					break;
				}

				v1 = modX.vTop[icont];
				v2 = modX.vBot[icont];
				rho = v2rho((v1 + v2) / 2., velRef, denRef); //average density computed.
				if (z2 > zDig) z2 = zDig;
				weightDig += rho*(z2 - z1);
			} //end of weight calcualation for one point.


			  //compute for sediment isostasy correction
			  // note: the following 2 formulas are all correct!
			  // dz = zDig - (3.25*zDig-weightDig)/(3.25-1.03);  
			dz = (weightDig - 1.03 * zDig) / (3.25 - 1.03);

			modNew.zm[j2][icont2] = velMod.zm[j2][icont2] - (float)dz;

			// now, the digitized depth should be adjusted to 
			zDig -= dz;
			if (modNew.zm[j2][icont2] <= zDig) {
				modNew.zm[j2][icont2] = (float)zDig;
			}
			else
				isBoundaryUseful = true;
		} // for j2
		if (!isBoundaryUseful) {
			boundaryCut = icont2;
			break;
		}
	} // for icont2

	  // do not update the first boundary which is sea surface
	for (int icontNew = 1; icontNew < velMod.ncont - boundaryCut + 1; icontNew++) {
		// icont is the new boundary number
		int icontOld = icontNew + boundaryCut - 1;  // icontOld is the previous boundary number 
		for (j = 0; j < velMod.nzed[icontOld]; j++) {
			velMod.xm[j][icontNew] = velMod.xm[j][icontOld];
			velMod.zm[j][icontNew] = modNew.zm[j][icontOld];
		}
		velMod.nzed[icontNew] = velMod.nzed[icontOld];
		for (int k = 0; k < 2; k++) {
			// k==0 means at the top of layer; k==1 means bottom of layer
			for (j = 0; j < velMod.nvel[icontOld][k]; j++) {
				velMod.xvel[j][icontNew][k] = velMod.xvel[j][icontOld][k];
				velMod.vf[j][icontNew][k] = velMod.vf[j][icontOld][k];
			}
			velMod.nvel[icontNew][k] = velMod.nvel[icontOld][k];
		}
	}
	velMod.ncont -= boundaryCut - 1;
	draw.iLayerFocus = boundaryCut;

	//vm.velModFreeArrays(&modNew);

	velMod.velSecName = getFileNameAppend(velMod.velSecName, _T("isoCorr"));
	AfxMessageBox(_T("All boundaries at and below the selected boundary are succesfully isostatically corrected for sediment loading."));

	OnToolbarSaveasv();
	//velMod.velSecOld = _T("");	//refresh velocity.
	SetModifiedFlag();
	UpdateAllViews(NULL);
	NotifyChanged();
}

//void CSeisWideDoc::DrawControls(CDC *pDC, CRect rectDeviceClient, CRect rect)
#include "jp2_segy.h"
CString CSeisWideDoc::myDrawmode2String()
{
	//0: time section by km; 1: depth section; 2: velocity color map; 
	// 3: both depth section and vel color; 4: velocity contours. 5: no draw.
	// 6: time section by trace; 
	// 7: OnViewHydro; ID_MENU_VIEW_HYDRO  hydro time display. 
	// 8: Disabled; OnViewStackingvelocitymap; ID_VIEW_STACKINGVELOCITYMAP; stacking Velocity contours will be drawn.
	// 9: OnViewVelocitycolortwtt; ID_VIEW_VELOCITYCOLORTWTT; Velocity contours will be drawn in TWTT domain.
	// 10:OnViewNmoVelocity  ID_VIEW_NMO_VELOCITY; RMS velocity display
	// 11:RMS velocity display (to be abandoned???)
	CString tStr;
	switch (cd.coord.drawmode) {
	case 0:
		tStr.Format(_T("Draw time section by km: %s, reduced by %g"),
			draw.timeSecName, draw.red.getVred());
		break;
	case 1:
		tStr.Format(_T("Draw depth section: %s"), draw.depthSecName);
		break;
	case 2:
		tStr.Format(_T("Draw velocity color map: %s"), velMod.velSecName);
		break;
	case 3:
		tStr.Format(_T("Draw both depth section %s and vel color: %s"), draw.depthSecName, velMod.velSecName);
		break;
	case 4:
		tStr.Format(_T("Draw both velocity contours: %s"), velMod.velSecName);
		break;
	case 6:
		tStr.Format(_T("Draw time section by trace: %s"), draw.timeSecName);
		break;
	case 7:
		tStr.Format(_T("Draw time section %s by reduced NMO: %g km/s, target depth %g km, gun %g m"), draw.timeSecName,
			draw.red.getVred(), draw.red.targetDepth, draw.red.gunDepth*1000.f);
	case 9:
		tStr.Format(_T("Draw TWT domain time section %s and velocity model %s"),
			draw.timeSecName, velMod.velSecName);
	case 10:
		tStr.Format(_T("Draw NMO velocity analysis for time section %s"), draw.timeSecName);
		break;
	default:
		break;
	}

	if (!bmp24.bmpName.IsEmpty())
		tStr = _T("Draw bitmap %s"), bmp24.bmpName + tStr;
	return tStr;
}

void CSeisWideDoc::DrawControlsSegy(CDC *pDC, CColorHelper::AMPCOLORDYN *pAmpColorDyn, CView* pView)
{
	//this routine is shared and  called by two OnDraw().
	//rect is where the X-Y axes are drawn.
	//rectDeviceClient is supplied in pixels, used only during the SeisWide's decision in traces that are to be skipped (so the program runs faster).
	// onDraw() of VIew class only call this routine when draw.isSameDataDisplay is FALSE

	// when !draw.isSameNodeDisplay, stops loading seismic going further to avoid crash!

	// NOTE: DrawControls() does not draw travel-time curves, digitized points and
	//		 line-drawings. However, it tries to do some fix up on these points 
	//		 when some problem occurs.
	//	TCHAR s[80];
	//	_stprintf(s, _T(" file not properly opened; assign path to file name for a fix!");
	//return;

	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	// you cannot call draw.gDC inside this function, since pDC can be actually already draw.gDC as called 
	// in ondraw() when cd.coord.drawmode != 3

	if (!isTimeDomainUtil(cd.coord.drawmode))
		cd.coord.isDistanceDisplay = TRUE;  // this can avoid problems.

											//if (!bmp24.bmpName.IsEmpty()) {
											//	if (bmp24.isInitializeNeeded < 0) return;
											//	CString t = GetFileExtension(bmp24.bmpName).MakeLower();
											//}

	if (!bmp24.bmpName.IsEmpty())
		DrawXImage(pDC);

	pFrame->myLogInfo(myDrawmode2String());

	CString fSection = cd.coord.isTimeDomain() ? draw.timeSecName : draw.depthSecName;


	CString tStr;
	CDC aDC;
	tStr.Format(_T(" File was not properly opened: %s."), fSection);
	switch (cd.coord.drawmode)
	{
	case 0:
	case 1:
		// show only the seismic section in depth
		if (!DrawSectionArr(pDC, fSection, cd.coord.Y1(), cd.coord.Y2(), pAmpColorDyn, pView)) {
			pFrame->myCaption(tStr);
		}
		break;
	case 2:
	case 4:
		// show only the velocity color map in depth, shared with case 2
		if (!DrawVel(pDC)) {
			pFrame->myCaption(tStr);
		}
		break;
	case 3:
		// NOTE:  this case is called by OnExportSegyAsBmp!!!
		// show both the velocity color map and depth section
		// This is because I want to separate DC when the seismic and velocity model are all displayed.
		// but it's used for other classes
		if (!DrawVelocityColormapDepth(pDC, &velMod, draw.isNoNodes, 0., draw.iLayerFocus)) {
			pFrame->myCaption(tStr);
		}

		CDCHelper::myCreateTempDC(pDC, &aDC, cd.coord.getPixelsAxes(), cd.coord.logicalAxes);
		if (!DrawSectionArr(&aDC, fSection, cd.coord.Y1(), cd.coord.Y2(), pAmpColorDyn, pView)) {
			pFrame->myCaption(tStr);
		}

		// now merge &aDC to pDC using SRCAND since we want to keep the background colormap
		pDC->BitBlt(cd.coord.logicalAxes.left, cd.coord.logicalAxes.top,
			cd.coord.logicalAxes.Width(), cd.coord.logicalAxes.Height(), 
			&aDC, 
			cd.coord.logicalAxes.left, cd.coord.logicalAxes.top,
			SRCAND);
		break;
	case 6:
		if (!DrawSectionTrcArr(pDC, fSection, cd.coord.trace1, cd.coord.trace2, pAmpColorDyn, pView)) {
			pFrame->myCaption(tStr);
		}
		break;
	case 7:
		if (!DrawSectionArr(pDC, fSection, cd.coord.Y1(), cd.coord.Y2(), pAmpColorDyn, pView)) {
			pFrame->myCaption(tStr);
		}
		break;
	case 8:
		if (!DrawVel(pDC)) {
			pFrame->myCaption(tStr);
		}
		break;
	case 9:
		if (isFileExistNotDirectory(fSection)) {
			cd.coord.isDistanceDisplay = TRUE;
			DrawSectionArr(pDC, fSection, cd.coord.Y1(), cd.coord.Y2(), pAmpColorDyn, pView);
		}
		break;
	case 10:
		if (!DrawSectionArr(pDC, fSection, cd.coord.Y1(), cd.coord.Y2(), pAmpColorDyn, pView)) {
			pFrame->myCaption(tStr);
		}
		break;
	}
	aDC.DeleteDC();
}



void CSeisWideDoc::DrawXImage(CDC *pDC)
{
	if (!isFileExistNotDirectory(bmp24.bmpName)) return;

	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	if (bmp24.isInitializeNeeded != 0) {
		int type = CxImage::GetTypeIdFromName(GetFileExtension(bmp24.bmpName));
		if (bmp24.ximage)
			delete bmp24.ximage;

		pFrame->statMain.myCursor(true);
		bmp24.ximage = new CxImage(bmp24.bmpName, type);
		if (!bmp24.ximage->IsValid()) {
			CString s = bmp24.ximage->GetLastError();
			pFrame->myCaption(s);
			delete bmp24.ximage;
			bmp24.ximage = NULL;
			return;
		}
		pFrame->statMain.myCursor(false);

		bmp24.isInitializeNeeded = 0;
	}

	CPoint p1, p2;
	bool isTime = this->cd.coord.isTimeDomain() == TRUE;
	p1 = cd.coord.mm_coord(bmp24.xmin, bmp24.ymin);
	p2 = cd.coord.mm_coord(bmp24.xmax, bmp24.ymax);
	long i;
	if (p1.x > p2.x) {
		// swap them
		i = p1.x;
		p1.x = p2.x;
		p2.x = i;
	}
	if (p1.y > p2.y) {
		// swap them
		i = p1.y;
		p1.y = p2.y;
		p2.y = i;
	}
	CRect rect;
	if (pFrame->statMain.isStretchMode) {
		rect = CRect(p1, p2);
		bmp24.ximage->Draw2(pDC->GetSafeHdc(), rect);
	}
	else {
		CPoint p3 = p1;  // one corner is fixed
		CPoint p4;  // to determine the other corner

					// if the displayed pic is smaller than screen, we need to enlarge it a little
					// if the image is too big than the screen can holds it, we need to shrink a little
		double yox = (double)bmp24.ximage->GetHeight() / (double)bmp24.ximage->GetWidth();
		if (!cd.coord.isFaceUp) {
			p4.x = p3.x + (LONG)(bmp24.ximage->GetWidth() * cd.coord.device2Logical);
			p4.y = p3.y + (int)((p4.x - p3.x) * yox);
			double fac = MIN((double)p2.x / (double)p4.x,
				(double)p2.y / (double)p4.y);
			p4.x = (int)myRound(p4.x * fac);
			p4.y = (int)myRound(p4.y * fac);
		}
		else {
			rect = CRect(p1, p2);
			p4.x = p2.x;
			p4.y = p3.y - (int)(rect.Width() * yox);
			if (p4.y < p2.y) {
				// right corner goes beyond
				p4.y = p2.y;
				p4.x = p3.x + (int)((p3.y - p4.y) / yox);
			}
		}

		rect = CRect(p3, p4);
		// bmp24.ximage->Draw2(pDC->GetSafeHdc(), rect);
		DWORD  dw = (cd.coord.drawmode == 3 || cd.coord.drawmode == 9) ? SRCAND : SRCCOPY;
		bmp24.ximage->Stretch(pDC->GetSafeHdc(), rect, dw);
	}
}


//
//void CSeisWideDoc::OnFileResizebitmap()
//{
//	if (!isFileExistNotDirectory(bmp24.bmpName)) {
//		OnFileImportbitmap();
//		return;
//	}
//
//	CString tStr;
//	if (cd.coord.isFaceUp || dig.totCurve != 1 || dig.nPoint[0] != 2) {
//		tStr.Format(_T("To adjust a bitmap mapping, digitize only 2 points for the upper left and lower right points with known coordinate values within the bitmap, and let SeisWide populate to the whole bitmap via linear interpolation."));
//		AfxMessageBox(tStr, MB_ICONQUESTION);
//		return;
//	}
//
//	if (bmp24.ymin > bmp24.ymax) {
//		double a = bmp24.ymin;
//		bmp24.ymin = bmp24.ymax;
//		bmp24.ymax = a;
//		cd.coord.isFaceUp = true;
//	}
//
//
//	CdlgImportbitmap dlg;
//	dlg.m_name = bmp24.bmpName;
//	dlg.m_X1 = (float)bmp24.xmin;
//	dlg.m_Z1 = (float)bmp24.ymin;
//	dlg.m_X2 = (float)bmp24.xmax;
//	dlg.m_Z2 = (float)bmp24.ymax;
//
//	if (dlg.DoModal() == IDOK) {
//		bmp24.bmpName = dlg.m_name;
//		if (cd.coord.isTraceMode()) {
//			if (!bmp24.setWorldPoint(dlg.m_X1, dlg.m_Z1, dlg.m_X2, dlg.m_Z2,
//				(int)dig.x[0][0], (int)dig.t[0][0], (int)dig.x[1][0], (int)dig.t[1][0])) {
//				tStr.Format(_T("Sorry, failed to properly resize."));
//				AfxMessageBox(tStr, MB_ICONQUESTION);
//				return;
//			}
//		}
//		else {
//			if (!bmp24.modifyWorldPoint(dlg.m_X1, dlg.m_Z1, dlg.m_X2, dlg.m_Z2,
//				(double)dig.x[0][0], (double)dig.t[0][0], (double)dig.x[1][0], (double)dig.t[1][0])) {
//				tStr.Format(_T("Sorry, failed to properly resize."));
//				AfxMessageBox(tStr, MB_ICONQUESTION);
//				return;
//			}
//		}
//
//		cd.coord.trace1 = (int)bmp24.xmin;
//		cd.coord.trace2 = (int)bmp24.xmax;
//		cd.coord.xmin = bmp24.xmin;
//		cd.coord.xmax = bmp24.xmax;
//	}
//	else return;
//
//	// now we need to set the display coords
//	if (cd.coord.isTimeMode()) {
//		cd.coord.tmin = bmp24.ymin;
//		cd.coord.tmax = bmp24.ymax;
//	}
//	else {
//		cd.coord.zmin = bmp24.ymin;
//		cd.coord.zmax = bmp24.ymax;
//	}
//
//	// since the bmp24 limits have changed, we need to revise the digitize points as well
//	dig.x[0][0] = bmp24.xmin;
//	dig.t[0][0] = bmp24.ymin;
//	dig.x[1][0] = bmp24.xmax;
//	dig.t[1][0] = bmp24.ymax;
//
//	draw.isNoLableOutside = FALSE; // we do need outside labels to be able to tell axis assignments
//	draw.isSameDataDisplay = FALSE; //indicate display has been changed and will re-load all data.
//	SetModifiedFlag();
//	UpdateAllViews(NULL);
//	NotifyChanged();
//}

void CSeisWideDoc::OnFileImportbitmap()
{
	if (bmp24.bmpName.IsEmpty()) {
		// note: only if the bitmap file string is empty, we open a new window. 
		// the user might have moved the bitmap file to another place. We want to let the user to modify the file name manually.
		// Otherwise if the current file name does not exist, and we open a new window, the user cannot revise the file name.
		CSeisWideApp* pApp = (CSeisWideApp *)AfxGetApp();
		if (pApp) pApp->OnFileNew();
		return;
	}
	
	CString tStr;
	if (dig.totCurve != 1 || dig.nPoint[0] != 2) {
		tStr.Format(_T("Bitmap itself does not have world coordinates. To assign/modify them, digitize only 2 points with known coordinate values anywhere in the bitmap, and let SeisWide linearly interpole."));
		AfxMessageBox(tStr, MB_ICONQUESTION);
		//if (AfxMessageBox(tStr, MB_YESNO | MB_ICONQUESTION) == IDYES) {
		//	this->bmp24.xmin = (float)(this->cd.coord.trace1 = 0);
		//	this->bmp24.xmax = (float)(this->cd.coord.trace2 = bmp24.ximage->GetWidth());
		//	this->bmp24.ymin = (float)(this->cd.coord.m_zmin = (float)(this->cd.coord.m_tmin = 0.));
		//	this->bmp24.ymax = (float)(this->cd.coord.m_zmax = (float)(this->cd.coord.m_tmax = bmp24.ximage->GetHeight()));
		//	
		//	this->cd.coord.xTick = getTickRounded(this->cd.coord.X1(), this->cd.coord.X2(), 2, 50, 0.0);
		//	this->cd.coord.tTick = getTickRounded(this->cd.coord.Y1(), this->cd.coord.Y2(), 2, 50, 0.0);
		//	this->cd.coord.isFaceUp = false;
		//	UpdateAllViews(NULL);
		//}
		return;
	}

	float digX1;
	float digY1;
	float digX2;
	float digY2;


	CdlgImportbitmap dlg;
	dlg.m_name = bmp24.bmpName;

	// this is a valid digitizing scheme to assign 
	digX1 = dig.x[0][0];
	digY1 = dig.t[0][0];
	digX2 = dig.x[1][0];
	digY2 = dig.t[1][0];
	dlg.m_X1 = digX1;
	dlg.m_Z1 = digY1;
	dlg.m_X2 = digX2;
	dlg.m_Z2 = digY2;

	if (cd.coord.isTraceMode())
		dlg.m_isOffset = 2; // trace mode
	else if (cd.coord.isDistanceDisplay)
		dlg.m_isOffset = 1; // distance mode
	else
		dlg.m_isOffset = 0; // offset mode
	
	if (dlg.DoModal() == IDOK) {
		bmp24.bmpName = dlg.m_name;
	}
	else return;

	draw.red.rvred = 0.; // must be zero reduction to begin with

	//// the digiziting values are stored in dlg.* struct
	float X1New = dlg.m_X1;
	float Y1New = dlg.m_Z1;
	float X2New = dlg.m_X2;
	float Y2New = dlg.m_Z2;

	if (!isFileExistNotDirectory(dlg.m_name)) {
		bmp24.isInitializeNeeded = 0; //when update screen, initialize the bitmap file and DC etc.
	}
	else {
		// if the same bitmap file and already initialized, so we do not need to update it again
		if (bmp24.bmpName.Compare(dlg.m_name) != 0 || bmp24.isInitializeNeeded == 1) {
			bmp24.bmpName = dlg.m_name;
			int type;
			if (bmp24.ximage)
				delete bmp24.ximage;
			if ((type = CxImage::GetTypeIdFromName(bmp24.bmpName)) != 0) {
				bmp24.ximage = new CxImage(bmp24.bmpName, type);
			}
		} // if

		if (bmp24.ximage->IsValid()) {
			if (!bmp24.setWorldPoint(
				//bmp24.xmin, bmp24.ymin, bmp24.xmax, bmp24.ymax,
				X1New, Y1New, X2New, Y2New,
				bmp24.getPixelIndexX(digX1),
				bmp24.getPixelIndexY(digY1),
				bmp24.getPixelIndexX(digX2),
				bmp24.getPixelIndexY(digY2)
				)) {
				tStr.Format(_T("Sorry, failed to properly resize."));
				AfxMessageBox(tStr, MB_ICONQUESTION);
				return;
			}




			if (bmp24.ymin > bmp24.ymax) {
				float a = bmp24.ymin;
				bmp24.ymin = bmp24.ymax;
				bmp24.ymax = a;
				cd.coord.isFaceUp = true;
			}
			if (bmp24.xmin > bmp24.xmax) {
				float a = bmp24.xmin;
				bmp24.xmin = bmp24.xmax;
				bmp24.xmax = a;
				cd.coord.isSwapX = true;
			}

			if (dlg.m_isOffset == 2) {
					if (cd.coord.drawmode != 6) {
						cd.coord.drawmode = 6; // trace mode
						this->cd.coord.trace1 = 0;
						this->cd.coord.trace2 = bmp24.ximage->GetWidth();
						this->cd.coord.setY1(0.);
						this->cd.coord.setY2(bmp24.ximage->GetHeight());
					}
				}
				else {
					if (dlg.m_isOffset == 1)
						// distance mode
						cd.coord.isDistanceDisplay = TRUE;
					else
						cd.coord.isDistanceDisplay = FALSE;

					if (cd.coord.drawmode != 0) {
						cd.coord.drawmode = 0;
						cd.coord.xmin = bmp24.xmin;
						cd.coord.xmax = bmp24.xmax;
						cd.coord.setY1(bmp24.ymin);
						cd.coord.setY2(bmp24.ymax);
					}
				}
		}
	}

	dig.freeDigAll();
	dig.isDigitizing = FALSE;

	// final fix: we want the user to be able switch to time or depth domains with the same params after the bitmap setup.
	if (cd.coord.isTimeDomain()) {
		cd.coord.m_zmin = cd.coord.m_tmin;
		cd.coord.m_zmax = cd.coord.m_tmax;
	}
	else {
		cd.coord.m_tmin = cd.coord.m_zmin;
		cd.coord.m_tmax = cd.coord.m_zmax;
	}



	draw.isNoLableOutside = FALSE;
	draw.isSameDataDisplay = FALSE; //indicate display has been changed and will re-load all data.
	//dig.isDigitizing = FALSE; // after loading, we need to get rid of digitizing since its numbers will not make sense in newer display
	SetModifiedFlag();
	UpdateAllViews(NULL);
	NotifyChanged();

}

//BOOL CSeisWideDoc::LoadBitmapInDC(CDC *pDC)
//{
//	//this routine will load a bmp24 file into a memory device context *pDC: bmp24.bmpDC, 
//	// with no coord transformation. *pDC is input, a major DC used by OnDraw(). 
//	// Another DC will be generated to hold the bitmap DC, transformed into a world coordinate, 
//	// and bitblt() into current DC.
//	// this routine loads any uncompressed bitmap format.
//	CDib m_Dib;
//	int nrow,ncol;
//	if (! m_Dib.LoadBMP(bmp24.bmp24Name, &bmp24.biForm, &ncol, &nrow) ) {
//		myCaption(_T("Could not load the bitmap file"));
//		return FALSE;
//	}

//	//bmp24.bmpDC.DeleteDC(); //if bmpDC is still there then delete it before we create it.

//	//CBitmap m_bmp; //deleted every time a routine has finished using it.
//	//BOOL trueFalse = bmp24.bmpDC.CreateCompatibleDC(pDC);
//	//if (bmp24.biForm == 1)
//	//	m_bmp.CreateBitmap(ncol, nrow, 1, 1, NULL); //only for monochrome.
//	//else
//	//	m_bmp.CreateCompatibleBitmap(pDC, ncol, nrow);
//	//bmp24.bmpDC.SelectObject(&m_bmp);
//	//bmp24.bmpDC.SetMapMode(MM_ANISOTROPIC);
//	//bmp24.bmpDC.SetViewportExt(ncol, nrow);
//	//bmp24.bmpDC.SetWindowExt(ncol, nrow);	 //for rect, logical, himetric coords.
//	//bmp24.bmpDC.SetBkMode(TRANSPARENT); //to avoid texts overlap each other.
//	//m_bmp.DeleteObject();

//	m_Dib.SetPalette(  &bmp24.bmpDC );
//	if (! m_Dib.Draw( &bmp24.bmpDC, 0, 0, ncol, nrow) ) {
//		myCaption(_T("Could not draw the bitmap file"));
//		return FALSE;
//	}


//	return TRUE;
//}


void CSeisWideDoc::OnProcessingDataresample()
{

	ULONGLONG Byte;
	long i, totShot = 0, rate, rate2;
	long outLen2;
	float *rData;
	CString outFile = BLANK, inFile = BLANK;
	static int numsampNew = 0;

	CdlgResample dlg;
	dlg.m_in = draw.timeSecName;
	dlg.m_out = getFileNameAppend(draw.timeSecName, _T("Resamp"));
	dlg.m_tmax = 0;
	dlg.m_tmin = 0;
	dlg.m_vRed = 0;
	dlg.m_numsampNew = numsampNew;
	if (dlg.DoModal() == IDOK) {
		inFile = dlg.m_in;
		outFile = dlg.m_out;
		rate = dlg.m_rate;
		rate2 = dlg.m_rate2;
		numsampNew = dlg.m_numsampNew;
	}
	else
		return;


	if (!isFileExistNotDirectory(inFile)) return;
	if (outFile == BLANK) return;


	// sometimes the user accidentally specified a stupid mistake in output sampling rate.
	if (rate2 < 10 || rate2 > 30000 || (float)rate2 / (float)rate < 0.1f || (float)rate2 / (float)rate > 10.f) {
		CString tmp;
		tmp.Format(_T("You desired sampling rate %d microsec is quite different from the existing %d microsec. Re-enter?"), rate2, rate);
		if (AfxMessageBox(tmp, MB_YESNO | MB_ICONINFORMATION) == IDYES) return;
	}




	outFile = SetFileExtension(outFile, _T("sgy"));

	segy tr, tr2;
	bhed bh, bh2;
	CFile file;
	if (!file.Open(inFile, CFile::modeRead | CFile::typeBinary | CFile::shareDenyNone)) {
		return;
	}

	//For progress control, need to know the last bytes no.
	ULONGLONG curBytesRead, totBytesRead = file.GetLength();
	file.Seek(0, CFile::begin);
	ULONGLONG bytesRead = file.Read(head.ascHead, 3200L);
	if (bytesRead < 3200) {
		AfxMessageBox(_T("Ascii section header read wrong"), MB_ICONQUESTION);
		file.Close();
		return;
	}
	file.Read(&bh, 400L);

	int numsamp = bh.hns;
	int format = bh.format;
	if (IsUnix(bh.format)) {
		AfxMessageBox(_T("Sorry, please convert to PC format first."), MB_ICONQUESTION);
		file.Close();
		return;
	}
	//int len = (bh.format != 3) ? numsamp * 4 + 240 : numsamp * 2 + 240;
	int len = bh.getTraceLenBytes();

	if (bh.hdt == 0) bh.hdt = bh.dto;
	int tpp = bh.hdt;

	float dt = (float)bh.hdt / (float)MIL;

	outLen2 = (int)ceil((double)bh.hns * (double)rate / (double)rate2); // if I add 1 to it, it will be too much
	if (outLen2 > SU_NFLTS) outLen2 = SU_NFLTS;
	if (outLen2 < 2) {
		file.Close();
		AfxMessageBox(_T("trace length too short"), MB_ICONQUESTION);
		return;
	}
	if (numsampNew > 0) outLen2 = numsampNew;

	// we make a convention: bh will store section header info for output. 
	// while  head struct store input file


	CFile file2;
	if (!file2.Open(outFile, CFile::modeWrite | CFile::modeCreate | CFile::typeBinary)) {
		file.Close();
		return;
	}



	// now modify the section header for output
	memcpy((void *)&bh2, (const void *)&bh, 400);
	bh2.hdt = (unsigned short)rate2;
	bh2.format = 1;  // we always want to output in floating point
	bh2.hns = (unsigned short)outLen2;
	file2.Write(head.ascHead, 3200L);
	file2.Write(&bh2, 400);
	float dt2 = (float)bh2.hdt / (float)MIL;

	rData = (float *)ealloc1float((size_t)numsamp);
	if (rData == NULL) {
		file.Close();
		file2.Close();
		AfxMessageBox(_T("Insufficient memory available"));
		return;
	}

	//Begin progress control.
	CMainFrame* pFrame =
		(CMainFrame*)AfxGetMainWnd();
	ASSERT(pFrame);
	ASSERT_KINDOF(CMainFrame, pFrame);
	pFrame->BeginProgress();

	while (file.Read(&tr, len) == (UINT)len) {
		curBytesRead = file.Seek(0, CFile::current);
		Byte = curBytesRead + len - 240;	//point to next trace.
		int iPos = (int)((double)curBytesRead / (double)totBytesRead*100.);
		if (iPos < 0)iPos = 0;
		if (iPos > 100)iPos = 100;
		pFrame->SetProgress(iPos);

		if (format == 1) { // float
			ibm_to_float((int *)tr.dat.data, (int *)tr.dat.data, (int)numsamp);
			for (i = 0; i < numsamp; i++) {
				rData[i] = tr.dat.data[i];
			} // for i
		}
		else if (format == 2) { // int
			for (i = 0; i < numsamp; i++) {
				rData[i] = (float)tr.dat.dataint[i];
			} // for i
		}
		else if (format == 3) { // short int
			for (i = 0; i < numsamp; i++) {
				rData[i] = (float)tr.dat.datashort[i];
			} // for i
		}
		else if (format == 5) { // float
			for (i = 0; i < numsamp; i++) {
				rData[i] = tr.dat.data[i];
			} // for i
		}
		else break;

		for (i = 0; i < numsamp; i++) {
			if (_isnan(rData[i])) rData[i] = 0.f;
		}

		// tr2.dat.data[] now represents the desired time sample in sec
		for (i = 0; i < outLen2; i++) {
			tr2.dat.data[i] = tr.getTraceDelay() + (float)i*dt2;
		} // for i

		ints8r((int)numsamp, // ntin
			dt,   // dtin
			tr.getTraceDelay(),   // ftin
			&rData[0], // yin[t=ntin], with yin[0] = y(fxin)
			0.f,  // yinl    value used to extrapolate yin values to left of yin[0]
			0.f,  // yinr	 value used to extrapolate yin values to right of yin[ntin-1]
			outLen2,   // nxout
			(float *)&tr2.dat.data[0],  // ntout
			(float *)&tr.dat.data[0]);    // tout
		tr.dt = (unsigned short)rate2;
		tr.ns = (unsigned short)outLen2;
		float_to_ibm((int *)tr.dat.data, (int *)tr.dat.data, (int)tr.ns);
		file2.Write(&tr, (long)(240 + outLen2 * 4));
	} // while

	pFrame->EndProgress();
	file.Close();
	file2.Close();

	free1float(rData);
	AfxMessageBox(_T("Success. Please check output file in the same directory."), MB_ICONQUESTION);
	//draw.timeSecOld = BLANK;
	//draw.timeSecName = outFile;
}

//
//int CSeisWideDoc::getPtdraw(BOOL pick, BOOL remove, BOOL move, BOOL add)
//{
//	// this routine converts the 4 states into a variable for easy handling.
//	if (pick) return 0;
//	else if (move) return 1;
//	else if (add) return 2;
//	else if (remove) return 3;
//	else return -1;
//}
//
//void CSeisWideDoc::setPtdraw(int statNew, BOOL &pick, BOOL &remove, BOOL &move, BOOL &add)
//{
//	// this routine converts the single stats into 4 variables.
//	if (statNew < 0) {
//		pick = remove = move = add = FALSE;
//	}
//	else if (statNew == 0) {
//		remove = move = add = FALSE;
//		pick = TRUE;
//	}
//	else if (statNew == 1) {
//		pick = remove = add = FALSE;
//		move = TRUE;
//	}
//	else if (statNew == 2) {
//		pick = remove = move = FALSE;
//		add = TRUE;
//	}
//	else if (statNew == 3) {
//		pick = add = move = FALSE;
//		remove = TRUE;
//	}
//	else if (statNew == 4) {
//		remove = move = add = FALSE;
//		pick = TRUE; // when using the right mouse, I do not want to have -1 mode
//	}
//	else {
//		pick = remove = move = add = FALSE;
//	}
//
//}




void CSeisWideDoc::OnProcessingDebias()
{
	long i;
	CString inFile = BLANK, outFile = BLANK;
	static int trace1 = 0;
	static int trace2 = 99999;

	segy tr;
	segy tr2;
	bhed bh;

	/*
	unsigned short *i2buf;
	i2buf = (unsigned short *) &tr;

	float *trcdat;
	trcdat = (float *) &i2buf[120];

	unsigned short *i2short;
	i2short = (unsigned short *) &i2buf[120];
	long *i2int;
	i2int = (long *) &i2buf[60];
	*/

	CdlgInOut dlg;
	dlg.m_inFile = draw.timeSecName;
	dlg.m_trace1 = trace1;
	dlg.m_trace2 = trace2;
	if (dlg.DoModal() == IDOK)
	{
		inFile = dlg.m_inFile;
		outFile = dlg.m_outFile;
		trace1 = dlg.m_trace1;
		trace2 = dlg.m_trace2;
		if (trace2 == trace1) {
			trace1 = 0;
			trace2 = 99999;
		}
	}
	else
	{
		return;
	}

	//	inFile = draw.timeSecName;
	//	outFile = inFile + _T(".UNIX");
	if (!isFileExistNotDirectory(inFile)) return;
	if (outFile == BLANK) return;
	if (outFile == inFile) {
		AfxMessageBox(_T("Output file name is the same as the input file name!"), MB_ICONQUESTION);
		return;
	}
	outFile = SetFileExtension(outFile, _T("sgy"));

	//put the path onto file2 if it doesn't have it.
	int pathLen = outFile.ReverseFind('\\');
	if (pathLen == (-1))
	{
		TCHAR curDir[_MAX_PATH];
		GetCurrentDirectory(_MAX_PATH, curDir);
		// outFile = (CString)curDir + _T("\\" + outFile;
		outFile.Format(_T("%s\\%s"), (CString)curDir, outFile);
	}

	CFile file;
	if (!file.Open(inFile, CFile::modeRead | CFile::typeBinary | CFile::shareDenyNone)) {
		return;
	}

	//For progress control, need to know the last bytes no.
	ULONGLONG curBytesRead, totBytesRead = file.GetLength();
	file.Seek(0, CFile::begin);
	//Begin progress control.
	CMainFrame* pFrame =
		(CMainFrame*)AfxGetMainWnd();
	ASSERT(pFrame);
	ASSERT_KINDOF(CMainFrame, pFrame);
	pFrame->BeginProgress();


	UINT bytesRead = file.Read(head.ascHead, 3200L);
	if (bytesRead < 3200)
		AfxMessageBox(_T("Ascii section header read wrong"), MB_ICONQUESTION);
	bytesRead = file.Read(&bh, 400L);
	if (bytesRead < 400)
		AfxMessageBox(_T("Binary section header read wrong"), MB_ICONQUESTION);
	//The following numbers have to be recalculated everytime,
	//because plotting the depth section will change these numbers.
	int numsamp = bh.hns; // (unsigned short)i2buf[10];
	int len = bh.getTraceLenBytes();

	//BOOL dataInt;
	//if (bh.format != 3) {
	//	dataInt = FALSE;
	//	len = numsamp * 4 + 240;
	//}
	//else {
	//	dataInt = TRUE;
	//	len = numsamp * 2 + 240;
	//}
	long headLenOut = numsamp * 4 + 240;  // output in floating point only


	CFile file2;
	if (!file2.Open(outFile, CFile::modeWrite | CFile::modeCreate | CFile::typeBinary)) {
		file.Close();
		return;
	}

	file2.Write(head.ascHead, 3200L);
	int formatIn = bh.format;
	bh.format = 1;  // always output in floating format
//	bh.format = pFrame->statMain.gIsIBMFloatSegy2 ? 1 : 5; // only floating is adopted for output
	file2.Write(&bh, 400L);

	ULONGLONG byteFileEnd = file.SeekToEnd();
	file.Seek(3600L, CFile::begin);

	while (file.Read(&tr, len) == (UINT)len) {
		if (tr.tracl < trace1 || tr.tracl > trace2) continue;

		tr.ns = numsamp; // this is for safer

		double sum = 0.0;
		double mean = 0.0;

		if (formatIn == 1) {
			// float data
			ibm_to_float((int *)tr.dat.data, (int *)tr.dat.data, (int)numsamp);

			for (i = 0; i < numsamp; i++)
				sum += (double)tr.dat.data[i];

			mean = sum / (double)numsamp;
			for (i = 0; i < numsamp; i++) {
				tr2.dat.data[i] = (float)(tr.dat.data[i] - mean);
			}

		}
		else if (formatIn == 2) {
			for (i = 0; i < numsamp; i++)
				sum += (double)(tr.dat.dataint[i]);

			mean = (double)sum / (double)numsamp;
			for (i = 0; i < numsamp; i++) {
				tr2.dat.data[i] = (float)(tr.dat.dataint[i] - mean);
			}

		}
		else if (formatIn == 3) {
			// short int data
			for (i = 0; i < numsamp; i++)
				sum = sum + (double)(tr.dat.datashort[i]);

			mean = (double)sum / (double)numsamp;
			for (i = 0; i < numsamp; i++) {
				tr2.dat.data[i] = (float)(tr.dat.datashort[i] - mean);
			}
		}
		else if (formatIn == 4) {
			AfxMessageBox(_T("Data is Fixed Point w/ Gain Code, not supported"), MB_ICONQUESTION);
			return;
		}
		else if (formatIn == 5) {
			for (i = 0; i < numsamp; i++)
				sum += (double)tr.dat.data[i];

			mean = sum / (double)numsamp;
			for (i = 0; i < numsamp; i++) {
				tr2.dat.data[i] = (float)(tr.dat.data[i] - mean);
			}
		}
		else {
			AfxMessageBox(_T("Unknown Data format"), MB_ICONQUESTION);
			return;
		}


		if (bh.format == 1) {
			float_to_ibm((int *)tr2.dat.data, (int *)tr2.dat.data, numsamp);
		}
		file2.Write(&tr, 240);
		file2.Write(&tr2.dat.data[0], numsamp * 4); // will output floating point format only!

		// progress control. Do not change
		curBytesRead = file.Seek(0, CFile::current);
		int iPos = (int)((double)curBytesRead / (double)totBytesRead*100.);
		if (iPos < 0)iPos = 0;
		if (iPos > 100)iPos = 100;
		pFrame->SetProgress(iPos);
	}	// while


	if (file) file.Close();
	if (file2) file2.Close();
	if (pFrame) {
		pFrame->EndProgress();
	}
}




void CSeisWideDoc::OnProcessingWiener()
{
	if (cd.coord.drawmode != 0 && cd.coord.drawmode != 6 && cd.coord.drawmode != 7) return;
	CString inFile = BLANK, outFile = BLANK;
	CString tStr;
	static float minLag = 0.03f;

	segy tr, out_tr;
	bhed bh;

	CdlgWienerFilter dlg;

	dlg.m_pnoise = 0.01f;
	dlg.m_maxcorr = dlg.m_tmax = (float)cd.coord.Y2();
	dlg.m_mincorr = dlg.m_tmin = (float)cd.coord.Y1();

	dlg.m_minlag = minLag;
	dlg.m_maxlag = (dlg.m_tmax - dlg.m_tmin) / 20.0f;

	dlg.m_nameIn = draw.timeSecName;
	dlg.m_nameOut = getFileNameAppend(draw.timeSecName, _T("_decon"));


	if (dlg.DoModal() == IDOK) {
		inFile = dlg.m_nameIn;
		outFile = dlg.m_nameOut;
		minLag = dlg.m_minlag;
	}
	else  {
		return;
	}

	if (outFile == BLANK) return;
	if (outFile == inFile) {
		AfxMessageBox(_T("Output file name is the same as the input file name!"), MB_ICONQUESTION);
		return;
	}

	float pnoise = dlg.m_pnoise;
	// now will use a few other variables: dlg.m_maxcorr, dlg.m_mincorr, dlg.m_maxlag

	CFile file;
	if (!file.Open(inFile, CFile::modeRead | CFile::typeBinary | CFile::shareDenyNone)) {
		return;
	}

	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	UINT bytesRead = file.Read(head.ascHead, 3200L);

	if (bytesRead < 3200)
		AfxMessageBox(_T("Ascii section header read wrong"), MB_ICONQUESTION);

	bytesRead = file.Read(&bh, 400L);
	BOOL isUnix = false;
	if (isUnix = IsUnix(bh.format)) SwapTapeHeader(&bh);
	if (bytesRead < 400)
		AfxMessageBox(_T("Binary section header read wrong"), MB_ICONQUESTION);

	if (bh.format != 1 && bh.format != 5) {
		file.Close();
		AfxMessageBox(_T("Sorry, only floating points are supported for this decon. Please convert first."), MB_ICONQUESTION);
		return;
	}

	int formatIn = bh.format;
	bh.format = 1; // only floating is adopted for output

	int numsamp = bh.hns;
//	int len = (bh.format != 3) ? numsamp * 4 + 240 : numsamp * 2 + 240;
	int len = bh.getTraceLenBytes();

	//The following numbers have to be recalculated everytime,
	//because plotting the depth section will change these numbers.
	// numsamp = bh.hns; // (unsigned short)i2buf[10];

	ULONGLONG byteFileEnd = file.SeekToEnd();
	file.Seek(3600L, CFile::begin);
	if (bh.hdt == 0) bh.hdt = bh.dto;
	float dt = (float)((float)bh.hdt / (float)MIL);
	double odt = MIL / (double)bh.hdt;

	CFile file2;
	if (!file2.Open(outFile, CFile::modeWrite | CFile::modeCreate | CFile::typeBinary)) {
		file.Close();
		return;
	}

	file2.Write(head.ascHead, 3200L);
	file2.Write(&bh, 400L);


	float *wiener = ealloc1float(numsamp);
	float *spiker = ealloc1float(numsamp);
	float *autocorr = ealloc1float(numsamp);

	int i;
	int j;
	float omax = (head.maxAmp > 0.f) ? (float)(1.0 / head.maxAmp) : 0.f;

	CString labelMinlags = BLANK;

	file.Seek(3600, CFile::begin);
	while (file.Read(&tr, len) == (UINT)len)
	{
		if (isUnix) {
			SwapN(&tr.dat, bh.format, numsamp);
			SwapTraceHeader(false, false, false, &tr);
		}
		if (formatIn == 1)
			ibm_to_float((int *)tr.dat.data, (int *)tr.dat.data, (int)numsamp);
		if ((int)(tr.tracl / 10) * 10 == tr.tracl) {
			tStr.Format(_T("Decon Trc %d"), tr.tracl);
			pFrame->myCaption(tStr);
		}

		tr.ns = (unsigned short)numsamp; // just to be safe

		// calculate lags
		int iminlag = (int)myRound(minLag*odt);
		if (iminlag < 1) iminlag = 1;
		int imaxlag = (int)myRound(dlg.m_maxlag *odt);
		if (imaxlag > numsamp) imaxlag = (int)myRound(0.05*numsamp);
		if (imaxlag < -numsamp) imaxlag = -(int)myRound(0.05*numsamp);
		int nlag = abs(imaxlag) - iminlag + 1;


		// now calculate corr window
		float reducedTime = (float)CCoords::getReduceTimeEx2(tr.getOffset(), cd.coord.drawmode, &draw.red);
		float mincorrAbs = dlg.m_mincorr + reducedTime;
		float maxcorrAbs = dlg.m_maxcorr + reducedTime;


		// for digitize curves, we can use them for calc decon factor window
		if (dig.isDigitizing
			&& !dig.isZeltFormat  // line-drawing format
			&& dig.totCurve > 0) {

			float dist = (cd.coord.isDistanceDisplay) ? tr.getDistance() : tr.getOffset();
			float aintopol = -1.f;;
			for (int i = 0; i < dig.nPoint[0] - 1; i++)
			{
				if (dist >= dig.x[i][0] && dist <= dig.x[i + 1][0])
				{
					if (dig.x[i][0] != dig.x[i + 1][0])
						aintopol = dig.t[i][0] + (dig.t[i + 1][0] - dig.t[i][0])
						/ (dig.x[i + 1][0] - dig.x[i][0])*(dist - dig.x[i][0]);
					else
						aintopol = dig.t[i][0];
					break;
				}
			} // for int i
			if (aintopol >= 0)
				mincorrAbs = aintopol;

			if (dig.totCurve > 1) {
				aintopol = -1.f;;
				for (int i = 0; i < dig.nPoint[1] - 1; i++)
				{
					if (dist >= dig.x[i][1] && dist <= dig.x[i + 1][1])
					{
						if (dig.x[i][1] != dig.x[i + 1][1])
							aintopol = dig.t[i][1] + (dig.t[i + 1][1] - dig.t[i][1])
							/ (dig.x[i + 1][1] - dig.x[i][1])*(dist - dig.x[i][1]);
						else
							aintopol = dig.t[i][1];
						break;
					}
				} // for int i

				if (aintopol > mincorrAbs)
					maxcorrAbs = aintopol;
			} // else if totCurve>1
			if (mincorrAbs >= maxcorrAbs) {
				// for some reason, after adjusting the corr window, we have mincorr >= maxcorr. we need to correct this
				mincorrAbs = dlg.m_mincorr + reducedTime;
				maxcorrAbs = dlg.m_maxcorr + reducedTime;
			}
		} // if draw.isDigitizing

		// before calculating index, we need to minus the trace delay from absolute time
		mincorrAbs -= tr.getTraceDelay();
		maxcorrAbs -= tr.getTraceDelay();

		// calc the start and end time for auto correlation window
		int imincorr = (int)myRound(mincorrAbs *odt);
		if (imincorr < 0) imincorr = 0;
		if (imincorr > numsamp) imincorr = numsamp;

		int imaxcorr = (int)myRound(maxcorrAbs *odt);
		if (imaxcorr < 0) imaxcorr = 0;
		if (imaxcorr > numsamp) imaxcorr = numsamp;

		// now the window can be zero length. So we have to get around this  dlg.m_maxcorr, dlg.m_mincorr
		int iwindowCorrLength = (int)ceil((dlg.m_maxcorr - dlg.m_mincorr)*odt) + 1;
		if (imincorr > imaxcorr - iwindowCorrLength) {
			imincorr = imaxcorr - iwindowCorrLength;
		}
		int ncorr = imaxcorr - imincorr + 1;

		// auto correlation starts
		for (i = 0; i < numsamp; i++) {
			tr.dat.data[i] *= omax;
		}

		/*****************************************************************************
		void xcor (int lx, int ifx, float *x,
		int ly, int ify, float *y,
		int lz, int ifz, float *z)
		Compute z = x cross-correlated with y; i.e.,

		ifx+lx-1
		z[i] =   sum    x[j]*y[i+j]  ;  i = ifz,...,ifz+lz-1
		j=ifx
		******************************************************************************
		Input:
		lx		length of x array
		ifx		sample index of first x
		x		array[lx] to be cross-correlated with y
		ly		length of y array
		ify		sample index of first y
		y		array[ly] with which x is to be cross-correlated
		lz		length of z array
		ifz		sample index of first z

		Output:
		z		array[lz] containing x cross-correlated with y
		*****************************************************************************/
		int itr = 0;
		++itr;
		xcor(ncorr, imincorr, tr.dat.data,
			ncorr, imincorr, tr.dat.data,
			abs(imaxlag), 0, autocorr);
		if (autocorr[0] == 0.0)
		{
			if (bh.format == 1) {
				float_to_ibm((int *)tr.dat.data, (int *)tr.dat.data, (int)numsamp);
			}
			file2.Write(&tr, len);
			continue;
		}

		// Whiten
		autocorr[0] *= 1.0f + pnoise;

		// Get inverse filter by Wiener-Levison
		/*****************************************************************************
		void stoepf (int n, float r[], float g[], float f[], float a[])
		Solve a symmetric Toeplitz linear system of equations Rf=g for f
		(float version)
		******************************************************************************
		Input:
		n		dimension of system
		r		array[n] of top row of Toeplitz matrix
		g		array[n] of right-hand-side column vector

		Output:
		f		array[n] of solution (left-hand-side) column vector
		a		array[n] of solution to Ra=v (Claerbout, FGDP, p. 57)
		******************************************************************************
		Notes:
		This routine does NOT solve the case when the main diagonal is zero, it
		just silently returns.

		The left column of the Toeplitz matrix is assumed to be equal to the top
		row (as specified in r); i.e., the Toeplitz matrix is assumed symmetric.
		******************************************************************************
		Author:  Dave Hale, Colorado School of Mines, 06/02/89
		*****************************************************************************/
		//float *crosscorr = autocorr + iminlag; // Set pointer to "cross" correlation
		//stoepf(nlag,autocorr,crosscorr,wiener,spiker);
		stoepf(nlag, autocorr, &autocorr[iminlag], wiener, spiker);


		/* Convolve pefilter with trace - don't do zero multiplies */
		float sum;
		int n;
		for (i = 0; i < numsamp; ++i)
		{
			n = MIN(i, imaxlag);
			sum = tr.dat.data[i];
			for (j = iminlag; j < n; ++j)
				sum -= wiener[j - iminlag] * tr.dat.data[i - j];
			out_tr.dat.data[i] = sum;
		}

		/* Output filtered trace */
		if (bh.format == 1) {
			float_to_ibm((int *)out_tr.dat.data, (int *)out_tr.dat.data, (int)numsamp);
		}
		memcpy((void *)&out_tr, (const void *)&tr, 240);
		//memcpy((void *)&out_tr.unass,(const void *) &tr.unass,30);
		file2.Write(&out_tr, len);
	} // while file.Read

	// must free the dynamic arrays
	free1float(wiener);
	free1float(spiker);
	free1float(autocorr);
	// &crosscorr  is just a pointer, not an array itself, so cannot free it
	//  free1float (crosscorr);

	file.Close();
	file2.Close();

	tStr.Format(_T("Finished decon"));
	pFrame->myCaption(tStr);

	draw.timeSecName = outFile;
	// draw.timeSecOld = BLANK;
	OnToolbarRefreshAll();


}

void CSeisWideDoc::OnDigitizingResizeSegments()
{
	OnDigitizingSavedig();

	// resize digitized line-drawings horizontally. Not very useful.
	CDigitize::DIGITIZE *pDig = NULL;
	if (dig.isDigitizing && dig.nPoint != NULL)
		pDig = &dig;
	else if (digMarker.isDigitizing && digMarker.nPoint != NULL)
		pDig = &digMarker;
	else
		return;

	// TODO: Add your command handler code here
	if (!pDig->isDigitizing) {
		AfxMessageBox(_T("Line drawings can only be modified in Digitizing mode."), MB_ICONQUESTION);
		return;
	}
	if (pDig->isZeltFormat) {
		AfxMessageBox(_T("Only line drawing segments can be horizontally widened here."), MB_ICONQUESTION);
		return;
	}

	float ratio = 2.f;
	CdlgDigResize dlg;
	long i, j;
	if (dlg.DoModal() == IDOK) {
		ratio = dlg.m_ratioResize;
	}
	else return;

	//	if (ratio< 1.f) {
	//		AfxMessageBox(_T("Ratio must be >= 1");
	//		return;
	//	}
	//
	pDig->totCurve = pDig->iCurveSel + 1;
	for (i = 0; i < pDig->totCurve; i++) {
		// first calculate the center x point
		float xmean = 0.f;
		for (j = 0; j < pDig->nPoint[i]; j++) {
			xmean += pDig->x[j][i];
		}
		if (pDig->nPoint[i] > 0) {
			xmean /= pDig->nPoint[i];
			for (j = 0; j < pDig->nPoint[i]; j++) {
				pDig->x[j][i] += (pDig->x[j][i] - xmean)*(ratio - 1.f);
			}
		}
	}
	CDigitize pDg;
	int isXInt = cd.coord.isTraceMode();
	pDg.myDigSaveAs2(&dig, isXInt);
	draw.isSameDataDisplay = FALSE;
	UpdateAllViews(NULL);
	NotifyChanged();
}


BOOL CSeisWideDoc::getLineColorArray()
{
	if (dig.digName.IsEmpty()) return FALSE;
	CString tStr = getPathAbs(dig.digName, getWorkingPathSlash());
	return CColorHelper::getLineColorArray(&lineColors, tStr) == 11;
}

//BOOL CSeisWideDoc::initDigitizeArray(int npoint, int ncurve)
//{
//	// before initialize, we need destroy whatever in there first
//	//CDigitize pDg;
//	dig.freeDigAll();
//	return dig.initDigitizeArray(npoint, ncurve);
//}


void CSeisWideDoc::OnEditUndo()
{
	CDigitize pDg;
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	
	if (cd.coord.drawmode == 2 || cd.coord.drawmode == 3 || cd.coord.drawmode == 4) {
		// onscreen display of model. Let's undo the editing
		CVelMod vm;
		if (vm.myModelBackup2(&velMod, pFrame->psei->restoreLevelMax, velColor.dz, cd.coord.isTimeDomain()))

			if (this->myModelRestore()) {
				UpdateAllViews(NULL);
			}
	}
	else if (dig.isDigitizing && dig.nPoint != NULL) {
		if (dig.iCurveSel >= 0 && dig.nPoint[dig.iCurveSel] > 0) {
			dig.nPoint[dig.iCurveSel] --;
			pFrame->myCaption(_T(" Your lastly-digitized point has been removed; Refresh screen to show the removal"));
			//pDg.myDigSaveAs(&dig, tx.xShotRay);
		}
		else if (dig.iCurveSel > 0) {
			if (AfxMessageBox(_T(" This will delete the last point in the previous curve; Stop? "), 
				MB_YESNO | MB_ICONINFORMATION) == IDNO) {
				dig.iCurveSel--;
				dig.totCurve--;
				dig.nPoint[dig.iCurveSel]--;
			//	pDg.myDigSaveAs(&dig, tx.xShotRay);
			}
		}
		else pFrame->myCaption(_T(" No points to undo"));
		draw.isSameDataDisplay = TRUE; //indicate display has been changed and will re-load all data in OnDraw().
	}


}

void CSeisWideDoc::OnEditRedo()
{
	if (cd.coord.drawmode == 2 || cd.coord.drawmode == 3 || cd.coord.drawmode == 4) {
		// onscreen display of model. Let's undo the editing
		//myModelBackup();
		CVelMod vm;
		CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
		vm.myModelBackup2(&velMod, pFrame->psei->restoreLevelMax, velColor.dz, cd.coord.isTimeDomain());

		if (this->myModelRestore(FALSE)) {
			UpdateAllViews(NULL);
		}
	}
}


BOOL CSeisWideDoc::myModelRestore(BOOL isBackward)
{
	// this is to restore model for undo. It'll deal with 9 versions. testing
	// not working yet
	CString tStr, aFile;
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();


	if (isBackward) {
		// draw.restoreLevelCurrent not saved. initialize with -1. 
		// If -1, restore the most recent velocity backup (say level 7), and this number will be 7.
		// the next time of restore (Cntl+Z), it will restore level 6, and the level index will be reduced to 6. 
		if (draw.restoreLevelCurrent < 0) {
			int fBackupIndex = 0;
			for (int i = 0; i < pFrame->psei->restoreLevelMax * 2; i++) {
				tStr.Format(_T("~%d~.bin"), i);
				aFile = getFileNameTemp(velMod.velSecName, tStr);
				if (!isFileExistNotDirectory(aFile)) {
					fBackupIndex = i;
					// now fBackupIndex is the maximum backup index that is not used. 
					break;
				}
			}
			draw.restoreLevelCurrent = fBackupIndex - 1;
		}
		// now draw.restoreLevelCurrent  should be the restore level for this round.


		tStr.Format(_T("~%d~.bin"), draw.restoreLevelCurrent);
		tStr = getFileNameTemp(velMod.velSecName, tStr);
		if (isFileExistNotDirectory(tStr)) {
			if (CopyFile(tStr, velMod.velSecName, FALSE)) {
				//velMod.velSecOld = BLANK; // this will ask program to reload the model file
				tStr.Format(_T("Restore level %d successful."), draw.restoreLevelCurrent);
				pFrame->myCaption(tStr);
				draw.restoreLevelCurrent--;
				return TRUE;
			} // if CopyFile
		} // if
	}
	else {
		if (draw.restoreLevelCurrent >= 0) {
			tStr.Format(_T("~%d~.bin"), draw.restoreLevelCurrent + 1);
			tStr = getFileNameTemp(velMod.velSecName, tStr);
			if (isFileExistNotDirectory(tStr)) {
				if (CopyFile(tStr, velMod.velSecName, FALSE)) {
					//velMod.velSecOld = BLANK; // this will ask program to reload the model file
					tStr.Format(_T("Restore level %d successful."), draw.restoreLevelCurrent + 1);
					draw.restoreLevelCurrent++;
					pFrame->myCaption(tStr);
					return TRUE;
				} // if CopyFile
			} // if
		} // if
	} // else

	pFrame->myCaption(_T("Failed to restore model."));
	return FALSE;
}



//BOOL CSeisWideDoc::isTimeDomain()
//{
//	//if true then in time domain.
//	BOOL isTime = isTimeDomainUtil(cd.coord.drawmode);
//
//	return isTime;
//}
//


// return true if the model is displayed,even if it is not visible
//BOOL CSeisWideDoc::isModelingMode()
//{
//	//if true then a valid model is displayed on screen, either in depth or time domains.
//	// note*******  special case:   cd.coord.drawmode==9 shows model on scrren but it is in time domain. Any problem with this?
//	return (cd.coord.drawmode == 2 || cd.coord.drawmode == 3 || cd.coord.drawmode == 4 || cd.coord.drawmode == 9) && velMod.ncont > 0;
//}

BOOL CSeisWideDoc::isModelVisible(CVelMod::VELMOD *velm, double xShift) {
	//if(xShift+velm->xmin >= cd.coord.xmax || xShift+velm->xmax <= cd.coord.xmin ||
	//	velm->zmin > cd.coord.Y2() || velm->zmax <= cd.coord.Y1()) return(FALSE);
	//if (xShift + velm->xmin >= cd.coord.xmax || xShift + velm->xmax <= cd.coord.xmin) return(FALSE);

	//return(TRUE);
	return velm->isModelVisible(&cd.coord, xShift);
}

void CSeisWideDoc::OnProcessingChangereducevelocityforbmp()
{
	return;

	//// This routine converts bitmapped segy data from 1 velocity to another.
	////the bitmap must be properly displayed on screen before continue.
	////	int j;
	//int row1,nrow,nrow1, col1,ncol,ncol1;
	//BYTE  r, g, b;
	//FILE* fou;
	//TCHAR * name;
	//unsigned char* bmpline;
	//float tempf, vredIn, vredOut;
	//CString newName;

	//if(!CheckTime(100)) {
	//	return;
	//}

	//if (cd.coord.drawmode != 0) {
	//	AfxMessageBox(_T("This function works in the Distance-Time domain only."));
	//	return;
	//}

	//if (bmp24.bmp24Name.IsEmpty()) {
	//	AfxMessageBox(_T("Please import a bitmap file first."));
	//	return;
	//}

	//if (cd.coord.isFaceUp==1) {
	//	tempf = bmp24.ymin;
	//	bmp24.ymin = bmp24.ymax;
	//	bmp24.ymax = tempf;
	//}

	//CSize siz = bmp24.bmpDC.GetWindowExt();
	//ncol = siz.cx;
	//nrow = siz.cy;

	////	CdlgTimDepthBMP dlg;
	//CdlgChangeReducingBMP dlg;
	//dlg.m_bmpIn = bmp24.bmp24Name;
	//dlg.m_bmpOut = bmp24.bmp24Name + _T("Out.bmp");
	//dlg.m_col = ncol;
	//dlg.m_row = nrow;
	//dlg.m_velIn = (float)para.red.vred;
	//dlg.m_velOut = 0.f;
	//dlg.m_bitSize = (bmp24.biForm == 1)?0:1;
	//dlg.m_sourceKm = (float)tx.xShot;
	//if(dlg.DoModal() == IDOK)
	//{
	//	bmp24.bmp24Name = dlg.m_bmpIn;
	//	newName = dlg.m_bmpOut;
	//	ncol1 = dlg.m_col;
	//	nrow1 = dlg.m_row;
	//	vredIn = dlg.m_velOut;
	//	vredOut = dlg.m_velOut;
	//	bmp24.biForm = (dlg.m_bitSize==0)? 1:24 ;
	//	tx.xShot = dlg.m_sourceKm;
	//}
	//else return;

	//delete dlg;

	////now in output, cd.coord.zmin to cd.coord.zmax would cover nrow1 pixels.
	////so 1 pixel is (cd.coord.zmax-cd.coord.zmin)/(nrow1-1) km.
	//double dx = (cd.coord.xmax-cd.coord.xmin)/(ncol1-1.0);
	//double dz = (cd.coord.zmax-cd.coord.zmin)/(nrow1-1.0);
	//long nzmin = (int)myRound (cd.coord.zmin / dz);
	//long nzmax = (int)myRound (cd.coord.zmax / dz);
	//COLORREF *colArray; //32-bit color values.

	////Prepare to formulate velocity traces.
	////	long iz;
	//colArray = (COLORREF *)malloc(nrow1*ncol1*sizeof(COLORREF));
	//if (colArray == NULL)
	//{
	//	AfxMessageBox(_T("Can not allocate memory for bitmap"));
	//	return;
	//}


	////Begin progress control.
	//CMainFrame* pFrame = 
	//	(CMainFrame*)AfxGetMainWnd();
	//ASSERT(pFrame);
	//ASSERT_KINDOF(CMainFrame, pFrame);
	//pFrame->BeginProgress();


	////start writing to file.
	//newName = SetFileExtension(newName, _T("bmp"));

	////generate a new file for holding output bitmap.
	//name = newName.GetBuffer(newName.GetLength());
	//if (0==(fou = BMP24CreateWriteStream(name, ncol1, nrow1, bmp24.biForm)) ) 
	//{
	//	AfxMessageBox(_T("Unable to generate a new file for output\n"));
	//	free (colArray);
	//	return;
	//}
	//newName.ReleaseBuffer();
	//if (0==(bmpline=BMP24CreateLineBuffer(ncol1, bmp24.biForm)) )
	//{
	//	AfxMessageBox(_T("Unable to allocate memory for holding bitmap data"));
	//	free (colArray);
	//	return;
	//}

	//for (row1=0; row1<nrow1; row1++)
	//{
	//	int iPos = (int)((float)row1/(float)nrow1*100.0);
	//	if(iPos<0)iPos=0;
	//	if(iPos>100)iPos=100;
	//	pFrame->SetProgress(iPos);

	//	for(col1=0; col1<ncol1; col1++)
	//	{
	//		if(colArray[row1*ncol1+col1] < 0)
	//			r=g=b=255;
	//		else
	//		{
	//			r   = (int)GetRValue(colArray[row1*ncol1+col1]);
	//			g   = (int)GetGValue(colArray[row1*ncol1+col1]);
	//			b   = (int)GetBValue(colArray[row1*ncol1+col1]);
	//		}
	//		BMP24SetRow(bmpline, col1, r, g, b, bmp24.biForm);
	//	}
	//	BMP24WriteRow(bmpline, ncol1, fou, bmp24.biForm);
	//	//	_ftprintf_s(stdout, _T("%s: %d rows total. %3d rows remaining        \r", fnou, nrow, nrow-1-row);
	//	// fflush(stdout);
	//}

	////close bitmap file.
	//fclose(fou);
	//pFrame->EndProgress();
	//free(bmpline);
	//free (colArray);
	//bmp24.bmp24Name  = newName;
	//bmp24.isNeedInitialize = TRUE;
	//bmp24.xmax = (float)cd.coord.xmax;
	//bmp24.xmin = (float)cd.coord.xmin;
	//bmp24.ymax = (float)cd.coord.zmax;
	//bmp24.ymin = (float)cd.coord.zmin;

	////Auto change mode to display both.
	////	cd.coord.drawmode = 3;	//Both velocity contours and depth sections will be drawn.
	////	draw.isNoColorMap = TRUE; //don't let color map overlay bitmap.
	//draw.isSameDataDisplay = FALSE; //indicate display has been changed and will re-load all data in OnDraw().

	//SetModifiedFlag();
	//UpdateAllViews(NULL);
	//NotifyChanged();


}


void CSeisWideDoc::DrawControlsEx(CDC *pDC)
{

	// draws everything else except already drawn by DrawControls() and Tick(), and DrawBitmap()
	// Sometimes, some customzation is required for some small step, then you cannot call this routine.
	CString tStr;
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	setCurrentPathAs(getWorkingPathSlash()); 
		// change this!!!!!!!

	// I move this line to earlier to avoid travel time curves covered by line drawings
	// or Zelt's format picks
	getLineColorArray();
	if (dig.isDigitizing || !draw.isNoLabelInSide)  // we will not show the curves if draw.isNoNodes is true when not digitizing
		drawLineDrawing(pDC); 


	if (cd.coord.drawmode == 8) {
		if (!isFileExistNotDirectory(_T("g.mod"))) {
			convVelocity2Density();
		}
		if (this->gden.loadDen(_T("g.mod")))
			this->DrawDenMod(pDC, &gden, draw.iLayerFocus);
	}
	else if (cd.coord.drawmode == 9) {
		DrawRayPathTwtt(pDC);
		DrawVelocityTwtt(pDC);
	}
	else if (cd.coord.drawmode == 7) {
		// hydro
		if (draw.xWell == ERRORVAL)
			draw.xWell = (float)velMod.getXWellDef();
		if (this->isHalfOffsetMode())
			DrawVelocityTwtt(pDC);  // if not in half offset mode, we cannot draw the velocity model otherwise there is conflict
		else {


			double xshot = getXShotAll2(&head);
			if (CCoords::isXShotDefined((float)xshot) && velMod.isVelModValid() && !draw.isNoLabelInSide) {
				CVelMod vm;
				CVelMod::VELMOD_X modX;
				modX.dist = xshot;
				vm.initModX(&velMod, &modX, true, true, velColor.dz);
				double t = vm.getTimeAtZ(&modX, draw.red.targetDepth, velColor.dz);

				// we only plot that oval at the zero offset location
				if (!cd.coord.isDistanceDisplay)
					xshot = 0.;
				CPoint p = cd.coord.mm_coord(xshot, t);
				int lenSeg = 200;
				int i1 = p.x - lenSeg;
				int i2 = p.y - lenSeg;
				int i3 = p.x + lenSeg;
				int i4 = p.y + lenSeg;
				if (i1 < cd.coord.logicalAxes.left) i1 = cd.coord.logicalAxes.left;
				if (i3 > cd.coord.logicalAxes.right) i3 = cd.coord.logicalAxes.right;
				if (i2 < cd.coord.logicalAxes.top) i2 = cd.coord.logicalAxes.top;
				if (i4 > cd.coord.logicalAxes.bottom) i2 = cd.coord.logicalAxes.bottom;
				if (i3 - i1 > 1 && i4 - i2 > 1) {
					CPen redPen(PS_SOLID, 20, GREEN);
					CBrush greenBrush(RED);
					CBrush *pBrush = pDC->SelectObject(&greenBrush);
					CPen* pOldPen = pDC->SelectObject(&redPen);
					pDC->Ellipse(i1, i2, i3, i4);
					pDC->SelectObject(pOldPen);
					pDC->SelectObject(pBrush);
				}
			}


		}
		myShowTravelTime(pDC, NULL);
	}
	else if (cd.coord.isTimeDomain()) {
		myShowTravelTime(pDC, NULL);
	}
	else {
		// depth domain
		//	if (!bmp24.bmp24Name.IsEmpty()) DrawVel(pDC, TRUE); // this redraw is for boundary only after BMP overlay
		//myShowFloatReflectors(pDC);

			DrawRayPath(pDC); // it will return if not showing raypath

			CVelMod vm;
			if (!vm.loadInitVel(&velMod, velMod.velSecName, velColor.dz, tStr))
				pFrame->myCaption(tStr);

			if (cd.coord.drawmode != 1 && isModelVisible(&velMod, 0.)) {
				DrawVelocityBoundaryDepth(pDC, &velMod, draw.isNoNodes, 0., NULL, draw.iLayerFocus);
			}

			if (draw.velSecNamesEx.GetLength() > 0) {
				CVelMod::VELMOD velm;
				//vm.velModSetArrays(&velm);
				double xposArr[MOD_POINTS_MAX];
				double xShiftArr[MOD_POINTS_MAX];
				CStringArray *arrVelNamesEx = new CStringArray();
				CVelMod::velNamesExParse(draw.velSecNamesEx, xShiftArr, xposArr, arrVelNamesEx);

				int lineThickness = (int)myRound(pFrame->statMain.thicknessLines * 50);
				CString seiFilePath(getWorkingPathSlash());
				for (int i = 0; i < arrVelNamesEx->GetCount(); i++) {
					// this is a vel model
					tStr = arrVelNamesEx->ElementAt(i);
					//	tStr = getSecNameRevised(tStr, seiFilePath);
					register bool isMainModelShowing = GetBaseFileName(velMod.velSecName) == GetBaseFileName(tStr);
					if (isMainModelShowing) continue; // do not show this one if it is the same as the main model
					register COLORREF cr = getGoodColorRand(isMainModelShowing);
					register CPen greenPen(PS_SOLID, lineThickness, cr);
					//	setCurrentDirectoryAs(getWorkingPathSlash());
					if (vm.loadInitVel(&velm, tStr, velColor.dz, tStr)) {
						if (isModelVisible(&velm, xShiftArr[i])) {
							if (velMod.velSecName.IsEmpty() && !isFileExistNotDirectory(draw.depthSecName))
								CVelMod::DrawVelocityColormapDepth(pDC, &velm, &cd.coord, &velColor, TRUE,
									xShiftArr[i], -1, draw.isNoColorMap, 1);

							DrawVelocityBoundaryDepth(pDC, &velm, TRUE, xShiftArr[i], &greenPen, 0);
							// if (xposArr[i] != ERRORVAL) 
							velm.wells[0].wellDist = (float)xposArr[i];
							DrawVelocityLabelDepth(pDC, &velm, xShiftArr[i], cr);
						}
					}
					else
						pFrame->myCaption(tStr); // print the error of model loading
					velm.velModReset();
				}

				arrVelNamesEx->RemoveAll();
				delete arrVelNamesEx;
				//vm.velModFreeArrays(&velm);
			}

			// here we want the labels on top of boundaries drawn, after (and thus on top  of) secondary models
			if (cd.coord.drawmode != 1 && isModelVisible(&velMod, 0.)) {
				DrawVelocityLabelDepth(pDC, &velMod, 0., getGoodColorRand(true));
			}



	}

	DrawMarkers(pDC);  // markers should be on top of line draws, otherwise harder to see

}

void CSeisWideDoc::OnProcessingChopdata()
{
	// added by Deping on Oct 26, 2004
	//	if(cd.coord.drawmode != 0 && cd.coord.drawmode != 7)
	if (!cd.coord.isTimeDomain() || !isFileExistNotDirectory(draw.timeSecName)) {
		AfxMessageBox(_T("This function will chop time domain segy data based on digitized polygon."), MB_ICONQUESTION);
		return;
	}
	if (!dig.isDigitizing || dig.totCurve<1 || dig.totCurve>2) {
		AfxMessageBox(_T("Please digitize with 1-2 segments forming a closed polygon, and try again to chop the segy data."), MB_ICONQUESTION);
		return;
	}


	CString outFile = BLANK;

	// we need to determine which segy file to use for chopping
	CString inFile = (cd.coord.isTimeDomain() && cd.coord.drawmode == 10) ? draw.depthSecName : draw.timeSecName;
	outFile = getFileNameAppend(inFile, _T("_Chop"));
	outFile = getFileNameNextVersion(outFile);

	//new file dialog.
	CFileDialog dlgOut(FALSE, BLANK, outFile,
		OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT | OFN_EXPLORER,
		_T("Output Data File (*.sgy)|*.sgy|"));
	dlgOut.m_ofn.lpstrTitle = _T("Select the output segy file");
	if (dlgOut.DoModal() == IDOK)
		outFile = dlgOut.GetPathName();
	else {
		return;
	}

	if (outFile == BLANK) return;
	if (outFile == inFile) {
		AfxMessageBox(_T("Output file name cannot be the same as the input file name!"));
		return;
	}


	bool isKeepBelowOrInside = true;
	if (dig.totCurve == 1) {
		int iDial = AfxMessageBox(_T("Chop above the curve? Click No for chopping below the curve instead."), MB_YESNOCANCEL | MB_ICONQUESTION);
		if (iDial != IDYES) 
			isKeepBelowOrInside = false;
		else if (iDial == IDCANCEL)
			return;
	}
	else if (dig.totCurve == 2) {
		int iDial = AfxMessageBox(_T("Chop any points outside the area? Click No for chopping inside the 2 digitized curves."), MB_YESNOCANCEL | MB_ICONQUESTION);
		if (iDial != IDYES)
			isKeepBelowOrInside = false;
		else if (iDial == IDCANCEL)
			return;
	}
	else return;

	bool isHalfOffsets = this->isHalfOffsetMode();
	



	//put the path onto file2 if it doesn't have it.
	//int pathLen = outFile.ReverseFind('\\');
	//if (pathLen == (-1)) {
	//	TCHAR curDir[_MAX_PATH];
	//	GetCurrentDirectory(_MAX_PATH, curDir);
	//	// outFile = (CString)curDir + _T("\\" + outFile;
	//	outFile.Format(_T("%s\\%s"), (CString)curDir, outFile);
	//}

	// Now start chopping seismic data
	// output segy file: outFile
	// area to retain after chop: 
	CFile file;
	if (!file.Open(inFile, CFile::modeRead | CFile::typeBinary | CFile::shareDenyNone)) {
		return;
	}

	segy tr, tr2;
	bhed bh;
	int i, j;


	//For progress control, need to know the last bytes no.
	ULONGLONG curBytesRead, totBytesRead = file.GetLength();
	file.Seek(0, CFile::begin);
	//Begin progress control.
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	pFrame->BeginProgress();


	UINT bytesRead = file.Read(head.ascHead, 3200L);
	if (bytesRead < 3200)
		AfxMessageBox(_T("Ascii section header read wrong"), MB_ICONQUESTION);
	bytesRead = file.Read(&bh, 400L);
	if (bytesRead < 400)
		AfxMessageBox(_T("Binary section header read wrong"), MB_ICONQUESTION);

	int numsamp = bh.hns; // (unsigned short)i2buf[10];
	int len = bh.getTraceLenBytes();
	CFile file2;
	if (!file2.Open(outFile, CFile::modeWrite | CFile::modeCreate | CFile::typeBinary)) {
		file.Close();
		return;
	}

	file2.Write(head.ascHead, 3200L);
	int formatIn = bh.format;
	bh.format = 1;  // always output in floating format
	// bh.format = pFrame->statMain.gIsIBMFloatSegy2 ? 1 : 5; // only floating is adopted for output
	file2.Write(&bh, 400L);

	ULONGLONG byteFileEnd = file.SeekToEnd();
	file.Seek(3600L, CFile::begin);

	if (bh.hdt == 0) bh.hdt = bh.dto;
	double aratio = (double)bh.hdt / (double)MIL;
	while (file.Read(&tr, len) == (UINT)len) {
		if (formatIn == 1) {
			// float data
			ibm_to_float((int *)tr.dat.data, (int *)tr.dat.data, (int)numsamp);
			//for (i = 0; i < numsamp; i++){
			//	tr2.dat.data[i] = (float)(tr.dat.data[i]);
			//}
			memcpy(tr2.dat.data, tr.dat.data, len - 240);
		}
		else if (formatIn == 2) {
			for (i = 0; i < numsamp; i++) {
				// tr2.dat.data[i] = (float)(i2int[i]);
				tr2.dat.data[i] = (float)(tr.dat.dataint[i]);
			}
		}
		else if (formatIn == 3) {
			// short int data
			for (i = 0; i < numsamp; i++) {
				tr2.dat.data[i] = (float)(tr.dat.datashort[i]);
			}
		}
		else if (formatIn == 5) {
			// float data
			//for (i = 0; i < numsamp; i++){
			//	tr2.dat.data[i] = (float)(tr.dat.data[i]);
			//}
			memcpy(tr2.dat.data, tr.dat.data, len - 240);
		}

		// ****************now do the chopping
		//float xpos;
		//if (cd.coord.drawmode == 6)
		//	xpos = (float)tr.tracl;
		//else if (cd.coord.isDistanceDisplay)
		//	xpos = tr.getDistance();
		//else
		//	xpos = tr.getOffset();

		register float trOffset = tr.getOffset();
		register float trDistance = tr.getDistance();
		register float xpos;
		if (cd.coord.drawmode == 6)
			xpos = (float)tr.tracl;
		else
			xpos = (cd.coord.isDistanceDisplay) ? trDistance : trOffset;
		if (isHalfOffsets)
			xpos = xpos - trOffset * 0.5f;


		register double tShift = tr.getTraceDelay();
		register double tReduced = CCoords::getReduceTimeEx2(trOffset, cd.coord.drawmode, &draw.red);
		register double tTop2 = ERRORVAL;
		register int iCurve = 0;  // top curve
		if (xpos >= dig.x[0][iCurve] && xpos <= dig.x[dig.nPoint[0] - 1][iCurve]) {
			for (j = 0; j < dig.nPoint[iCurve] - 1; j++) {
				if (xpos >= dig.x[j][iCurve] && xpos <= dig.x[j + 1][iCurve]) {
					register float dx = dig.x[j + 1][iCurve] - dig.x[j][iCurve];
					tTop2 = (dx > 0.00001f) ? (dig.t[j][iCurve] + (dig.t[j + 1][iCurve] - dig.t[j][iCurve]) / dx * (xpos - dig.x[j][iCurve])) : dig.t[j][iCurve];
					break;
				} // if
			} // for j
		}

		register double tBot2 = ERRORVAL;
		if (dig.totCurve > 1) {
			iCurve = 1;  // bottom curve
			if (xpos >= dig.x[0][iCurve] && xpos <= dig.x[dig.nPoint[iCurve] - 1][iCurve]) {
				for (j = 0; j < dig.nPoint[iCurve] - 1; j++) {
					if (xpos >= dig.x[j][iCurve] && xpos <= dig.x[j + 1][iCurve]) {
						register float dx = dig.x[j + 1][iCurve] - dig.x[j][iCurve];
						tBot2 = (dx > 0.00001f) ? (dig.t[j][iCurve] + (dig.t[j + 1][iCurve] - dig.t[j][iCurve]) / dx * (xpos - dig.x[j][iCurve])) : dig.t[j][iCurve];
						break;
					} // if
				} // for j
			} // if
		}

		for (i = 0; i < numsamp; i++) {
			// now need to decide if the point (xpos, ypos) is inside the area defined by struct dig
			// if outside, then set tr2.dat.data[] to zero.
			if (tTop2 < -9999.) {
				tr2.dat.data[i] = 0.0f;
				continue;
			}

			// note: tTop is screen time without considering reducing velocity at all
			register double ypos = (float)(i*aratio + tShift) - tReduced;
			if (dig.totCurve == 1) {
				// only 1 curve exists, so we only chop based on the first curve
					if (isKeepBelowOrInside && ypos < tTop2) {
						tr2.dat.data[i] = 0.0f;
						continue;
					}
					else if (!isKeepBelowOrInside && ypos > tTop2) {
						tr2.dat.data[i] = 0.0f;
						continue;
					}
			}
			else {
				// 2 curves case
				if (tBot2 < -9999.) {
					tr2.dat.data[i] = 0.0f;
					continue;
				}

				if (tTop2 > tBot2) {
					// need to reverse the top and bottom
					SWITCH_DOUBLE(tTop2, tBot2);
				}

				if (isKeepBelowOrInside) {
					if (ypos < tTop2 || ypos > tBot2) {
						tr2.dat.data[i] = 0.0f;
					}
				}
				else {
					if (ypos > tTop2 || ypos < tBot2) {
						tr2.dat.data[i] = 0.0f;
					}
				}
			}

		} // for i

		// ****************end of chopping
		if (bh.format == 1) {
			float_to_ibm((int *)tr2.dat.data, (int *)tr2.dat.data, (int)numsamp);
		}

		memcpy(&tr2, &tr, 240);
		if (isHalfOffsets) {
			// if here, I need to adjust the trace start time, and the distance to match the veolcity model
			// double a = tShift - tReduced;
			tr2.setTraceDelayF(tShift - tReduced);
			tr2.setDistance(xpos); // note that the trace distance is different from xpos because of the half offset mode
		}
		tr2.ns = numsamp;
		file2.Write(&tr2, 240);
		file2.Write(&tr2.dat.data, numsamp * 4);

		// progress control. Do not change
		curBytesRead = file.Seek(0, CFile::current);
		int iPos = (int)((double)curBytesRead / (double)totBytesRead*100.);
		if (iPos < 0)iPos = 0;
		if (iPos > 100)iPos = 100;
		pFrame->SetProgress(iPos);
	}	// while


	if (file) file.Close();
	if (file2) file2.Close();
	if (pFrame) pFrame->EndProgress();

	AfxMessageBox(_T("Chopped file is output as ") + outFile);

}


int CSeisWideDoc::setShotsFromCoherency(CStringArray *sarray,
	int *filej,
	int *shotk, float *shotDist,
	int numShotIn, int numShotOut,
	int iwin1, int iwin2,
	int itauHalf, int itauInc,
	float freq1, float freq2,
	float distMaxPreferred)
{
	// this routine has not considered IBM floating point issue?????!!!!!

	// now we have too (~100) many traces: numShotIn traces as indicated in the arrays filej[] and shotk[].
	// we need to reduce it to numShotOut traces to stack, based on the maximum coherent traces
	// in a small time window [iwin1, iwin2]
	// the results will be stored in the first numShotOut values in the arrays sarray[], filej[], shotk[]

	// the actual number of traces will be returned!
	if (numShotIn < 1) return 0;
	if (numShotIn <= numShotOut) numShotOut = numShotIn;
	if (numShotOut == 1) return 1; // no need to bother with 1 trace only to process
	if (iwin1 < 0) iwin1 = 0;
	int lenWin = iwin2 - iwin1 + 1;
	float **trSegy = (float **)ealloc2float(lenWin, numShotIn);
	memset((void *)trSegy[0], (int) '\0', sizeof(float)*lenWin*numShotIn);
	float *trEnergy = (float *)ealloc1float(numShotIn);

	// now loop through the same loops
	int aj, ii, i, j, k;
	for (aj = 0; aj < numShotIn; aj++)
	{
		j = filej[aj];
		k = shotk[aj];

		// found a trace to sum for trace i. 
		CString aName = sarray->GetAt(j);
		aName.Replace(_T(".xls"), _T(".SG0")); // aName is now the segy file to sum
		if (!isFileExistNotDirectory(aName)) continue;

		// segy file exist and we need to grab its related trace
		CFile file;
		if (!file.Open(aName, CFile::modeRead | CFile::typeBinary | CFile::shareDenyNone)) {
			continue;
		}
		file.Seek(3200L, CFile::begin);
		bhed bh;
		file.Read(&bh, 400);
		if (bh.hdt == 0) bh.hdt = bh.dto;
		int tpp = bh.hdt;
		int sampByte = (bh.format != 3) ? 4 : 2;
		int lenByte = bh.hns*sampByte;


		// now search for trace number k for segy aName 
		if (file.Seek(k*lenByte + 3600L + iwin1*sizeof(float), CFile::begin) < 0) continue;


		// now trace number k is found
		if (file.Read(&trSegy[aj][0], lenWin*sizeof(float)) == (UINT)lenWin*sizeof(float)) {
			// first, convert from big endian to small endian
			for (ii = 0; ii < lenWin; ii++)
				swap_float_4((float *)&trSegy[aj][ii]);


			filterTimeDomain(&trSegy[aj][0], lenWin, freq1, freq2, tpp);


			// always normalize to a median of 1.0 for proper calculation
			double aMedian = getMedianAbsolute(&trSegy[aj][0], lenWin);
			if (aMedian > MINAMP) {
				aMedian = (1. / aMedian);
				for (ii = 0; ii < lenWin; ii++) {
					trSegy[aj][ii] *= (float)aMedian;
				}
			}
		} // if (file.Read(&tr

		file.Close();

		trEnergy[aj] = 0.f;
		for (ii = 0; ii < lenWin; ii++) {
			trEnergy[aj] += trSegy[aj][ii] * trSegy[aj][ii];
		}
	} // for aj

	// now start calc semblence
	float **semb = (float **)ealloc2float(numShotIn, numShotIn);
	for (i = 0; i < numShotIn; i++) {
		semb[i][i] = 2.f;  // center value in the matrix shall not be used
		for (j = 0; j < i; j++) {
			semb[i][j] = semb[j][i];
		}
		for (j = i + 1; j < numShotIn; j++) {
			// given trace i, and need to computer its maximum semblence with trace j --> semb[i][j]
			//    note that we allow a static shift itau that ranges in a small window [iwin1, iwin2]
			semb[i][j] = 0.f;

			// nom = (a1+b1)**2 + (a2+b2)**2 + (a3+b3)**2 + (a4+b4)**2;
			// denom = (a1**2+b1**2 + a2**2+b2**2 + a3**2+b3**2 + a4**2+b4**2) / 2;
			double denom = trEnergy[i] + trEnergy[j];
			if (denom > MINAMP) {
				// loop through the itau
				double sumMax = 0.;
				for (int itau = -itauHalf; itau <= itauHalf; itau++) {
					double nom = 0.;
					for (int iwin = 0; iwin < lenWin; iwin++) {
						int jwin = itau + iwin;
						if (jwin >= 0 && jwin < lenWin) {
							double a = trSegy[i][iwin] + trSegy[j][jwin];
							nom += a*a;
						}
					}
					if (sumMax < nom) sumMax = nom;
					itau += (itauInc - 1);
				} // itau
				semb[i][j] = (float)(sumMax / denom);
			} // if denom
		} // for j
	} // for i
	free2float(trSegy);
	free1float(trEnergy);


	// now, from numShotIn traces, we need to sort out only numShotOut traces, 
	// and put them into the first numShotOut elements in the 3 input arrays

	// first find out "popularity" of each trace relative to all its nabours
	float *semb2 = (float *)ealloc1float(numShotIn);
	for (i = 0; i < numShotIn; i++)
	{
		semb2[i] = 0.f;
		for (j = 0; j < numShotIn; j++) {
			if (j != i)
				semb2[i] += semb[i][j];
		}
	}
	free2float(semb); // 2D array semb is no use any more

	// search for only numShotOut maximum semblence and store the indice in index2[]
	int *index2 = (int *)ealloc1int(numShotOut);
	int *filej2 = (int *)ealloc1int(numShotOut);
	int *shotk2 = (int *)ealloc1int(numShotOut);
	float *shotDist2 = (float *)ealloc1float(numShotOut);



	// note: numShotOut only if there are more than 1 traces matching, we select the traces
	//  with a maximum distance of distMaxPreferred. Another limit is <=numShotOut traces are needed


	// first, determine how many maximum traces to output
	// note: shotDist[]  is already distance in meters squared
	distMaxPreferred *= distMaxPreferred;
	int numOfPreferred = 0;
	for (i = 0; i < numShotIn; i++) {
		if (shotDist[i] <= distMaxPreferred) {
			numOfPreferred++;
		}
	}
	if (numOfPreferred < numShotOut) numShotOut = numOfPreferred;
	if (numShotOut < 1) numShotOut = 1;


	// now do the assigning
	for (i = 0; i < numShotOut; i++) {
		index2[i] = i;
	}
	for (i = numShotOut; i < numShotIn; i++) {
		for (int ii = 0; ii < numShotOut; ii++) {
			int index4Out = index2[ii];
			// weight the semblence according to distance
			// double a = (shotDist[index4Out]+1.)/(shotDist[i]+1.);
			if (shotDist[index4Out] * semb2[i] > shotDist[i] * semb2[index4Out]) {
				index2[ii] = i;
				break;
			}
		}
	}

	for (i = 0; i < numShotOut; i++) {
		filej2[i] = filej[index2[i]];
		shotk2[i] = shotk[index2[i]];
		shotDist2[i] = shotDist[index2[i]];
	}

	for (i = 0; i < numShotOut; i++) {
		filej[i] = filej2[i];
		shotk[i] = shotk2[i];
		shotDist[i] = shotDist2[i];
	}

	free1int(filej2);
	free1int(shotk2);
	free1float(shotDist2);
	free1int(index2);
	free1float(semb2);

	return numShotOut;
}

BOOL CSeisWideDoc::DrawStackVelocity(CDC* pDC)
{
	// this function is just for testing any codes.
	cd.coord.drawmodeOld = cd.coord.drawmode;
	cd.coord.drawmode = -1;












	// first define the desired seismic line
	CIniReader iniReader(_T("F:\\data\\cook\\Logger.ini"));
	CString szName = iniReader.ReadString(_T("Setting"), _T("Name"), BLANK);
	int iAge = iniReader.ReadInteger(_T("Setting"), _T("Age"), 25);
	float fltHieght = iniReader.ReadFloat(_T("Setting"), _T("Height"), 1.80f);
	bool bMarriage = iniReader.ReadBoolean(_T("Setting"), _T("Marriage"), true);

	const int MAX_SUM = iniReader.ReadInteger(_T("Setting"), _T("MAX_SUM"), 1);
	CString outDir = iniReader.ReadString(_T("Setting"), _T("outDir"), _T("F:\\data\\cook"));
	CString outName = iniReader.ReadString(_T("Setting"), _T("outName"), _T("out1.sgy"));
	const int numShotStack = iniReader.ReadInteger(_T("Setting"), _T("numShotStack"), 12);
	const float distMaxPreferred = iniReader.ReadFloat(_T("Setting"), _T("distMaxPreferred"), 0.4f);

	const float winCoh1 = iniReader.ReadFloat(_T("Setting"), _T("winCoh1"), 0.3f);
	const float winCoh2 = iniReader.ReadFloat(_T("Setting"), _T("winCoh2"), 1.3f);

	const float twmin = iniReader.ReadFloat(_T("Setting"), _T("twmin"), 2.6f);  // small window for the limeline
	const float twmax = iniReader.ReadFloat(_T("Setting"), _T("twmax"), 2.9f);

	const float tauMax = iniReader.ReadFloat(_T("Setting"), _T("tauMax"), 0.15f); // max window for computing cohency of traces for static shift

	const float freq1 = iniReader.ReadFloat(_T("Setting"), _T("freq1"), 10.0f);
	const float freq2 = iniReader.ReadFloat(_T("Setting"), _T("freq2"), 90.0f);

	const bool isCoherency = iniReader.ReadBoolean(_T("Setting"), _T("isCoherency"), false);
	const bool isRemoveTimeline = iniReader.ReadBoolean(_T("Setting"), _T("isRemoveTimeline"), false);
	const double distInc = iniReader.ReadFloat(_T("Setting"), _T("distInc"), 100.f);  // every 100 meters we want a trace
	const double distSum = iniReader.ReadFloat(_T("Setting"), _T("distSum"), 2000.f);  // any trace that falls in a 1000 meter circle will be summed

	// hard code the 4 corners
	const double lon1 = iniReader.ReadFloat(_T("Setting"), _T("lon1"), -85.25f);
	const double lon2 = iniReader.ReadFloat(_T("Setting"), _T("lon2"), -79.1985935f);
	const double lat1 = iniReader.ReadFloat(_T("Setting"), _T("lat1"), 83.367f);
	const double lat2 = iniReader.ReadFloat(_T("Setting"), _T("lat2"), 83.7579465f);


	/*
	// my first successful line: shorter, southern part
	double lon1 = -82.6293;
	double lon2 = -79.1985935;
	double lat1 = 83.5314185;
	double lat2 = 83.7579465;
	cart1[0] = -277360.;
	cart2[0] = -228729.;
	cart1[1] = -665357.;
	cart2[1] = -656874.;
	which is at:
	(-82.6293, 83.5314185)
	(-79.1985935, 83.7579465)
	*/



	//***********************************************//
	CString newName = outDir + outName;
	newName.Replace(_T(".sgy"), _T("_Nav.txt"));
	FILE *stream;
	if (_tfopen_s(&stream, newName, _T("w")) != 0)
	{
		AfxMessageBox(_T("The new file was not opened"), MB_ICONQUESTION);
		return FALSE;
	}

	newName = outDir + outName;
	newName.Replace(_T(".sgy"), _T("_Nav2.txt"));
	FILE *stream2;
	if (_tfopen_s(&stream2, newName, _T("w")) != 0) return FALSE;

	double *cart1 = convLatlon2XY(lon1, lat1);
	double *cart2 = convLatlon2XY(lon2, lat2);
	double distSum2 = distSum*distSum;

	double x1 = cart1[0];
	double x2 = cart2[0];
	double y1 = cart1[1];
	double y2 = cart2[1];

	// pre-calculate
	double distTotal = sqrt((x1 - x2)*(x1 - x2) + (y1 - y2)*(y1 - y2));
	double dx = distInc / distTotal * (x2 - x1);
	double dy = distInc / distTotal * (y2 - y1);
	int numTotal = (int)((distTotal / distInc) + 1.5);  // 1813 traces


	// calculate an area for stacking, for outputting a rectangle only, no other use
	double dxxPlot = distSum * (y1 - y2) / distTotal;
	double dyyPlot = distSum * (x2 - x1) / distTotal;


	// put all related file path names in CStringArray
	CStringArray *sarrayRaw = getAllPathArray(outDir);
	CStringArray 	*sarray = new CStringArray();
	sarray->RemoveAll();		// Not really necessary - Just habit
	int j;
	for (j = 0; j < sarrayRaw->GetSize(); j++) {
		CString aNameExcel = sarrayRaw->GetAt(j);
		aNameExcel.MakeLower();
		if (aNameExcel.Right(4) == _T(".xls")) {
			CString aName = aNameExcel;
			aName.Replace(_T(".xls"), _T(".SG0")); // aName is now the segy file 
			if (isFileExistNotDirectory(aName)) {
				sarray->Add(aNameExcel);
				_ftprintf_s(stream, _T("%s\n"), (LPCTSTR)aNameExcel);
			}
		}

	}
	sarrayRaw->RemoveAll();
	delete sarrayRaw;

	_ftprintf_s(stream, _T("\n\nThe follow lists all existing control points in Cartesion coordinates:\n"));

	// first count how many Excel files
	int numExcel = (int)sarray->GetSize();

	// now convert the lat long inside Segy/XLS files into double arrays.
	// note: there are numExcel files, with each file containing a few coordinates
	int *nShotSegy = (int *)ealloc1int(numExcel);

	// assuming a maximum of MAXSHOT shots in each segy file
	static int MAXSHOT = 1200;
	float **xxSegy = (float **)ealloc2float(MAXSHOT, numExcel);
	float **yySegy = (float **)ealloc2float(MAXSHOT, numExcel);

	// loop through all files to locate related shots
	CStringArray colTrace;
	CStringArray colLat;
	CStringArray colLon;
	for (j = 0; j < numExcel; j++)
	{
		CString aNameExcel = sarray->GetAt(j);
		// now let's read the XLS file
		CSpreadSheet *SS = new CSpreadSheet(aNameExcel, _T("Sheet1"));
		SS->ReadColumn(colTrace, 1);
		SS->ReadColumn(colLat, 6);
		SS->ReadColumn(colLon, 7);
		delete SS;

		int nShotInExcel = 0;
		int aNum = (int)colTrace.GetSize();
		int k;
		nShotSegy[j] = -1;
		// the first row is header in Excel
		for (k = 1; k < aNum; k++) {
			if (colTrace.GetAt(k) == BLANK) {
				nShotInExcel = k - 1;
				nShotSegy[j] = _tstoi(colTrace.GetAt(k - 1)); // total number of shot for a segy
				break;
			}
		}
		if (nShotSegy[j] < 0) {
			// this means that the Excel collumn does not contain extra blank cells
			nShotSegy[j] = _tstoi(colTrace.GetAt(aNum - 1));
			nShotInExcel = aNum - 1;
		}
		if (nShotSegy[j] > MAXSHOT) {
			CString tmp;
			tmp.Format(_T("Shot number is large: %d in Excel File: %s"), nShotSegy[j], aNameExcel);
			AfxMessageBox(tmp);
		}

		// local arrays
		int *trcInExcel = (int *)ealloc1int(nShotInExcel);
		float *xxInExcel = (float *)ealloc1float(nShotInExcel);
		float *yyInExcel = (float *)ealloc1float(nShotInExcel);

		for (k = 0; k < nShotInExcel; k++) {
			// CString trc = colTrace.GetAt(k);
			trcInExcel[k] = _tstoi(colTrace.GetAt(k + 1));
		}
		// Trace number collumn always has 1 more value (i.e. the last shot number)
		for (k = 0; k < nShotInExcel - 1; k++) {
			CString tmp = colLon.GetAt(k + 1);
			//	yySegy[j][k-1] = (float)_tstof(colLat.GetAt(k+1));
			double *a = convLatlon2XY(_tstof(colLon.GetAt(k + 1)), _tstof(colLat.GetAt(k + 1)));
			xxInExcel[k] = (float)a[0];
			yyInExcel[k] = (float)a[1];
			free1double(a);
			//	_ftprintf_s(stream, _T("%f %f\n", xxInExcel[k], yyInExcel[k]);
			//	_ftprintf_s(stream2, _T("%s %s\n", colLon.GetAt(k+1), colLat.GetAt(k+1));
		}
		// _ftprintf_s(stream2, _T(">\n");
		if (nShotInExcel < 3) {
			_ftprintf_s(stream, _T("    %s has too little navigation information for a usccessful interpolation\n"), (LPCTSTR)aNameExcel);
		}

		// construct segy trace sequence for the current Excel file, 
		// loop thru each segy trace, starting with 1, increment by 1
		int s;
		for (s = 1; s <= nShotSegy[j]; s++) {
			// for each segy trace s, search  where it belongs to a shot in Excel file
			// s exactly corresponds to the actual shot number starting with 1

			if (nShotInExcel < 3) {
				/*
				// note: if k2=nShotInExcel-1, then only trcInExcel[k2] has value, but xxInExcel[k2] will not
				trace	LAT. (DEG)	LONG. (DEG)
				72	    83.615	-81.281
				178

				for this, nShotInExcel=2
				*/
				xxSegy[j][s - 1] = (float)(xxInExcel[0] + 100. *(s - trcInExcel[0]));  // 100 is kind of arbitrary
				yySegy[j][s - 1] = (float)(yyInExcel[0] + 100. *(s - trcInExcel[0]));  // 100 is kind of arbitrary
			}
			else {
				/*
				trace	LAT. (DEG)	LONG. (DEG)
				109	    83.451	-84.347				row=0
				253	    83.45	-84.352				row=1
				397		83.45	-84.357				row=2
				541		83.45	-84.35				row=4
				542									row=5
				*/
				int row1 = -1;
				int row2 = 99999;
				if (s == nShotSegy[j]) {
					int aaa = 1;
				}
				for (int row = 0; row < nShotInExcel; row++) {
					if (s <= trcInExcel[row]) {
						if (row == 0) {
							row1 = row;
							row2 = row + 1;
							// since we have at least 2 rows, row+1 must exist already
						}
						else if (row == nShotInExcel - 1) {
							// last row is different
							row1 = row - 2;
							row2 = row - 1;
						}
						else {
							row1 = row - 1;
							row2 = row;
						}
						break;
					}
				}
				if (row1 >= 0) {
					// found coordinates to interpolate. Note that trace numbers are integers
					// need to cast to double before division
					double avalue = (double)(s - trcInExcel[row1]) / (double)(trcInExcel[row2] - trcInExcel[row1]);
					xxSegy[j][s - 1] = (float)(xxInExcel[row1] + avalue*(xxInExcel[row2] - xxInExcel[row1]));
					yySegy[j][s - 1] = (float)(yyInExcel[row1] + avalue*(yyInExcel[row2] - yyInExcel[row1]));
				}
			} // else
		} // for s

		// fix since I have found all segy file j has its first and last trace swapped
		int n = nShotSegy[j];
		for (s = 0; s < n / 2; s++) {
			int s2 = n - s - 1;
			float a = xxSegy[j][s];
			xxSegy[j][s] = xxSegy[j][s2];
			xxSegy[j][s2] = a;
			a = yySegy[j][s];
			yySegy[j][s] = yySegy[j][s2];
			yySegy[j][s2] = a;
		} // for s

		free1int(trcInExcel);
		free1float(xxInExcel);
		free1float(yyInExcel);

		// now print out the line positions in the excel file
		_ftprintf_s(stream, _T("%f %f\n"), xxSegy[j][0], yySegy[j][0]);
		_ftprintf_s(stream, _T("%f %f\n"), xxSegy[j][nShotSegy[j] - 1], yySegy[j][nShotSegy[j] - 1]);


		bool isACloser2FirstShot = true;
		double *c = convLatlon2XY(_tstof(colLon.GetAt(1)), _tstof(colLat.GetAt(1)));
		double *d = convLatlon2XY(_tstof(colLon.GetAt(nShotInExcel - 1)), _tstof(colLat.GetAt(nShotInExcel - 1)));
		if ((pow(xxSegy[j][0] - c[0], 2) + pow(yySegy[j][0] - c[1], 2)) > (pow(xxSegy[j][0] - d[0], 2) + pow(yySegy[j][0] - d[1], 2))) isACloser2FirstShot = false;
		/*
		if (colLon.GetAt(1) == _T("-83.851") {
		int yyyyyy = 1;
		}
		*/
		double *a = convXY2Latlon(xxSegy[j][0], yySegy[j][0]);
		double *b = convXY2Latlon(xxSegy[j][nShotSegy[j] - 1], yySegy[j][nShotSegy[j] - 1]);
		if (isACloser2FirstShot)
			_ftprintf_s(stream2, _T("%f %f %d %s\n"), a[0], a[1], 1, (LPCTSTR)sarray->GetAt(j));
		else
			_ftprintf_s(stream2, _T("%f %f %d %s\n"), b[0], b[1], 1, (LPCTSTR)sarray->GetAt(j));

		for (k = 0; k < nShotInExcel - 1; k++) {
			_ftprintf_s(stream2, _T("%s %s\n"), (LPCTSTR)colLon.GetAt(k + 1), (LPCTSTR)colLat.GetAt(k + 1));
		}

		double ax = xxSegy[j][0] - xxSegy[j][nShotSegy[j] - 1];
		double ay = yySegy[j][0] - yySegy[j][nShotSegy[j] - 1];
		if (isACloser2FirstShot)
			_ftprintf_s(stream2, _T("%f %f %d %f\n"), b[0], b[1], nShotSegy[j], (float)sqrt(ax*ax + ay*ay)*0.001);
		else
			_ftprintf_s(stream2, _T("%f %f %d %f\n"), a[0], a[1], nShotSegy[j], (float)sqrt(ax*ax + ay*ay)*0.001);
		free1double(a);
		free1double(b);
		free1double(c);
		free1double(d);
		_ftprintf_s(stream2, _T(">\n"));
		// end print out the line positions in the excel file
	} // j
	colTrace.RemoveAll();
	colLat.RemoveAll();
	colLon.RemoveAll();

	// write the last few lines for the output files
	//	_ftprintf_s(stream, _T("%f %f\n", x1, y1);
	//	_ftprintf_s(stream, _T("%f %f\n", x2, y2);
	//	_ftprintf_s(stream, _T(">\n");
	_ftprintf_s(stream, _T("%f %f\n"), x1 + dxxPlot, y1 + dyyPlot);
	_ftprintf_s(stream, _T("%f %f\n"), x2 + dxxPlot, y2 + dyyPlot);
	_ftprintf_s(stream, _T("%f %f\n"), x2 - dxxPlot, y2 - dyyPlot);
	_ftprintf_s(stream, _T("%f %f\n"), x1 - dxxPlot, y1 - dyyPlot);
	_ftprintf_s(stream, _T("%f %f\n"), dxxPlot, dyyPlot);
	_ftprintf_s(stream, _T("%f %f\n"), x1 + dxxPlot, y1 + dyyPlot);
	fclose(stream);
	/*
	double *a = convXY2Latlon(x1,  y1);
	_ftprintf_s(stream2, _T("%f %f\n", a[0], a[1]);
	a = convXY2Latlon(x2,  y2);
	_ftprintf_s(stream2, _T("%f %f\n", a[0], a[1]);
	_ftprintf_s(stream2, _T(">\n");
	*/
	double *a = convXY2Latlon(x1 + dxxPlot, y1 + dyyPlot);
	_ftprintf_s(stream2, _T("%f %f\n"), a[0], a[1]);
	a = convXY2Latlon(x2 + dxxPlot, y2 + dyyPlot);
	_ftprintf_s(stream2, _T("%f %f\n"), a[0], a[1]);
	free1double(a);
	a = convXY2Latlon(x2 - dxxPlot, y2 - dyyPlot);
	_ftprintf_s(stream2, _T("%f %f\n"), a[0], a[1]);
	free1double(a);
	a = convXY2Latlon(x1 - dxxPlot, y1 - dyyPlot);
	_ftprintf_s(stream2, _T("%f %f\n"), a[0], a[1]);
	free1double(a);
	a = convXY2Latlon(x1 + dxxPlot, y1 + dyyPlot);
	_ftprintf_s(stream2, _T("%f %f\n"), a[0], a[1]);
	free1double(a);
	_ftprintf_s(stream2, _T(">\n"));


	// now compute the desired shot locations; we use meters as unit
	double *xxOut = (double *)ealloc1double(numTotal);
	double *yyOut = (double *)ealloc1double(numTotal);
	xxOut[0] = x1;
	yyOut[0] = y1;

	// define some segy structs
	segy tr, tr2;  // tr2 is for output trace with timeline removed
	bhed bh;

	// for generating an output segy, we grab the section headers from the first input segy
	CString aNameSegyRef = sarray->GetAt(0);
	aNameSegyRef.Replace(_T(".xls"), _T(".SG0"));
	CFile fileRef(aNameSegyRef, CFile::modeRead | CFile::typeBinary);
	fileRef.Read(head.ascHead, 3200L);
	fileRef.Read(&bh, 400L);
	fileRef.Close();

	// convert from unix format to PC format
	BOOL isUnix;
	if (isUnix = IsUnix(bh.format)) SwapTapeHeader(&bh);
	int numsamp = bh.hns;
	int len = numsamp*sizeof(float) + 240;
	if (bh.hdt == 0) bh.hdt = bh.dto;
	int tpp = bh.hdt; // in micro sec


	// file2 is the output file handler. It must already have existed.
	// This is because we cannot guarantee that the first trace of the output is not blank
	CFile file2;
	if (!file2.Open(outDir + outName, CFile::modeWrite | CFile::modeCreate | CFile::typeBinary)) {
		return FALSE;
	}

	ebc2asc(head.ascHead, 3200);
	file2.Write(head.ascHead, 3200L);
	file2.Write(&bh, 400L);

	// file2.Seek(3600L, CFile::begin);

	//Begin progress control.
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	ASSERT(pFrame);
	ASSERT_KINDOF(CMainFrame, pFrame);
	pFrame->BeginProgress();

	// define a small time window to cut the scale line. The timeline occurs only between
	// 2.5-2.9 sec, slightly floated. The final cut-off width is twdt=0.08  sec
	int itauMax = (int)(tauMax * MIL / tpp + 0.5);  // maximum static shift, used for coherency mixing window
	int itauMaxHalf = itauMax / 2;
	itauMax = itauMaxHalf * 2 + 1; // must be an even number
	int itauInc = 2;  // to save CPU time, we do not calculate cohenrncy for every delay
	int itwdt = (int)(0.12 * MIL / tpp + 0.5); // a small time window to cut the scale line
	int itwmin = (int)(twmin * MIL / tpp + 0.5);

	int iwinCoh1 = (int)(winCoh1 * MIL / tpp + 0.5);
	int iwinCoh2 = (int)(winCoh2 * MIL / tpp + 0.5);


	int itwmax = (int)(twmax * MIL / tpp + 0.5);
	double ax, ay, adist2, totxweight;
	float *trsqrt = (float *)ealloc1float(numsamp);
	float *tr2sqrt = (float *)ealloc1float(numsamp);
	float **trcorr = (float **)ealloc2float(numsamp, itauMax);


	// store a maximum of 24 shots number as k. Each shot has a excel file numbered as j
	int *filej = (int *)ealloc1int(MAX_SUM);
	int *shotk = (int *)ealloc1int(MAX_SUM);
	float *shotDist = (float *)ealloc1float(MAX_SUM);

	// now loop thru all desired shot points
	CTime time0 = CTime::GetCurrentTime();
	for (int i = 1; i < numTotal; i++) {
		// the output trace reset to 0
		_ftprintf_s(stream2, _T("\nTrace %d"), i);
		CTime TimeStart = CTime::GetCurrentTime();
		memset((void *)&tr2, (int) '\0', len);
		//	memset((void *)&tr2Ref,(int) '\0',len); 
		totxweight = 0.;
		int numSum = 0;

		xxOut[i] = xxOut[i - 1] + dx;
		yyOut[i] = yyOut[i - 1] + dy;

		// precalculate the arrays
		int numShot2Sum = 0;
		for (int jb = 0; jb < numExcel; jb++) {
			// For each Excel file jb, we have a number of shots kb to process
			// look for related traces in a circle of  distSum  to sum up
			// from point (xx[i], yy[i])   to   (xxSegy[j][k], yySegy[j][k])
			for (int kb = 0; kb < nShotSegy[jb] - 1; kb++) {
				ax = xxOut[i] - xxSegy[jb][kb];
				ay = yyOut[i] - yySegy[jb][kb];
				adist2 = ax*ax + ay*ay;
				if (adist2 < distSum2) {
					// found a trace to sum for trace i. 
					if (numShot2Sum >= MAX_SUM) {
						// now, more than 24 traces fit, but we only need 24 traces to stack.
						// so we choose the closest traces
						setShotsFromDist(&filej[0], &shotk[0], &shotDist[0], numShot2Sum, jb, kb, (float)adist2);
						// after coming to here, numShot2Sum will not increase any more!!!
					}
					else {
						filej[numShot2Sum] = jb;
						shotk[numShot2Sum] = kb;
						shotDist[numShot2Sum] = (float)adist2;
						numShot2Sum++;
					}
				}
			} // k
		} // jb

		if (numShot2Sum > 0) {
			// print out the nav
			_ftprintf_s(stream2, _T("\n   Trace %d : total of %d nearby traces:"), i, numShot2Sum);
			for (int cj = 0; cj < numShot2Sum; cj++) {
				int j = filej[cj];
				int k = shotk[cj];
				CString aName = sarray->GetAt(j);
				aName.Replace(_T(".xls"), _T(".SG0")); // aName is now the segy file to sum
				if (!isFileExistNotDirectory(aName)) continue;
				a = convXY2Latlon(xxSegy[j][k], yySegy[j][k]);
				_ftprintf_s(stream2, _T("\n   %f %f "), a[0], a[1]);
				free1double(a);
				_ftprintf_s(stream2, _T(" %d %d %f %s"), i, k, (float)sqrt(shotDist[cj]), (LPCTSTR)aName);
			}


			// now we have too (~100) many traces: numShot2Sum traces as indicated in the arrays filej[] and shotk[].
			// we need to reduce it to ~12 traces to stack, based on the maximum coherent traces
			int numReturned = setShotsFromCoherency(sarray, &filej[0], &shotk[0], &shotDist[0], numShot2Sum, numShotStack, iwinCoh1, iwinCoh2, itauMaxHalf, itauInc, freq1, freq2, distMaxPreferred);


			// now loop through the same loops
			_ftprintf_s(stream2, _T("\n Trace %d : total of %d stacked traces (Long Lat Trc TrcExcel DistInMeter NameSgyRaw):"), i, numReturned);
			for (int aj = 0; aj < numReturned; aj++) {
				int j = filej[aj];
				int k = shotk[aj];

				// found a trace to sum for trace i. 
				CString aName = sarray->GetAt(j);
				aName.Replace(_T(".xls"), _T(".SG0")); // aName is now the segy file to sum
				if (!isFileExistNotDirectory(aName)) continue;

				// print out the nav
				a = convXY2Latlon(xxSegy[j][k], yySegy[j][k]);
				_ftprintf_s(stream2, _T("\n %f %f "), a[0], a[1]);
				free1double(a);
				_ftprintf_s(stream2, _T(" %d %d %f %s"), i, k, (float)sqrt(shotDist[aj]), (LPCTSTR)aName);

				// segy file exist and we need to grab its related trace
				CFile file;
				if (!file.Open(aName, CFile::modeRead | CFile::typeBinary | CFile::shareDenyNone)) {
					continue;
				}

				// now search for trace number k for segy aName 
				if (file.Seek(k*len + 3600L, CFile::begin) > 0) {
					// now trace number k is found
					if (file.Read(&tr, len) == (UINT)len) {
						// first, convert from big endian to small endian

						if (isUnix) {
							SwapTraceHeader(false, false, false, &tr);
							SwapN(&tr.dat, bh.format, numsamp);
						}
						if (bh.format == 1)
							ibm_to_float((int *)tr.dat.data, (int *)tr.dat.data, (int)numsamp);
						filterTimeDomain(&tr.dat.data[0], numsamp, freq1, freq2, tpp);


						// now we need to calculate remove the timeline within a small windows of twdt=0.08 sec 
						// this actual window should be between  itwmin and itwmax
						//	double sum2 = 0.;
						if (isRemoveTimeline) {
							removeTimeLine(&tr.dat.data[0], itwmin, itwmax, itwdt);
						} // if isRemoveTimeline

						if (aj == 0) {
							// first trace, no need to mix anything
							for (int ii = 0; ii<numsamp; ii++) {
								tr2.dat.data[ii] = tr.dat.data[ii];
							}
						}
						else {
							// first, we should normalize the tr.dat to balance with tr2.dat
							double temp2 = getMedianAbsolute(&tr2.dat.data[0], numsamp);
							double temp = getMedianAbsolute(&tr.dat.data[0], numsamp);

							double aMedian = 0.; // the desired output median to use
							if (temp > MINAMP && temp2 > MINAMP)
								aMedian = (temp + temp2)*0.5;
							else if (temp2 > MINAMP)
								aMedian = temp2;
							else
								aMedian = temp;

							temp = (temp > MINAMP) ? (aMedian / temp) : 1.;
							if (temp != 1.) {
								for (int ii = 0; ii<numsamp; ii++) {
									tr.dat.data[ii] *= (float)temp;
								}
							}

							temp2 = (temp2>MINAMP) ? (aMedian / temp2) : 1.;
							if (temp2 != 1.) {
								for (int ii = 0; ii < numsamp; ii++) {
									tr2.dat.data[ii] *= (float)temp2;
								}
							}

							// first prepare a few arrays data. This is because the multiplication
							// takes much longer CPU time
							// tr2 is the reference trace
							int ii;
							for (ii = itwmin - itauMaxHalf; ii <= itwmax + itauMaxHalf; ii++) {
								// I know that ii will not exceed the limits of the arrays, so it's ok
								trsqrt[ii] = tr.dat.data[ii] * tr.dat.data[ii];
								tr2sqrt[ii] = tr2.dat.data[ii] * tr2.dat.data[ii];
							}

							int itau;
							for (itau = -itauMaxHalf; itau <= itauMaxHalf; itau++) {
								// indexTau is actual index in the array for tau
								// itau is the actual delay in number of samples
								int indexTau = itau + itauMaxHalf;
								for (ii = itwmin - itauMaxHalf; ii <= itwmax + itauMaxHalf; ii++) {
									// for each ii, there is a range of itauMax tau values
									float a = tr2.dat.data[ii];
									int jj = ii + itau;
									if (jj >= 0 && jj < numsamp) {
										a += tr.dat.data[jj];
									}
									trcorr[indexTau][ii] = a*a;
								}
							}



							// now we need to coherency mixing for applying sttaic shift
							// we base it on the timeline within a small windows of itauMax (~33 samples) 
							// we only consider 2 traces: tr2.dat.data[]  and tr.dat.data[]
							// Window of cohenrency: itwmin, itwmax, in between (i.e. 2.6-2.9 sec) there is a strong timeline
							int itauChosen = 0;  // this default means no delay
							double cohChosen = 0.;
							double cohChosenNoWeight = 0.;
							for (itau = -itauMaxHalf; itau <= itauMaxHalf; itau++) {
								// nom = (a1+b1)**2 + (a2+b2)**2 + (a3+b3)**2 + (a4+b4)**2;
								// denom = (a1**2+b1**2 + a2**2+b2**2 + a3**2+b3**2 + a4**2+b4**2) / 2;
								double nom = 0.;
								double denom = 0.;
								int indexTau = itau + itauMaxHalf;
								for (int iwin = itwmin; iwin <= itwmax; iwin++) {
									nom += trcorr[indexTau][iwin]; // trcorr[] index must start from 0
									denom += tr2sqrt[iwin] + trsqrt[iwin + itau];
								}

								if (denom > MINAMP) {
									double cohNoWeightThis = nom / denom * 2.;
									double tweight = (1. - fabs((double)itau) / (float)itauMaxHalf);
									double cohThis = cohNoWeightThis*tweight*tweight;
									// note: this weighting is very important for proper results

									// if sum3==2, it means one of the 2 traces is all zero
									// if sum3==4, the 2 traces are exactly equal
									// if sum3==0, the 2 traces are reversed polarity
									if (fabs(cohThis - 2.) > MINAMP && cohThis > cohChosen) {
										cohChosen = cohThis;
										cohChosenNoWeight = cohNoWeightThis;
										itauChosen = itau;
									}
								}
							} // itau
							// tr2Ref.dat.data[ii] = (float)itauChosen; // this is actually the time shifts in number of samples
							// tr2Semb.dat.data[ii] = (float)sum2;

							// do the final mixing
							// itauChosen = 0;  // testing
							for (ii = 0; ii < numsamp; ii++) {
								int jj = itauChosen + ii;
								if (jj >= 0 && jj<numsamp) {
									// tr2.dat.data[ii] = (tr2.dat.data[ii] + tr.dat.data[jj]) * 0.5f;
									tr2.dat.data[ii] += tr.dat.data[jj];
									//	tr2.dat.data[ii] *= 0.5f; // no need since we will normalize it later
								}
								else {
									// do nothing
									//	tr2.dat.data[ii] = 0.f;
								}

								// multiple by the semblence
								if (isCoherency) {
									if (cohChosen > MINAMP)
										tr2.dat.data[ii] *= (float)cohChosenNoWeight;
								}
							}

							// rescale the amplitude to fix the desired amplitude level
							temp = getMedianAbsolute(&tr2.dat.data[0], numsamp);
							if (temp > MINAMP) {
								float a = (float)(aMedian / temp);
								for (ii = 0; ii < numsamp; ii++) {
									tr2.dat.data[ii] *= a;
								}

								// to avoid instability of amplitudes, cut the maximum amplitude for output
								float ampMax = (float)(aMedian*10.);
								for (ii = 0; ii<numsamp; ii++) {
									if (fabs(tr2.dat.data[ii]) > ampMax)
										tr2.dat.data[ii] = ampMax;
								}
							} // if (temp > 
						}	// if (aj==0)


						numSum++;
					} // if (file.Read(&tr
				} // if (file.Seek(k*len+3600L
				file.Close();
			} // for aj
		} // if (numShot2Sum>0


		// process a few trace headers
		tr2.tracl = i;

		ax = xxOut[i] - xxOut[0];
		ay = yyOut[i] - yyOut[0];
		tr2.setDistancei((int)(sqrt(ax*ax + ay*ay) + 0.5));  // directly in meters
		tr2.cdpbak = i;

		tr2.ep = i;
		tr2.dt = (unsigned short)tpp;
		tr2.ns = (unsigned short)numSum;


		if (bh.format == 1) {
			tr2.idistopt = 8;
			float_to_ibm((int *)tr2.dat.data, (int *)tr2.dat.data, (int)tr2.ns);
		}
		file2.Write(&tr2, len);

		int iPos = (int)((double)i / (double)numTotal*100.);
		if (iPos < 0)iPos = 0;
		if (iPos > 100)iPos = 100;
		pFrame->SetProgress(iPos);

		// write info for viewing
		CTime TimeEnd = CTime::GetCurrentTime();
		CTimeSpan timeSpan = TimeEnd - TimeStart;
		_ftprintf_s(stream2, _T("\n Trace %d took %d seconds with %d traces stacked"), i, timeSpan.GetSeconds(), numSum);
		fflush(stream2);
	} // for i shot points
	pFrame->EndProgress();

	CTime time1 = CTime::GetCurrentTime();
	CTimeSpan timeSpan = time1 - time0;
	_ftprintf_s(stream2, _T("Total %d min spent\n"), timeSpan.GetMinutes());
	fclose(stream2);

	// close the array
	free1float(trsqrt);
	free1float(tr2sqrt);
	free2float(trcorr);

	free1int(filej);
	free1int(shotk);
	free1float(shotDist);

	free1double(xxOut);
	free1double(yyOut);
	sarray->RemoveAll();
	delete sarray;
	free1int(nShotSegy);
	free2float(xxSegy);
	free2float(yySegy);

	file2.Seek(3200L, CFile::begin);
	file2.Read(&bh, 400L);
	bh.setnx(numTotal);
	file2.Seek(3200L, CFile::begin);
	file2.Write(&bh, 400L);
	file2.Close();

	showFileInNotePad(newName);


	/*
	// the following code sucessfully traverse all subdirectories and
	// print out all directories and files
	char s[1000];
	CString newName = _T("F:\\a\\aTempName.txt";
	FILE *stream;
	if( _tfopen_s(&stream, newName, _T("w" ) != 0 )
	{
	AfxMessageBox( _T("The new file was not opened" );
	return FALSE;
	}


	static const TCHAR szFileToFind[] = _T("F:\\data\\cook\\*.*");

	CFileFind finder;
	BOOL bResult = finder.FindFile(szFileToFind);

	_ftprintf_s(stream, _T("Searched results for %s:\r\n", szFileToFind);
	while (bResult)
	{
	bResult = finder.FindNextFile();
	CString aName = (LPCTSTR) finder.GetFileName();
	if (aName == _T("." || aName == _T("..") continue;
	CString aPath = (LPCTSTR) finder.GetFilePath();

	_ftprintf_s(stream, _T("Path|Name is %s|%s\r\n", aPath, aName);
	if (!isFileExistNotDirectory(aName)) {
	CFileFind finder2;
	BOOL bResult2 = finder2.FindFile(aPath + _T("\\*.*");
	while (bResult2)
	{
	bResult2 = finder2.FindNextFile();
	CString aName2 = (LPCTSTR) finder2.GetFileName();
	if (aName2 == _T("." || aName2 == _T("..") continue;
	CString aPath2 = (LPCTSTR) finder2.GetFilePath();

	_ftprintf_s(stream, _T("    Path2|Name2 is %s|%s\r\n", aPath2, aName2);
	if (!isFileExistNotDirectory(aName2)) {
	CFileFind finder3;
	BOOL bResult3 = finder3.FindFile(aPath2 + _T("\\*.*");
	while (bResult3)
	{
	bResult3 = finder3.FindNextFile();
	CString aName3 = (LPCTSTR) finder3.GetFileName();
	if (aName3 == _T("." || aName3 == _T("..") continue;
	CString aPath3 = (LPCTSTR) finder3.GetFilePath();

	_ftprintf_s(stream, _T("      Path3|Name3 is %s|%s\r\n", aPath3, aName3);

	// now the files are found here. do calculation here
	//
	//
	}
	finder3.Close();
	}

	}
	finder2.Close();
	}
	_ftprintf_s(stream, _T("  Root is %s\r\n", (LPCTSTR) finder.GetRoot());

	_ftprintf_s(stream, _T("  Title is %s\r\n", (LPCTSTR) finder.GetFileTitle());
	_ftprintf_s(stream, _T("  Path is %s\r\n", aPath);
	_ftprintf_s(stream, _T("  URL is %s\r\n", (LPCTSTR) finder.GetFileURL());

	}
	finder.Close();

	_ftprintf_s(stream, _T("Original: %f %f\r\n", -78.507, 83.848);
	double *a = convLatlon2XY(-78.507,  83.848);
	_ftprintf_s(stream, _T("XY: %f %f\r\n", a[0], a[1]);
	double *b = convXY2Latlon(a[0], a[1]);
	_ftprintf_s(stream, _T("Output degrees: %f %f\r\n", b[0], b[1]);
	// alon = -78.507;
	// alat = 83.848;

	fclose(stream);
	showFileInNotePad(newName);

	*/





	/*
	CString aName = (LPCTSTR) finder.GetFileName();
	_ftprintf_s(stream, _T("  Root is %s\r\n", (LPCTSTR) finder.GetRoot());
	_ftprintf_s(stream, _T("  Title is %s\r\n", (LPCTSTR) finder.GetFileTitle());
	_ftprintf_s(stream, _T("  Path is %s\r\n", (LPCTSTR) finder.GetFilePath());
	_ftprintf_s(stream, _T("  URL is %s\r\n", (LPCTSTR) finder.GetFileURL());
	Searched results for F:\data\cook\*.*:
	Name is p181
	Directory
	Root is F:\data\cook
	Title is p181
	Path is F:\data\cook\p181
	URL is file://F:\data\cook\p181
	Name is p182
	Directory
	Root is F:\data\cook
	Title is p182
	Path is F:\data\cook\p182
	URL is file://F:\data\cook\p182
	*
	*
	*/
	return true;



	/*
	// this part is for working with Sonya. It works very well.

	TCHAR s[80];
	CString nameOffset;
	//	FILE *ifh1;

	bhed bh;
	segy tr, tr2;
	short *i2buf;
	i2buf = (short *) &tr;
	float *trcdat;
	trcdat = (float *) &i2buf[120];

	CString nameTab = _T("F:\\a\\intvel_johnPC.sgy";
	if (!isFileExistNotDirectory(nameTab)) return false;

	CFile file(nameTab, CFile::modeReadWrite | CFile::typeBinary);
	int bytesRead = file.Seek(3200L, CFile::begin);

	bytesRead = file.Read(&bh, 400);
	if (bh.hdt == 0) bh.hdt = bh.dto;
	int sampRate = bh.hdt; // in micros sec
	int ns = bh.hns;
	int iformat = bh.format;
	long nbytePerTrc = 0;
	if(iformat!=3)
	nbytePerTrc = ns*4 + 240;
	else
	nbytePerTrc = ns*2 + 240;

	int numProcessed = 0;
	float dz = bh.hdt * 0.001f; // meter
	//	int ttt  = sizeof(long);
	while (file.Read(&tr, nbytePerTrc) == (unsigned long)nbytePerTrc)
	{
	tr2.dat.data[0] = 0;
	if (tr.dat.data[0]<0.001f) tr.dat.data[0] = 1500.f;
	for (int i=1; i<ns; i++) {
	if (tr.dat.data[i]<0.00001) tr.dat.data[i] = tr.dat.data[i-1];
	tr2.dat.data[i] = tr2.dat.data[i-1] + 2.f*dz/tr.dat.data[i];
	}
	for (i=0; i<ns; i++) {
	tr.dat.data[i] = tr2.dat.data[i];
	}
	file.Seek(-nbytePerTrc, CFile::current);  // variable nbytePerTrc cannot be unsigned
	file.Write(&tr, nbytePerTrc);
	numProcessed++;

	}
	_stprintf(s, _T("%d trace procesed",numProcessed);
	AfxMessageBox(s, MB_OK |MB_ICONINFORMATION);
	//	fclose(ifh1);
	file.Close();

	return true;

	*/
















	// testing ******************************
	/*
	PROFILE deping1->1           TYPE 1 29                                          2d_ci7m_gf.ifdf  m  ms
	SNAPPING PARAMETERS 2    19 1
	1.13814000E+06  4.97529221E+06  1 14  3283.08   5366.33  16099.00 5071 3.4028235E+38 2 1205-100
	1.13815252E+06  4.97529322E+06  1 14  3280.97   5366.67  16100.00 5072 3.4028235E+38 2 1205-100
	easting         northern       No.    TWTT      FFID

	5120   -->   0.661km


	5366.330 -->
	5883.330
	*/



	/* The following code works very well: it takes NOPAK velocity data, and convert into
	*  velocity file for Claritas software to use
	*/
	/*
	CString nameTab = _T("F:\\data2\\Hud2004-030\\stacking_velocities\\TGS-notpak.txt";
	FILE *ifh1;

	if (_tfopen_s(&ifh1, nameTab,_T("r")) != 0)
	{AfxMessageBox(_T("Error opening file: "+ nameTab); return FALSE; }

	CString nameOut = _T("F:\\data2\\Hud2004-030\\stacking_velocities\\TGS-notpak-dig.txt";
	FILE *ifh2;
	_tfopen_s(&ifh2, nameOut,_T("w"));

	CString tmp;
	TCHAR line[MAXLINE];
	float a,b;
	int i;
	double rate = 0.037494915;
	while (_fgetts(line,MAXLINE,ifh1)) {
	if (_tcslen(line) < 2) continue;
	if (line[0] == '#') continue; // we do not need comment lines
	CString cs = CString(line);
	if (cs.Compare(BLANK)==0) continue;
	if (cs.Left(3).Compare("EOD")==0) continue;
	if (cs.Left(7).Compare("PROFILE")==0) continue;
	if (cs.Left(8).Compare("SNAPPING")==0) continue;

	i = _tstoi(cs.Mid(33, 3));  // curve number
	a = (float)_tstof(cs.Mid(50, 8));  // FFID
	b = (float)_tstof(cs.Mid(40, 8));  // TWTT
	tmp.Format(_T("%8.3f %8.3f %8d\n", (float)(0.661+(a-5120.)*rate), (float)(b*0.001), i);
	_fputts(tmp,ifh2);
	}
	fclose(ifh1);
	fclose(ifh2);
	*/
	/* end of code for convert velocity data for Claritas */





	/*
	int nxMax=200, nzMax = 500;
	int *nzed;
	float **xv, **zv, **vf;
	nzed = (int *) ealloc1int(nxMax);
	xv = (float **) ealloc2float(nzMax,nxMax);
	zv = (float **) ealloc2float(nzMax,nxMax);
	vf = (float **) ealloc2float(nzMax,nxMax);
	if (xv==NULL || zv==NULL || vf==NULL) return FALSE;

	// initialize parameters
	float xstart = 0.661f;
	float xinc = 0.037495f;
	float xstartReadin = ERRORVAL;   // this will be read in from the first line of file

	FILE *ifh1;
	CString nameTab = _T("F:\\data2\\Hud2004-030\\stacking_velocities\\stk_vel_1205.lst";
	if (_tfopen_s(&ifh1, nameTab,_T("r")) != 0)
	{AfxMessageBox(_T("Error opening file: "+ nameTab); return FALSE; }
	CString startChar;
	CString ss = _T("VELMIG";
	int i = -1;
	int j = -1;
	TCHAR line[MAXLINE];
	CString tmp;
	while (_fgetts(line,MAXLINE,ifh1))
	{
	if (_tcslen(line) < 2) continue;
	if (line[0] == '#') continue; // we do not need comment lines
	_stscanf_s(line,"%6s",startChar);
	int ia = ss.CompareNoCase(startChar.Left(6));
	if (ia==0) {
	// this means it is the first line for a given shot.
	// AfxMessageBox(line);
	i++;
	if (i>nxMax-1) {
	tmp.Format(_T("ix=%d Out of bounds: %s", i, line);
	AfxMessageBox(tmp);
	break;
	}
	xv[i][0] = (float)_tstoi(CString(line).Right(5));
	if (i==0) {
	//save the first shot for calculating distance
	xstartReadin = xv[i][0];
	}
	//		xv[i][0] = (xv[i][0]-xstartReadin)*xinc + xstart;
	j=0;
	nzed[i] = 0;
	continue;
	}

	CString cs = CString(line);
	for (int k = 0; k<5; k++) {
	zv[i][j+k] = _tstoi(cs.Mid(k*12, 6));
	vf[i][j+k] = _tstoi(cs.Mid(k*12+6, 6));
	if (vf[i][j+k] == 0) continue;
	nzed[i]++;
	}

	j+=5;
	if (j<0 || j+4>nzMax-1) {
	tmp.Format(_T("iz=%d Out of bounds at this line: %s", j, line);
	AfxMessageBox(tmp);
	break;
	}

	}
	fclose(ifh1);

	CString nameOut = _T("F:\\data2\\Hud2004-030\\stacking_velocities\\stk_vel_1205.nmo";
	FILE *ifh2;
	_tfopen_s(&ifh2, nameOut,_T("w"));
	tmp = _T("NMO\n";
	_fputts(tmp,ifh2);
	tmp = _T("PRIMARY KEY : SHOT\n";
	_fputts(tmp,ifh2);
	_fputts("SECONDARY KEY : ???\n",ifh2);
	_fputts("INTERPOLATION KEY : Interpolate/End\n",ifh2);
	_fputts("Initial Spherical Divergence Velocity\n",ifh2);
	_fputts("|KEYVAL|{T1     |V1}     |{T2     |V2}     |{T3     |V3}     |{T4     |V4}...  |\n",ifh2);


	// now write the actual data points to file
	int nxv = i+1; // total number of records read in
	int ix, iz;
	for (ix=0; ix<nxv; ix++)
	{
	tmp.Format(_T("%7d ", (int)xv[ix][0]);
	_fputts(tmp,ifh2);
	for (iz=0; iz<nzed[ix]; iz+=4)
	{
	tmp = BLANK;
	for (int k=0; k<4; k++) {
	if (iz+k < nzed[ix])
	tmp.Format(tmp+"%8d %8d ", (int)zv[ix][iz+k], (int)vf[ix][iz+k]);
	}
	_fputts(tmp,ifh2);
	_fputts("\n        ",ifh2);
	}

	// since the last output line for ix should not have the 8 spaces,
	// we need to backspace for 8 spaces
	fseek(ifh2, -8L, SEEK_CUR);
	}

	fclose(ifh2);

	free2float(xv);
	free2float(zv);
	free2float(vf);
	free1int(nzed);
	*/

	/*
	// now we have read in the complete velocity file
	//Generate velocity contours
	short ix, iz, iv;
	double vminLayer=1.5f, vmaxLayer=7.;
	double range, depth;
	double a,b,x1,x2,y1,y2, v,dv;
	CPoint p,p1,plta[1000],pltb[1000];

	//Start plotting velocity color map.
	CPen whitePen(PS_NULL, 0, RGB(255,255,255));
	CPen whiteLinePen(PS_SOLID, 0, RGB(255,255,255));
	CPen blackPen(PS_SOLID, 0, RGB(0,0,0));
	CPen redPen(PS_SOLID, (int)(cd.coord.logicalAxes.Height()/400), RGB(255,0,0));
	CPen greenPen(PS_SOLID, (int)(cd.coord.logicalAxes.Height()/400), RGB(0,255,0));
	CPen thickPen(PS_SOLID, (int)(min(cd.coord.logicalAxes.Width(),cd.coord.logicalAxes.Height())/600), RGB(0,0,0));
	CPen thinPen(PS_SOLID, 0, RGB(0,100,0));
	CBrush blackBrush(RGB(0,0,0));
	CBrush redBrush(RGB(255,0,0));
	CBrush greenBrush(RGB(0,255,0));
	CBrush blueBrush(RGB(0,0,255));

	if(vminLayer<=velColor.vmin) dv = velColor.dv1;
	else if(vminLayer<=velColor.vmid) dv = velColor.dv1;
	else if (vminLayer<=velColor.vmid2) dv = velColor.dv2;
	else if (vminLayer<=velColor.vmid3) dv = velColor.dv3;
	else if (vminLayer<=velColor.vmid4) dv = velColor.dv4;
	else dv = velColor.dv5;

	//vminLayer should be rounded to a multiple of dv.
	vminLayer = (int)(vminLayer/dv) * dv;

	int nv = (int)((vmaxLayer-vminLayer)/dv + .5);
	if(nv<2)  nv=2;
	if(nv>=500) {
	dv = (vmaxLayer-vminLayer)/499;
	nv = 500;
	}	//Make sure plt[] array do not exceed 500.

	//Loop through colors for this layer.
	for (iv=0; iv<nv-1; iv++)
	{
	v = vminLayer + iv*dv;
	if(v>vmaxLayer) break;

	//Search by interpolation for the curve for v.
	for (ix=0; ix<nxv; ix++)
	{
	// first, for this ix, search for the velocity contour between v and (v+dv)
	for (iz=0; iz<nzed[ix]-1; iz++)
	{
	float v1 = vf[ix][iz];
	if (v1>=v && v1<(v+dv)) {
	// found a v
	range = xv[ix][iz];
	depth = zv[ix][iz];
	double dzm = zv[ix][iz+1]-depth;
	double dvm=vf[ix][iz+1]-v1;
	if(dzm<0.)
	{
	// should not happen -- next node shallower
	a = depth;
	}
	else if(fabs(dvm)<0.001)
	{
	//const vel
	if(fabs(v-v1) <= dv ) a=depth;
	else a=zv[ix][iz+1];
	}
	else
	{
	a =depth+dzm*(v-v1)/dvm;
	}

	if(a<depth) a=depth;
	if(a<cd.coord.zmin) a=cd.coord.zmin;
	if(a>cd.coord.zmax) a=cd.coord.zmax;
	plta[ix] = cd.mm_coord(range, a);
	// plt[2*nx-ix-1] = cd.mm_coord(range, b);
	} // end of if v
	} // end of for iz

	} //End of loop ix.

	// start the final plot
	COLORREF colThis = getVelocityColor((float)v, vel);
	oldPen = pDC->SelectObject(&blackPen);
	CBrush brush;
	brush.CreateSolidBrush(colThis);
	oldBrush = pDC->SelectObject(&brush);
	pDC->Polygon(plt, 2*nx);
	pDC->SelectObject(oldBrush);
	pDC->SelectObject(oldPen);
	} //End of loop iv.

	//	double xx[500],zz[500];
	*/
	return(TRUE);
}




COLORREF CSeisWideDoc::getRayColor(int irayCol)
{
	// 0 for black, 1 for red TT curves; 2 for white, 3 for blue, 4 for random colors.

	if (irayCol == 0)
		return RGB(90, 90, 90);
	else if (irayCol == 1)
		return RGB(255, 20, 20);
	else if (irayCol == 2)
		return RGB(235, 235, 235);
	else if (irayCol == 3)
		return RGB(0, 0, 225);
	else {
		double r = rand() / (double)RAND_MAX * 220 + 30; // always <= 1.0;
		double g = rand() / (double)RAND_MAX * 200 + 40;
		double b = rand() / (double)RAND_MAX * 200 + 30;

		// avoid too white rays
		if (r + g + b > 570.) {
			//r = 1.;
			//g = 255.;
			//b = 1;
			return getRayColor(irayCol);
		}
		double diff = fabs(r - g) + fabs(g - b) + fabs(b - r);
		if (diff < 40.)
			return getRayColor(irayCol);

		return RGB((int)r, (int)g, (int)b);
	}
}

void CSeisWideDoc::OnToolbarBiggerAmp()
{
	CSeisWideApp* pSeiApp = (CSeisWideApp*)AfxGetApp();
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	draw.isSameDataDisplay = FALSE;
	if (pSeiApp->statWin.getShiftPressed()) {
		head.maxAmp *= 0.7;
	}
	else {
		if (draw.wiggle >= 4) {
			if (pSeiApp->statWin.getControlPressed() && draw.logScaleThreshold<100) {
				draw.logScaleThreshold += 5;
				if (draw.logScaleThreshold > 100) {
					draw.logScaleThreshold = 100;
					pFrame->myCaption(_T("Max thresshold reached."));
				}
			}
			else {
				// here, we just reduce the color scale to reveal smaller amps
				CString fSection = cd.coord.isTimeDomain() ? draw.timeSecName : draw.depthSecName;
				CColorHelper::AMPCOLORDYN ampColor11(fSection);  // must be 11 colors
				if (!ampColor11.getAmpColorArray2(2, true)) return;
				if (ampColor11.ampColorLower())
					CColorHelper::saveAmpColorToFile1(&ampColor11);
			}
		}
		
		if (draw.wiggle < 4 || draw.isWiggleInDisplay()) {
			if (pSeiApp->statWin.getControlPressed() && areaFill.clip<999.999) {
				//areaFill.clip *= 1.2;
				areaFill.gain *= 1.2;
			}
			else {
				areaFill.gain *= 1.2;
				if (pFrame->statMain.isClipChangeWithGain) {
					areaFill.clip *= 1.2;
				}
			}
			if (areaFill.clip > 1000.) areaFill.clip = 1000.;
		}
	} // else

	UpdateAllViews(NULL);
	NotifyChanged();
	myUpdateStatusBar();

}

void CSeisWideDoc::OnToolbarLessAmp()
{
	CSeisWideApp* pSeiApp = (CSeisWideApp*)AfxGetApp();
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	draw.isSameDataDisplay = FALSE;
	if (pSeiApp->statWin.getShiftPressed()) {
		head.maxAmp *= 1.43;
	}
	else {
		if (draw.wiggle >= 4) {
			if (pSeiApp->statWin.getControlPressed() && draw.logScaleThreshold > 0) {
				draw.logScaleThreshold -= 5;
				if (draw.logScaleThreshold < 0) {
					draw.logScaleThreshold = 0;
					pFrame->myCaption(_T("Min thresshold reached."));
				}
			}
			else {
				// here, we just reduce the color scale to reveal smaller amps
				CString fSection = cd.coord.isTimeDomain() ? draw.timeSecName : draw.depthSecName;
				CColorHelper::AMPCOLORDYN ampColor11(fSection);  // must be 11 colors
				if (!ampColor11.getAmpColorArray2(2, true)) return;
				if (ampColor11.ampColorHigher())
					CColorHelper::saveAmpColorToFile1(&ampColor11);
			}
		}

		if (draw.wiggle < 4 || draw.isWiggleInDisplay()) {
			if (pSeiApp->statWin.getControlPressed() && areaFill.clip>1.1) {
				areaFill.gain /= 1.2;
				//areaFill.clip /= 1.2;
			}
			else {
				areaFill.gain /= 1.2;
				if (pFrame->statMain.isClipChangeWithGain) {
					areaFill.clip /= 1.2;
				}
			}
			if (areaFill.clip < 0.5) areaFill.clip = 0.5;
		}
	}

	UpdateAllViews(NULL);
	NotifyChanged();
	myUpdateStatusBar();
}



void CSeisWideDoc::OnProcessingAppendmanysegyfiles()
{
	short nf = 0;
	CString inFileName, inFileName2, inFileNames[999], logFileName, gmtFileName;

	AfxMessageBox(_T("Note: each segy must have the sample rate and lengtt, otherwise will not be included in output."), MB_ICONQUESTION);

	//Open file dialog.
	CFileDialog dlg(TRUE, _T("sgy; SEG"), _T("*.sgy"),
		OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT | OFN_ALLOWMULTISELECT | OFN_EXPLORER,
		_T("Input Segy Files (*.sgy)|*.sgy|"));
	TCHAR* buff = (TCHAR*)alloc1(65535, sizeof(TCHAR));
	buff[0] = '\0';
	dlg.m_ofn.lpstrTitle = _T("Select all segy files for appending at alphabetical order, regardless of whatever in display. ");
	dlg.m_ofn.lpstrFile = buff;
	dlg.m_ofn.nMaxFile = 65535;//sizeof(buff);


	POSITION Position;

	bool isCanceled = false;
	if (dlg.DoModal() == IDOK) {
		Position = dlg.GetStartPosition();
		while (Position) {
			inFileName = dlg.GetNextPathName(Position);
			if (!inFileName.IsEmpty()) {
				inFileNames[nf] = inFileName;
				nf++;
			}
		}
		delete dlg;

	} //end dlg.DoModal function.
	else {
		delete dlg;
		isCanceled = true;
	}

	free1(buff);
	if (isCanceled) return;

	// If data numbers exceed max, just change this number
	int MAX_FILES = 999;
	if (nf > MAX_FILES) {
		AfxMessageBox(_T("Maximum number of files selected is exceeded."), MB_ICONQUESTION);
		return;
	}

	//now reorganize these files sequentially, alphabetically.
	int n;
	CString t;
	for (n = 0; n < nf - 1; n++) {
		for (int i = n + 1; i<nf; i++) {
			if (inFileNames[n]>inFileNames[i]) {
				t = inFileNames[i];
				inFileNames[i] = inFileNames[n];
				inFileNames[n] = t;
			}
		}
	}




	int totShot;
	bhed bh;
	segy tr, tr2;

	ULONGLONG curBytesRead, bytesRead;
	int iPos;
	BOOL isUnix = false;

	CString tStr;

	//###############initilize output file pointer###################
	CFile file2;
	CFile gmtFile2;
	inFileName2 = inFileNames[0];
	if ((n = inFileNames[0].GetLength()) > 4) {
		// inFileName2 = GetFileNameAppendExt(inFileNames[0], _T("Merged"), _T("sgy"));
		inFileName2 = SetFileExtension(getFileNameAppend(inFileNames[0], _T("Merged")), _T("sgy"));
		logFileName = GetFileNameAppendExt(inFileNames[0], _T("Merged"), _T("log"));
		gmtFileName = GetFileNameAppendExt(inFileNames[0], _T("MergedGmt"), _T("log"));
		tStr = GetPathFromFileSlash(inFileNames[0]);
		if (isDirectoryExist(tStr))
			SetCurrentDirectory(tStr);
	}
	else {
		inFileName2 = _T("outMerged.sgy");
		logFileName = _T("outMerged.log");
		gmtFileName = _T("outMergedGmt.log");
	}

	if (!file2.Open(inFileName2, CFile::modeCreate | CFile::modeReadWrite | CFile::typeBinary)) {
		return;
	}

	FILE *log, *logGmt;


	if (_tfopen_s(&log, logFileName, _T("w")) != 0) {
		AfxMessageBox(_T("Cannot open log file to write."), MB_ICONQUESTION);
		file2.Close();
		return;
	}
	_tfopen_s(&logGmt, gmtFileName, _T("w"));
	//###############end initilize output file pointer###################


	//Begin progress control.
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	pFrame->BeginProgress();


	//###############loop thru the input files ###################
	totShot = 0;
	int i;
	int outLen = 0;
	int outRate = 0;
	bool isProb = false;
	for (n = 0; n < nf; n++) {
		curBytesRead = file2.Seek(0, CFile::current);
		iPos = (int)((double)n / (double)nf*100.);
		if (iPos < 0)iPos = 0;
		if (iPos > 100)iPos = 100;
		pFrame->SetProgress(iPos);


		if (!isFileExistNotDirectory(inFileNames[n])) continue;
		CFile file;
		if (!file.Open(inFileNames[n], CFile::modeRead | CFile::typeBinary | CFile::shareDenyNone)) {
			continue;
		}

		// first, we processs the tape headers
		bytesRead = file.Read(head.ascHead, 3200L);
		if (bytesRead < 3200) {
			AfxMessageBox(_T("Ascii section header for 2nd file read wrong"), MB_ICONQUESTION);
			file.Close();
			continue;
		}
		// ebc2asc(head.ascHead, 3200);
		_ftprintf_s(log, _T("\n--------------------\nSEGY NAME:\n%s\n"), (LPCTSTR)inFileNames[n]);
		_ftprintf_s(logGmt, _T(">%s\n"), (LPCTSTR)inFileNames[n]);
		 
		for (i = 0; i < 260; i++)
			_ftprintf_s(log, _T("%c"), head.ascHead[i]);
		_ftprintf_s(log, _T("\n\n"));


		bytesRead = file.Read(&bh, 400L);
		if (isUnix = IsUnix(bh.format)) SwapTapeHeader(&bh);
		if (bh.hdt == 0) bh.hdt = bh.dto;

		if (bytesRead < 400 || !IsFormatValid(bh.format)) {
			AfxMessageBox(_T("Binary section header read wrong"), MB_ICONQUESTION);
			file.Close();
			continue;
		}

		// get some parameters from the tape header
		int len = (bh.format == 3) ? (2 * bh.hns) : 4 * bh.hns;
		len += 240;

		if (outLen == 0) {
			// this means the output is starting to write tape headers
			file2.Write(head.ascHead, 3200L);
			int bhFormatBak = bh.format;
			bh.format = 1; // we only output in IBM floating point format
			file2.Write(&bh, 400L);
			bh.format = (short)bhFormatBak;
			_ftprintf_s(log, _T("Trace, Long, Lat, CDP, CDPBak, TimeRec\n"));
			outLen = bh.hns;
			outRate = bh.hdt;
		}
		//	int iii = sizeof(bh);

		//	int yyyy = sizeof(tr);

		// we now process the data
		if (bh.hdt == outRate && bh.hns == outLen) {
			while (file.Read(&tr, len) == (UINT)len) {
				if (isUnix) {
					SwapTraceHeader(false, false, false, &tr);
					SwapN(&tr.dat, bh.format, outLen);
				}
				if (bh.format == 1) {
					// floating
					ibm_to_float((int *)tr.dat.data, (int *)tr.dat.data, (int)bh.hns);
					memcpy(&tr2.dat.data[0], &tr.dat.data[0], bh.hns*sizeof(float));
				}
				else if (bh.format == 2) {
					// we want to convert fixed point to float for easier processing
					for (i = 0; i < bh.hns; i++)
						tr2.dat.data[i] = (float)tr.dat.dataint[i];
				}
				else if (bh.format == 3) {
					// short int for input
					for (i = 0; i < bh.hns; i++)
						tr2.dat.data[i] = (float)tr.dat.datashort[i];
					//for (i = 0; i < bh.hns; i++)
					//	tr.dat.data[i] = (float)tr2.dat.data[i];
				}
				else
					memcpy(&tr2.dat.data[0], &tr.dat.data[0], bh.hns*sizeof(float));

				if (bh.hns < outLen) {
					for (i = bh.hns; i < outLen; i++)
						tr2.dat.data[i] = 0.f;
				}

				// revise some params in header
				tr.tracl = totShot + 1;
				tr.ns = outLen;

				// we only output in IBM floating point format
				float_to_ibm((int *)tr2.dat.data, (int *)tr2.dat.data, (int)tr.ns);

				file2.Write(&tr.tracl, 240);
				file2.Write(&tr2.dat.data[0], outLen*sizeof(float));

				_ftprintf_s(log, _T("%d %8.5f %8.5f %d %d %d:%d:%d:%d\n"), tr.tracl, (float)(0.0001f*tr.gx), (float)(0.0001f*tr.gy), tr.cdp, tr.cdpbak, tr.year, tr.hour, tr.minute, tr.sec);
				// _ftprintf_s(logGmt, _T("%8.5f %8.5f %d:%d:%d:%d\n", (float)(0.0001f*tr.gx), (float)(0.0001f*tr.gy),tr.year,tr.hour,tr.minute,tr.sec);
				_ftprintf_s(logGmt, _T("%8.5f %8.5f 6 0 8 LM \\040\n"), (float)(0.0001f*tr.gx), (float)(0.0001f*tr.gy));
				totShot++;
			} // while file.Read
		} // if
		else {
			_ftprintf_s(log, _T("  *** this file is not merged: \n  **** sampling rate/num samples changed from: %d/%d to %d/%d.Resampe it first!\n"), outRate, outLen, bh.hdt, bh.hns);
			isProb = true;
		}
		file.Close();
		file2.Flush();
	} // for n
	pFrame->EndProgress();

	if (totShot > 0) {
		CSegyMeta::setSegyTotalTrace(&file2, totShot);
		//file2.Seek(3200L, CFile::begin);
		//file2.Read(&bh, 400L);
		//bh.format = 1;
		//bh.setnx(totShot);
		//file2.Seek(3200L, CFile::begin);
		//file2.Write(&bh, 400L);

		if (isProb)
			tStr.Format(_T("Problem entered. Check log. However, succesfully Mixing the datain the temp directory! A total of %d traces processed."), totShot);
		else
			tStr.Format(_T("Succesfully Mixing the data in the temp directory! A total of %d traces processed."), totShot);
	}
	else
		tStr.Format(_T("Not even one trace appended!"));

	file2.Close();
	fclose(log);
	fclose(logGmt);

	AfxMessageBox(tStr, MB_ICONQUESTION);

	showFileInNotePad(logFileName);
}



//// this function calculates color for an amplitude
//// it uses global variables of  seisBiColor, draw.ampMax
//COLORREF CSeisWideDoc::getAmpRgb(CPoint *pint, int numfa, int xFull, int xZero)
//{
//	// depreciated
//	if (ampColorDyn.r == NULL && !getAmpColorArray()) return RGB(0,0,0);
//	if (ampColorDyn.num == 0) return RGB(0,0,0);
//	int ampMax;
//	double scale;
//	//	return RGB(ampBiColor.rhi[ii], ampBiColor.ghi[ii], ampBiColor.bhi[ii]);
//	/*
//	-5	0	0	255	-4	51	51	255
//	-4	51	51	255	-3	102	102	255
//	-3	102	102	255	-2	153	153	255
//	-2	153	153	255	-1	204	204	255
//	-1	204	204	255	0	255	255	255
//	0	255	255	255	1	255	204	204
//	1	255	204	204	2	255	153	153
//	2	255	153	153	3	255	102	102
//	3	255	102	102	4	255	51	51
//	4	255	51	51	5	255	0	0
//	*/

//	if (xFull == xZero) {
//		scale = 0.5;
//	}
//	else if (xFull > xZero) {
//		ampMax = -(int)MIL;
//		for (int i=0; i<numfa; i++) {
//			if (ampMax < pint[i].x) ampMax = pint[i].x;
//		}
//		scale = (float)(ampMax - xZero) /(float)(xFull-xZero);
//	}
//	else {
//		// fill the left half
//		ampMax = (int)MIL;
//		for (int i=0; i<numfa; i++) {
//			if (ampMax > pint[i].x) ampMax = pint[i].x;
//		}
//		scale = - (float)(ampMax - xZero) /(float)(xFull-xZero);
//	}

//	int ii = (int)myRound(5.0 * scale);
//	if (ii<-5) ii = -5;
//	else if (ii>5) ii=5;

//	ii += 5;

//	//if (ampColorDyn.r[ii] > 200 && ampColorDyn.g[ii] > 200 && ampColorDyn.b[ii] > 200) {
//	//	int sdfsd = 1;
//	//}

//	return RGB(ampColorDyn.r[ii], ampColorDyn.g[ii], ampColorDyn.b[ii]);

//}
//COLORREF CSeisWideDoc::getAmpRgbSimple(int fullAmpR, int fullAmpG, int fullAmpB)
//{
//	return RGB(fullAmpR, fullAmpG, fullAmpB);
//}




//COLORREF CSeisWideDoc::getAmpRgb(float amp)
//{
//	// and then we use amp, head.maxAmp, draw.avgAmp to determine the color
//	//return getAmpRgbPixel(amp, -(float)head.maxAmp,(float)head.maxAmp);
//	//int ii = (amp < 0.f)  ?  0  :  10;
//	//return RGB(ampColorDyn.r[ii], ampColorDyn.g[ii], ampColorDyn.b[ii]);


//	if (ampColorDyn.r == NULL && !getAmpColorArray()) return RGB(0,0,0);
//	if (ampColorDyn.num == 0) return RGB(0,0,0);

//	int num = ampColorDyn.num;

//	//float ampPercent = ampColorDyn.percent[0] + 
//	//	(ampColorDyn.percent[num-1] - ampColorDyn.percent[0]) *
//	//	(float)(amp + head.maxAmp) / (float)(2.*head.maxAmp);

//	if (amp <= ampColorDyn.percentAmp[0])
//		return RGB(ampColorDyn.r[0], ampColorDyn.g[0], ampColorDyn.b[0]);
//	else if (amp >= ampColorDyn.percentAmp[num-1]) {
//		return RGB(ampColorDyn.r[num-1], ampColorDyn.g[num-1], ampColorDyn.b[num-1]);
//	}


//	for (int i = 0; i<num; i++) {
//		if (amp == ampColorDyn.percentAmp[i]) {
//			return RGB(
//				ampColorDyn.r[i],
//				ampColorDyn.g[i],
//				ampColorDyn.b[i]
//			);
//		}
//	}

//	for (int i = 1; i<num; i++) {
//		if (amp >= ampColorDyn.percentAmp[i-1] && amp <= ampColorDyn.percentAmp[i]) {
//			return RGB(
//				(ampColorDyn.r[i-1]+ampColorDyn.r[i])/2,
//				(ampColorDyn.g[i-1]+ampColorDyn.g[i])/2,
//				(ampColorDyn.b[i-1]+ampColorDyn.b[i])/2
//				);
//		}
//	}

//	// now the rate is not covered. This cannot happen unless program erros
//	return RGB(ampColorDyn.r[num], ampColorDyn.g[num], ampColorDyn.b[num]);
//}



/*
// This function just get an average color from the 4 surrounding points
DWORD GetSubTexel( int x, int y )
{
const int h = (x & 0xff00) / 255;
const int i = (y & 0xff00) / 255;

x = x >> 16;
y = y >> 16;

const COLORREF cr1 = GetTexel( x + 0, y + 0 );
const COLORREF cr2 = GetTexel( x + 1, y + 0 );
const COLORREF cr3 = GetTexel( x + 1, y + 1 );
const COLORREF cr4 = GetTexel( x + 0, y + 1 );

const int a = (0x100 - h) * (0x100 - i);
const int b = (0x000 + h) * (0x100 - i);
const int c = (0x000 + h) * (0x000 + i);
const int d = 65536 - a - b - c;

const unsigned int R = 0x00ff0000 & (((cr1 >> 16)      * a) + ((cr2 >> 16)      * b) + ((cr3 >> 16)      * c) + ((cr4 >> 16)      * d));
const unsigned int G = 0xff000000 & (((cr1 & 0x00ff00) * a) + ((cr2 & 0x00ff00) * b) + ((cr3 & 0x00ff00) * c) + ((cr4 & 0x00ff00) * d));
const unsigned int B = 0x00ff0000 & (((cr1 & 0x0000ff) * a) + ((cr2 & 0x0000ff) * b) + ((cr3 & 0x0000ff) * c) + ((cr4 & 0x0000ff) * d));

return R|((G|B)>>16);
}
*/

//int CSeisWideDoc::getAmpRgbIndex(COLORREF col) {
//	for (int i = 1; i<ampColorDyn.num; i++) {
//		if ( RGB(ampColorDyn.r[i], ampColorDyn.g[i], ampColorDyn.b[i]) == col ) return i;
//	}
//	return ampColorDyn.num /2;
//}


//COLORREF CSeisWideDoc::getAmpRgbPixel(float amp)
//{
//	// will use global struct seisBiColor, global variable draw.ampMax
//	if (ampColorDyn.r == NULL && !getAmpColorArray() ) return RGB(0,0,0);
//	if (ampColorDyn.num == 0) return RGB(0,0,0);

//	float p1 = ampColorDyn.percentAmp[0];
//	float p2 = ampColorDyn.percentAmp[2];
//	float p3 = ampColorDyn.percentAmp[8];
//	float p4 = ampColorDyn.percentAmp[10];

//	//float ampPercent = ampColorDyn.percent[0] + 
//	//	(ampColorDyn.percent[ampColorDyn.num-1] - ampColorDyn.percent[0]) *
//	//	(amp + head.maxAmp) / (head.maxAmp*0.5);

//	int iSel = 0;
//	//double ampPercent = ampColorDyn.percent[0] + 
//	//	(ampColorDyn.percent[ampColorDyn.num-1] - ampColorDyn.percent[0]) *
//	//	(amp + head.maxAmp) / (head.maxAmp*0.5);

//	for (int i = 1; i<ampColorDyn.num; i++) {
//		if (amp >= ampColorDyn.percentAmp[i-1] && amp <= ampColorDyn.percentAmp[i]) {
//			double rate =  (ampColorDyn.percentAmp[i] == ampColorDyn.percentAmp[i-1])  ?
//				0.0
//				:
//			(amp - ampColorDyn.percentAmp[i-1]) / (ampColorDyn.percentAmp[i] - ampColorDyn.percentAmp[i-1]);
//			return RGB(
//				myRound((double)ampColorDyn.r[i-1] + (double)(ampColorDyn.r[i] - ampColorDyn.r[i-1]) * rate),
//				myRound((double)ampColorDyn.g[i-1] + (double)(ampColorDyn.g[i] - ampColorDyn.g[i-1]) * rate),
//				myRound((double)ampColorDyn.b[i-1] + (double)(ampColorDyn.b[i] - ampColorDyn.b[i-1]) * rate)
//				);
//		}
//	}

//	// now the rate is not covered. This cannot happen unless program erros
//	if (amp > ampColorDyn.percentAmp[0])
//		return RGB(ampColorDyn.r[0], ampColorDyn.g[0], ampColorDyn.b[0]);
//	else {
//		int n = ampColorDyn.num - 1;
//		return RGB(ampColorDyn.r[n], ampColorDyn.g[n], ampColorDyn.b[n]);
//	}
//}

void CSeisWideDoc::OnEditDisplaytuneupAdjustinglabelsizes()
{
	// TODO: Add your command handler code here
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	ASSERT(pFrame);
	ASSERT_KINDOF(CMainFrame, pFrame);


	CdlgLabelSizes dlg;
	dlg.m_LabelNumberHeigth = pFrame->statMain.fLabelDistance3;
	dlg.m_LabelNumberWidth = pFrame->statMain.fLabelDistance3;
	dlg.m_LabelSize = pFrame->statMain.fLabelDistance3;
	if (dlg.DoModal() == IDOK)
	{
		pFrame->statMain.fLabelDistance3 = dlg.m_LabelSize;
	}
	else return;

	SetModifiedFlag();
	UpdateAllViews(NULL);
	NotifyChanged();
}

BOOL CSeisWideDoc::myDigSaveAs(CString aName)
{
	// this means that the backup file is the same as target file. It'll just overwrite the file.
	CDigitize pDg;
	dig.digName = aName;
	int isXInt = cd.coord.isTraceMode();
	return pDg.myDigSaveAs2(&dig, isXInt);
}

BOOL CSeisWideDoc::myDigSaveAs(CString aName, CString aNameOrig)
{
	CDigitize pDg;
	dig.digName = aName;
	int isXInt = cd.coord.isTraceMode();
	return pDg.myDigSaveAs2(&dig, isXInt);
}







//BOOL CSeisWideDoc::myDigSaveAsWithZplot(CDigitize::DIGITIZE *dig2, CString aName, BOOL isSort, BOOL isSortY, CString strRemarkLine)
//{
//	//	if(!dig2->isZeltFormat2) { //Here a plain text format is chosen.
//	//		CString CSeisWideDoc::myDigSaveAsPlain(CDigitize::DIGITIZE *dig2, CString aName, CString aNameOrig, BOOL isSort, BOOL isSortY)
//
//	if (dig2->isZeltFormat) {
//		isSort = TRUE;
//		isSortY = FALSE;
//	}
//
//	// isSort=TRUE would mean it'll sort the data points before saving. Sometimes we do not want to sort the points however.
//	if (GetBaseFileName(aName).IsEmpty()) aName = GetFileNameAppendExt(draw.timeSecName, _T("_digiAuto"), _T("txt"));
//
//	float t1, t2, t3;
//	short n, k;
//	int fileFormat = 0;
//	FILE *stream;
//	long i, j;
//
//	CString aNameBak;
//	aNameBak = aName + ".bak";
//	if (_tfopen_s(&stream, aName, _T("w")) != 0) {
//		CString aExt = CDigitize::getDigExtension(dig2);
//		CFileDialog dlg(FALSE, aExt, dig2->digName,
//			OFN_OVERWRITEPROMPT | OFN_EXPLORER,
//			_T("File name for the digfitized points (*.") + aExt + ")|*." + aExt + "|");
//		//	dlg.m_ofn.lpstrTitle = _T("Each shot number in one line please";
//		if (dlg.DoModal() == IDOK) {
//			BOOL a = myDigSaveAs(dlg.GetPathName(), dig2->digName);
//			if (a) {
//				dig2->digName = dlg.GetPathName();
//			}
//			return a;
//			// dig2->digName = a;  // do not update the digName, otherwise it may crash
//		}
//	}
//	// why do we need a backup file before overwriting ?
//	// This is because our digitized array in memory only reads in for a 
//	// particular source. When we save the digitized data, we do not want 
//	// to overwrite data for a different shot.----- solved
//	//
//
//
//	FILE *streamZplot = NULL;
//	//int countTrace = 0;
//	//float *ptrace = NULL;
//	//float *pdist = NULL;
//
//	if (gIsZplotFormat && isFileExistNotDirectory(draw.timeSecName)) {
//
//		if (_tfopen_s(&streamZplot, aName + "Zplot.txt", _T("w+")) != 0) {
//			AfxMessageBox(_T("File could not be opened to write."));
//			return FALSE;
//		}
//
//		// if segy file name exists, try to save trace numbers in addition to the distance km.
//		//CFile file;
//		//if (!file.Open(draw.timeSecName, CFile::modeRead | CFile::typeBinary)) {
//		// if (streamZplot) fclose(streamZplot);
//		// return FALSE;
//		//}
//
//
//		//file.Seek(3200, CFile::begin);
//		//bhed bh;
//		//segy tr;
//		//if(file.Read(&bh, 400) < 400) {
//		// fclose(stream);
//		// file.Close();
//		// return FALSE;
//		//}
//
//		//long len = 0;
//		//if(bh.format!=3)  len = bh.hns*4 + 240;
//		//else len = bh.hns*2 + 240;
//
//		//while (file.Read(&tr, 4)==4) {
//		// countTrace++;
//		// file.Seek(len-4, CFile::current);
//		//}
//
//		//ptrace = (float *)ealloc1float(countTrace+1);  // must add 1 more point for work space
//		//pdist = (float *)ealloc1float(countTrace+1);
//		//int j = 0;
//		//file.Seek(3600, CFile::begin);
//		//while (file.Read(&tr, 24)==24) {
//		// ptrace[j] = (float)tr.tracl;
//		// pdist[j] = (cd.coord.isDistanceDisplay)  ?   getDistance(&tr)  :  getOffset(&tr);  // in km
//		// j++;
//		// file.Seek(len-24, CFile::current);
//		// //  if (j>= countTrace) break;
//		//}
//		//countTrace = j;  // make sure it does not overflow.
//		//file.Close();
//		//sort2(countTrace, pdist, ptrace);
//	} // if (!draw.timeSecName.IsEmpty())
//
//
//
//
//
//
//
//	// there may be some points not in proper order. Let's correct for this
//	CDigitize pDg;
//	pDg.myDigSort(dig2, isSort, FALSE, cd.coord.xmin, cd.coord.xmax);
//
//	if (!strRemarkLine.IsEmpty())
//		_ftprintf_s(stream, _T("#%s\n"), strRemarkLine);
//
//	CString tStr;
//
//	if (!dig2->isZeltFormat)
//	{	//Here a plain text format is chosen.
//
//		// first, we remove an irregularity
//		for (i = 0; i < dig2->totCurve; i++)
//		{
//			for (j = 0; j < dig2->nPoint[i]; j++)
//			{
//				if (dig2->x[j][i] < -99999. && dig2->t[j][i] < -99999.) {
//					pDg.myDigRemove(dig2, j, i); // this changes the num of points for this curve
//					break;
//				}
//			}
//		} // for
//
//
//		for (i = 0; i < dig2->totCurve; i++)
//		{
//			tStr = dig2->getLabelString(i);
//			for (j = 0; j < dig2->nPoint[i]; j++)
//			{
//				t1 = dig2->x[j][i];
//				t2 = dig2->t[j][i];
//				_ftprintf_s(stream, _T(" %11.5f %11.5f %s"), t1, t2, tStr);
//				if (head.dist != NULL) {
//					int kk = getClosestIndex(head.dist, head.numTraces, t1);
//					if (kk >= 0) {
//						_ftprintf_s(stream, _T("  %9d"), (UINT)head.traces[kk]);
//						_ftprintf_s(streamZplot, _T("%6d %5d %5s %11.3f\n"), 1, (UINT)head.traces[kk], tStr, t2);
//					}
//				}
//				_ftprintf_s(stream, _T("\n"));
//
//			}
//		}
//
//
//	}	//End for plain text format option.
//	else {
//
//		if (isFileExistNotDirectory(aNameBak)) {
//
//			// We first want to put all dig points that are not of the same source, and write as is.
//			// We will EXCLUDE any dig points that have the same source as the active one.
//			// This way, we can append the active data to the end of the file.
//			FILE  *streamBak;
//
//			if (_tfopen_s(&streamBak, aNameBak, _T("r")) != 0) {
//				TCHAR line[MAXLINE];
//				BOOL firstTim = TRUE, textErr = FALSE;
//				while (_fgetts(line, MAXLINE, streamBak) != NULL)
//				{
//					if (_tcslen(line) < 2) continue;
//					if (line[0] == '#') continue; // we do not need comment lines
//					if (_stscanf_s(line, _T("%f%f%f%d"), &t1, &t2, &t3, &k) == 0)
//					{
//						textErr = TRUE;
//						continue;
//					}
//					else if (k == 0 && fabs(t2) == 1.0f)
//					{ // Start one side of the OBS.
//						//if here then decide the shot location.
//						if (!CCoords::isXShotDefined(tx.xShotRay)) tx.xShotRay = t1;
//
//						if (fabs(tx.xShotRay - t1) <= 0.00001f)
//						{
//							// this shot needs to be excluded.
//							while (_fgetts(line, MAXLINE, streamBak) != NULL) {
//								if (_tcslen(line) < 2) continue;
//								if (line[0] == '#') continue; // we do not need comment lines
//								if (_stscanf_s(line, _T("%f%f%f%d"), &t1, &t2, &t3, &k) == 0) break;
//								if (k == 0 && (fabs(t2) == 1.0f) &&
//									fabs(tx.xShotRay - t1) > 0.00001f) {
//									break;
//								}
//								else if ((fabs(t2) - 1.0f) < 0.00001f && k == -1)
//								{ //end of the file.
//									break;
//								}
//							} // while
//						}
//						if (k >= 0) _ftprintf_s(stream, _T("%s"), line);
//					}
//					else if (k == -1)
//					{ //end of the file; we do not want the last line
//						// since it will be appended later
//						continue;
//					}
//					else {
//						// duplicate data except the end line
//						_ftprintf_s(stream, _T("%s"), line);
//					}
//				}
//				fclose(streamBak);
//
//			} // if (streamBak 
//		} // if (isFileExistNotDirectory(aName)
//
//
//		_ftprintf_s(stream, _T(" %9.3f %9.3f %9.3f %9d\n"), tx.xShotRay, -1.f, 0.f, 0);
//		n = 0;
//		for (i = 0; i < dig2->totCurve; i++)
//		{
//			t3 = dig2->zeltResolution[i];
//			BOOL newCurve = TRUE;
//			for (j = 0; j<dig2->nPoint[i]; j++)
//			{
//				t1 = dig2->x[j][i];
//				if (!cd.coord.isDistanceDisplay) t1 += (float)tx.xShotRay;
//				if (t1>tx.xShotRay) continue;
//				if (newCurve) { n++; newCurve = FALSE; }
//				t2 = dig2->t[j][i]; //reduction velocity is already accounted for.
//				//   _ftprintf_s(stream," %9.3f %9.3f %9.3f %9d",t1,t2,t3,n);
//				_ftprintf_s(stream, _T(" %9.3f %9.3f %9.3f %9d"), t1, t2, t3, dig2->ivray[i]);
//				if (head.dist != NULL && head.traces != NULL) {
//					int kk = getClosestIndex(head.dist, head.numTraces, t1);
//					if (kk >= 0) {
//						_ftprintf_s(stream, _T("  %9d"), (UINT)head.traces[kk]);
//						// _ftprintf_s(streamZplot,"%6d %5d %5d %11.3f\n",1,(UINT)ptrace[kk],n,t2);
//						_ftprintf_s(streamZplot, _T("%6d %5d %5d %11.3f\n"), 1, (UINT)head.traces[kk], dig2->ivray[i], t2);
//					}
//
//				}
//				_ftprintf_s(stream, _T("\n"));
//			}
//		}
//		_ftprintf_s(stream, _T(" %9.3f %9.3f %9.3f %9d\n"), tx.xShotRay, 1.f, 0.f, 0);
//		n = 0;
//		for (i = 0; i < dig2->totCurve; i++)
//		{
//			t3 = dig2->zeltResolution[i];
//			BOOL newCurve = TRUE;
//			for (j = 0; j < dig2->nPoint[i]; j++)
//			{
//				t1 = dig2->x[j][i];
//				if (!cd.coord.isDistanceDisplay) t1 += (float)tx.xShotRay;
//				if (t1 < tx.xShotRay) continue;
//				if (newCurve) { n++; newCurve = FALSE; }
//				t2 = dig2->t[j][i];
//				//   _ftprintf_s(stream," %9.3f %9.3f %9.3f %9d",t1,t2,t3,n);
//				_ftprintf_s(stream, _T(" %9.3f %9.3f %9.3f %9d"), t1, t2, t3, dig2->ivray[i]);
//				if (head.dist != NULL && head.traces != NULL) {
//					int kk = getClosestIndex(head.dist, head.numTraces, t1);
//					if (kk >= 0) {
//						_ftprintf_s(stream, _T("  %9d"), (UINT)head.traces[kk]);
//						// _ftprintf_s(streamZplot,"%6d %5d %5d %11.3f\n",1,(UINT)ptrace[kk],n,t2);
//						_ftprintf_s(streamZplot, _T("%6d %5d %5d %11.3f\n"), 1, (UINT)head.traces[kk], dig2->ivray[i], t2);
//					}
//				}
//				_ftprintf_s(stream, _T("\n"));
//			}
//
//		}
//		_ftprintf_s(stream, _T(" %9.3f %9.3f %9.3f %9d\n"), 0., 0., 0., -1);
//
//	}
//
//	fclose(stream);
//
//	//free1float (ptrace);
//	//free1float (pdist);
//
//	if (gIsZplotFormat) {
//		fclose(streamZplot);
//		showFileInNotePad(aName + "Zplot.txt");
//	}
//
//	return TRUE;
//}
//







void CSeisWideDoc::OnDigitizingReviselinelabel()
{
	// this line is important to avoid crash
	//if (!dig.isDigitizing || dig.iCurveSel < 0 || dig.iCurveSel > 99999) return;

	CDigitize::DIGITIZE *pDig = NULL;
	if (dig.isDigitizing && dig.nPoint != NULL)
		pDig = &dig;
	else if (digMarker.isDigitizing && digMarker.nPoint != NULL)
		pDig = &digMarker;
	else
		return;


	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	if (pDig->isZeltFormat) {
		OnDigitizingChangecurveres(); // this is meant for zelt format
		//pFrame->myCaption(_T("Cannot change option for Zelt format"));
		return;
	}
	CString tStr;
	if (pDig->curveVal[pDig->iCurveSel] < -9999.f) pDig->curveVal[pDig->iCurveSel] = 1.f;
	tStr.Format(_T("%g"), pDig->curveVal[pDig->iCurveSel]);
	dlgDigOption DLG;
	DLG.m_nCurve = pDig->iCurveSel;
	DLG.m_label = tStr;
	DLG.m_isSort = pDig->isSortedX;
	DLG.m_isSortY = pDig->isSortedY;

	if (DLG.DoModal() == IDOK) {
		if (!IsNumeric(DLG.m_label)) {
			AfxMessageBox(_T("Sorry, only floating labels are allowed."));
			OnDigitizingReviselinelabel();
			return;
		}
		//dig.strComment = DLG.m_label;
		pDig->curveVal[pDig->iCurveSel] = (float)StringToFloat(DLG.m_label);
//		pDig->labelArr->SetAt(pDig->iCurveSel, DLG.m_label);
		draw.isNoPromptLabel = DLG.m_NotShow;
		pDig->isSortedX = DLG.m_isSort;
		pDig->isSortedY = DLG.m_isSortY;

	}

	UpdateAllViews(NULL);
	NotifyChanged();
}



void CSeisWideDoc::OnEditLabelInside()
{
	draw.isNoLabelInSide = !draw.isNoLabelInSide;
	UpdateAllViews(NULL);
	NotifyChanged();

}









//void CSeisWideDoc::OnDigitizingRaycodes()
//{
//	// TODO: Add your command handler code here
//	draw.isShowRaycode = !draw.isShowRaycode;
//	UpdateAllViews(NULL);
//	NotifyChanged();
//}
/*
	void CSeisWideDoc::myCaption(CString text)
	{
	CMainFrame* pFrame =
	(CMainFrame*)AfxGetMainWnd();
	ASSERT(pFrame);
	ASSERT_KINDOF(CMainFrame, pFrame);
	CString tStr;
	pFrame->GetWindowText(tStr);
	CString a = text.Left(50);
	CString b = tStr.Left(50);
	if (a != b) {
	a.Format(_T("%s ... %s"), text.GetString(), tStr);
	text = a.Left(255);
	}

	pFrame->SetMessageText(text);
	pFrame->m_wndStatusBar.Invalidate();
	pFrame->m_wndStatusBar.UpdateWindow();

	}*/

// working path: important. Back slash at the end shall be returned as well.
CString CSeisWideDoc::getWorkingPathSlash()
{
	//int nPathLength =  GetModuleFileName (NULL,name.GetBuffer(_MAX_PATH), _MAX_PATH );
	// Note: the default working folder has been changed around several times. 
	// If a DOC/VIEW .SEI file is in a folder different from the velocity file, we want to keep the .SEI as the working folder.
	// This way, a velocity file can be in many different folders, and I can display a long model by overlaying many different 
	// models in the same figure, which is very useful.
	if (isFileExistNotDirectory(this->m_strPathName))
		return GetPathFromFileSlash(this->m_strPathName);
	else if (isFileExistNotDirectory(this->bmp24.bmpName))
		return GetPathFromFileSlash(this->bmp24.bmpName);
	else if (isFileExistNotDirectory(this->velMod.velSecName))
		return GetPathFromFileSlash(this->velMod.velSecName);
	else if (isFileExistNotDirectory(this->draw.timeSecName))
		return GetPathFromFileSlash(this->draw.timeSecName);
	else if (isFileExistNotDirectory(this->draw.depthSecName))
		return GetPathFromFileSlash(this->draw.depthSecName);

	// now no files exist 
	TCHAR curDir[_MAX_PATH];
	GetCurrentDirectory(_MAX_PATH, curDir);
	CString aPath = (CString)curDir;
	return GetPathFromFileSlash(aPath);
}


// Get a color from a file for a given ray code. If not existing in the file, create the file. 
COLORREF CSeisWideDoc::getRaycodeColor(int irrCol)
{
	return getRaycodeColor(irrCol, FALSE);
}

COLORREF CSeisWideDoc::getRaycodeColor(float rayCode)
{
	// we first calculate irrCol based on rayCode in tx struct
	int irrCol = 0;
	for (int i = 0; i < 100; i++) {
		if (tx.rayCodeIn[i] == rayCode) {
			irrCol = tx.ivray[i];
			break;
		}
	}

	return this->getRaycodeColor(irrCol, FALSE);
}

// I tried to move this function to CMainFrame, but failed, since we want to fully control its calculation here
COLORREF CSeisWideDoc::getRaycodeColor(int irrCol, BOOL isColorRecalc)
{
	if (irrCol < 0) irrCol = 0;  // this fixes some initialization issue
	if (irrCol == 0) return getRayColor(draw.TTCurveColor);

	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	if (irrCol >= RAYCODENUM) {
		irrCol -= (int)(irrCol / RAYCODENUM) * RAYCODENUM;
	}

	// by now, it is possible we have irrCol==0, in which case we would want to use it
	if (isColorRecalc || pFrame->statMain.gRayColor[irrCol] == 0) {
		// in selecting random colors, we want bright red, but if green and blue are full 255, we get pure white, which is not good.
		double r1 = rand() / (RAND_MAX + 1.0);
		double r2 = rand() / (RAND_MAX + 1.0);
		double r3 = rand() / (RAND_MAX + 1.0);
		//pFrame->gRayColor[irrCol] = RGB( (int)(220*r1)+34, (int)(200*r2)+54, (int)(200*r3)+54 );
		//pFrame->gRayColor[irrCol] = RGB( 
		// (int)(220*r1)+34, 
		// (int)(200*r2)+54, 
		// (int)(200*r3)+54 
		// );

		// the following line makes the colors very pure.
		int r = (int)(255 * (int)(r1 + 0.5));
		int g = (int)(255 * (int)(r2 + 0.5));
		int b = (int)(255 * (int)(r3 + 0.5));

		// we do not want a pure white ray, since it may not be visible in some cases
		//if (r > 240 && g > 240 && b > 240) {
		//	r = g = b = 240;
		//}
		if (r + g + b > 720) {
			return getRaycodeColor(irrCol, isColorRecalc);
		}
		double diff = abs(r - g) + abs(g - b) + abs(b - r);
		if (diff < 90.)
			return getRaycodeColor(irrCol, isColorRecalc);

		// we do not want very yellow color, since it makes display very vague
		if (r > 240 && g > 240 && b < 10)
			return getRaycodeColor(irrCol, isColorRecalc);


		pFrame->statMain.gRayColor[irrCol] = RGB(r, g, b);
	}



	return pFrame->statMain.gRayColor[irrCol];
}

void CSeisWideDoc::OnDigitizingSavedigffid()
{
	if (dig.nPoint == NULL || dig.totCurve<1) return;

	// this may be repetivie, but it is reported it is wrongly using trace mode
	if (cd.coord.isTraceMode())
		dig.xMode = CDigitize::XMODE::trace;
	else if (cd.coord.isDistanceDisplay)
		dig.xMode = CDigitize::XMODE::distance;
	else
		dig.xMode = CDigitize::XMODE::offset;

	CString outFile;
	if (dig.isZeltFormat && head.numTraces > 1) {
		if (AfxMessageBox(_T("Save FFID/SP in Zelt-compatible format?"), MB_YESNO | MB_ICONQUESTION) == IDYES) {
			CDigitize pDg;
			//outFile = SetFileExtension(dig.digName, _T("kml"));

			outFile = getFileNameAppendTemp(dig.digName, _T("_FFID"));
			if (pDg.myDigSaveAsZeltFFID(&dig, outFile, dig.xShotCache, cd.coord.isMinusXShot,
				head.numTraces, head.traces, head.dist, head.ffid, head.offsets))
				showFileInNotePad(outFile);
			return;
		}
	}



	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();

	CDigitize pDg;
	CString a = pDg.myDigSaveWithFFID(&dig, head.numTraces, head.traces, head.dist, head.ffid, head.offsets);
	if (head.numTraces>0 && !a.IsEmpty())
		showFileInNotePad(a);
	else
		pFrame->myCaption(_T("Failed to show digitize with FFID"));
	 
	//	CStringArray linesArr;
	//	getLinesFromFile2(&linesArr, dig.digName, false, 0);
	if (dig.isDigLonLatPossible()) {
		outFile = SetFileExtension(dig.digName, _T("kml"));
		if (CDigitize::digitize2Kml(&dig, outFile, true))
			showFileInNotePad(outFile);
		
	}

}


// this clipping will consider reducing velocity; it will first apply reducing velocity, and decide if it is outside of the bounds. 
// In the end,it will put the reducing velocity back as before to the DIGITIZE struct if needed
// this function cannot be moved to CDigitize
void CSeisWideDoc::myClipReducePoints4Depreciate(CDigitize::DIGITIZE *digIn, CDigitize::DIGITIZE *digOut, 
	CCoords::REDUCE *pred, bool isReducedOutput)
{
	CDigitize::myClipReducePoints4(digIn, digOut, &cd.coord, pred, digIn->xShotCache, isReducedOutput);
	//SEI_PAIR seiMin, seiMax;
	//seiMin.x = cd.coord.X1();
	//seiMin.y = cd.coord.Y1();
	//seiMax.x = cd.coord.X2();

	//seiMax.y = cd.coord.Y2();
	//CDigitize::myClipReducePoints4(digIn, digOut,
	//	seiMin, seiMax, pred,
	//	tx.xShotRay, cd.coord.isDistanceDisplay, cd.coord.isMinusXShot,
	//	cd.coord.drawmode, isReducedOutput);
	//return;
} // end myClipReducePoints4()


void CSeisWideDoc::OnTimeForwide()
{
	// This routine converts wide-angle segy data from time to depth.
	if (!CheckTime(100))
	{
		return;
	}

	static float offsetMax = 20.f;
	static float stackWidth = 2.0f;
	static float stackWidth2 = 3.0f;
	static BOOL isRaytrace = TRUE;


	int j;
	int icont;
	CdlgWide2Depth dlg;
	dlg.m_xmax = (float)cd.coord.xmax;
	dlg.m_xmin = (float)cd.coord.xmin;

	// we have the issue of half offset after NMO
	if ((dlg.m_xmax - dlg.m_xmin) < offsetMax) {
		// the user has already run this routine before, and the x bounds are too small
		//dlg.m_xmax += offsetMax*0.5f;
		//if (dlg.m_xmax > cd.coord.xmax) dlg.m_xmax = (float)cd.coord.xmax;
		//dlg.m_xmin = dlg.m_xmax - offsetMax;
	}

	if (draw.raymode < 0) draw.raymode = 0;

	dlg.m_depthSecName = (draw.depthSecName.IsEmpty()) ?
		getFileNameAppend(draw.timeSecName, _T("_Depth")) : draw.depthSecName;


	dlg.m_dz = (float)velColor.dz;
	dlg.m_zmax = (float)cd.coord.Y2();
	dlg.m_zmin = (float)cd.coord.m_zmin;
	dlg.m_timeSecName = draw.timeSecName;
	if (fabs(draw.sphericOrder) > 100.f) draw.sphericOrder = 0.f;
	dlg.m_sphericOrder = draw.sphericOrder; //not saved in documents
	dlg.m_velSecName = velMod.velSecName;

	dlg.m_rayTracing = draw.rayName;
	dlg.m_floatName = velMod.flFloatName;
	dlg.m_rayMode = draw.raymode;
	dlg.m_offsetMax = offsetMax;

	dlg.m_isRaytrace = isRaytrace;
	dlg.m_tmin = (float)cd.coord.Y1();
	dlg.m_tmax = (float)cd.coord.Y2();
	dlg.m_stackWidth = stackWidth;
	dlg.m_stackWidth2 = stackWidth2;

	if (dlg.DoModal() == IDOK)
	{
		draw.rayName = dlg.m_rayTracing;
		velMod.flFloatName = dlg.m_floatName;
		offsetMax = dlg.m_offsetMax;
		draw.raymode = dlg.m_rayMode;

		cd.coord.xmax = dlg.m_xmax;
		cd.coord.xmin = dlg.m_xmin;
		draw.depthSecName = dlg.m_depthSecName;
		velColor.dz = dlg.m_dz;
		cd.coord.m_zmax = dlg.m_zmax;
		cd.coord.m_zmin = dlg.m_zmin;
		draw.timeSecName = dlg.m_timeSecName.Trim();
		draw.sphericOrder = dlg.m_sphericOrder;	//not saved in documents
		velMod.velSecName = dlg.m_velSecName.Trim();

		isRaytrace = dlg.m_isRaytrace;
		cd.coord.m_tmin = dlg.m_tmin;
		cd.coord.m_tmax = dlg.m_tmax;
		stackWidth = dlg.m_stackWidth;
		stackWidth2 = dlg.m_stackWidth2;
	}
	else
	{
		return;
	}
	if (!isFileExistNotDirectory(draw.timeSecName)) return;

	float stackWidthGradient = (stackWidth2 - stackWidth) / (float)(cd.coord.m_zmax - cd.coord.m_zmin);

	delete dlg;



	// fix up for dz, since it cannot be too big
	if (velColor.dz*MIL > USHRT_MAX - 1) velColor.dz = (USHRT_MAX - 1) / (double)MIL;


	draw.depthSecName = SetFileExtension(draw.depthSecName, _T("sgy"));

	if (draw.depthSecName.IsEmpty()) return;


	//################### Prepare the raytracing
	if (!checkModelError(velMod.velSecName)) {
		if (AfxMessageBox(_T("Current model has boundary overlaps; Raytracing may hang up if this model is used; Do you want to continue?"), MB_YESNO | MB_ICONINFORMATION) != IDYES)
		{
			return;
		}
	}

	CString txoutName = _T("tx.outsemb");
	if (draw.raymode == 0) txoutName += _T("pp");
	else if (draw.raymode == 1) txoutName += _T("ps");
	else if (draw.raymode == 2) txoutName += _T("sp");

	CString astr;
	CString t;

	//make tx.out file in the same directory as velMod.velSecName.
	CString name = velMod.velSecName;
	int pathLen = name.ReverseFind('\\');
	t = name.Left(pathLen);
	t.MakeLower();
	if (pathLen < 0) {
		TCHAR curDir[_MAX_PATH];
		GetCurrentDirectory(_MAX_PATH, curDir);
		t = (CString)curDir;
	}
	CString txPath;
	if (!isEndWith(t, _T("temp")))
		txPath.Format(_T("%s\\temp"), t);
	else
		txPath = t;

	if (!isDirectoryExist(txPath)) {
		// create the temp dir
		if (!CreateDirectory(txPath, NULL)) {
			astr.Format(_T("Cannot create a working directory: %s"), txPath);
			AfxMessageBox(astr);
			return;
		}
	}
	SetCurrentDirectory(txPath);


	// copy r.in. Note: allways apply anisotropy because we are only 2DNMO for near-offset
	t = txPath + "\\r.in";
	CString tempStr = draw.rayName;
	tempStr.MakeLower();
	if (tempStr != t &&  tempStr != _T("r.in")) {
		CopyFile(draw.rayName, t, FALSE);
	}

	// copy v.bin
	tempStr = velMod.velSecName;
	tempStr.MakeLower();
	t = txPath + "\\v.bin";
	if (tempStr != t && tempStr != _T("v.bin")) {
		CopyFile(velMod.velSecName, _T("v.bin"), FALSE);
	}

	if (cd.coord.m_zmax < cd.coord.m_zmin) cd.coord.m_zmax = cd.coord.m_zmax + 1.;
	int nz = (int)ceil((cd.coord.m_zmax - cd.coord.m_zmin) / velColor.dz) + 1;
	if (nz > 6000) {
		nz = 6000;  // fortran program has this array limit to impose
		cd.coord.m_zmax = cd.coord.m_zmin + (nz - 1)*velColor.dz;
		AfxMessageBox(_T("Max depth adjusted due to array size limitation of 3000 points. Contact programer to increase size if needed."));
		OnTimeForwide();
		return;
	}


	//##################### now do the raytracing
	if (!CCoords::isXShotDefined(dig.xShotCache)) {
		// need to initialize the *head first!!!
		CSegyMeta::segyHeadInit(draw.timeSecName, &head);
		dig.xShotCache = (float)head.xshotInSegy;
		//CString workingPathSlash = getWorkingPathSlash();
		//dig.xShotCache = (float)CRayHelper::getXPosAll(draw.timeSecName, workingPathSlash);
	}
	//Do not refresh screen in any way until raytracing finished. Otherwise, 
	// it may refresh screen while raytracing is running!
	draw.isSameDataDisplay = TRUE;
	CString fileContour = BLANK;

	if (isRaytrace) {
		// generate f.insemb file
		fileContour = this->setContour4Raytrace(txPath + _T("\\f.insemb"), (float)dig.xShotCache, (float)velColor.dz, (float)cd.coord.m_zmin, &cd.coord.m_zmax, 1.5f, 8.f, 0.1f);
		if (fileContour.IsEmpty()) {
			AfxMessageBox(_T("Failed to generate f.insemb file"));
			return;
		}
		astr.Format(_T("%s\\%s*"), txPath, txoutName);
		CShellFileOp sfo;
		BOOL         bAPICalled;
		int          nAPIReturnVal;
		sfo.AddSourceFile(astr);
		sfo.SetOperationFlags
			(FO_DELETE,         // the operation type (delete in this case)
			AfxGetMainWnd(), // pointer to parent window
			FALSE,           // flag - silent mode?
			FALSE,           // flag - allow undo?
			FALSE,           // flag - should wild cards affect files only?
			TRUE,            // flag - suppress confirmation messages?
			TRUE,            // flag - suppress confirmation messages 
			// when making directories?
			FALSE,           // flag - rename files when name collisions occur?
			FALSE);         // flag - simple progress dialog?
		if (sfo.Go(&bAPICalled, &nAPIReturnVal))
		{
			// The operation succeeded!
		}


		// start generating string for fortran batch procoessing
		name = m_strPathName;
		int nPathLength = GetModuleFileName(NULL, name.GetBuffer(_MAX_PATH), _MAX_PATH);
		name.ReleaseBuffer();
		CString progPath = "\"" + name.Left(name.ReverseFind('\\')) + ("\\sembRayinvr.exe\"");
		// progPath += ("\\sembRayinvr.exe\"");


		CString str;
		str.Format(_T(" %3d %3d %6.3f"), 0, draw.raymode, 1.5f);
		progPath += str;
		myUnicodeProcess(progPath, txPath);

		if (AfxMessageBox(_T("Please wait for the raytracing program to finish. Click YES when finished raytracing. Click NO to quit."), MB_YESNO | MB_ICONINFORMATION) == IDNO) {
			return;
		}
		isRaytrace = FALSE; // the next time it runs the same routine, it will be prompted as not raytracing again.
	}

	if (fileContour.IsEmpty()) fileContour = txPath + "\\myf.txt";

	float vPerturb = 1.5f;
	astr.Format(_T("%s\\%s%5.3f"), txPath, txoutName, vPerturb);
	CStringArray *txArray = getLinesFromFile(astr);
	if (txArray == NULL) {
		AfxMessageBox(_T("Failed to load the raytraced results."));
		return;
	}




	CStringArray *xzContourArray = getLinesFromFile(fileContour);
	int npoint = 0;
	int izOld = 0;
	int i, iz;
	float f1, f2, f7, f8;
	int np_max = 30;
	bool isProb = false;
	for (icont = 0; icont < velMod.ncont; icont++)
	{
		if (npoint < velMod.nzed[icont]) npoint = velMod.nzed[icont];
	}
	float **xArray = (float **)ealloc2float(npoint * 2, nz);
	float **zArray = (float **)ealloc2float(npoint * 2, nz);    // data for the floating reflectors.
	int *nArray = (int *)ealloc1int(nz);
	i = 0;
	for (j = 0; j < xzContourArray->GetSize(); j++) {
		if (_stscanf_s(xzContourArray->ElementAt(j).Trim(), _T("%f%f%d"), &f1, &f2, &iz) == 0) continue;
		if (iz >= nz) {
			// if here, the raytracing data does not exactly match the current paramaters. The user 
			// will have to raytrace again.
			isProb = true;
		}
		if (iz != izOld) {
			nArray[izOld] = i;
			i = 0;
			izOld = iz;
		}
		xArray[iz][i] = f1;
		zArray[iz][i] = f2;
		i++;
	} // if j
	nArray[iz] = i; // last line needs to assign
	xzContourArray->RemoveAll();
	delete xzContourArray;
	xzContourArray = NULL;

	if (iz != nz - 1) isProb = true;
	if (isProb) {
		free2float(xArray);
		free2float(zArray);
		free1int(nArray);
		astr = _T("Parameter in the raytracing mismatches. Please rerun this processing.");
		AfxMessageBox(astr);
		OnTimeForwide();
		return;
	}



	// ################### Use the raytracing results to form segy output
	segy tr;
	bhed bh;

	CFile file;
	if (!file.Open(draw.timeSecName, CFile::modeRead | CFile::typeBinary | CFile::shareDenyNone)) {
		return;
	}
	file.Seek(0, CFile::begin);
	UINT bytesRead = file.Read(head.ascHead, 3200L);
	if (bytesRead < 3200)
		AfxMessageBox(_T("Ascii section header read wrong"));
	file.Read(&bh, sizeof(bhed));
	if (bytesRead < 400)
		AfxMessageBox(_T("Binary section header read wrong"));
	//The following numbers have to be recalculated everytime,
	//because plotting the depth section will change these numbers.

	int numsamp = bh.hns;
	int format = bh.format;
	// backup the original format since bh.format will be overwritten for output header
	int len = (format != 3) ? (numsamp * 4 + 240) : (numsamp * 2 + 240);
	if (bh.hdt == 0) bh.hdt = bh.dto;
	int tpp = bh.hdt;

	long nzmin = (int)ceil(cd.coord.m_zmin / velColor.dz);
	long nzmax = nzmin + nz;
	float dtField = (float)((double)tpp / (double)MIL);

	//For progress control, need to know the last bytes no.
	ULONGLONG curBytesRead, totBytesRead = file.GetLength();
	file.Seek(3600, CFile::begin);

	//Begin progress control.
	CMainFrame* pFrame =
		(CMainFrame*)AfxGetMainWnd();
	ASSERT(pFrame);
	ASSERT_KINDOF(CMainFrame, pFrame);
	pFrame->BeginProgress();

	int nxmax = 0;  // total number of traces in the input segy file
	while (file.Read(&tr, 4) == (UINT)4)
	{
		file.Seek(len - 4, CFile::current);
		nxmax++;
	}
	file.Seek(3600, CFile::begin);

	// allocate array big enough for storing all the input segy data in memory
	segydynamic *trArr = (segydynamic *)xmalloc(sizeof(segydynamic) * nxmax);
	if (ERROR == trArr) return;
	for (j = 0; j < nxmax; j++) {
		trArr[j].data = ealloc1float(numsamp);
		if (ERROR == trArr[j].data) {
			// clean up before return
			for (int jj = 0; jj < j - 1; jj++) {
				free1float(trArr[jj].data);
				trArr[jj].data = NULL;
			}
			AfxMessageBox(_T("Sorry, failed to allocate memory for loading all traces into memory."));
			return;
		}
	} // for j


	int nxStore = 0;
	if (dig.xShotCache <= ERRORVAL) dig.xShotCache = 0.;  // a fix
	while (file.Read(&tr, len) == (UINT)len) {
		//Formulating velocity traces first.
		curBytesRead = file.Seek(0, CFile::current);
		int iPos = (int)((double)curBytesRead / (double)totBytesRead*100.);
		if (iPos < 0)iPos = 0;
		if (iPos > 100)iPos = 100;
		pFrame->SetProgress(iPos);

		if (tr.trid == 2) //dead traces.
		{
			file.Seek(len, CFile::current);
			continue;
		}


		// assign only the trace header to the trArr[]
		memcpy((void *)&trArr[nxStore], (void *)&tr, 240L);

		// Note: format points to the original data in time, while bh.format  is already modified for output
		if (format == 3)
			for (j = 0; j < numsamp; j++) trArr[nxStore].data[j] = (float)tr.dat.datashort[j];
		else if (format == 1) {
			ibm_to_float((int *)tr.dat.data, (int *)tr.dat.data, (int)numsamp);
			for (j = 0; j < numsamp; j++) trArr[nxStore].data[j] = (float)tr.dat.data[j];
		}
		else if (format == 2)
			for (j = 0; j < numsamp; j++) trArr[nxStore].data[j] = (float)tr.dat.dataint[j];
		else if (format == 5) {
			for (j = 0; j<numsamp; j++) trArr[nxStore].data[j] = (float)tr.dat.data[j];
		}
		else break;

		double aMedian = getMedianAbsolute(&trArr[nxStore].data[0], numsamp);
		if (aMedian < MINAMP) continue;

		if (draw.sphericOrder > 0.f) {
			double a = tr.getTraceDelay();  // a is now the initial time in sec for this trace

			double aGain = pow(a + numsamp *  dtField, (double)draw.sphericOrder);
			if (aGain > 0.) aGain = 1. / aGain;
			else aGain = 1.;

			double b;
			for (j = 0; j < numsamp; j++) {
				b = a + j* (double)tpp / (double)MIL;      // b is now the actual time in sec for the inidex j
				if (draw.sphericOrder == 2.f)
					trArr[nxStore].data[j] *= (float)(b*b*aGain);
				else
					trArr[nxStore].data[j] *= (float)(aGain* pow(b, (double)draw.sphericOrder));
			}  // for j
		} // if

		nxStore++;
	} // while file.Read
	file.Close();
	pFrame->EndProgress();



	// ####NOTE: nxmax is frequently smaller than originally planned!
	if (nxStore < nxmax) {
		for (j = nxStore; j < nxmax; j++) {
			free1float(trArr[j].data); trArr[j].data = NULL;
		}
		nxmax = nxStore;
	} // for 

	// finished loading all segy data into memory trArr[]
	astr.Format(_T("finished loading all segy data into memory"));
	pFrame->SetMessageText(astr);



	//################################################################################
	//############################ start loading X-T values for velocity perturbation#####
	//################################################################################

	// first, we need to calculate max number of points of (x,t) pair for a certain iz
	float **xwTraced = (float **)ealloc2float(np_max, nz);
	float **twTraced = (float **)ealloc2float(np_max, nz);
	int *numTraced = (int *)ealloc1int(nz);
	float *zTraced = (float *)ealloc1int(nz);  // not used at all
	memset((void *)xwTraced[0], 0, sizeof(float)*np_max*nz);
	memset((void *)twTraced[0], 0, sizeof(float)*np_max*nz);
	memset((void *)numTraced, 0, sizeof(int)*nz);
	memset((void *)zTraced, 0, sizeof(float)*nz);
	bool isTooMany = false;


	int izmaxTraced = -1;
	isProb = false;

	for (j = 0; j < txArray->GetSize(); j++) {
		if (_stscanf_s(txArray->ElementAt(j).Trim(), _T("%f%f%d%d%f%f"), &f1, &f2, &iz, &icont, &f7, &f8) == 0) continue;
		if (iz == 0 && !isFloatEqual(f8, (float)cd.coord.m_zmin)) {
			isProb = true;
			cd.coord.m_zmin = f8;
			break;
		}
		if (iz == -2 && !isFloatEqual(f8, (float)velColor.dz)) {
			// this is the last line of a raytracing file
			isProb = true;
			velColor.dz = f8;
			break;
		}
		if (iz <= 0 || icont == 0 || iz > nz) continue;  // note: input file has  iz=1:nz.... from Fortran
		if ((i = numTraced[iz - 1]) < np_max) {
			xwTraced[iz - 1][i] = f1;
			twTraced[iz - 1][i] = f2;
			numTraced[iz - 1]++;  // we want array index to be zero based
			zTraced[iz - 1] = f8;  // not used at all
			// so we just ignore the user input
			if (izmaxTraced < iz) izmaxTraced = iz;
		}
		else {
			isTooMany = true;
		}
	} // if j
	txArray->RemoveAll();
	delete txArray;
	txArray = NULL;


	if (!isProb) {
		// since xw[][] may not be ordered monotonically with distance, we need to reorder it.
		for (iz = 0; iz < nz; iz++) {
			for (j = 0; j < numTraced[iz] - 1; j++) {
				for (int k = j + 1; k<numTraced[iz]; k++) {
					if (xwTraced[iz][j] > xwTraced[iz][k]) {
						// swap the 2 values
						f1 = xwTraced[iz][j];
						xwTraced[iz][j] = xwTraced[iz][k];
						xwTraced[iz][k] = f1;
						f1 = twTraced[iz][j];
						twTraced[iz][j] = twTraced[iz][k];
						twTraced[iz][k] = f1;
					} // if
				} // for k
			} // for j
		} // for iz

		astr.Format(_T("finished loading and parsing into memory the raytracing results"));
		pFrame->SetMessageText(astr);
	} // if


	// note: sei_zAll[nvPerturb][iz]  info is only for checking here, not used in later NMO calculation, as we all assume
	//       the depth indece are uniform.

	if (isTooMany)
		AfxMessageBox(_T("Too many points found in the raytracing. Will truncate. You may limit number of points per ray <=30 ."));
	if (isProb) {
		free2float(xwTraced); xwTraced = NULL;
		free2float(twTraced); twTraced = NULL;
		free1int(numTraced); numTraced = NULL;
		free1float(zTraced); zTraced = NULL;
		for (j = 0; j < nxmax; j++) {
			free1float(trArr[j].data); trArr[j].data = NULL;
		}
		xfree(trArr); trArr = NULL;

		astr = _T("Depth in the raytracing mismatches with desired zmin, zmax or dz that are now adjusted accordingly. Note that temporary raytracing results cannot be mixed for different running. Please rerun this processing.");
		AfxMessageBox(astr);
		OnTimeForwide();
		return;
	}







	CFile filez;
	if (!filez.Open(draw.depthSecName, CFile::modeCreate | CFile::modeReadWrite | CFile::typeBinary)) {
		return;
	}

	filez.Write(head.ascHead, 3200L);
	bh.hns = nz; // numsamp for output;
	bh.format = 1; // we always output in floating points
	bh.hdt = (unsigned short)myRound(velColor.dz*MIL);	//Sampling rate;
	filez.Write(&bh, sizeof(bh));

	//Prepare to formulate velocity traces.
	WORD totShot = 0;
	double oneodt = (double)(MIL / (double)tpp);

	astr.Format(_T("Start loop for 2D NMO correction. Please wait ..."));
	pFrame->SetMessageText(astr);
	segydynamic tTrcDepth;
	tTrcDepth.data = (float *)ealloc1float(nz);
	segydynamic trcDepth;
	trcDepth.data = (float *)ealloc1float(nz);
	// memset((void *)tTrcDepth.data, (int)'\0', sizeof(float)*nz);
	double t1, t2, x1, x2, t11, x11;
	for (nxStore = 0; nxStore < nxmax; nxStore++) {
		memcpy((void *)&tr, (void *)&trArr[nxStore], 240L);
		// float offset = getOffset(&tr); // note: offset here can be negative!
		//	if (!isFloatEqual(0.f, offsetMax) &&  fabs(offset) > 2.f*offsetMax) continue;
		float dist = tr.getDistance();

		for (iz = 0; iz < nz; iz++) {
			// tTrcDepth.data[iz] = -1.f;
			tr.dat.data[iz] = 0.f;
			int n = numTraced[iz];
			if (n < 2) continue;
			// Be very careful here, as it affects the results drastically!

			// Now stack ~2km of data trArr[0:nxmax-1] around dist=getDistance(&trArr[nxStore]) along a hyperbola curve  
			// this curve is controled by indexTracedFound, m=numTraced[iz], xwTraced[iz][0:indexTracedFound:m], xwTraced[][], x1,x2,t1,t2,
			// put result into  tr.dat.data[iz].
			int countStacked = 0;
			float widthAtDepth = stackWidth + iz * (float)velColor.dz * stackWidthGradient;
			for (int ix = 0; ix < nxmax; ix++) {
				float x = trArr[ix].getDistance();
				if (x < dist - widthAtDepth*0.5f || x > dist + widthAtDepth*0.5f) continue;
				float offset = trArr[ix].getOffset(); // note: offset here can be negative!

				// now we want to stack all the remaining traces along a given hyperbola which is already pre-calculated in the arrays
				// we just need to use linear interpolcations
				bool isFound = false;
				for (j = 1; j < numTraced[iz]; j++) {
					if (x >= xwTraced[iz][j - 1] && x < xwTraced[iz][j]) {
						x1 = xwTraced[iz][j - 1] - dig.xShotCache; // we calculate using offset instead of dist here
						x2 = xwTraced[iz][j] - dig.xShotCache;
						t1 = twTraced[iz][j - 1];
						t2 = twTraced[iz][j];

						if ((x1 < 0) == (x2 < 0)) {
							// now x1 and x2 are on the same side of the source
							isFound = true;
						}
						else {
							// now the 2 points are on diff sides of the source
							if ((x1 < 0) == (offset < 0)) {
								// x1 and xw[iz][j-1] is on the same side as source
								if (j > 1) {
									x1 = xwTraced[iz][j - 2] - dig.xShotCache;
									x2 = xwTraced[iz][j - 1] - dig.xShotCache;
									t1 = twTraced[iz][j - 2];
									t2 = twTraced[iz][j - 1];
									isFound = true;
								}
							} // if x1
							else {
								// x2 and xw[iz][j] is on the same side as source
								if (j < numTraced[iz] - 1) {
									x1 = xwTraced[iz][j] - dig.xShotCache;
									x2 = xwTraced[iz][j + 1] - dig.xShotCache;
									t1 = twTraced[iz][j];
									t2 = twTraced[iz][j + 1];
									isFound = true;
								}
							}
						} // if x1

						break;
					} // if dist
				} // for j
				if (!isFound) {
					// this part is important, since sometimes Zelt's raytracing cannot reach a certain distance
					// while the observed phases are strong there, such as the shallowest sediment reflections in
					// a complex 2D structure
					int jj = numTraced[iz] - 1;
					if (x < xwTraced[iz][0]) {
						x1 = xwTraced[iz][0] - dig.xShotCache;
						x2 = xwTraced[iz][1] - dig.xShotCache;
						t1 = twTraced[iz][0];
						t2 = twTraced[iz][1];
						isFound = true;
					}
					else if (x > xwTraced[iz][jj]) {
						x1 = xwTraced[iz][jj - 1] - dig.xShotCache;
						x2 = xwTraced[iz][jj] - dig.xShotCache;
						t1 = twTraced[iz][jj - 1];
						t2 = twTraced[iz][jj];
						isFound = true;
					}
				}
				if (!isFound) continue;

				// **** we get:   x1,x2,t1,t2  for  trArr[ix]  ****
				float tInterpolated = -1.f;
				if (fabs(t1 - t2) < 0.0001) {
					tInterpolated = (float)t1;
				}
				else {
					// first try hyperbola interpolation
					t11 = t1*t1;
					x11 = x1*x1;
					double x22 = x2*x2;
					double t22 = t2*t2;
					double vr2 = (x22 - x11) / (t22 - t11);
					if (fabs(vr2) > MINAMP) {
						// hyperbola interpolation
						double t00 = t11 + (offset*offset - x11) / vr2;
						if (t00 > 0.) {
							tInterpolated = (float)sqrt(t00);
						}
					}
					else {
						// testing shows this neven happened
						int ttt = 1;
					}
					if (tInterpolated < 0.f) {
						// since hyperbola interpolation fails, we do linear interpolation
						// continue;  // testing shows this neven happened
						if (fabs(x2 - x1) > 0.0001)
							tInterpolated = (float)(t1 + (offset - x1) / (x2 - x1) * (t2 - t1));
						else
							tInterpolated = (float)t1;
					}
				} // else

				// **** now we use: tInterpolated  for  trArr[ix] ****
				tr.dat.data[iz] += trArr[ix].getTraceAmp(tInterpolated, dtField);
				countStacked++;
			} // for ix
			if (countStacked > 1) tr.dat.data[iz] /= (float)countStacked;


			// now tr.dat.data[iz=0:nz-1] has a wrong depth except at dist! we need to correct this using the contouring scheme
			// the desired distance should be at the reflecting point CMP
			double offsetOut = dist - dig.xShotCache; // note: offset here can be negative!
			double cmpOut = dig.xShotCache + offsetOut*0.5f; //**** Improtant */
			double ax;
			for (iz = 0; iz < nz; iz++) {
				// we will put the real depth in km into array  tTrcDepth.data[iz]
				tTrcDepth.data[iz] = -1.f;
				for (j = 0; j < nArray[iz] - 1; j++) {
					if ((cmpOut >= xArray[iz][j] && cmpOut <= xArray[iz][j + 1])
						||
						(cmpOut >= xArray[iz][j + 1] && cmpOut <= xArray[iz][j])
						) {
						// found the segment of contour
						ax = (xArray[iz][j + 1] - xArray[iz][j]);
						if (fabs(ax) < 0.00001f)
							tTrcDepth.data[iz] = zArray[iz][j];
						else
							tTrcDepth.data[iz] = (float)(zArray[iz][j] + (zArray[iz][j + 1] - zArray[iz][j]) * (cmpOut - xArray[iz][j]) / ax);
						break;
					} // if
				} // for j
				if (tTrcDepth.data[iz] < 0.f) {
					int dasdas = 1; // never happened
				}
			} // for iz

			double az, bz;
			for (int izMig = 0; izMig < nz; izMig++) {
				az = cd.coord.m_zmin + (double)izMig * velColor.dz;
				for (iz = 0; iz < nz - 1; iz++) {
					// look for the right index to grab the correct amp
					if (az >= tTrcDepth.data[iz] && az <= tTrcDepth.data[iz + 1]) {
						// found it
						// trcDepth.data[izMig] = tr.dat.data[iz];
						bz = tTrcDepth.data[iz + 1] - tTrcDepth.data[iz];
						trcDepth.data[izMig] = (fabs(bz) < 0.0001) ?
							tr.dat.data[iz]
							:
							tr.dat.data[iz] +
							(tr.dat.data[iz + 1] - tr.dat.data[iz]) * (float)((az - tTrcDepth.data[iz]) / bz);
						break;
					}
				} // for j
			} // for izMig
			for (iz = 0; iz < nz; iz++) {
				tr.dat.data[iz] = trcDepth.data[iz];
			}


			//	memcpy( (void *)tr.dat.data, (void *)&vTrc[nzmin], (nzmax-nzmin+1)*sizeof(float));
			tr.ns = (unsigned short)nz;
			tr.dt = (unsigned short)(velColor.dz*MIL);
			tr.setTraceDelayF(cd.coord.m_zmin);
			tr.setDistance((float)cmpOut); // make it to be CMP

			if (format == 1) {
				float_to_ibm((int *)tr.dat.data, (int *)tr.dat.data, (int)nz);
			}
			filez.Write(&tr, nz*sizeof(float) + 240);
		} // for nxStore



		CString digNameOut = GetFileNameAppendExt(dig.digName, _T("2dnmoDepth"), _T("txt"));
		if (dig.isDigitizing && dig.isZeltFormat) {
			// Zelt format is in  dig struct. ******* this section needs revision******
			CDigitize pDg;
			CDigitize::DIGITIZE dig2;
			dig2.initDigitizeArray(2, dig.digPointMax*dig.totCurve);
			dig2.isZeltFormat = FALSE;
			dig2.totCurve = 0;  // we start from 0 here
			for (int ic = 0; ic < dig.totCurve; ic++) {
				for (int jp = 0; jp < dig.nPoint[ic]; jp++) {
					double dist = dig.x[jp][ic];
					double offset = dist - dig.xShotCache;
					dig2.nPoint[dig2.totCurve] = 0;
					// float tt = dig.t[jp][ic];

					for (iz = 0; iz < nz; iz++) {
						tTrcDepth.data[iz] = -1.f;
						int n = numTraced[iz];
						if (n < 2) continue;
						// Be very careful here, as it affects the results drastically!
						if (dist < xwTraced[iz][0] - offsetMax) continue; // we excluse any traces left of min raytraced distance
						if (dist > xwTraced[iz][n - 1] + offsetMax) continue;  // we excluse any traces right of max raytraced distance.

						double az = cd.coord.m_zmin + (double)iz * velColor.dz;
						bool isFound = false;
						for (j = 1; j < numTraced[iz]; j++) {
							if (dist >= xwTraced[iz][j - 1] && dist < xwTraced[iz][j]) {
								x1 = xwTraced[iz][j - 1] - dig.xShotCache; // we calculate using offset instead of dist here
								x2 = xwTraced[iz][j] - dig.xShotCache;
								t1 = twTraced[iz][j - 1];
								t2 = twTraced[iz][j];

								if ((x1 < 0) == (x2 < 0)) {
									// now x1 and x2 are on the same side of the source
									isFound = true;
								}
								else {
									// now the 2 points are on diff sides of the source
									if ((x1 < 0) == (offset < 0)) {
										// x1 and xw[iz][j-1] is on the same side as source
										if (j > 1) {
											x1 = xwTraced[iz][j - 2] - dig.xShotCache;
											x2 = xwTraced[iz][j - 1] - dig.xShotCache;
											t1 = twTraced[iz][j - 2];
											t2 = twTraced[iz][j - 1];
											isFound = true;
										}
									} // if x1
									else {
										// x2 and xw[iz][j] is on the same side as source
										if (j < numTraced[iz] - 1) {
											x1 = xwTraced[iz][j] - dig.xShotCache;
											x2 = xwTraced[iz][j + 1] - dig.xShotCache;
											t1 = twTraced[iz][j];
											t2 = twTraced[iz][j + 1];
											isFound = true;
										}
									}
								} // if x1

								break;
							} // if dist
						} // for j
						if (!isFound) {
							// this part is important, since sometimes Zelt's raytracing cannot reach a certain distance
							// while the observed phases are strong there, such as the shallowest sediment reflections in
							// a complex 2D structure
							int jj = numTraced[iz] - 1;
							if (dist < xwTraced[iz][0]) {
								x1 = xwTraced[iz][0] - dig.xShotCache;
								x2 = xwTraced[iz][1] - dig.xShotCache;
								t1 = twTraced[iz][0];
								t2 = twTraced[iz][1];
								isFound = true;
							}
							else if (dist > xwTraced[iz][jj]) {
								x1 = xwTraced[iz][jj - 1] - dig.xShotCache;
								x2 = xwTraced[iz][jj] - dig.xShotCache;
								t1 = twTraced[iz][jj - 1];
								t2 = twTraced[iz][jj];
								isFound = true;
							}
						}
						if (!isFound) continue;

						// get the tTrcDepth.data[iz] for interpolation
						if (fabs(t1 - t2) > 0.0001) {
							// testing shows here 0.0001  is better than MINAMP!!!
							bool isSuc = false;
							// first try hyperbola interpolation

							t11 = t1*t1;
							x11 = x1*x1;
							double vr2 = (x2*x2 - x11) / (t2*t2 - t11);
							if (fabs(vr2) > MINAMP) {
								// hyperbola interpolation
								double t00 = t11 + (offset*offset - x11) / vr2;
								if (t00 > 0.) {
									tTrcDepth.data[iz] = (float)sqrt(t00);
									isSuc = true;
								}
							}

							if (!isSuc) {
								// since hyperbola interpolation fails, we do linear interpolation
								// continue;  // testing
								if (fabs(x2 - x1) > 0.0001)
									tTrcDepth.data[iz] = (float)(t1 + (offset - x1) / (x2 - x1) * (t2 - t1));
								else
									tTrcDepth.data[iz] = (float)t1;
							}


						}
						else
							tTrcDepth.data[iz] = (float)t1;
					} // for iz

					// now for each dist, we get a complete array of tTrcDepth.data[iz], where iz=[0,nz). We now need to
					float zmin_bar = -1.f;
					float zmax_bar = -1.f;
					int iz2;
					for (iz = 0; iz < nz; iz++) {
						if (tTrcDepth.data[iz] < 0.f) continue;
						if (tTrcDepth.data[iz] >= dig.t[jp][ic] - dig.curveVal[ic] * 0.5f) {
							// found the iz is the start of the error bar in the depth domain
							zmin_bar = (float)(cd.coord.m_zmin + iz*velColor.dz);
							// now try to find the maximum value
							for (iz2 = iz; iz2 < nz; iz2++) {
								if (tTrcDepth.data[iz2] < 0.f) {
									// if here, only 1 iz is detected 
									zmax_bar = zmin_bar;
									break; // out of loop for iz2
								}
								else if (iz2>0 && tTrcDepth.data[iz2] > dig.t[jp][ic] + dig.curveVal[ic] * 0.5f) {
									zmax_bar = (float)(cd.coord.m_zmin + (iz2 - 1)*velColor.dz);
									break; // out of loop for iz2
								}
							} // for iz2
							if (zmax_bar < 0.f) zmax_bar = (float)(cd.coord.m_zmin + (nz - 1)*velColor.dz);
							break; // out of loop for iz
						} // if
					} // for iz

					if (zmin_bar > 0.f && zmax_bar > zmin_bar) {
						// now we need to add this point to dig2

						// estimated dz at the average depth
						//float dzHyperbola = dig.t[jp][ic] / (zmin_bar+zmax_bar) * dig.digResolution[ic] * (vmin+vmax) * 0.125f;
						//if (zmax_bar - zmin_bar > dzHyperbola * 5.f) {

						dig2.x[0][dig2.totCurve] = (float)(dig.xShotCache + offset*0.5);
						dig2.x[1][dig2.totCurve] = (float)(dig.xShotCache + offset*0.5);
						dig2.t[0][dig2.totCurve] = zmin_bar;
						dig2.t[1][dig2.totCurve] = zmax_bar;
						dig2.nPoint[dig2.totCurve] = 2;
						dig2.totCurve++;
					} // if

				} // for jp
			} // for ic
			dig2.digName = digNameOut;
			dig.isSortedX = dig.isSortedY = FALSE;
			pDg.myDigSaveAs2(&dig2, false);
			dig2.freeDigAll();

			// now indicate to display the dig results in the depth domain
			//if (!isTimeDomain()) {
			//	dig.digName = digNameOut;
			//}
		} // if





		//################################################################################
		//############################ end loop for velocity perturbation###############
		//################################################################################

		//Free up space
		free2float(xwTraced); xwTraced = NULL;
		free2float(twTraced); twTraced = NULL;
		free1int(numTraced); numTraced = NULL;
		free1float(zTraced); zTraced = NULL;
		free1float(tTrcDepth.data);
		free1float(trcDepth.data);

		for (j = 0; j < nxmax; j++) {
			free1float(trArr[j].data); trArr[j].data = NULL;
		}
		xfree(trArr); trArr = NULL;

		free2float(xArray);
		free2float(zArray);
		free1int(nArray);








		//#####################################################################################################
		//#####################################################################################################
		//#####################################################################################################
		//#####################################################################################################

		cd.coord.drawmodeOld = cd.coord.drawmode;
		cd.coord.drawmode = 10;	//show section in TWTT domain.

		astr.Format(_T("Start converting back from depth to TWTT domain ..."));
		pFrame->SetMessageText(astr);
		//UpdateAllViews(NULL);
		//NotifyChanged();

		draw.strXLabelOverwrite = _T("Distance");

		// we need to use vTop[] and vBot[] info at the OBS location, so we pre-calculate
		double val;
		int it;
		double frac;
		float atimeOutput;
		double **twtt2d = (double **)ealloc2double(nz, 1);
		// double depth[MOD_LAYER_MAX],vTop[MOD_LAYER_MAX],vBot[MOD_LAYER_MAX];

		CVelMod vm;
		CVelMod::VELMOD_X modX;


		//################################################################################
		//################################################################################
		//################################################################################
		segydynamic *trzArr = (segydynamic *)xmalloc(sizeof(segydynamic) * nxmax);
		segydynamic *trzArr2 = (segydynamic *)xmalloc(sizeof(segydynamic) * nxmax);
		filez.Seek(3600L, CFile::begin);
		for (nxStore = 0; nxStore < nxmax; nxStore++) {
			trzArr[nxStore].data = (float *)ealloc1float(nz);
			trzArr2[nxStore].data = (float *)ealloc1float(numsamp);

			filez.Read(&trzArr[nxStore], 240L);
			if (format == 1)
				ibm_to_float((int *)&trzArr[nxStore].data[0], (int *)&trzArr[nxStore].data[0], (int)nz);
			filez.Read(&trzArr[nxStore].data[0], nz*sizeof(float));

			memcpy((void *)&trzArr2[nxStore], (void *)&trzArr[nxStore], 240L); // just copy the segy trace header only
			memset((void *)&trzArr2[nxStore].data[0], 0, sizeof(float)*numsamp);
		}



		//*******************************************************************
		//********* display results in the TWTT domain***********************
		//*******************************************************************
		//****************Now twtt2d[nvPerturb][iz] complete with all TWTT info****************
		//****************Now trzArr[nvPerturb].data[iz] with all un-migrated data in depth domain****************
		//****************Now trzArr2[nvPerturb].data[it] space allocated to store data in TWTT domain****************
		// NOTE: for twtt[nvPerturb][iz], and trzArr[nvPerturb].data[iz], iz=0 is at cd.coord.zmin !

		velMod.m_isConvert = true;
		for (nxStore = 0; nxStore < nxmax; nxStore++) {
			float dist = trzArr[nxStore].getDistance();
			if (dist<cd.coord.xmin || dist > cd.coord.xmax) continue;

			// pre-calculate twtt2d[0][] for the current trace with CMP distance
			modX.dist = dist;
			vm.initModX(&velMod, &modX, cd.coord.isTimeDomain() == TRUE, true, velColor.dz);
			if (draw.raymode > 0) {
				// here, we only assume S waves
				CStringArray *csArr = new CStringArray();
				if (loadParam(draw.rayName, _T("pois"), csArr)) {
					int poisCount = (int)csArr->GetCount();
					for (icont = 0; icont < velMod.ncont - 1; icont++)
					{
						float apois = (icont < poisCount) ?
							(float)_tstof(csArr->ElementAt(icont)) : (float)_tstof(csArr->ElementAt(poisCount - 1));
						float vsvp = (float)sqrt((1. - 2.*apois) / (2.*(1. - apois)));
						if (vsvp > 0.f) {
							// if vsvp == 0.f, it means water, and we have to use vTop[] vBot[] without any conversion to S wave
							modX.vTop[icont] *= vsvp;
							modX.vBot[icont] *= vsvp;
						}
					}
				} // if loadParam
				csArr->RemoveAll();
				delete csArr;
				csArr = NULL;
			} // if raymode

			memset((void *)twtt2d[0], 0, sizeof(double)*nz);
			vm.getTzFromZModGrad(&modX, nz, velColor.dz, &twtt2d[0][0]);
			// note: this function will produce nz values in twtt2d[0][0:nz-1]

			// convert from depth to twtt domain
			for (atimeOutput = (float)cd.coord.m_tmin, it = 0; atimeOutput <= (float)cd.coord.m_tmax; atimeOutput += dtField, it++) {
				// now we need to find out the corresponding index in tTrcDepth.data[] for atime
				if (it >= numsamp) continue;

				for (iz = 1; iz<nz; iz++) {
					if (atimeOutput <= twtt2d[0][iz]) {
						// now  atimeOutput is between  twtt2d[nvPerturb][iz-1]  and twtt2d[nvPerturb][iz]
						// NOTE: iz=0 is at cd.coord.zmin !
						frac = twtt2d[0][iz] - twtt2d[0][iz - 1];
						float zt = (fabs(frac) > 0.000001) ?
							(float)(velColor.dz * (iz - 1 + (atimeOutput - twtt2d[0][iz - 1]) / frac))
							:
							(float)(velColor.dz * (iz - 1));
						register double vt = vm.getVFromVz(&modX, zt + cd.coord.m_zmin);
						val = (fabs(frac) > 0.000001) ?
							trzArr[nxStore].data[iz - 1] + (trzArr[nxStore].data[iz] - trzArr[nxStore].data[iz - 1]) * (atimeOutput - twtt2d[0][iz - 1]) / frac
							:
							trzArr[nxStore].data[iz - 1];

						trzArr2[nxStore].data[it] = (float)val;
						break;  // finished for loop iz
					} // if atimeOutput, it
				} // for iz
			} // for atimeOutput
		} // for nxStore








		bh.dto = bh.hdt = (unsigned short)tpp;	//Sampling rate;
		bh.hns = numsamp;
		filez.Seek(3200L, CFile::begin);
		filez.Write(&bh, 400);
		for (nxStore = 0; nxStore < nxmax; nxStore++) {
			// memcpy((void *)&tr, (void *)&trzArr2[nvPerturb], 240L);
			trzArr2[nxStore].ns = (unsigned short)numsamp;
			trzArr2[nxStore].dt = (unsigned short)tpp;
			trzArr2[nxStore].setTraceDelayF(cd.coord.m_tmin);

			if (format == 1) {
				float_to_ibm((int *)&trzArr2[nxStore].data[0], (int *)&trzArr2[nxStore].data[0], (int)numsamp);
			}

			filez.Write(&trzArr2[nxStore], 240L);  // note for simplicity, the segy headers in trzArr[nvPerturb]  is not directly assigned
			filez.Write(&trzArr2[nxStore].data[0], numsamp*sizeof(float));
			//showArrayInFile(trzArr[nvPerturb].data, numsamp);
		} // for nxStore

		free2double(twtt2d);
		//*******************************************************************
		//********* end display results in the TWTT domain***********************
		//*******************************************************************


		// free some last memory blocks
		for (j = 0; j < nxmax; j++) {
			free1float(trzArr[j].data);
		}
		for (j = 0; j < nxmax; j++) {
			free1float(trzArr2[j].data);
		}
		xfree(trzArr2);
		xfree(trzArr);

		cd.coord.isDistanceDisplay = TRUE;  // always display in distance


		//################################################################################
		//################################################################################
		//############################ end preparing for P-velocity display###############
		//################################################################################




		filez.Close();


		CDigitize pDg;
		dig.freeDigAll();
		if (dig.isDigitizing && dig.isZeltFormat) {
			t.Format(_T("Zelt's format points are 2DNMO corrected to depth domain and stored in %s"), digNameOut);
			dig.digName = digNameOut;
			dig.isZeltFormat = FALSE;
			AfxMessageBox(t);
		}

		dig.isDigitizing = FALSE;
		draw.isSameDataDisplay = FALSE; //indicate display has been changed and will re-load all data in OnDraw().
//		draw.depthSecOld.Format(BLANK);	//recalculate gain.

		astr.Format(_T("Completed 2D NMO correction!"));
		pFrame->SetMessageText(astr);

		SetModifiedFlag();
		UpdateAllViews(NULL);
		NotifyChanged();
		//	AfxMessageBox(_T("Succesfully converting into depth domain");
	}
}

double CSeisWideDoc::getXp(double p, int nz, float dz, float vTrc[])
{
	double result = 0.;
	double p2 = p*p;
	for (int i = 0; i<nz; i++) {
		register double t = 1. - p2 * vTrc[i] * vTrc[i];
		if (t > 0.)
			result += dz*vTrc[i] / sqrt(t);
	}
	return result * 2. * p;
}
double CSeisWideDoc::setTp(double p, int nz, float dz, float vTrc[])
{
	double result = 0.;
	double p2 = p*p;
	for (int i = 0; i<nz; i++) {
		double t = 1. - p2 * vTrc[i] * vTrc[i];
		if (t > 0.)
			result += dz / (vTrc[i] * sqrt(t));
	}
	return result * 2.;
}

//
//int CSeisWideDoc::formatVelocityArray(float dvUniform, int ncont, double depth[], double vTop[], double vBot[])
//{
//	for (int i=0; i<ncont; i++) {  
//		if (fabs(vBot[i] - vTop[i]) > dvUniform) {
//			// if here, the velocity gradient is too great, we split the layer into smaller pieces 
//			for (int icont = ncont-1; icont>i; icont--) {
//				depth[icont+1] = depth[icont];
//				vTop[icont+1] = vTop[icont]; // no meaning for vTop[ncont]
//				vBot[icont+1] = vBot[icont];
//			}
//			depth[i+1] = depth[i] + dvUniform * (depth[i+1] - depth[i]) / (vBot[i] - vTop[i]);
//			vTop[i+1] = vTop[i] + dvUniform;
//			vBot[i+1] = vBot[i];
//			vBot[i] = vTop[i+1];
//			ncont ++;
//			return formatVelocityArray(dvUniform, ncont, (double *)&depth[0], (double *)&vTop[0], (double *)&vBot[0]);
//		}
//	} // for i
//	return ncont;
//}

/*
dvUniform is the velocity increment that can be treated minimal for a uniform velocity layer
*/
double CSeisWideDoc::getXp2(float p, float z, int ncont, double depth[], double vTop[], double vBot[])
{
	double result = 0.;
	double p2 = p*p;
	//for (int i=0; i<nz; i++) {
	//	double t = 1. - p2 * vTrc[i] * vTrc[i];
	//	if (t > 0.) 
	//		result += dz*vTrc[i] / sqrt(t);
	//}

	double t, v;
	for (int i = 0; i<ncont - 1; i++) {  // exclude the last layer for this loop
		if (z >= depth[i + 1]) {
			v = (vBot[i] + vTop[i]) * 0.5; // average velocity in this layer
			t = 1. - p2 * v * v;
			if (t > 0.)
				result += (depth[i + 1] - depth[i]) * v / sqrt(t);
			else
				return 99999.;  // invalid ray encountered
		}
		else {
			// wil terminate here
			t = depth[i + 1] - depth[i];
			if (t > 0.) {
				v = vTop[i] + (vBot[i] - vTop[i]) * (z - depth[i]) / t;
				t = 1. - p2 * v * v;
				if (t > 0.)
					result += (z - depth[i]) * v / sqrt(t);
				else {
					// note: we only want the last layer to return 99999. when ray invalid
					return 99999.;
				}
			}
			break;
		}
	} // for i

	return result * 2. * p;
}

bool CSeisWideDoc::getXp3(float p, float z, int ncont, double depth[], double vTop[], double vBot[], double xt[])
{
	// test
	//xt[0] = getXp2(p, (float)z, ncont, (double *)&depth[0], (double *)&vTop[0], (double *)&vBot[0]);
	//xt[1] = setTp2(p, (float)z, ncont, (double *)&depth[0], (double *)&vTop[0], (double *)&vBot[0]);
	//return (xt[0] != 99999.);



	xt[0] = 0.;
	xt[1] = 0.;
	double p2 = p*p;
	double oneov;
	double dz2;

	double tmp, v, dz, vz, x1, x2, x3, x4, t1, t2, t3, t4;
	double theta1, theta2, theta3, theta4;
	for (int i = 0; i < ncont - 1; i++) {  // exclude the last layer for this loop
		if (z >= depth[i + 1]) {
			dz = (depth[i + 1] - depth[i]);
			if (dz < 0.0001) continue;
			v = (vBot[i] + vTop[i]) * 0.5; // average velocity in this layer
			oneov = 1. / v;
			vz = (vBot[i] - vTop[i]) / dz;  // constant for each layer
			tmp = p * vTop[i];
			if (tmp <= 1.0) {
				theta1 = asin(tmp);
				tmp = p * v;
				if (tmp > 1.0)
					theta2 = theta3 = theta1;
				else
					theta2 = theta3 = asin(tmp);
				tmp = p * vBot[i];
				if (tmp > 1.0)
					theta4 = theta1;
				else
					theta4 = asin(tmp);

				//theta2 = theta1 + 0.5 * dz * vz * oneov * tan(theta1);
				//theta3 = theta2 + 0.5 * dz * vz * oneov * tan(theta2);
				//theta4 = theta3 + dz * vz * oneov * tan(theta3);

				x1 = tan(theta1) * dz; // first order
				x2 = tan(theta2) * dz; // second order. here, v is the vel at half the interval
				x3 = tan(theta3) * dz; // third order
				x4 = tan(theta4) * dz; // fourth order
				xt[0] += (x1 + 2.*x2 + 2.*x3 + x4) / 6.;  // Runge-Kutta formula

				dz2 = dz*dz;
				t1 = sqrt(x1*x1 + dz2) / vTop[i];
				t2 = sqrt(x2*x2 + dz2) * oneov;
				t3 = sqrt(x3*x3 + dz2) * oneov;
				t4 = sqrt(x4*x4 + dz2) / vBot[i];

				xt[1] += (t1 + 2.*t2 + 2.*t3 + t4) / 6.;  // Runge-Kutta formula
			}
			else {
				xt[0] = 99999.;
				return false;  // invalid ray encountered
			}
		}
		else {
			// will terminate here
			dz = (z - depth[i]);
			if (dz < 0.0000001 || vBot[i] <= vTop[i]) {
				// this means there is no need to calculate any more. The result is already usable
				break;
			}
			double vmid = vTop[i] + dz / (depth[i + 1] - depth[i]) * (vBot[i] - vTop[i]);
			v = (vmid + vTop[i]) * 0.5; // average velocity in this layer above z depth
			oneov = 1. / v;
			vz = (vmid - vTop[i]) / dz;  // constant for each layer
			tmp = p * vTop[i];
			if (tmp <= 1.0) {
				theta1 = asin(tmp);
				tmp = p * v;
				if (tmp > 1.0)
					theta2 = theta3 = theta1;
				else
					theta2 = theta3 = asin(tmp);
				tmp = p * vmid;
				if (tmp > 1.0)
					theta4 = theta1;
				else
					theta4 = asin(tmp);
				//theta2 = theta1 + 0.5 * dz * vz * oneov * tan(theta1);
				//theta3 = theta2 + 0.5 * dz * vz * oneov * tan(theta2);
				//theta4 = theta3 + dz * vz * oneov * tan(theta3);

				x1 = dz * tan(theta1); // first order
				x2 = dz * tan(theta2); // second order
				x3 = dz * tan(theta3); // third order
				x4 = dz * tan(theta4); // fourth order
				xt[0] += (x1 + 2.*x2 + 2.*x3 + x4) / 6.;  // Runge-Kutta formula


				dz2 = dz*dz;
				t1 = sqrt(x1*x1 + dz2) / vTop[i];
				t2 = sqrt(x2*x2 + dz2) * oneov;
				t3 = sqrt(x3*x3 + dz2) * oneov;
				t4 = sqrt(x4*x4 + dz2) / vBot[i];

				xt[1] += (t1 + 2.*t2 + 2.*t3 + t4) / 6.;  // Runge-Kutta formula
			}
			else {
				xt[0] = 99999.;
				return false;  // invalid ray encountered
			}
			break;
		}
	} // for i

	xt[0] *= 2.;
	xt[1] *= 2.;
	return true;
}

double CSeisWideDoc::setTp2(float p, float z, int ncont, double depth[], double vTop[], double vBot[])
{
	double result = 0.;
	double t, v;
	double p2 = p*p;
	for (int i = 0; i < ncont - 1; i++) {  // exclude the last layer for this loop
		if (fabs(depth[i + 1] - depth[i]) > 0.) {
			if (z >= depth[i + 1]) {
				v = (vBot[i] + vTop[i]) * 0.5; // average velocity in this layer
				t = 1. - p2 * v * v;
				if (t > 0.)
					result += (depth[i + 1] - depth[i]) / (v * sqrt(t));
				else
					return 99999.;  // invalid ray encountered
			}
			else {
				// wil terminate here
				t = depth[i + 1] - depth[i];
				if (t > 0.) {
					v = vTop[i] + (vBot[i] - vTop[i]) * (z - depth[i]) / t;
					t = 1. - p2 * v * v;
					if (t > 0.)
						result += (z - depth[i]) / (v * sqrt(t));
					else
						return 99999.;  // invalid ray encountered
				}
				break;
			} // if z>=
		} // if fabs(depth
	} // for i

	return result * 2.;
}

BOOL CSeisWideDoc::DrawVelocityLabelDepth(CDC* pDC, CVelMod::VELMOD *velm, double xShift, COLORREF cr)
{
	if (this->cd.coord.isTimeDomain() || draw.isNoLabelInSide || velm->ncont < 2)
		return FALSE;

	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();

	bool isMainModelShowing =
		GetBaseFileName(velm->velSecName) == GetBaseFileName(velMod.velSecName);

	if (!draw.isNoLabelInSide && !isMainModelShowing) {
		// only not the main model, we draw sonobuoy positions embeded in .VXML file
		// The main model can have raytracing has been performed, r.in file already contains OBS positions, so we do not want duplicates
		// But non-main models do not have OBS pos, unless displayed from here
		CVelMod::DrawSonobuoyPos(pDC, &cd.coord, velm, xShift, pFrame->statMain.bigNodes, cr, pFrame->statMain.isShowDetails);
	}
	

	double xpos;
	if (isMainModelShowing) {
		xpos = draw.xWell;
		if (isFloatEqual(xpos, (double)ERRORVAL)) 
			xpos = 0.5 * (velm->getXmin() + velm->getXmax());
		CVelMod::DrawVelocityLabelDepth2(pDC,
			&cd.coord,
			velm,
			xShift,
			xpos,
			cr,
			pFrame->statMain.fLabelDistance3,
			isMainModelShowing,
			draw.iLayerFocus,
			draw.nodeMode,
			velColor.dz);
	}
	else {
		int i;
		for (i = 0; i < TX_SHOTS_MAX; i++) {
			xpos = (float)velm->wells[i].wellDist;
			if (!isFloatEqual(xpos, (double)ERRORVAL)) break;
		}

		if (isFloatEqual(xpos, (double)ERRORVAL)) {
			for (i = 0; i < TX_SHOTS_MAX; i++) {
				xpos = (float)velm->deploys[i].deployDist;
				if (!isFloatEqual(xpos, (double)ERRORVAL)) break;
			}
		}

		if (xpos + xShift >= velm->getXmin() && xpos+xShift<= velm->getXmax())
			CVelMod::DrawVelocityLabelDepth2(pDC,
			&cd.coord,
			velm,
			xShift,
			xpos,
			cr,
			pFrame->statMain.fLabelDistance3,
			isMainModelShowing,
			draw.iLayerFocus,
			draw.nodeMode,
			velColor.dz);
	}

	return TRUE;
}


void CSeisWideDoc::DrawTempPoint(CDC* pDC, SEI_PAIR seip)
{
	if (!seip.isValid) return;
	CPoint plt;

	plt = cd.coord.mm_coord(seip.x, seip.y);

	CPen redPen(PS_SOLID, 1, RED);
	CPen *pOldPen = pDC->SelectObject(&redPen);
	pDC->Ellipse(plt.x - 200, plt.y - 200, plt.x + 200, plt.y + 200);
	pDC->SelectObject(pOldPen);
	seip.isValid = false;
}


void CSeisWideDoc::DrawVelocityTheoreticalDepth(CDC* pDC, CVelMod::VELMOD *velm)
{

	// global variables used: draw, velMod, para, psei
	if (this->cd.coord.isTimeDomain() || !draw.isShowTheoryModel || draw.isNoLabelInSide || velm->ncont < 2)
		return;

	CString tStr;
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();

	// now show the reference curves
	if (pFrame->psei->regionalModelA > 0.0001 && pFrame->psei->regionalModelB > 0.0001 && pFrame->psei->regionalModelV0 != 0.0) {
		CPen* oldPen;
		int numWaterLayers = (velMod.vf[0][1][0] > 1.55 || velMod.vf[0][1][1] > 1.55) ? 1 : 2;

		CPen bluePen(PS_DASH, 1, RGB(255, 0, 255));
		oldPen = pDC->SelectObject(&bluePen);
		double beta = log(pFrame->psei->regionalModelVinf / pFrame->psei->regionalModelV0 - 1.);

		double a = (1. / 2. - pFrame->psei->regionalModelA) / pFrame->psei->regionalModelB;
		double h = (log(a) - beta) / pFrame->psei->regionalModelAlpha;
	//	DrawModelDashCurve(pDC, velm, numWaterLayers, h);
		CVelMod::DrawModelDashCurve(pDC, &cd.coord, velm, numWaterLayers, h);
		a = (1. / 3. - pFrame->psei->regionalModelA) / pFrame->psei->regionalModelB;
		h = (log(a) - beta) / pFrame->psei->regionalModelAlpha;
		CVelMod::DrawModelDashCurve(pDC, &cd.coord, velm, numWaterLayers, h);
		a = (1. / 4. - pFrame->psei->regionalModelA) / pFrame->psei->regionalModelB;
		h = (log(a) - beta) / pFrame->psei->regionalModelAlpha;
		CVelMod::DrawModelDashCurve(pDC, &cd.coord, velm, numWaterLayers, h);
		pDC->SelectObject(oldPen);

	} // if pFrame
}

void CSeisWideDoc::OnViewVelocitycolortwtt()
{
	// TODO: Add your command handler code here
	// AfxMessageBox(_T("ok");
	dlgVelocityTwtt2 dlg;
	dlg.m_plotTitle = draw.plotTitle;
	dlg.m_velSecName = velMod.velSecName;
	dlg.m_xmax = (float)myFloat(cd.coord.xmax, 3);
	dlg.m_xmin = (float)myFloat(cd.coord.xmin, 3);
	dlg.m_xTick = (float)myFloat(cd.coord.xTick);
	dlg.m_tmin = (float)myFloat(cd.coord.m_tmin, 3);
	dlg.m_tmax = (float)myFloat(cd.coord.m_tmax, 3);
	dlg.m_tTick = (float)myFloat(cd.coord.tTick, 3);
	dlg.m_timeSecName = draw.timeSecName;

	dlg.m_gain = (float)myFloat(areaFill.gain, 3);
	dlg.m_clip = (float)myFloat(areaFill.clip, 3);

	// sometimes the clip is zero and it will not display well
	if (dlg.m_clip < 0.000001) dlg.m_clip = 1.9f;

	dlg.m_fillOff = (float)myFloat(areaFill.fillOff, 3);

	dlg.m_digName = dig.digName;
	dlg.m_markerName = digMarker.digName; // addition on Nov. 14, 2003
	dlg.m_xMultFactor = dig.transXMultFactor;
	dlg.m_xShift = dig.transXShift;
	dlg.m_yMultFactor = dig.transYMultFactor;
	dlg.m_yShift = dig.transYShift;
	dlg.m_markerRevYAxis = dig.transIsRevYAxis;
	dlg.m_vrmsTauName = draw.vrmsTauNameDisabled;
	dlg.m_wiggle = draw.wiggle;
	//dlg.m_isAveEnergy = draw.isAvgEnergy;
	dlg.m_ampPower = draw.ampPower;
	dlg.m_xWell = (float)draw.xWell;
	dlg.m_velModExtras = CVelMod::velNamesExReformat(draw.velSecNamesEx);
	dlg.m_distShift = draw.distShift;
	dlg.m_logScaleThreshold = draw.logScaleThreshold;
	dlg.m_isNegativeFill = areaFill.isNegativeFill;
	dlg.m_isSwapX = cd.coord.isSwapX;
	dlg.m_isSwapYLabel = cd.coord.isSwapYLabel;
	dlg.m_travelTime = draw.isRayShowing;

	if (dlg.DoModal() == IDOK) {
		draw.plotTitle = dlg.m_plotTitle;
		velMod.velSecName = dlg.m_velSecName.Trim();
		draw.timeSecName = dlg.m_timeSecName.Trim();
		cd.coord.xmax = (float)dlg.m_xmax;
		cd.coord.xmin = (float)dlg.m_xmin;
		cd.coord.xTick = (float)dlg.m_xTick;
		//cd.coord.setY2(dlg.m_tmax);
		//cd.coord.setY1(dlg.m_tmin);
		cd.coord.m_tmin = dlg.m_tmin;
		cd.coord.m_tmax = dlg.m_tmax;

		cd.coord.tTick = dlg.m_tTick;

		areaFill.gain = dlg.m_gain;
		areaFill.clip = dlg.m_clip;
		areaFill.fillOff = dlg.m_fillOff;

		CDigitize dg;
		if (dig.digName.CompareNoCase(dlg.m_digName) != 0) {
			dig.digName = dlg.m_digName; 
			dg.myDigitizingLoadTXTUnix2(&dig, FALSE);
		}
		if (digMarker.digName.CompareNoCase(dlg.m_markerName) != 0) {
			digMarker.digName = dlg.m_markerName; 
			dg.myDigitizingLoadTXTUnix2(&digMarker, FALSE);
		}


		dig.transXMultFactor = dlg.m_xMultFactor;
		dig.transXShift = dlg.m_xShift;
		dig.transYMultFactor = dlg.m_yMultFactor;
		dig.transYShift = dlg.m_yShift;
		dig.transIsRevYAxis = dlg.m_markerRevYAxis;
		draw.vrmsTauNameDisabled = dlg.m_vrmsTauName;
		draw.wiggle = dlg.m_wiggle;
		// draw.isAvgEnergy = dlg.m_isAveEnergy;
		draw.ampPower = dlg.m_ampPower;
		draw.xWell = dlg.m_xWell;
		//if (velMod.wells[0].wellDist != dlg.m_xWell) {
		//	velMod.wells[0].wellDist = dlg.m_xWell;
		//	velMod.wells[0].wellLatLong[0] =
		//		velMod.wells[0].wellLatLong[1] =
		//		ERRORVAL;
		//}

		draw.velSecNamesEx = dlg.m_velModExtras;
		draw.distShift = dlg.m_distShift;
		draw.logScaleThreshold = dlg.m_logScaleThreshold;
		cd.coord.isSwapX = dlg.m_isSwapX;
		cd.coord.isSwapYLabel = dlg.m_isSwapYLabel;
		areaFill.isNegativeFill = dlg.m_isNegativeFill;
		draw.isRayShowing = dlg.m_travelTime;
	}
	else
		return;

	cd.coord.drawmodeOld = cd.coord.drawmode;  // setting this to -1 guarentees re-calc velMod.tm[] , otherwise if cd.coord.drawmodeOld==cd.coord.drawmode it will not re-calc tm[]!!!
	cd.coord.drawmode = 9;	//Velocity contours will be drawn in TWTT domain.
	draw.isSameDataDisplay = FALSE; //indicate display has been changed and will re-load all data in OnDraw().

	SetModifiedFlag();
	UpdateAllViews(NULL);
	NotifyChanged();

}


void CSeisWideDoc::DrawVelocityLabelTwtt2(CDC* pDC, CVelMod::VELMOD *velm, double xShift, COLORREF cr)
{
	// global variables used: draw, velMod, para
	if (!this->cd.coord.isTimeDomain() || draw.isNoLabelInSide || velm->ncont < 2)
		return;
	setCurrentPathAs(getWorkingPathSlash());
	if (!isFileExistNotDirectory(velm->velSecName) || !this->isModelVisible(velm, xShift)) return;

	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();

	if (!draw.isNoLabelInSide) {
		// draw sonobuoy symbol
		CVelMod::DrawSonobuoyPos(pDC, &cd.coord, velm, xShift, pFrame->statMain.bigNodes, cr, pFrame->statMain.isShowDetails);
	}

	bool isMainModelShowing =
		GetBaseFileName(velm->velSecName) == GetBaseFileName(velMod.velSecName);

	if (isMainModelShowing)
		CVelMod::DrawVelocityLabelTwtt2(pDC,
			&cd.coord,
			velm,
			xShift,
			(double)draw.xWell,
			cr,
			pFrame->statMain.fLabelDistance3,
			isMainModelShowing,
			pFrame->statMain.isShowDetails,
			draw.iLayerFocus,
			draw.nodeMode,
			velColor.dz);
	else {
		double xpos;
		int i;
		for (i = 0; i < TX_SHOTS_MAX; i++) {
			xpos = (float)velm->wells[i].wellDist;
			if (!isFloatEqual(xpos, (double)ERRORVAL)) break;
		}

		if (isFloatEqual(xpos, (double)ERRORVAL)) {
			for (i = 0; i < TX_SHOTS_MAX; i++) {
				xpos = (float)velm->deploys[i].deployDist;
				if (!isFloatEqual(xpos, (double)ERRORVAL)) break;
			}
		}

		CVelMod::DrawVelocityLabelTwtt2(pDC,
			&cd.coord,
			velm,
			xShift,
			xpos,
			cr,
			pFrame->statMain.fLabelDistance3,
			isMainModelShowing,
			pFrame->statMain.isShowDetails,
			draw.iLayerFocus,
			draw.nodeMode,
			velColor.dz);
	}


	return; // ????





	//double xpos = velm->wells[0].wellDist + xShift;
	//if (xpos<velm->getXmin() || xpos>velm->getXmax())
	//	xpos = velm->deploys[0].deployDist + xShift;

	////if (!cd.coord.isVisibleOrNot(xpos + xShift)) return;


	//CString tStr;

	//// can move this code to a separate routine
	//// xShift will not be applied to RMS velocity display as below
	//int oldBkMode = pDC->SetBkMode(OPAQUE);
	//CPoint p1, p2;
	//if (!draw.vrmsTauNameDisabled.IsEmpty() && cd.coord.isVisibleOrNot(dig.xShotCache)) {

	//	LOGFONT logFontNum;  // font for drawing numbers
	//	pDC->GetCurrentFont()->GetLogFont(&logFontNum);
	//	float xyRatio = (float)logFontNum.lfWidth / (float)logFontNum.lfHeight;
	//	int numXLogical = (int)myRound(pFrame->statMain.fLabelDistance3 * cd.coord.device2Logical * cd.coord.getDefDisplayAdjust(pDC) * 6.);
	//	int numYLogical = (int)(numXLogical / xyRatio);

	//	CDigitize::DIGITIZE dig2;
	//	CDigitize pDg;
	//	int xplot;
	//	int yplot;
	//	dig2.digName = draw.vrmsTauNameDisabled;
	//	if (pDg.myDigitizingLoadTXTUnix2(&dig2, FALSE)) {
	//		int n = dig2.nPoint[0];
	//		bool isMilisec = (dig2.x[n - 1][0] > 1000.f) ? true : false;

	//		for (int j = 0; j < n; j++) {
	//			if (j > 500) break; // we do not think this is a valid file

	//			register float t = dig2.t[j][0];
	//			if (isMilisec) t *= 0.001f;
	//			if (t < cd.coord.tmin || t > cd.coord.tmax) continue;
	//			p1 = cd.coord.mm_coord(xpos, t);

	//			xplot = p1.x + 9 * numXLogical;
	//			yplot = p1.y;

	//			// minor adjustment for label vertical position
	//			if (j + 1 < n) {
	//				register float tNext = dig2.t[j + 1][0];
	//				if (isMilisec) tNext *= 0.001f;
	//				p2 = cd.coord.mm_coord(xpos, tNext);
	//				register int yplotNext = p2.y;
	//				if (yplotNext - yplot < numYLogical + 2) {
	//					// the next label is too close. 
	//					yplot = yplotNext - numYLogical - 2;
	//				}
	//			}

	//			register float v = dig2.x[j][0];
	//			if (isMilisec) v *= 0.001f;
	//			v = myFloat(v, 2);
	//			tStr.Format(_T("%1.2f"), v);
	//			pDC->TextOut(xplot, yplot, tStr);
	//		} // for j
	//		tStr.Format(_T("(Vint-rms)"));
	//		p1 = cd.coord.mm_coord(xpos, (float)cd.coord.tmin);
	//		pDC->TextOut(xplot, p1.y, tStr);
	//	} // if
	//} // if velMod


	//pDC->SetBkMode(oldBkMode);
	//return;
}


// this function will draw only dotted lines for all uncontroled parts of the model VELMOD *velm in either depth or time domain
BOOL CSeisWideDoc::DrawVelocityUncontroledRight(CDC* pDC, CVelMod::VELMOD *velm, double xShift)
{
//	return TRUE;

	if (draw.isNoBoundary) return TRUE;
	if (!cd.coord.isDistanceDisplay) return FALSE;
	if (!this->isModelVisible(velm, xShift)) return FALSE;
	int i, j, icont;

	//Generate velocity contours
	CPoint p, p1, plt[MOD_POINTS_MAX * 2], pltOld[MOD_POINTS_MAX];
	double xx[MOD_POINTS_MAX * 2], tt[MOD_POINTS_MAX * 2];
	CPen* pOldPen;
	int lineWidthThis = (int)(cd.coord.getPenThicknessNormal()/2.7);
	CPen dotPen(PS_DOT, lineWidthThis, RGB(255, 100, 0));

	pOldPen = pDC->SelectObject(&dotPen);  // tempoarily initialize pOldPen
	bool isTime = cd.coord.isTimeDomain();
	for (icont = 0; icont < velm->ncont; icont++) {
		if (velm->xmMax[icont] == ERRORVAL) continue;
		i = 0;
		xx[i] = velm->getXmax(icont);
		tt[i] = (float)velm->getCurrHorizonAtDist((float)xx[i], icont, isTime);
		xx[i] += xShift;
		i++;
		for (j = 0; j < velm->nzed[icont]; j++) {
			xx[i] = velm->xm[j][icont];
			if (xx[i] > velm->getXmax(icont)) {
				xx[i] += xShift;
				tt[i] = isTime ? velm->tm[j][icont] : velm->zm[j][icont];
				i++;
			}
		} // for j
		if (i < 2) continue;
		register int nLimit = min(2 * i, MOD_POINTS_MAX * 2);
		i = myClipPoints2(i, nLimit, xx, tt, cd.coord.X12Y12());
		if (i < 2) continue;
		for (j = 0; j < i; j++)
			plt[j] = cd.coord.mm_coord(xx[j], tt[j]);

		// when a polygon has a segment at the axes, I need to split the polygon into 2. 
		// The clipping routine above already modified the curve this way when it crosses the axes.
		register bool isLinePlotted = false;
		for (j = 0; j < i - 1; j++) { // note: i is the total number of points to plot
			if (plt[j].y == cd.coord.logicalAxes.top || plt[j].y == cd.coord.logicalAxes.bottom) {
				if (plt[j].y == plt[j + 1].y) {
					// now plot it with 2 polygons
					pDC->Polyline(plt, j + 1);
					pDC->Polyline(&plt[j + 1], i - j - 1);
					isLinePlotted = true;
					break;
				}
			}
		}
		if (!isLinePlotted)
			pDC->Polyline(plt, i);
	}
	pDC->SelectObject(pOldPen);

	return TRUE;
}

BOOL CSeisWideDoc::DrawVelocityUncontroledLeft(CDC* pDC, CVelMod::VELMOD *velm, double xShift)
{
	if (draw.isNoBoundary) return TRUE;
	if (!cd.coord.isDistanceDisplay) return FALSE;
	if (!this->isModelVisible(velm, xShift)) return FALSE;
	int i, j, icont;

	//Generate velocity contours
	CPoint p, p1, plt[MOD_POINTS_MAX * 2], pltOld[MOD_POINTS_MAX];
	double xx[MOD_POINTS_MAX * 2], tt[MOD_POINTS_MAX * 2];
	CPen* pOldPen;
	int lineWidthThis = (int)(cd.coord.getPenThicknessNormal() / 2.7);
	CPen dotPen(PS_DOT, lineWidthThis, RGB(255, 100, 0));

	pOldPen = pDC->SelectObject(&dotPen);  // tempoarily initialize pOldPen
	bool isTime = cd.coord.isTimeDomain();
	for (icont = 0; icont < velm->ncont; icont++) {
		if (velm->xmMin[icont] == ERRORVAL) continue;
		i = 0;
		for (j = 0; j < velm->nzed[icont]; j++) {
			xx[i] = velm->xm[j][icont];
			if (xx[i] < velm->getXmin(icont)) {
				xx[i] += xShift;
				tt[i] = isTime ? velm->tm[j][icont] : velm->zm[j][icont];
				i++;
			}
		} // for j
		xx[i] = velm->getXmin(icont);
		tt[i] = (float)velm->getCurrHorizonAtDist((float)xx[i], icont, isTime);
		xx[i] += xShift;
		i++;

		if (i < 2) continue;
		register int nLimit = min(2 * i, MOD_POINTS_MAX * 2);
		i = myClipPoints2(i, nLimit, xx, tt, cd.coord.X12Y12());
		if (i < 2) continue;
		for (j = 0; j < i; j++)
			plt[j] = cd.coord.mm_coord(xx[j], tt[j]);

		// when a polygon has a segment at the axes, I need to split the polygon into 2. 
		// The clipping routine above already modified the curve this way when it crosses the axes.
		register bool isLinePlotted = false;
		for (j = 0; j < i - 1; j++) { // note: i is the total number of points to plot
			if (plt[j].y == cd.coord.logicalAxes.top || plt[j].y == cd.coord.logicalAxes.bottom) {
				if (plt[j].y == plt[j + 1].y) {
					// now plot it with 2 polygons
					pDC->Polyline(plt, j + 1);
					pDC->Polyline(&plt[j + 1], i - j - 1);
					isLinePlotted = true;
					break;
				}
			}
		}
		if (!isLinePlotted)
			pDC->Polyline(plt, i);
	}
	pDC->SelectObject(pOldPen);

	return TRUE;
}

// iLayerFocus: indicate which boundary to display as a thick line, set to -1 if all thin lines  
// greenPen can be NULL and will default to zero with or thicker if at iLayerFocus boundary with randome color
BOOL CSeisWideDoc::DrawVelocityTwtt(CDC* pDC, CVelMod::VELMOD *velm, BOOL isNoNodes,
	double xShift, CPen* pBluePen, int iLayerFocus)
{
	// pointer velm must already has been initialized to continue.
	if (draw.isNoBoundary) return TRUE;
	if (cd.coord.drawmode != 9 && cd.coord.drawmode!=7) return FALSE;

	CString tStr = getSecNameRevised(velm->velSecName, getWorkingPathSlash());

	if (!isFileExistNotDirectory(tStr) || !this->isModelVisible(velm, xShift)) return FALSE;

	CVelMod vm;
	if (draw.ncontFlatten > 0) {
		float xShot = CCoords::isXShotDefined(tx.xShotRay) ? tx.xShotRay : (float)cd.coord.xmin;
		velm->setHorizonModel2Flat(draw.ncontFlatten, xShot);
	}

	DrawVelocityUncontroledLeft(pDC, velm, xShift);
	DrawVelocityUncontroledRight(pDC, velm, xShift);

	int i, j, icont;

	//Generate velocity contours
	CPen* pOldPen;
	bool isMainModelShowing = velm->velSecName.Compare(velMod.velSecName) == 0 && cd.coord.isModelingMode();

	//Start plotting velocity color map.
	COLORREF clMain = isMainModelShowing ? RED : RGB(200, 255, 0);
	int lineWidthThis = cd.coord.isModelingMode() ? 
		cd.coord.getPenThicknessNormal() : 9;
	CPen redPenThick(PS_SOLID, lineWidthThis*2, clMain);
	CPen redPenThin(PS_SOLID, lineWidthThis, clMain);
	CPen bluePen(PS_SOLID, lineWidthThis, BLUE);
	CPen yellowPen(PS_SOLID, lineWidthThis, YELLOW);
	//	CPen greyUnconstrainedPen(PS_SOLID, lineWidthThis, RGB(220, 220, 220));
	CPen greyUnconstrainedPen(PS_DOT, 4, BLUE); // Valid only when the pen width is 1 or less, in device units.
	CPen whitePen(PS_SOLID, lineWidthThis, WHITE);
	CPen dotPen(PS_DOT, 0, RGB(255, 100, 0));

	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();

	//if (pFrame->statMain.bigNodes < 1) pFrame->statMain.bigNodes = 1;
	//int dPlt = lineWidthThis * pFrame->statMain.bigNodes;
	int dPlt = (int)(lineWidthThis * pFrame->statMain.bigNodes * 0.5);
	if (dPlt < lineWidthThis) dPlt = lineWidthThis;

	//float *twttMod = (float *)ealloc1float(velm->ncont);

	// main loop for boundary lines, not nodes
	CPoint p, p1, plt[MOD_POINTS_MAX * 2], pltOld[MOD_POINTS_MAX];
	double xx[MOD_POINTS_MAX * 2], tt[MOD_POINTS_MAX * 2];
	double xxBackup[MOD_POINTS_MAX * 2];
	int xcount = velm->getXmAll(xxBackup);


	CVelMod::VELMOD_X *modXs = (CVelMod::VELMOD_X*)alloc1(xcount, sizeof(CVelMod::VELMOD_X));
	for (j = 0; j < xcount; j++) {
		modXs[j].dist = xxBackup[j];
		vm.initModX(velm, &modXs[j], true, true, velColor.dz);
	}



	register int nLimit = MOD_POINTS_MAX * 2;

	pOldPen = pDC->SelectObject(pBluePen);  // tempoarily initialize pOldPen
	for (icont = 0; icont < velm->ncont; icont++) {




		i = 0;
		if (velm->xmMin[icont] == ERRORVAL) {
			for (j = 0; j < velm->nzed[icont]; j++) {
				xx[i] = velm->xm[j][icont];
				xx[i] += xShift;
				tt[i] = velm->tm[j][icont];
				i++;
			}
		}
		else {
			xx[i] = velm->getXmin(icont);
			tt[i] = velm->getCurrHorizonTimeAtDist((float)xx[i], icont);
			xx[i] += xShift;
			i++;
			for (j = 0; j < velm->nzed[icont]; j++) {
				xx[i] = velm->xm[j][icont];
				if (xx[i] >= velm->getXmin(icont) && xx[i] <= velm->getXmax(icont)) {
					xx[i] += xShift;
					tt[i] = velm->tm[j][icont];
					if (xx[i] != xx[i - 1])
						i++;
				}
			}
			xx[i] = velm->getXmax(icont);
			tt[i] = velm->getCurrHorizonTimeAtDist((float)xx[i], icont);
			xx[i] += xShift;
			if (xx[i] != xx[i - 1])
				i++;
		}
		if (i < 2) continue;


		i = myClipPoints2(i, nLimit, xx, tt, cd.coord.X12Y12()); // this will modify xx[], tt[]
		if (i < 2) continue;
		//i = xcount;
		for (j = 0; j < i; j++)
			plt[j] = cd.coord.mm_coord(xx[j], tt[j]);


		if (velm->isSedimentRegression(icont) || velm->isSedimentRegression(icont - 1))
			pDC->SelectObject(&yellowPen);
		else if (isMainModelShowing && icont == iLayerFocus) {
			if (draw.nodeMode == 1)
				pDC->SelectObject(&redPenThick);
			else {
				if (draw.isTopBound)
					pDC->SelectObject(&redPenThick);
				else
					pDC->SelectObject(&redPenThin);
			}
		}
		else if (isMainModelShowing && icont == iLayerFocus + 1) {
			if (draw.nodeMode == 1) {
				if (icont < velm->ncontMaxConstrained)
					pDC->SelectObject(&bluePen);
				else
					pDC->SelectObject(&greyUnconstrainedPen);
			}
			else {
				if (draw.isTopBound)
					pDC->SelectObject(&redPenThin);
				else
					pDC->SelectObject(&redPenThick);
			}
		}
		else {
			if (icont + 1 > velm->ncontMaxConstrained)
				pDC->SelectObject(&greyUnconstrainedPen);
			else if (pBluePen)
				pDC->SelectObject(pBluePen);
			else
				pDC->SelectObject(&bluePen);
		}


		// added Jan 30, 2017
		// when a polygon has a segment at the axes, I need to split the polygon into 2. 
		// The clipping routine above already modified the curve this way when it crosses the axes.
		register bool isLinePlotted = false;
		for (j = 0; j < i-1; j++) { // note: i is the total number of points to plot
			if (plt[j].y == cd.coord.logicalAxes.top || plt[j].y == cd.coord.logicalAxes.bottom) {
				if (plt[j].y == plt[j + 1].y) {
					// now plot it with 2 polygons
					pDC->Polyline(plt, j+1);
					pDC->Polyline(&plt[j+1], i-j-1);
					isLinePlotted = true;
					break;
				}
			}
		}
		if (!isLinePlotted)
			pDC->Polyline(plt, i);


		pDC->SelectObject(pOldPen);
	}
	free1(modXs);

	// main loop for boundary nodes, not lines
	if (!isNoNodes && cd.coord.isModelingMode()) {
		register double x1;
		register double t1;
		for (icont = 0; icont < velm->ncont; icont++) {
			if (icont == iLayerFocus) {
				pOldPen = pDC->SelectObject(&redPenThick);
			}
			else {
				pOldPen = pDC->SelectObject(&redPenThin);
			}
			if (draw.nodeMode == 1) {
				for (j = 0; j < velm->nzed[icont]; j++) {
					if (icont == 0 && (j == 0 || j == velm->nzed[0] - 1)) continue;
					// do not plot the nodes at the top corners otherwise it's hard to position on screen

					x1 = velm->xm[j][icont] + xShift;
					t1 = velm->tm[j][icont];
					if (cd.coord.isVisibleOrNot(x1, t1)) {
						p = cd.coord.mm_coord(x1, t1);
						pDC->Ellipse(p.x - dPlt, p.y - dPlt, p.x + dPlt, p.y + dPlt);
					}
				} // for j
			}
			else if (draw.nodeMode == 2 && iLayerFocus >= 0 && iLayerFocus < velm->ncont - 1 && icont == iLayerFocus) {
				for (int k = 0; k < 2; k++) {
					i = 0;
					int icontSel = (k == 0) ? icont : icont + 1;
					for (j = 0; j < velm->nvel[icont][k]; j++) {
						x1 = velm->xvel[j][icont][k] + xShift;
						for (int ix = 0; ix < (velm->nzed[icontSel] - 1); ix++) {
							if (x1 >= velm->xm[ix][icontSel] + xShift && x1 <= velm->xm[ix + 1][icontSel] + xShift) {
								t1 = velm->tm[ix][icontSel] + (velm->tm[ix + 1][icontSel] -
									velm->tm[ix][icontSel])*(x1 - velm->xm[ix][icontSel]) /
									(velm->xm[ix + 1][icontSel] - velm->xm[ix][icontSel]);
								break;
							}
						}
						if (cd.coord.isVisibleOrNot(x1, t1)) {
							p = cd.coord.mm_coord(x1, t1);
							pDC->Ellipse(p.x - dPlt, p.y - dPlt, p.x + dPlt, p.y + dPlt);
						}
					}
				} // for k
			}
			pDC->SelectObject(pOldPen);
		} // for icont
	} // if isNoNodes

//	free1float(twttMod);

	return TRUE;
}



bool CSeisWideDoc::DrawVelocityTwtt(CDC* pDC)
{
	if (cd.coord.drawmode != 9 && cd.coord.drawmode != 7) return FALSE;
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();

	CString tStr;
	CString workingPath = CString(getWorkingPathSlash());
	CVelMod vm;
	if (!vm.loadInitVel(&velMod, velMod.velSecName, velColor.dz, tStr))
		pFrame->myCaption(tStr); // print the error of model loading
	else if (isModelVisible(&velMod, 0.)) {
		DrawVelocityTwtt(pDC, &velMod, draw.isNoNodes, 0., NULL, draw.iLayerFocus);
	}

	if (draw.velSecNamesEx.GetLength() > 0) {
		CVelMod::VELMOD velm;
		//vm.velModSetArrays(&velm);
		double xposArr[MOD_POINTS_MAX];
		double xShiftArr[MOD_POINTS_MAX];
		CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
		int lineThickness = (int)myRound(pFrame->statMain.thicknessLines * 50);
		CStringArray *arrVelNamesEx = new CStringArray();
		CVelMod::velNamesExParse(draw.velSecNamesEx, xShiftArr, xposArr, arrVelNamesEx);

		for (int i = 0; i < arrVelNamesEx->GetCount(); i++) {
			// this is a vel model
			tStr = arrVelNamesEx->ElementAt(i);
			bool isMainModelShowing = GetBaseFileName(velMod.velSecName) == GetBaseFileName(tStr);
			COLORREF cr = getGoodColorRand(isMainModelShowing);
			CPen greenPen(PS_SOLID, lineThickness, cr);
			if (vm.loadInitVel(&velm, tStr, velColor.dz, tStr)) {
				if (isModelVisible(&velm, xShiftArr[i])) {
					DrawVelocityTwtt(pDC, &velm, TRUE, xShiftArr[i], &greenPen, 0);
					// if (xposArr[i] != ERRORVAL) 
					velm.wells[0].wellDist = (float)xposArr[i]; 
					// the problem: do we plot lables at new xpos, or just use 
					// the pseudo-well in the velm* ? Do not know!!!
					DrawVelocityLabelTwtt2(pDC, &velm, xShiftArr[i], cr);
				}
			}
			else
				pFrame->myCaption(tStr); // print the error of model loading
			velm.velModReset();
		}

		arrVelNamesEx->RemoveAll();
		delete arrVelNamesEx;
		//vm.velModFreeArrays(&velm);
	}

	// here we want the labels on top of boundaries drawn, after (and thus on top  of) secondary models
	if (isModelVisible(&velMod, 0.)) {
		DrawVelocityLabelTwtt2(pDC, &velMod, 0., getGoodColorRand(true));
	}

	cd.coord.drawmodeOld = 9;   // this means already converted to time

	return true;
}




/*
NMO modes: depreciated. Some codes not working as a result of code updates
*/
void CSeisWideDoc::OnTimeForwideNmovelocity()
{
	AfxMessageBox(_T("Depreciated. Some codes not working as a result of code updates"));
	return;

	//	this->setContour4Raytrace("E:\\project\\work3\\myRayInvr2008\\sembRayInvr\\f.insemb", 12.830f, 0.005f, 0.6f, 3.f, 1.9f, 1, 3.3f);
	//	return;
	int j;
	int nvPerturb;

	// local parameters for the routine not saved by .sei file
	float vPerturb;
	static float vPerturbMin = 1.6f;
	static float vPerturbMax = 6.f;
	static float vPerturbDv = 0.02f;
	static float secsmooth = 0.06f;
	static int numDisplay = 0;
	static BOOL isCoh = false;
	static int raymode = 0;  // 0=PP; 1=PS; 2=SP
	static int stackmode = 0;  // 0=amplitude summation approach; 1=semblence coefficient; 2=Energy normalised cross correlation 
	static float xpercent = 0.8f; //
	static float offsetMax = 10.f;
	/*
	" Notes:								     ",
	" UnNormalized Selective CrossCorrelation sum: is based on the coherence     ",
	" measure known as crosscorrelation sum. The difference is that the selective",
	" approach sum only crosscorrelation pairs with relatively large differential",
	" moveout, thus increasing the resolving power in the velocity spectra       ",
	" compared to that achieved by conventional methods.  The selection is made  ",
	" using a parabolic approximation of the differential moveout and imposing a ",
	" threshold for those differential moveouts.				     ",
	"									     ",
	" That threshold is the parameter tau in this program, which varies between  ",
	" 0 to 1.  A value of tau=0, means conventional crosscorrelation sum is      ",
	" applied implying that all crosscorrelations are included in the sum. In    ",
	" contrast, a value of tau=1 (not recomended) means that only the            ",
	" crosscorrelation formed by the trace pair involving the shortest and longest",
	" offset is included in the sum. Intermediate values will produce percentages",
	" of the crosscorrelations included in the sum that will be shown in the     ",
	" screen before computing the velocity spectra. Typical values for tau are   ",
	" between 0.2 and 0.6, producing approximated percentages of crosscorrelations",
	" summed between 60% and 20%. The higher the value of tau the lower the     ",
	" percentage and higher the increase in the resolving power of velocity	      ",
	" spectra.								      ",
	"									      ",
	" Keeping the percentage of crosscorrelations included in the sum between 20%",
	" and 60% will increase resolution and avoid the precense of artifacts in the",
	" results.  In data contaminated by random noise or statics distortions is    ",
	" recomended to mantaing the percentage of crosscorrelations included in the  ",
	" sum above 25%.  After computing the velocity spectra one might want to     ",
	" adjust the level and number of contours before velocity picking.  	      ",
	*/

	draw.isSameDataDisplay = TRUE; //indicate display has been changed and will re-load all data in OnDraw().

	// dialog controls
	CdlgWide2Velocity dlg;
	dlg.m_timeSecName = draw.timeSecName;
	if (draw.depthSecName.IsEmpty()) draw.depthSecName = _T("depth.sgy");
	dlg.m_depthSecName = draw.depthSecName;
	dlg.m_velname = velMod.velSecName;
	dlg.m_rayTracing = draw.rayName;
	dlg.m_floatName = velMod.flFloatName;
	dlg.m_zmax = (float)cd.coord.m_zmax;
	dlg.m_zmin = (float)cd.coord.m_zmin;
	dlg.m_dz = (float)velColor.dz;
	dlg.m_vPerturbMin = vPerturbMin;
	dlg.m_vPerturbMax = vPerturbMax;
	dlg.m_dv = vPerturbDv;
	dlg.m_iLayerFocus = draw.iLayerFocus;
	dlg.m_secsmooth = secsmooth;
	dlg.m_iscoh = isCoh;
	dlg.m_numDisplay = numDisplay;
	dlg.m_basePower = (float)draw.basePower;  if (fabs(draw.basePower) > 100.f) draw.basePower = 0.f;
	dlg.m_rayMode = raymode;
	dlg.m_sumMethod = stackmode;
	dlg.m_xpercent = (int)myRound(xpercent*100.);
	dlg.m_offsetMax = offsetMax;

	dlg.m_tmin = (float)cd.coord.m_tmin;
	dlg.m_tmax = (float)cd.coord.m_tmax;

	if (dlg.DoModal() == IDOK)
	{
		draw.timeSecName = dlg.m_timeSecName.Trim();
		draw.depthSecName = dlg.m_depthSecName;
		velMod.velSecName = dlg.m_velname.Trim();
		draw.rayName = dlg.m_rayTracing;
		velMod.flFloatName = dlg.m_floatName;
		cd.coord.m_zmax = dlg.m_zmax;
		cd.coord.m_zmin = dlg.m_zmin;
		velColor.dz = dlg.m_dz;
		vPerturbMin = dlg.m_vPerturbMin;
		vPerturbMax = dlg.m_vPerturbMax;
		vPerturbDv = dlg.m_dv;

		vPerturbMin = myFloat(vPerturbMin);
		vPerturbMax = myFloat(vPerturbMax);
		vPerturbDv = myFloat(vPerturbDv);

		draw.iLayerFocus = dlg.m_iLayerFocus; // note: this is 1-based, while our convention is 0-based
		if (draw.iLayerFocus < 0) draw.iLayerFocus = 0;
		secsmooth = dlg.m_secsmooth;
		isCoh = dlg.m_iscoh;
		numDisplay = dlg.m_numDisplay;
		draw.basePower = dlg.m_basePower;
		raymode = dlg.m_rayMode;
		stackmode = dlg.m_sumMethod;
		xpercent = (float)myFloat(dlg.m_xpercent * 0.01f);
		if (xpercent>1.f) xpercent = 1.f;
		else if (xpercent < 0.01f) xpercent = 0.01f;
		offsetMax = dlg.m_offsetMax;
		cd.coord.m_tmin = dlg.m_tmin;
		cd.coord.m_tmax = dlg.m_tmax;
	}
	else
	{
		return;
	}












	// fix up for dz, since it cannot be too big
	if (velColor.dz*MIL > USHRT_MAX - 1) velColor.dz = (double)(USHRT_MAX - 1) / (double)MIL;
	draw.depthSecName = SetFileExtension(draw.depthSecName, _T("sgy"));



	if (!isFileExistNotDirectory(draw.timeSecName)) return;

	if (draw.depthSecName.IsEmpty()) return;



	//################### Prepare the raytracing
	if (!checkModelError(velMod.velSecName)) {
		if (AfxMessageBox(_T("Current model has boundary overlaps; Raytracing may hang up if this model is used; Do you want to continue?"), MB_YESNO | MB_ICONINFORMATION) != IDYES)
			return;
	}

	CString txoutName = _T("tx.outsemb");
	if (raymode == 0) txoutName += _T("pp");
	else if (raymode == 1) txoutName += _T("ps");
	else if (raymode == 2) txoutName += _T("sp");

	CString astr;
	CString t;

	//make tx.out file in the same directory as velMod.velSecName.
	CString name = velMod.velSecName;
	int pathLen = name.ReverseFind('\\');
	t = name.Left(pathLen);
	t.MakeLower();
	if (pathLen < 0) {
		TCHAR curDir[_MAX_PATH];
		GetCurrentDirectory(_MAX_PATH, curDir);
		t = (CString)curDir;
	}
	CString txPath;
	txPath.Format(_T("%s\\temp"), t);
	if (!isDirectoryExist(txPath)) {
		// create the temp dir
		if (!CreateDirectory(txPath, NULL)) {
			astr.Format(_T("Cannot create a working directory: %s"), txPath);
			AfxMessageBox(astr);
			return;
		}
	}
	SetCurrentDirectory(txPath);


	// copy r.in 
	t = txPath + "\\r.in";
	CString tempStr = draw.rayName;
	tempStr.MakeLower();
	if (tempStr != t &&  tempStr != _T("r.in")) {
		CopyFile(draw.rayName, t, FALSE);
	}

	// copy v.bin
	tempStr = velMod.velSecName;
	tempStr.MakeLower();
	t = txPath + "\\v.bin";
	if (tempStr != t && tempStr != _T("v.bin")) {
		CopyFile(velMod.velSecName, _T("v.bin"), FALSE);
	}


	if (cd.coord.m_zmax < cd.coord.m_zmin) cd.coord.m_zmax = cd.coord.m_zmax + 1.;
	int nz = (int)((cd.coord.m_zmax - cd.coord.m_zmin) / velColor.dz + 1.0);
	if (nz > 6000) {
		nz = 6000;  // fortran program has this array limit to impose
		cd.coord.m_zmax = cd.coord.m_zmin + (nz - 1)*velColor.dz;
		AfxMessageBox(_T("Max depth adjusted due to array size limitation of 6000 points. Contact programer to increase size if needed."));
		OnTimeForwideNmovelocity();
		return;
	}


	//##################### now do the raytracing
	if (!CCoords::isXShotDefined(tx.xShotRay)) {
		CSegyMeta::segyHeadInit(draw.timeSecName, &head);
		tx.xShotRay = (float)head.xshotInSegy;
		//CString workingPath = getWorkingPathSlash();
		//tx.xShotRay = (float)CRayHelper::getXPosAll(draw.timeSecName, workingPath);
	}
	//Do not refresh screen in any way until raytracing finished. Otherwise, 
	// it may refresh screen while raytracing is running!
	draw.isSameDataDisplay = TRUE;

	astr.Format(_T("%s\\%s%5.3f"), txPath, txoutName, vPerturbMin);
	if (!isFileExistNotDirectory(astr) ||
		AfxMessageBox(_T("Do you want to raytrace for the current parameters? If you choose Yes, you will need to wait until raytracing completed, and rerun this processing."), MB_YESNO | MB_ICONINFORMATION) == IDYES) {
		// generate f.insemb file
		if (this->setContour4Raytrace(txPath + _T("\\f.insemb"), (float)tx.xShotRay, (float)velColor.dz, 
			(float)cd.coord.m_zmin, &cd.coord.m_zmax, vPerturbMin, vPerturbMax, vPerturbDv) == BLANK) {
			AfxMessageBox(_T("Failed to generate f.insemb file"));
			return;
		}
		// if raytracing fails, my display routine still uses the old "tx.out". This line avoids this.
		//DeleteFile("tx.out"); 
		//DeleteFile("rPath.out"); 
		//DeleteFile("r1.out"); 
		astr.Format(_T("%s\\%s*"), txPath, txoutName);
		CShellFileOp sfo;
		BOOL         bAPICalled;
		int          nAPIReturnVal;
		sfo.AddSourceFile(astr);
		sfo.SetOperationFlags
			(FO_DELETE,         // the operation type (delete in this case)
			AfxGetMainWnd(), // pointer to parent window
			FALSE,           // flag - silent mode?
			FALSE,           // flag - allow undo?
			FALSE,           // flag - should wild cards affect files only?
			TRUE,            // flag - suppress confirmation messages?
			TRUE,            // flag - suppress confirmation messages 
			// when making directories?
			FALSE,           // flag - rename files when name collisions occur?
			FALSE);         // flag - simple progress dialog?
		if (sfo.Go(&bAPICalled, &nAPIReturnVal))
		{
			// The operation succeeded!
		}



		name = m_strPathName;
		int nPathLength = GetModuleFileName(NULL, name.GetBuffer(_MAX_PATH), _MAX_PATH);
		name.ReleaseBuffer();
		CString progPathBak = _T("\"") + name.Left(name.ReverseFind('\\'));
		progPathBak += _T("\\sembRayinvr.exe\"");
		CString progPath = BLANK;
		CString str;

		// start generating string for fortran batch procoessing
		for (vPerturb = vPerturbMin, nvPerturb = 0; vPerturb < vPerturbMax; vPerturb += vPerturbDv, nvPerturb++) {
			progPath += progPathBak;
			str.Format(_T(" %3d %3d %6.3f"), draw.iLayerFocus, raymode, vPerturb);
			// progPath += str + _T("\r\n";
			progPath.Format(_T("%s\r\n"), str);
		}

		myUnicodeProcess(progPath, txPath);
		//if(AfxMessageBox(_T("Please wait for the raytracing program to finish. Click YES when finished raytracing.", MB_YESNO |MB_ICONINFORMATION) != IDYES) {
		//	return;
		//}
		return;
	}




	int np_max = 0;
	np_max = 30;
	int nv_max = 0;
	for (vPerturb = vPerturbMin, nvPerturb = 0; vPerturb <= vPerturbMax; vPerturb += vPerturbDv, nvPerturb++) {
		astr.Format(_T("%s\\%s%5.3f"), txPath, txoutName, vPerturb);
		if (!isFileExistNotDirectory(astr)) {
			// we need to restrain the vPerturbMax accordingly, otherwise we may have array indexing problem
			vPerturbMax = vPerturbMin + (float)(nvPerturb - 1)*vPerturbDv;
			break;
		}
	}
	nv_max = nvPerturb;
	if (nvPerturb < 2) {
		AfxMessageBox(_T("Less than 2 pertubations read in. pertubations intervals may have changed. Please check."));
		return;
	}






	// ################### Use the raytracing results to form segy output
	segy tr;
	bhed bh;

	CFile file;
	if (!file.Open(draw.timeSecName, CFile::modeRead | CFile::typeBinary | CFile::shareDenyNone)) {
		return;
	}
	file.Seek(0, CFile::begin);
	UINT bytesRead = file.Read(head.ascHead, 3200L);
	if (bytesRead < 3200)
		AfxMessageBox(_T("Ascii section header read wrong"));
	file.Read(&bh, sizeof(bhed));
	if (bytesRead < 400)
		AfxMessageBox(_T("Binary section header read wrong"));
	//The following numbers have to be recalculated everytime,
	//because plotting the depth section will change these numbers.

	int numsamp = bh.hns;
	int format = bh.format;
	// backup the original format since bh.format will be overwritten for output header
	int len = (format != 3) ? (numsamp * 4 + 240) : (numsamp * 2 + 240);
	if (bh.hdt == 0) bh.hdt = bh.dto;
	int tpp = bh.hdt;

	long nzmin = (int)ceil(cd.coord.m_zmin / velColor.dz);
	long nzmax = nzmin + nz;


	float dtField = (float)((double)tpp / (double)MIL);

	int nsmooth = (int)ceil(secsmooth / dtField) + 1;
	if ((int)(nsmooth / 2) == nsmooth * 2) nsmooth++;  // we want odd numbers for nsmooth..... not needed

	//For progress control, need to know the last bytes no.
	ULONGLONG curBytesRead, totBytesRead = file.GetLength();
	file.Seek(3600, CFile::begin);

	//Begin progress control.
	CMainFrame* pFrame =
		(CMainFrame*)AfxGetMainWnd();
	ASSERT(pFrame);
	ASSERT_KINDOF(CMainFrame, pFrame);
	pFrame->BeginProgress();

	int nxmax = 0;  // total number of traces in the input segy file
	while (file.Read(&tr, 240) == (UINT)240)
	{
		file.Seek(len - 240, CFile::current);
		nxmax++;
	}
	file.Seek(3600, CFile::begin);

	// allocate array big enough for storing all the input segy data in memory
	segydynamic *trArr = (segydynamic *)xmalloc(sizeof(segydynamic) * nxmax);
	if (ERROR == trArr) return;
	for (j = 0; j < nxmax; j++) {
		trArr[j].data = ealloc1float(numsamp);
		if (ERROR == trArr[j].data) {
			// clean up before return
			for (int jj = 0; jj < j - 1; jj++) {
				free1float(trArr[jj].data);
				trArr[jj].data = NULL;
			}
			AfxMessageBox(_T("Sorry, failed to allocate memory for loading all traces into memory."));
			return;
		}
	} // for j


	int nxStore = 0;
	if (tx.xShotRay <= ERRORVAL) tx.xShotRay = 0.;  // a fix
	while (file.Read(&tr, len) == (UINT)len) {
		//Formulating velocity traces first.
		curBytesRead = file.Seek(0, CFile::current);
		int iPos = (int)((double)curBytesRead / (double)totBytesRead*100.);
		if (iPos < 0)iPos = 0;
		if (iPos > 100)iPos = 100;
		pFrame->SetProgress(iPos);

		if (tr.trid == 2) //dead traces.
		{
			file.Seek(len, CFile::current);
			continue;
		}


		// assign only the trace header to the trArr[]
		memcpy((void *)&trArr[nxStore], (void *)&tr, 240L);

		// Note: format points to the original data in time, while bh.format  is already modified for output
		if (format == 3)
			for (j = 0; j < numsamp; j++) trArr[nxStore].data[j] = (float)tr.dat.datashort[j];
		else if (format == 1) {
			ibm_to_float((int *)tr.dat.data, (int *)tr.dat.data, (int)numsamp);
			for (j = 0; j < numsamp; j++) trArr[nxStore].data[j] = (float)tr.dat.data[j];
		}
		else if (format == 2)
			for (j = 0; j<numsamp; j++) trArr[nxStore].data[j] = (float)tr.dat.dataint[j];
		else if (format == 5) {
			for (j = 0; j<numsamp; j++) trArr[nxStore].data[j] = (float)tr.dat.data[j];
		}
		else break;

		if (draw.sphericOrder > 0.f) {
			double a = tr.getTraceDelay();  // a is now the initial time in sec for this trace

			double aGain = pow(a + numsamp *  dtField, (double)draw.sphericOrder);
			if (aGain > 0.) aGain = 1. / aGain;
			else aGain = 1.;

			double b;
			for (j = 0; j < numsamp; j++) {
				b = a + j* (double)tpp / (double)MIL;      // b is now the actual time in sec for the inidex j
				if (draw.sphericOrder == 2.f)
					trArr[nxStore].data[j] *= (float)(b*b*aGain);
				else
					trArr[nxStore].data[j] *= (float)(aGain* pow(b, (double)draw.sphericOrder));
			}  // for j
		} // if

		nxStore++;
	} // while file.Read
	file.Close();
	pFrame->EndProgress();
	// finished loading all segy data into memory trArr[]

	astr.Format(_T("finished loading all segy data into memory"));
	pFrame->SetMessageText(astr);



	//################################################################################
	//############################ start loading X-T values for velocity perturbation#####
	//################################################################################

	// first, we need to calculate max number of points of (x,t) pair for a certain iz
	int icont;
	int i, iz;
	float f1, f2, f7, f8;



	float ***xwAll = (float ***)ealloc3float(np_max, nz, nv_max);
	float ***twAll = (float ***)ealloc3float(np_max, nz, nv_max);    // data for the floating reflectors.
	int **isei_npAll = (int **)ealloc2int(nz, nv_max);
	float **sei_zAll = (float **)ealloc2int(nz, nv_max);
	memset((void *)xwAll[0][0], 0, sizeof(float)*np_max*nz*nv_max);
	memset((void *)twAll[0][0], 0, sizeof(float)*np_max*nz*nv_max);
	memset((void *)isei_npAll[0], 0, sizeof(int)*nz*nv_max);
	memset((void *)sei_zAll[0], 0, sizeof(float)*nz*nv_max);
	bool isTooMany = false;










	int izmaxTraced = -1;
	bool isProb = false;
	for (vPerturb = vPerturbMin, nvPerturb = 0; vPerturb <= vPerturbMax; vPerturb += vPerturbDv, nvPerturb++) {
		if (!isCoh && nvPerturb != numDisplay) continue;  // for simple non-coherency display, we only display one velocity pertubation
		astr.Format(_T("%s\\%s%5.3f"), txPath, txoutName, vPerturb);
		if (!isFileExistNotDirectory(astr)) {
			CString str2;
			str2.Format(_T("Raytracing result file %s does not exist. Please check parameter."), astr);
			AfxMessageBox(str2);
			break;
		}
		CStringArray *txArray = getLinesFromFile(astr);
		for (j = 0; j < txArray->GetSize(); j++) {
			if (_stscanf_s(txArray->ElementAt(j).Trim(), _T("%f%f%d%d%f%f"), &f1, &f2, &iz, &icont, &f7, &f8) == 0) continue;
			if (iz == 0 && !isFloatEqual(f8, (float)cd.coord.m_zmin)) {
				isProb = true;
				cd.coord.m_zmin = f8;
				break;
			}
			if (iz == -1 && !isFloatEqual(f8, (float)cd.coord.m_zmax)) {
				isProb = true;
				cd.coord.m_zmax = f8;
				break;
			}
			if (iz == -2 && !isFloatEqual(f8, (float)velColor.dz)) {
				// this is the last line of a raytracing file
				isProb = true;
				velColor.dz = f8;
				break;
			}
			if (iz == -1 && icont > 0) {
				draw.iLayerFocus = icont;  // update perturbation layer number since it may be different by the user input
			}
			if (iz <= 0 || icont == 0 || iz > nz) continue;  // note: input file has  iz=1:nz.... from Fortran
			if ((i = isei_npAll[nvPerturb][iz - 1]) < np_max) {
				xwAll[nvPerturb][iz - 1][i] = f1;
				twAll[nvPerturb][iz - 1][i] = f2;
				isei_npAll[nvPerturb][iz - 1]++;  // we want array index to be zero based
				sei_zAll[nvPerturb][iz - 1] = f8;
				// so we just ignore the user input
				if (izmaxTraced < iz) izmaxTraced = iz;
			}
			else {
				isTooMany = true;
			}
		} // if j
		txArray->RemoveAll();
		delete txArray;
		txArray = NULL;


		if (!isProb) {
			// since xw[][] may not be ordered monotonically with distance, we need to reorder it.
			for (iz = 0; iz < nz; iz++) {
				for (j = 0; j < isei_npAll[nvPerturb][iz] - 1; j++) {
					for (int k = j + 1; k < isei_npAll[nvPerturb][iz]; k++) {
						if (xwAll[nvPerturb][iz][j] > xwAll[nvPerturb][iz][k]) {
							// swap the 2 values
							f1 = xwAll[nvPerturb][iz][j];
							xwAll[nvPerturb][iz][j] = xwAll[nvPerturb][iz][k];
							xwAll[nvPerturb][iz][k] = f1;
							f1 = twAll[nvPerturb][iz][j];
							twAll[nvPerturb][iz][j] = twAll[nvPerturb][iz][k];
							twAll[nvPerturb][iz][k] = f1;
						} // if
					} // for k
				} // for j
			} // for iz

			astr.Format(_T("finished loading and parsing into memory the raytracing results for %5.3f (%5.3f, %5.3f, %5.3f) km/s"), vPerturb, vPerturbMin, vPerturbMax, vPerturbDv);
			pFrame->SetMessageText(astr);
		} // if


		// note: sei_zAll[nvPerturb][iz]  info is only for checking here, not used in later NMO calculation, as we all assume
		//       the depth indece are uniform.
		if (isProb) break;

	} // for vPerturb
	if (isTooMany)
		AfxMessageBox(_T("Too many points found in the raytracing. Will truncate. You may limit number of points per ray <=30 ."));
	if (isProb) {
		free3float(xwAll); xwAll = NULL;
		free3float(twAll); twAll = NULL;
		free2int(isei_npAll); isei_npAll = NULL;
		free2float(sei_zAll); sei_zAll = NULL;
		for (j = 0; j < nxmax; j++) {
			free1float(trArr[j].data); trArr[j].data = NULL;
		}
		xfree(trArr); trArr = NULL;

		//if (izmaxTraced < nz) {
		//	cd.coord.zmax = (float)(cd.coord.zmin + (izmaxTraced - 1) * velColor.dz);
		//	astr = _T("Specified maximum depth is greater than raytraced, and adjusted accordingly. Please rerun this processing.";
		//}
		//else {
		//}
		astr = _T("Depth in the raytracing mismatches with desired zmin, zmax or dz that are now adjusted accordingly. Note that temporary raytracing results cannot be mixed for different running. Please rerun this processing.");
		AfxMessageBox(astr);
		OnTimeForwideNmovelocity();
		return;
	}







	CFile filez;
	if (!filez.Open(draw.depthSecName, CFile::modeCreate | CFile::modeReadWrite | CFile::typeBinary)) {
		return;
	}

	filez.Write(head.ascHead, 3200L);
	bh.hns = nz; // numsamp for output;
	bh.format = 1; // we always output in floating points
	bh.dto = bh.hdt = (unsigned short)myRound(velColor.dz*MIL);	//Sampling rate;
	filez.Write(&bh, sizeof(bh));

	//Prepare to formulate velocity traces.
	WORD totShot = 0;
	double oneodt = (double)(MIL / (float)tpp);

	segydynamic tTrcDepth;
	tTrcDepth.data = (float *)ealloc1float(nz);

	astr.Format(_T("Start loop for velocity pertubation"));
	pFrame->SetMessageText(astr);


	//################################################################################
	//############################ start loop for velocity perturbation###############
	//################################################################################
	float **xw = (float **)ealloc2float(np_max, nz);
	float **tw = (float **)ealloc2float(np_max, nz);    // data for the floating reflectors.
	int *isei_np = (int *)ealloc1int(nz);

	for (vPerturb = vPerturbMin, nvPerturb = 0; vPerturb <= vPerturbMax; vPerturb += vPerturbDv, nvPerturb++) {
		if (nvPerturb >= nv_max) break;
		if (!isCoh && nvPerturb != numDisplay) continue;  // for simple non-coherency display, we only display one velocity pertubation
		memset((void *)tTrcDepth.data, (int)'\0', sizeof(float)*nz);

		for (iz = 0; iz < nz; iz++) {
			// just copy from xwAll to xw
			isei_np[iz] = isei_npAll[nvPerturb][iz];
			memcpy((void *)xw[iz], (const void *)xwAll[nvPerturb][iz], isei_np[iz] * sizeof(float));
			memcpy((void *)tw[iz], (const void *)twAll[nvPerturb][iz], isei_np[iz] * sizeof(float));
			//for (j=0; j<isei_npAll[nvPerturb][iz]; j++) {
			//	xw[iz][j] = xwAll[nvPerturb][iz][j];
			//	tw[iz][j] = twAll[nvPerturb][iz][j];
			//}
		} // for iz


		int lenz = 240 + nz * 4;
		double t1, t2, x1, x2, t12, x12;
		float dt = (float)((double)tpp / (double)MIL);
		if (!isCoh) {
			for (nxStore = 0; nxStore < nxmax; nxStore++) {

				memcpy((void *)&tr, (void *)&trArr[nxStore], 240L);
				float offset = tr.getOffset();
				if (!isFloatEqual(0.f, offsetMax) && fabs(offset) > offsetMax) continue;
				float dist = tr.getDistance();

				for (iz = 0; iz < nz; iz++) {
					tTrcDepth.data[iz] = 0.f;

					int n = isei_np[iz];
					if (n < 2) continue;
					// Be very careful here, as it affects the results drastically!
					if (dist < xw[iz][0] - offsetMax) continue; // we excluse any traces left of min raytraced distance
					if (dist > xw[iz][n - 1] + offsetMax) continue;  // we excluse any traces right of max raytraced distance.


					double az = cd.coord.m_zmin + (double)iz * velColor.dz;
					bool isFound = false;
					for (j = 1; j < isei_np[iz]; j++) {
						if (dist >= xw[iz][j - 1] && dist < xw[iz][j]) {
							x1 = xw[iz][j - 1] - tx.xShotRay; // we calculate using offset instead of dist here
							x2 = xw[iz][j] - tx.xShotRay;
							t1 = tw[iz][j - 1];
							t2 = tw[iz][j];

							if ((x1 < 0) == (x2 < 0)) {
								// now x1 and x2 are on the same side of the source
								isFound = true;
							}
							else {
								// now the 2 points are on diff sides of the source
								if ((x1 < 0) == (offset < 0)) {
									// x1 and xw[iz][j-1] is on the same side as source
									if (j > 1) {
										x1 = xw[iz][j - 2] - tx.xShotRay;
										x2 = xw[iz][j - 1] - tx.xShotRay;
										t1 = tw[iz][j - 2];
										t2 = tw[iz][j - 1];
										isFound = true;
									}
								} // if x1
								else {
									// x2 and xw[iz][j] is on the same side as source
									if (j < isei_np[iz] - 1) {
										x1 = xw[iz][j] - tx.xShotRay;
										x2 = xw[iz][j + 1] - tx.xShotRay;
										t1 = tw[iz][j];
										t2 = tw[iz][j + 1];
										isFound = true;
									}
								}
							} // if x1

							break;
						} // if dist
					} // for j
					if (!isFound) {
						// this part is important, since sometimes Zelt's raytracing cannot reach a certain distance
						// while the observed phases are strong there, such as the shallowest sediment reflections in
						// a complex 2D structure
						int jj = isei_np[iz] - 1;
						if (dist < xw[iz][0]) {
							x1 = xw[iz][0] - tx.xShotRay;
							x2 = xw[iz][1] - tx.xShotRay;
							t1 = tw[iz][0];
							t2 = tw[iz][1];
							isFound = true;
						}
						else if (dist > xw[iz][jj]) {
							x1 = xw[iz][jj - 1] - tx.xShotRay;
							x2 = xw[iz][jj] - tx.xShotRay;
							t1 = tw[iz][jj - 1];
							t2 = tw[iz][jj];
							isFound = true;
						}
					}
					if (!isFound) continue;

					// get the tTrcDepth.data[iz] for interpolation
					if (fabs(t1 - t2) > 0.0001) {
						// testing shows here 0.0001  is better than MINAMP!!!
						bool isSuc = false;
						// first try hyperbola interpolation

						t12 = t1*t1;
						x12 = x1*x1;
						double vr2 = (x2*x2 - x12) / (t2*t2 - t12);
						if (fabs(vr2) > MINAMP) {
							// hyperbola interpolation
							double t02 = t12 + (offset*offset - x12) / vr2;
							if (t02 > 0.) {
								tTrcDepth.data[iz] = (float)sqrt(t02);
								isSuc = true;
							}
						}

						if (!isSuc) {
							// since hyperbola interpolation fails, we do linear interpolation
							// continue;  // testing
							if (fabs(x2 - x1) > 0.0001)
								tTrcDepth.data[iz] = (float)(t1 + (offset - x1) / (x2 - x1) * (t2 - t1));
							else
								tTrcDepth.data[iz] = (float)t1;
						}


					}
					else
						tTrcDepth.data[iz] = (float)t1;

				} // for iz

				//		trArr[nxStore].data[numsamp] = 0.f;  // fix up
				ints8r((int)numsamp, // ntin
					dt,   // dtin
					tr.getTraceDelay(),   // ftin
					&trArr[nxStore].data[0], // yin[t=ntin], with yin[0] = y(fxin)
					0.f,  // yinl    value used to extrapolate yin values to left of yin[0]
					0.f,  // yinr	 value used to extrapolate yin values to right of yin[ntin-1]
					nz,   // nxout
					(float *)&tTrcDepth.data[0],  // ntout
					(float *)&tr.dat.data[0]);    // tout


				//	memcpy( (void *)tr.dat.data, (void *)&vTrc[nzmin], (nzmax-nzmin+1)*sizeof(float));
				tr.ns = (unsigned short)nz;
				tr.dt = (unsigned short)(velColor.dz*MIL);
				tr.setTraceDelayF(cd.coord.m_zmin);
				tr.setDistance(dist);

				if (bh.format == 1) {
					float_to_ibm((int *)tr.dat.data, (int *)tr.dat.data, (int)tr.ns);
				}
				filez.Write(&tr, lenz);
			} // for nxStore
			break;  // for simple display, we only display one velocity pertubation
		} // if !isCoh
		else {
			//for (nxStore=0; nxStore < nxmax; nxStore++) {
			//	memset((void *)trArrOut[nxStore].data, 0, sizeof(float)*nz);
			//}
			float *numi = ealloc1float(nsmooth); // semblence nominator
			float *deno = ealloc1float(nsmooth); // semblence denominator
			float *nnz = ealloc1float(nsmooth);  // counting non-zero samples.
			float **amp = ealloc2float(nsmooth, nxmax);

			float *timew = ealloc1float(nsmooth); // at each iz and ix, we produce a time window timew[] for velocity analysis
			// int nsmoothHalf = (int)(nsmooth*0.5);

			float *offset2 = ealloc1float(nxmax); // 
			float offset;
			for (nxStore = 0; nxStore < nxmax; nxStore++) {
				offset = trArr[nxStore].getOffset();
				offset2[nxStore] = sgn(offset) * offset*offset;
			}
			float offset2_threshold = (1.f - xpercent) * getMaxValueAbsolute(offset2, nxmax);

			for (iz = 0; iz < nz; iz++) {
				// for each depth iz, we have <=nxmax traces (trArr[nxStore = 0 : nxmax]) for semblence stack
				// the semb stacking curve is defined by xw, tw [iz][j = 0 : isei_np[iz] ]
				// A stacking time window of nsmooth = 11 samples
				tTrcDepth.data[iz] = 0.f;
				if (isei_np[iz] < 2) continue;
				memset((void *)amp[0], 0, sizeof(float)*nsmooth*nxmax);
				// this is needed since some traces have no data and we would not touch them during calculation!
				memset((void *)timew, 0, sizeof(float)*nsmooth);

				for (nxStore = 0; nxStore < nxmax; nxStore++) {
					float offset = trArr[nxStore].getOffset();
					if (!isFloatEqual(0.f, offsetMax) && fabs(offset) > offsetMax) continue;
					float dist = trArr[nxStore].getDistance();

					int n = isei_np[iz];
					if (n < 2) continue;
					// Be very careful here, as it affects the results drastically!
					if (dist < xw[iz][0] - offsetMax) continue; // we excluse any traces left of min raytraced distance
					if (dist > xw[iz][n - 1] + offsetMax) continue;  // we excluse any traces right of max raytraced distance.



					// calculate the right t thru hiperbola interpolation
					bool isFound = false;
					for (j = 1; j < isei_np[iz]; j++) {
						if (dist >= xw[iz][j - 1] && dist <= xw[iz][j]) {
							x1 = xw[iz][j - 1] - tx.xShotRay; // we calculate using offset instead of dist here
							x2 = xw[iz][j] - tx.xShotRay;
							t1 = tw[iz][j - 1];
							t2 = tw[iz][j];

							if ((x1 < 0) == (x2 < 0)) {
								// now x1 and x2 are on the same side of the source
								isFound = true;
							}
							else {
								// now the 2 points are on diff sides of the source
								if ((x1 < 0) == (offset < 0)) {
									// x1 and xw[iz][j-1] is on the same side as source
									if (j > 1) {
										x1 = xw[iz][j - 2] - tx.xShotRay;
										x2 = xw[iz][j - 1] - tx.xShotRay;
										t1 = tw[iz][j - 2];
										t2 = tw[iz][j - 1];
										isFound = true;
									}
								} // if x1
								else {
									// x2 and xw[iz][j] is on the same side as source
									if (j < isei_np[iz] - 1) {
										x1 = xw[iz][j] - tx.xShotRay;
										x2 = xw[iz][j + 1] - tx.xShotRay;
										t1 = tw[iz][j];
										t2 = tw[iz][j + 1];
										isFound = true;
									}
								}
							} // if x1

							break;
						} // if dist
					} // for j
					if (!isFound) {
						// this part is important, since sometimes Zelt's raytracing cannot reach a certain distance
						// while the observed phases are strong there, such as the shallowest sediment reflections in
						// a complex 2D structure
						int jj = isei_np[iz] - 1;
						if (dist < xw[iz][0]) {
							x1 = xw[iz][0] - tx.xShotRay;
							x2 = xw[iz][1] - tx.xShotRay;
							t1 = tw[iz][0];
							t2 = tw[iz][1];
							isFound = true;
						}
						else if (dist > xw[iz][jj]) {
							x1 = xw[iz][jj - 1] - tx.xShotRay;
							x2 = xw[iz][jj] - tx.xShotRay;
							t1 = tw[iz][jj - 1];
							t2 = tw[iz][jj];
							isFound = true;
						}
					}
					if (!isFound) continue;

					// get the t for interpolation
					float t;
					if (fabs(t1 - t2) > 0.0001) {
						// testing shows here 0.0001  is better than MINAMP!!!
						bool isSuc = false;
						// first try hyperbola interpolation

						t12 = t1*t1;
						x12 = x1*x1;
						double vr2 = (x2*x2 - x12) / (t2*t2 - t12);
						if (fabs(vr2) > MINAMP) {
							// hyperbola interpolation
							double t02 = t12 + (offset*offset - x12) / vr2;
							if (t02 > 0.) {
								t = (float)sqrt(t02);
								isSuc = true;
							}
						}

						if (!isSuc) {
							// since hyperbola interpolation fails, we do linear interpolation
							if (fabs(x2 - x1) > 0.0001)
								t = (float)(t1 + (offset - x1) / (x2 - x1) * (t2 - t1));
							else
								t = (float)t1;
						}


					} // if fabs(t1-t2)
					else
						t = (float)t1;


					// start interpolation of trace data for the time window (length nsmooth) around t
					for (int iw = 0; iw < nsmooth; iw++) {
						//timew[iw] = (float)( t - dt*(nsmoothHalf-iw) );
						timew[iw] = (float)(t + dt*iw);
					}
					ints8r((int)numsamp, // ntin
						dt,   // dtin
						trArr[nxStore].getTraceDelay(),   // ftin
						&trArr[nxStore].data[0], // yin[t=ntin], with yin[0] = y(fxin)
						0.f,  // yinl    value used to extrapolate yin values to left of yin[0]
						0.f,  // yinr	 value used to extrapolate yin values to right of yin[ntin-1]
						nsmooth,   // nxout
						&timew[0],  // ntout
						&amp[nxStore][0]);    // tout
				} // for nxStore


				memset((void *)numi, 0, sizeof(float)*nsmooth);
				memset((void *)deno, 0, sizeof(float)*nsmooth);
				memset((void *)nnz, 0, sizeof(float)*nsmooth);

				if (stackmode == 0) {
					//################################ amplitude summation ############################
					//########################################################################
					for (int iw = 0; iw < nsmooth; iw++) {
						for (int i = 0; i < nxmax; i++) {
							if (fabs(amp[i][iw]) > MINAMP) {
								numi[iw] += amp[i][iw];
								nnz[iw] += 1.f;
							}
						} // for i
					} // for iw
					double nsum = 0.; // semblence numerator sum
					double dsum = 0.; // semblence denominator sum
					for (int iw = 0; iw < nsmooth; iw++) {
						nsum += fabs(numi[iw]);
						dsum += nnz[iw];
					} // for iw
					tTrcDepth.data[iz] = (dsum > MINAMP) ? (float)(nsum / dsum) : 0.0f;
					//################################ end amplitude summation ############################
					//########################################################################
				}
				else if (stackmode == 1) {
					//################################ semblance ############################
					//########################################################################
					for (nxStore = 0; nxStore < nxmax; nxStore++) {
						for (int iw = 0; iw < nsmooth; iw++) {
							if (fabs(amp[nxStore][iw]) > MINAMP) {
								numi[iw] += (float)amp[nxStore][iw];
								deno[iw] += (float)(amp[nxStore][iw] * amp[nxStore][iw]);
								nnz[iw] += 1.f;
							}
						} // for iw
					} // for nxStore
					double nsum = 0.; // semblence numerator sum
					double dsum = 0.; // semblence denominator sum
					for (int iw = 0; iw < nsmooth; iw++) {
						nsum += numi[iw] * numi[iw];
						dsum += nnz[iw] * deno[iw];
					} // for iw
					tTrcDepth.data[iz] = (dsum > MINAMP) ? (float)(nsum / dsum) : 0.0f;
					//################################ end semblence ########################
					//########################################################################
				}
				else {
					//################################ Energy Normalized Cross Correlation function ############################
					//########################################################################
					// Energy Normalized Cross Correlation function, less sensitive to amp variations between traces

					// we first want to find the min and max offsets that have data, and calculate the min offset difference for correlation
					float offset2max = -MIL;
					for (int i = 0; i < nxmax; i++) {
						if (fabs(amp[i][0]) > MINAMP) {
							if (offset2max < fabs(offset2[i])) offset2max = (float)fabs(offset2[i]);
						}
					}
					offset2max *= (1.f - xpercent); // now offset2max is the maximum offset2 for x-correlation


					for (int iw = 0; iw < nsmooth; iw++) {
						for (int i = 0; i < nxmax; i++) {
							if (fabs(amp[i][iw]) > MINAMP) {
								for (int k = i + 1; k < nxmax; k++) {
									if (fabs(offset2[i] - offset2[k]) > offset2max  &&  fabs(amp[k][iw]) > MINAMP) {
										numi[iw] += (float)(amp[i][iw] * amp[k][iw]);
										nnz[iw] += 1.f;
									} // if fabs(offset2
								} // for k
								deno[iw] += (float)(amp[i][iw] * amp[i][iw]);
							} // if
						} // for i
					} // for iw
					double nsum = 0.; // Correlation numerator sum
					double dsum = 0.; // Correlation denominator sum
					for (int iw = 0; iw < nsmooth; iw++) {
						nsum += numi[iw]; // numi[] can be negative since it is X-correlation
						dsum += nnz[iw] * deno[iw];
					} // for iw
					tTrcDepth.data[iz] = (fabs(dsum) > MINAMP) ? (float)(nxmax * nsum / dsum) : 0.0f;
					//tTrcDepth.data[iz] = (float)nsum;
					//################################ End Energy Normalized Cross Correlation function ############################
					//########################################################################
				} // if stackmode

				/*
				" Semblance is defined by the following quotient:			",
				"									",
				"		 n-1		 					",
				"		[ sum q(t,j) ]^2					",
				"		 j=0		 					",
				"	s(t) = ------------------					",
				"		 n-1		 					",
				"		n sum [q(t,j)]^2					",
				"		 j=0		 					",
				"									",
				" where n is the number of non-zero samples after muting.		",
				" Smoothing (nsmooth) is applied separately to the numerator and denominator",
				" before computing this semblance quotient.				",
				*/
				UpdateAllViews(NULL);
			} // for iz


			//if (nvPerturb % 20 == 0)
			//	showArrayInFile(&tTrcDepth.data[0], nz);


			memcpy((void *)&tr, (void *)&trArr[0], 240L);
			tr.tracl = nvPerturb;
			tr.cdp = nvPerturb;
			tr.cdpt = 1;
			tr.ns = (unsigned short)nz;
			tr.dt = (unsigned short)myRound(velColor.dz*MIL);
			tr.setTraceDelayF(cd.coord.m_zmin);
			tr.setDistance((float)vPerturb);
			tr.setOffset(0.f); // zero offset in output

			if (bh.format == 1) {
				tr.idistopt = 8;
				float_to_ibm((int *)&tTrcDepth.data[0], (int *)&tTrcDepth.data[0], (int)tr.ns);
			}

			filez.Write(&tr, 240);
			filez.Write(tTrcDepth.data, nz*sizeof(float));

			free1float(numi);
			free1float(deno);
			free1float(nnz);
			free2float(amp);
			free1float(offset2);
			free1float(timew);

		} // else if isCoh


		astr.Format(_T("Please wait: perturbation for velocity %5.3f => (%5.3f, %5.3f, %5.3f) completed"), vPerturb, vPerturbMin, vPerturbMax, vPerturbDv);
		pFrame->SetMessageText(astr);

		UpdateAllViews(NULL);
		NotifyChanged();
	} // for vPerturb 

	//################################################################################
	//############################ end loop for velocity perturbation###############
	//################################################################################

	//Free up space
	free2float(xw); xw = NULL;
	free2float(tw); tw = NULL;
	free1int(isei_np); isei_np = NULL;
	free3float(xwAll); xwAll = NULL;
	free3float(twAll); twAll = NULL;
	free2int(isei_npAll); isei_npAll = NULL;
	free2float(sei_zAll); sei_zAll = NULL;
	free1float(tTrcDepth.data);

	for (j = 0; j < nxmax; j++) {
		free1float(trArr[j].data); trArr[j].data = NULL;
	}
	xfree(trArr); trArr = NULL;

	CVelMod vm;
	CDigitize pDg;

	//#####################################################################################################
	//#####################################################################################################
	//#####################################################################################################
	//#####################################################################################################
	//#####################################################################################################
	//#####################################################################################################
	//############# compute V-Z curve and, for each iz, migrate the data due to velocity gradient##########
	//#####################################################################################################
	//#####################################################################################################
	//#####################################################################################################

	//Auto change mode to display both.
	if (!isCoh) {
		cd.coord.drawmodeOld = cd.coord.drawmode;
		cd.coord.drawmode = 3;	//Both velocity color and depth sections will be drawn.
		draw.isNoColorMap = true;
		CSegyMeta::setSegyTotalTrace(&filez, nvPerturb);
		dig.freeDigAll();
	}
	else {
		cd.coord.xmin = vPerturbMin - vPerturbDv;
		if (cd.coord.xmin < 0.1) cd.coord.xmin = 0.1; // for PS perturb mode, the min is around 0.1
		cd.coord.xmax = vPerturbMax;
		cd.coord.xmax *= 2; // we have double the vPerturbMax only when outputing due to velocity gradient considered
		if (cd.coord.xmax > 8.) cd.coord.xmax = 8.;
		if (cd.coord.xTick > 0.1) cd.coord.xTick = 0.1;

		// display 
		// we need to use vTop[] and vBot[] info at the OBS location, so we pre-calculate


		// double depth[MOD_LAYER_MAX],vTop[MOD_LAYER_MAX],vBot[MOD_LAYER_MAX];
		CVelMod::VELMOD_X modX;
		modX.dist = tx.xShotRay;
		bool isTime = cd.coord.isTimeDomain() == TRUE;
		velMod.m_isConvert = true;
		vm.initModX(&velMod, &modX, isTime, true, velColor.dz);
		dig.initDigitizeArray(MOD_LAYER_MAX * 2, 1);
		dig.isZeltFormat = FALSE;
		dig.totCurve = 1;
		dig.nPoint[0] = 0;

		//################################################################################
		//******************First we compute the single curve that delineates the input velocities****
		//################################################################################
		// draw in TWTT domain
		dig.digName = txPath + "\\_vtcurve.txt";
		int nzmaxModelAll = (int)(modX.depthMod[velMod.ncont - 1] / velColor.dz + 1.0);
		tTrcDepth.data = (float *)ealloc1float(nzmaxModelAll);
		vm.getTzFromZMod(&modX, nzmaxModelAll, 0.f, velColor.dz, tTrcDepth.data);
		//  here, iz=0 is at the surface, not at cd.coord.zmin !
		// now tTrcDepth.data[] contains TWTT trace data

		// now depth[]  needs to be in TWTT
		//	double time[MOD_LAYER_MAX];
		for (icont = 0; icont < velMod.ncont; icont++) {
			// we want :  depth[icont] ==>  time[icont]
			register bool isSuc = false;
			for (iz = 0; iz < nzmaxModelAll - 1; iz++) {
				register float z = (float)(iz*velColor.dz);
				if (fabs(z - modX.depthMod[icont]) <= velColor.dz) {
					// if here, the current iz is the closest to depth[icont] ==>  time[icont]
					modX.timeMod[icont] = tTrcDepth.data[iz] + (tTrcDepth.data[iz + 1] - tTrcDepth.data[iz]) / velColor.dz * (modX.depthMod[icont] - z);
					// now we got TWTT writen in time[icont]
					isSuc = true;
					break;
				}
			} // for iz
			if (!isSuc) {
				if (icont > 0)
					modX.timeMod[icont] = modX.timeMod[icont - 1];
				//AfxMessageBox(_T("A boundary cannot be converted into TWTT domain");
			}
		} // for icont

		if (raymode > 0) {
			// raymode==1:  PS mode
			// raymode==2:  SP mode
			CStringArray *csArr = new CStringArray();
			loadParam(draw.rayName, _T("pois"), csArr);
			for (icont = 0; icont < csArr->GetCount(); icont++) {
				if (icont >= velMod.ncont - 1) continue;
				int ip = dig.nPoint[0];
				dig.x[ip][0] = (float)_tstof(csArr->ElementAt(icont));
				dig.t[ip][0] = (float)modX.timeMod[icont];

				if (modX.timeMod[icont] < cd.coord.m_tmin && modX.timeMod[icont + 1] > cd.coord.m_tmin) {
					// need to add a point at cd.coord.zmin
					dig.x[ip + 1][0] = (float)_tstof(csArr->ElementAt(icont));
					dig.x[ip + 2][0] = (float)_tstof(csArr->ElementAt(icont));
					dig.t[ip + 1][0] = (float)cd.coord.m_tmin;
					dig.t[ip + 2][0] = (float)modX.timeMod[icont + 1];
					dig.nPoint[0] += 3;
				}
				else if (modX.timeMod[icont] < cd.coord.m_tmax && modX.timeMod[icont + 1] > cd.coord.m_tmax) {
					// we need to add a point at the axis 
					dig.x[ip + 1][0] = (float)_tstof(csArr->ElementAt(icont));
					dig.x[ip + 2][0] = (float)_tstof(csArr->ElementAt(icont));
					dig.t[ip + 1][0] = (float)cd.coord.m_tmax;
					dig.t[ip + 2][0] = (float)modX.timeMod[icont + 1];
					dig.nPoint[0] += 3;
				}
				else {
					dig.x[ip + 1][0] = (float)_tstof(csArr->ElementAt(icont));
					dig.t[ip + 1][0] = (float)modX.timeMod[icont + 1];
					dig.nPoint[0] += 2;
				}
			}
			csArr->RemoveAll();
			delete csArr;
			csArr = NULL;

		} // end raymode>0
		else {
			// P wave mode
			for (icont = 0; icont < velMod.ncont - 1; icont++) {
				// note:  depth[icont]  is now TWWW in sec!!!
				int ip = dig.nPoint[0];
				dig.x[ip][0] = (float)modX.vTop[icont];
				dig.t[ip][0] = (float)modX.timeMod[icont];

				if (modX.timeMod[icont] < cd.coord.m_tmax && modX.timeMod[icont + 1] > cd.coord.m_tmax) {
					// we need to add a point at the axis 
					dig.x[ip + 1][0] = (float)(modX.vTop[icont] + 
						(modX.vBot[icont] - modX.vTop[icont]) / (modX.timeMod[icont + 1] - modX.timeMod[icont])*(cd.coord.m_tmax - modX.timeMod[icont]));
					dig.t[ip + 1][0] = (float)cd.coord.m_tmax;
					dig.t[ip + 2][0] = (float)modX.timeMod[icont + 1];
					dig.x[ip + 2][0] = (float)modX.vBot[icont];
					dig.nPoint[0] += 3;
				}
				else {
					dig.x[ip + 1][0] = (float)modX.vBot[icont];
					dig.t[ip + 1][0] = (float)modX.timeMod[icont + 1];
					dig.nPoint[0] += 2;
				}
			}
			free1float(tTrcDepth.data);
		}
		//} // end if producing single vz or vt curve
		CDigitize pDg;
		dig.isSortedX = dig.isSortedY = FALSE;
		pDg.myDigSaveAs2(&dig, false);
		//draw.extLineDrawing = !draw.labelAsTWTT;
		//draw.extLineDrawingTim = draw.labelAsTWTT;
		cd.coord.drawmodeOld = cd.coord.drawmode;
		cd.coord.drawmode = 10;
		draw.strXLabelOverwrite = _T("Velocity");
		//################################################################################
		//******************End computing the single curve that delineates the input velocities****
		//################################################################################





		if (raymode == 0) {
			//################################################################################
			//################################################################################
			//############################ start preparing for P-velocity display###############
			//################################################################################
			int icontFocus = draw.iLayerFocus - 1;
			// NOTE: draw.iLayerFocus  is   1-based, while all our other C++ code (icontFocus) is zero based!!!

			astr.Format(_T("Migrating due to velocity gradients at and below layer %d at [%6.3f, %6.3f] km"),
				icontFocus + 1, (float)modX.depthMod[icontFocus], (float)modX.depthMod[icontFocus + 1]);
			pFrame->SetMessageText(astr);
			segydynamic *trzArr = (segydynamic *)xmalloc(sizeof(segydynamic) * nv_max);
			for (nvPerturb = 0; nvPerturb < nv_max; nvPerturb++) {
				trzArr[nvPerturb].data = (float *)ealloc1float(nz);
			}
			filez.Seek(3600L, CFile::begin);
			for (nvPerturb = 0; nvPerturb < nv_max; nvPerturb++) {
				filez.Read(&trzArr[nvPerturb], 240L);
				filez.Read(&trzArr[nvPerturb].data[0], nz*sizeof(float));
				if (bh.format == 1)
					ibm_to_float((int *)&trzArr[nvPerturb].data[0], (int *)&trzArr[nvPerturb].data[0], (int)nz);
			}

			segydynamic *trzArr2 = (segydynamic *)xmalloc(sizeof(segydynamic) * nv_max * 2); // note: because of hor. migration, iv can be doubled
			for (nvPerturb = 0; nvPerturb < nv_max * 2; nvPerturb++) {
				if (nvPerturb < nv_max)
					memcpy((void *)&trzArr2[nvPerturb], (void *)&trzArr[nvPerturb], 240L); // just copy the segy trace header only
				else {
					memcpy((void *)&trzArr2[nvPerturb], (void *)&trzArr[0], 240L); // just copy the segy trace header only
					trzArr2[nvPerturb].tracl = nvPerturb;
					trzArr2[nvPerturb].cdp = nvPerturb;
					trzArr2[nvPerturb].setDistance((float)(vPerturbMin + nvPerturb*vPerturbDv));
				}
			} // for nvPerturb
			//// NOW: trzArr2 trace header already assigned, but its data[] not allocated at all!!!

			double val;

			// now we need to convert the depth domain segy data into twtt time domain!

			// We can think of this process as: for each  vPerturb, we vertically shift the amplutides along iz axis only; 
			// do not shift along the vPerturb axis. This wil convert to TWTT domain.
			CVelMod::VELMOD_X modX2;

			float **twtt2d = (float **)ealloc2float(nz, nv_max);
			memset((void *)twtt2d[0], 0, sizeof(float)*nz*nv_max);
			for (nvPerturb = 0; nvPerturb < nv_max; nvPerturb++) {
				for (icont = 0; icont < velMod.ncont - 1; icont++) {
					modX2.vTop[icont] = modX.vTop[icont];
					modX2.vBot[icont] = modX.vBot[icont];
					if (icont >= icontFocus) {
						modX2.vTop[icont] += -modX.vTop[icontFocus] + vPerturb;
						modX2.vBot[icont] += -modX.vTop[icontFocus] + vPerturb;
					}
				} // for icont
				vm.getTzFromZMod(&modX2, nz, cd.coord.m_zmin, velColor.dz, &twtt2d[nvPerturb][0]);
			} // for vPerturb


			for (nvPerturb = 0; nvPerturb < nv_max * 2; nvPerturb++) {
				trzArr2[nvPerturb].data = (float *)ealloc1float(numsamp);
				memset((void *)&trzArr2[nvPerturb].data[0], 0, sizeof(float)*numsamp);
			} // for vPerturb
			//****************Now twtt2d[nvPerturb][iz] complete with all TWTT info****************
			//****************Now trzArr[nvPerturb].data[iz] with all un-migrated data in depth domain****************
			//****************Now trzArr2[nvPerturb].data[it] space allocated to store data in TWTT domain****************
			// NOTE: for twtt[nvPerturb][iz], and trzArr[nvPerturb].data[iz], iz=0 is at cd.coord.zmin !

			int it;
			double frac;
			float atimeOutput;
			for (vPerturb = vPerturbMin, nvPerturb = 0; vPerturb <= vPerturbMax; vPerturb += vPerturbDv, nvPerturb++) {
				if (nvPerturb >= nv_max) break;
				for (icont = 0; icont < velMod.ncont - 1; icont++) {
					modX2.vTop[icont] = modX.vTop[icont];
					modX2.vBot[icont] = modX.vBot[icont];
					if (icont >= icontFocus) {
						modX2.vTop[icont] += -modX.vTop[icontFocus] + vPerturb;
						modX2.vBot[icont] += -modX.vTop[icontFocus] + vPerturb;
					}
				} // for icont

				for (atimeOutput = (float)cd.coord.m_tmin, it = 0; atimeOutput <= (float)cd.coord.m_tmax; atimeOutput += dtField, it++) {
					// now we need to find out the corresponding index in tTrcDepth.data[] for atime
					if (it >= numsamp) continue;

					for (iz = 1; iz<nz; iz++) {
						if (atimeOutput <= twtt2d[nvPerturb][iz]) {
							// now  atimeOutput is between  twtt2d[nvPerturb][iz-1]  and twtt2d[nvPerturb][iz]
							// NOTE: iz=0 is at cd.coord.zmin !
							frac = twtt2d[nvPerturb][iz] - twtt2d[nvPerturb][iz - 1];
							register double zt = (fabs(frac) > 0.000001) ?
								velColor.dz * (iz - 1 + (atimeOutput - twtt2d[nvPerturb][iz - 1]) / frac)
								:
								velColor.dz * (iz - 1);
							register double vt = vm.getVFromVz(&modX2, zt + cd.coord.m_zmin);
							register int iv = (int)myRound((vt - vPerturbMin) / vPerturbDv);
							//iv = nvPerturb; // test
							if (iv >= 0 && iv<nv_max * 2) {
								val = (fabs(frac) > 0.000001) ?
									trzArr[nvPerturb].data[iz - 1] + (trzArr[nvPerturb].data[iz] - trzArr[nvPerturb].data[iz - 1]) * (atimeOutput - twtt2d[nvPerturb][iz - 1]) / frac
									:
									trzArr[nvPerturb].data[iz - 1];

								if (fabs(val) > 0.0000001) {
									if (fabs(trzArr2[iv].data[it]) > 0.0000001f) {
										// both values are non-zero, so we average
										trzArr2[iv].data[it] = (float)((val + trzArr2[iv].data[it]) * 0.5);
									}
									else
										trzArr2[iv].data[it] = (float)val;
								}
							} // if iv
							break;  // finished for loop iz
						} // if atimeOutput, it
					} // for iz
				} // for atimeOutput
			} // for nvPerturb








			bh.dto = bh.hdt = (unsigned short)tpp;	//Sampling rate;
			bh.hns = numsamp;
			filez.Seek(3200L, CFile::begin);
			filez.Write(&bh, 400);
			for (nvPerturb = 0; nvPerturb < nv_max * 2; nvPerturb++) {
				// memcpy((void *)&tr, (void *)&trzArr2[nvPerturb], 240L);
				trzArr2[nvPerturb].ns = (unsigned short)numsamp;
				trzArr2[nvPerturb].dt = (unsigned short)tpp;
				trzArr2[nvPerturb].setTraceDelayF(cd.coord.m_tmin);

				if (bh.format == 1) {
					trzArr2[nvPerturb].idistopt = 8;
					float_to_ibm((int *)&trzArr2[nvPerturb].data[0], (int *)&trzArr2[nvPerturb].data[0], (int)numsamp);
				}

				filez.Write(&trzArr2[nvPerturb], 240L);  // note for simplicity, the segy headers in trzArr[nvPerturb]  is not directly assigned
				filez.Write(&trzArr2[nvPerturb].data[0], numsamp*sizeof(float));
				//showArrayInFile(trzArr[nvPerturb].data, numsamp);
			} // for nvPerturb

			free2float(twtt2d);
			//*******************************************************************
			//********* end display results in the TWTT domain***********************
			//*******************************************************************
			//}


			// free some last memory blocks
			for (j = 0; j < nv_max; j++) {
				free1float(trzArr[j].data);
			}
			for (j = 0; j < nv_max * 2; j++) {
				free1float(trzArr2[j].data);
			}
			xfree(trzArr2);
			xfree(trzArr);

			cd.coord.isDistanceDisplay = TRUE;  // always display in distance


			//################################################################################
			//################################################################################
			//############################ end preparing for P-velocity display###############
			//################################################################################
		} // if (raymode == 0


	} // if else


	filez.Close();

//	draw.depthSecOld = BLANK;	//recalculate gain.
	draw.isSameDataDisplay = FALSE; //indicate display has been changed and will re-load all data in OnDraw().


	SetModifiedFlag();
	UpdateAllViews(NULL);
	NotifyChanged();
	//	AfxMessageBox(_T("Succesfully converting into depth domain");

}

// This will calculate a big list of contours as floating reflectors for raytracing, for NMO velocity analysis using semblence stack
// expected file extension from aFile:   tx.insemb
CString CSeisWideDoc::setContour4Raytrace(CString aFile, float xpos, float dz, float zmin, double *zmaxMod,
	float vminPerturb, float vmaxPerturb, float dvPerturb)
{
	// global variables used: velMod struct
	// velMod.floatName
	// return 0 if failed
	if (dz < 0.000001f) dz = 0.004f;

	// first calculate the total number of contours / floating reflectors to do raytracing
	int nz = (int)((*zmaxMod - zmin) / dz + 1.0);
	if (nz > 6000) {
		nz = 6000;  // fortran program has this array limit to impose
		*zmaxMod = zmin + (nz - 1)*dz;
	}

	// calculate max number of points per curve
	int npoint = 0;
	int icont;
	for (icont = 0; icont < velMod.ncont; icont++)
	{
		if (npoint < velMod.nzed[icont]) npoint = velMod.nzed[icont];
	}
	if (npoint == 0) {
		AfxMessageBox(_T("no points for output to raytracing."));
		return BLANK;
	}

	float *xArray = (float *)ealloc1float(npoint * 2);
	float *zArray = (float *)ealloc1float(npoint * 2);    // data for the floating reflectors.
	int *nArray = (int *)ealloc1int(npoint * 2);

	CString out = setContour4Raytrace(aFile, xpos, dz, zmin, zmaxMod, vminPerturb, vmaxPerturb, dvPerturb,
		nArray, xArray, zArray);


	free1float(xArray);
	free1float(zArray);
	free1int(nArray);

	return out;
}


CString CSeisWideDoc::setContour4Raytrace(CString aFile, float xpos, float dz, float zmin, double *zmaxMod,
	float vminPerturb, float vmaxPerturb, float dvPerturb,
	int *nArray, float *xArray, float *zArray)
{
	if (cd.coord.isTimeDomain()) {
		AfxMessageBox(_T("Sorry, this only works in the depth domain."));
		return BLANK;
	}


	// global variables used: velMod struct
	// velMod.floatName
	// return 0 if failed
	if (dz < 0.000001f) dz = 0.004f;

	// first calculate the total number of contours / floating reflectors to do raytracing
	int nz = (int)((*zmaxMod - zmin) / dz + 1.0);
	if (nz > 6000) {
		nz = 6000;  // fortran program has this array limit to impose
		*zmaxMod = zmin + (nz - 1)*dz;
	}

	// calculate max number of points per curve
	int j, jj, k, icont, iz;
	double v1, v2;

	CVelMod vm;
	CVelMod::VELMOD_X modX;
	modX.dist = xpos;
	velMod.m_isConvert = true;
	vm.initModX(&velMod, &modX, cd.coord.isTimeDomain() == TRUE, true, velColor.dz);
	// vm.getZModFromZ(&velMod, &modX, true); 
	// apply anisotropy automatically as long as it exists for the layer!


	// a dump of contours would be a good check on screen
	FILE *stream2;
	CString tt = _T("myf.txt");
	if (_tfopen_s(&stream2, tt, _T("w+")) != 0) return BLANK;





	CFile filev(aFile, CFile::modeCreate | CFile::modeWrite | CFile::typeBinary);
	if (filev == NULL)
	{
		AfxMessageBox(_T("A new file ") + aFile + _T(" could not open"));
		return BLANK;
	}
	filev.Write(&nz, sizeof(int));
	filev.Write(&xpos, sizeof(float));
	filev.Write(&vminPerturb, sizeof(float));
	filev.Write(&vmaxPerturb, sizeof(float));
	filev.Write(&dvPerturb, sizeof(float));
	// we do not need to specify the following 2 lines. We do it in the command line!
	//filev.Write(&draw.iLayerFocus, sizeof(int));
	//filev.Write(&irefrMode, sizeof(int));


	// note: if there are extra floating reflectors imposed, npoint  should be added by the max number of these points!!!
	if (isFileExistNotDirectory(velMod.flFloatName)) {
		CVelMod::myLoadFloatReflectors(&velMod);
		// velMod.floatName=BLANK; // always load again here: user may change from other places.
	} // if
	// now deals with specified floating reflectors: we only consider the first 2 of them.
	float zf1 = -1.f;
	float zf2 = -1.f;
	float zfThis = -1.f;
	for (int icurve = 0; icurve < velMod.flTotCurve; icurve++) {
		if (icurve >= 2) break;
		for (j = 0; j < velMod.flNpArray[icurve] - 1; j++)
		{
			if (xpos >= velMod.flXArray[j][icurve] && xpos < velMod.flXArray[j + 1][icurve]) {
				float dx = velMod.flXArray[j + 1][icurve] - velMod.flXArray[j][icurve];
				// if we have 2 curves, we restrain the curve between z1 and z2.
				// if only 1 curve, we just have z1
				if (dx > 0.00001f) zfThis = velMod.flTArray[j][icurve] + (velMod.flTArray[j + 1][icurve] - velMod.flTArray[j][icurve])
					/ dx * (xpos - velMod.flXArray[j][icurve]);
				else zfThis = velMod.flTArray[j][icurve];
				if (icurve == 0) zf1 = zfThis;
				else if (icurve == 1) zf2 = zfThis;
				break;
			}
		} // for j
	} // for icurve


	float z1, z2;
	int np;

	for (iz = 0; iz < nz; iz++) {

		float z = (float)(zmin + iz*dz);
		double v = 0.;
		np = 0; // initilize it !

		// first, calculate v at the current point (xpos, z)

		// which layer number is z situated?
		int icontSel = -1;
		for (icont = 1; icont < velMod.ncont; icont++) {
			if (z >= modX.depthMod[icont - 1] && z < modX.depthMod[icont]) {
				icontSel = icont - 1;
				break;
			}
		} // for icont
		if (icontSel < 0) continue; // no need to go further for this z

		if (icontSel > 0) {
			int asdasd = 1;
		}

		// now for (xpos,z) inside layer icontSel, we need to formulate a contour for output
		for (j = 0; j < velMod.nzed[icontSel]; j++) {
			xArray[j] = velMod.xm[j][icontSel];
		}
		np = velMod.nzed[icontSel];
		float ax;






		for (j = 0; j < velMod.nzed[icontSel + 1]; j++) {
			// we want to make sure the current velMod.xm[j][icontSel]  is not already inside xArray[]
			bool isExist = false;
			ax = velMod.xm[j][icontSel + 1];
			for (jj = 0; jj < velMod.nzed[icontSel]; jj++) {
				if (fabs(xArray[jj] - ax) < 0.00001) {
					// only if the point is not the same can we use it
					isExist = true;
					break;
				} // if
			} // for jj
			if (!isExist) {
				xArray[np] = ax;
				np++;
			}
		} // for j

		// now we sort for each point at xArray[][iz]. 
		for (j = 0; j < np - 1; j++) {
			for (k = j + 1; k<np; k++) {
				if (xArray[j] > xArray[k]) {
					// swap the 2 values
					ax = xArray[j];
					xArray[j] = xArray[k];
					xArray[k] = ax;
				}
			} // for k
		} // for j

		// now we calculate the depth for each point xArray[k][iz]
		for (j = 0; j < np; j++) {
			//v1 = vdepth[icontSel][0];
			//v2 = vdepth[icontSel][1];
			v1 = modX.vTop[icontSel];
			v2 = modX.vBot[icontSel];
			z1 = (float)modX.depthMod[icontSel];
			z2 = (float)modX.depthMod[icontSel + 1];
			v = (fabs(z2 - z1) > 0.00001) ? v1 + (v2 - v1)*(z - z1) / (z2 - z1) : v1;
			double percent = 0.;
			if ((z2 - z1) > 0.00001) percent = (z - z1) / (z2 - z1);
			zArray[j] = (float)getDepthFromVel(xArray[j], v, icontSel, percent);
		} // for j

		// now deals with given floating reflectors
		if (velMod.flNpArray != NULL && zf1 > 0) {
			if (fabs(z - zf1) < 2.*dz) {
				// if only 1 curve, we just have zf1
				np = 0; // we reset for this iz
				for (j = 0; j < velMod.flNpArray[0]; j++)
				{
					xArray[np] = velMod.flXArray[j][0];
					zArray[np] = velMod.flTArray[j][0] + z - zf1;
					np++;
				} // for j
			} // if fabs(z-zf1)
		} // if zf1

		// now write results to file
		int ai = iz + 1;
		filev.Write(&ai, sizeof(int));  // seq contour number, starting from 1
		ai = icontSel + 1;
		filev.Write(&ai, sizeof(int));  // layer number in the Zelt's model, starting from 1
		filev.Write(&np, sizeof(int));  // number of points for each contour
		filev.Write(&z, sizeof(float)); // the depth of the contour at xpos 
		filev.Write(&xArray[0], np*sizeof(float));
		filev.Write(&zArray[0], np*sizeof(float));

		if (stream2 != NULL) {
			for (int i = 0; i < np; i++)
			{
				_ftprintf_s(stream2, _T(" %9.3f %9.3f %9d\n"), xArray[i], zArray[i], iz);
			}
		}
	} // for iz




	filev.Close();

	fclose(stream2);

	return tt;  // success
}

double CSeisWideDoc::getDepthFromVel(double dist, double vel, int icont, double percent)
{
	CVelMod vm;
	return vm.getDepthFromVel(&velMod, dist, vel, icont, percent);
}

void CSeisWideDoc::OnViewNmoVelocity()
{
	if (dig.isDigitizing && (cd.coord.drawmode < 1 || (cd.coord.drawmode>4 && cd.coord.drawmode < 10)))
	{
		AfxMessageBox(_T(" You are still digitizing a time section "), MB_OK | MB_ICONINFORMATION);
		return;
	}
	cd.coord.drawmodeOld = cd.coord.drawmode;
	cd.coord.drawmode = 10;	//Depth section will be drawn.

	if (!myParas())
	{
		return;
	}
	draw.isSameDataDisplay = FALSE; //indicate display has been changed and will re-load all data in OnDraw().

	SetModifiedFlag();
	UpdateAllViews(NULL);
	NotifyChanged();
}

void CSeisWideDoc::OnModelingMergemodel()
{
	CString tStr;
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();

	static double shiftKm = 0.;
	static double shiftKm2 = 0.;
	static double vTolerance = 0.05;

	//	CString secondFile;
	CdlgMergeModels dlg;
	dlg.m_velSecName = velMod.velSecName;
	dlg.m_shiftKm2 = (float)shiftKm2;
	dlg.m_vTolerancePerc = (float)(vTolerance * 100.);

	if (draw.velSecNamesEx.GetLength() > 0) {
		draw.velSecNamesEx.Replace(_T(",\n"), CARRAGE);
		draw.velSecNamesEx.Replace(_T(",\r\n"), CARRAGE);
		draw.velSecNamesEx.Replace(_T(","), CARRAGE);
		CStringArray arr;
		SplitStringArr(draw.velSecNamesEx, CARRAGE, &arr, false);
	//	int nElementCount = arr.GetCount();
		for (int i = 0; i < arr.GetCount() - 1; i++) {
			// example:  80, 115, G:\arcticSBs\sb2007\sb21\model0721New.bin
			double xShift = 0.;
			double xpos = -99999.;
			if (IsNumeric(arr.ElementAt(i).Trim())) {
				xShift = StringToFloat(arr.ElementAt(i).Trim());
				i++;
			}
			if (IsNumeric(arr.ElementAt(i).Trim())) {
				xpos = StringToFloat(arr.ElementAt(i).Trim());
				i++;
			}
			tStr = arr.ElementAt(i).Trim();
			if (!IsNumeric(tStr) && isFileExistNotDirectory(tStr)) {
				if (dlg.m_velSecName.IsEmpty()) {
					dlg.m_velSecName = tStr;
					dlg.m_shiftKm = (float)xShift;
				}
				else if (tStr != dlg.m_velSecName) {
					dlg.m_velSecName2 = tStr;
					dlg.m_shiftKm2 = (float)xShift;
					break;
				}
			}
		} // for
		arr.RemoveAll();
	} // if
	if (dlg.DoModal() != IDOK) return;
	dlg.m_velSecName = dlg.m_velSecName.Trim();
	dlg.m_velSecName2 = dlg.m_velSecName2.Trim();
	shiftKm = dlg.m_shiftKm;
	shiftKm2 = dlg.m_shiftKm2;
	vTolerance = dlg.m_vTolerancePerc * 0.01;

	CVelMod vm;
	velMod.velSecName = dlg.m_velSecName;
	if (!vm.loadInitVel(&velMod, velMod.velSecName, velColor.dz, tStr)) {
		pFrame->myCaption(tStr);
		return;
	}

	CVelMod::VELMOD velMod2;
	//vm.velModSetArrays(&velMod2);
	velMod2.velSecName = dlg.m_velSecName2;
	if (!vm.loadInitVel(&velMod2, velMod2.velSecName, velColor.dz, tStr)) {
		pFrame->myCaption(tStr);
		return;
	}

	// decide if velMod and velMod2 should be swapped.!
	if (velMod.getXmin() > velMod2.getXmin()) {
		// do the swapping
		tStr = dlg.m_velSecName;
		velMod.velSecName = dlg.m_velSecName = dlg.m_velSecName2;
		velMod2.velSecName = dlg.m_velSecName2 = tStr;
		vm.loadInitVel(&velMod, velMod.velSecName, velColor.dz, tStr);
		vm.loadInitVel(&velMod2, velMod2.velSecName, velColor.dz, tStr);
	}


	if (vm.myModelsMerge(&velMod, shiftKm, &velMod2, shiftKm2, vTolerance, velColor.dz)) {
		CdlgNewVelFile dlg2;
		dlg2.m_velNewFileName = getFileNameAppend(dlg.m_velSecName, _T("_merge"));
		if (dlg2.DoModal() == IDOK) {

			//if (myModelSaveAs(dlg2.m_velNewFileName))
			bool isTime = cd.coord.isTimeDomain();
			if (!vm.saveModelAs(&velMod, dlg2.m_velNewFileName, velColor.dz, isTime, TRUE)) {
				tStr.Format(_T("Models merged but cannot save"));
				pFrame->myCaption(tStr);
			}

			SetModifiedFlag();
			UpdateAllViews(NULL);
			NotifyChanged();
		}
	}
	else {
		pFrame->myCaption(_T("Sorry, model merging failed."));
	}
	//velMod.velSecOld = BLANK;

	// must free the dynamicly assigned arrays
	//vm.velModFreeArrays(&velMod2);
}

void CSeisWideDoc::OnModelingGeneratesyntheticsegydata()
{
	CString tStr = _T("To generate synthetic segy, you need to:\n1. Dos consol.\n2. Copy v.bin, r.in (w/ extra lines) to run myTramp.exe.\n3. Modify s.in to run myPltSyn.exe to produce syn.sgy.data (self-containing all needed header info).\n4. Click this menu item. Continue?");
	if (AfxMessageBox(tStr, MB_OKCANCEL | MB_ICONINFORMATION | MB_ICONQUESTION) == IDCANCEL) return;

	//Openfiles.
	CString inFile = BLANK, outFile = BLANK;
	CFileDialog dlg(TRUE, _T("data; DATA"), _T("*.data; *.DATA"),
		OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT | OFN_EXPLORER,
		_T("Input syn.sgy.data File (*.data;*.DATA)|*.data; *.DATA|"));

	TCHAR* buff = (TCHAR*)alloc1(65535, sizeof(TCHAR));
	buff[0] = '\0';
	dlg.m_ofn.lpstrTitle = _T("Select the syn.sgy.data file generated by myPltsyn.exe program");
	dlg.m_ofn.lpstrFile = buff;
	dlg.m_ofn.nMaxFile = 65535;//sizeof(buff);

	if (dlg.DoModal() == IDOK)
	{
		inFile = dlg.GetPathName();
	}
	else {
		free1(buff);
		return;
	}

	free1(buff);
	delete dlg;
	outFile = inFile + _T(".sgy");


	float dist, xshot;
	int npts;
	float sps;  // rate in sec
	float tmin;
	segy tr;
	CFile file;
	if (!file.Open(inFile, CFile::modeRead | CFile::typeBinary | CFile::shareDenyNone)) {
		return;
	}
	//  write(13) dist,xshot,npts,tmin,sps,(s(j),j=1,npts)
	file.Read(&dist, 4);
	file.Read(&xshot, 4);
	file.Read(&npts, 4);
	file.Read(&tmin, 4);
	file.Read(&sps, 4);

	int deltaT = (int)(MIL / (float)sps);
	if (deltaT > USHRT_MAX) {
		tStr.Format(_T("Sampling interval is too large: the maximum is about 65000!"));
		AfxMessageBox(tStr, MB_ICONQUESTION);
		file.Close();
		return;
	}
	file.SeekToBegin();

	CFile file2;
	if (!file2.Open(outFile, CFile::modeReadWrite | CFile::modeCreate | CFile::typeBinary)) {
		file.Close();
		return;
	}

	file2.Write(head.ascHead, 3200L);
	bhed bh;
	bh.format = 1;
	// bh.format = ((CMainFrame*)AfxGetMainWnd())->statMain.gIsIBMFloatSegy2 ? 1 : 5; // only floating is adopted for output
	bh.hns = npts;
	bh.dto = bh.hdt = (unsigned short)deltaT; // convert from 
	file2.Write(&bh, 400L);

	int k = 0;
	while (file.Read(&dist, 4) == 4) {
		if (file.Read(&xshot, 4) != 4) break;
		file.Read(&npts, 4);
		file.Read(&tmin, 4);
		file.Read(&sps, 4);

		tr.tracl = k;
		tr.tracr = k;
		tr.fldr = k;
		tr.tracf = k;
		tr.ep = k;
		tr.trid = 1; // seismic trace
		tr.cdp = k;
		tr.sx = (int)(xshot*1000.);

		tr.ns = (unsigned short)npts;
		tr.dt = (unsigned short)deltaT;
		tr.setTraceDelayF(tmin);
		tr.setOffset(dist - xshot);
		tr.setDistance((float)dist);

		// note: this non-segy data is not IBM float!
		file.Read(&tr.dat.data[0], (long)(npts * 4));


		if (bh.format == 1) {
			float_to_ibm((int *)tr.dat.data, (int *)tr.dat.data, (int)tr.ns);
		}
		file2.Write(&tr, (long)(240 + npts * 4));
		k++;
	} // while

	CSegyMeta::setSegyTotalTrace(&file2, k);
	file.Close();

	//         write(13) dist(i),xshot,npts,tmin,sps,(s(j),j=1,npts)
	tStr.Format(_T("Generated segy is %s."), outFile);
	AfxMessageBox(tStr, MB_ICONQUESTION);

	file2.Close();
}






BOOL CSeisWideDoc::InitializeSec()
{

	//When a new file is opened, amplitude parameters have
	//to be initialized.
	CString tStr, fStr;
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	if (cd.coord.isTimeDomain()) {
		fStr = draw.timeSecName;
	}
	else {
		fStr = draw.depthSecName;
		cd.coord.isDistanceDisplay = TRUE;  // indicate it will display as distance, not offset!
	}

	CString fEncoded = CSegyMeta::getSegyMetaCacheName(fStr, false);
	if (getFileModifiedTime(fStr) != head.modifiedtime || fStr != head.secName || !isFileExistNotDirectory(fEncoded)) {
		if (isFileExistNotDirectory(fStr)) {
			tStr.Format(_T("Initializing: %s"), GetBaseFileName(fStr));
			pFrame->myCaption(tStr);
			if (CSegyMeta::segyHeadInit(fStr, &head)) {
				head.modifiedtime = getFileModifiedTime(fStr);
				if (head.secName != fStr) head.secName = fStr;
			}
			else {
				tStr.Format(_T("Cannot initialize segy file: %s"), fStr);
				pFrame->myCaption(tStr);
				return FALSE;
			}
		}
	}

	CVelMod vm;
	if (!vm.loadInitVel(&velMod, velMod.velSecName, velColor.dz, tStr)) {
		// failed to initialize model. ok to continue
		draw.isVelErr = FALSE;	//new vel file assuming no error.
	} 

	if (head.numTraces < 2) {
		// if no segy file is defined, we need to define head to avoid problems
		head.tminFile = 0;
		if (velMod.isVelModValid())
			head.tmaxFile = velMod.getTimeMax();
		else
			head.tmaxFile = 12.; // just assume a common value since not existing
	}

	return TRUE;
}


void CSeisWideDoc::OnModelingDosconsol()
{
	CString name = m_strPathName;
	int nPathLength = GetModuleFileName(NULL, name.GetBuffer(_MAX_PATH), _MAX_PATH);
	name.ReleaseBuffer();
	CString progPathBak = name.Left(name.ReverseFind('\\'));
	CString progPath;
	BOOL isDebug = progPathBak.Find(_T("Debug")) > 0;
	if (isDebug) {
		progPath = progPathBak + _T("\\..\\docs\\SeisWide64\\others\\myRayInvrWork\\run2010");
		if (!isDirectoryExist(progPath))
			progPath = progPathBak + _T("\\..\\docs\\SeisWide64\\others\\myRayInvrWork\\run2010");

		if (isDirectoryExist(progPath)) {
			SetCurrentDirectory(progPath);
		}
	}
	else {
		progPath = progPathBak + _T("\\..\\docs\\myRayInvrWork\\run2010");
		if (isDirectoryExist(progPath)) {
			// this is some older version format
			SetCurrentDirectory(progPath);
		}
		else {
			progPath = progPathBak + _T("\\others\\myRayInvrWork\\run2010");
			// this is the newer dir formats of SeisWide
			if (isDirectoryExist(progPath)) {
				SetCurrentDirectory(progPath);
			}
		}
	}

	myUnicodeProcess("cmd.exe", progPath);
}

void CSeisWideDoc::OnTimeTimesectionwithperturbedtravel()
{
	if (cd.coord.drawmode != 0) {
		AfxMessageBox(_T("Please show a wide-angle time section with km first, and rerun this processing to display computed traveltime curves for 2D NMO-velocity analysis."));
		return;
	}

	int j;
	int nvPerturb;

	// local parameters for the routine not saved by .sei file
	float vPerturb;
	static float vPerturbMin = 1.9f;
	static float vPerturbMax = 2.5f;
	static float vPerturbDv = 0.02f;
	static float secsmooth = 0.06f;
	static int numDisplay = -1;
	static BOOL isCoh = false;
	static int raymode = 0;  // 0=PP; 1=PS; 2=SP
	static int stackmode = 0;  // 0=amplitude summation approach; 1=semblence coefficient; 2=Energy normalised cross correlation 
	static float xpercent = 0.5f; //

	draw.isSameDataDisplay = TRUE; //indicate display has been changed and will re-load all data in OnDraw().

	// dialog controls
	CdlgWide2Velocity dlg;
	dlg.m_timeSecName = draw.timeSecName;
	if (draw.depthSecName.IsEmpty()) draw.depthSecName = _T("depth.sgy");
	dlg.m_depthSecName = draw.depthSecName;
	dlg.m_velname = velMod.velSecName;
	dlg.m_rayTracing = draw.rayName;
	dlg.m_floatName = velMod.flFloatName;
	dlg.m_zmax = (float)cd.coord.m_zmax;
	dlg.m_zmin = (float)cd.coord.m_zmin;
	dlg.m_dz = (float)velColor.dz;
	dlg.m_vPerturbMin = vPerturbMin;
	dlg.m_vPerturbMax = vPerturbMax;
	dlg.m_dv = vPerturbDv;
	dlg.m_iLayerFocus = draw.iLayerFocus;
	dlg.m_secsmooth = secsmooth;
	dlg.m_iscoh = isCoh;
	dlg.m_numDisplay = numDisplay;
	dlg.m_basePower = (float)draw.basePower;  if (fabs(draw.basePower) > 100.f) draw.basePower = 0.f;
	dlg.m_rayMode = raymode;
	dlg.m_sumMethod = stackmode;
	dlg.m_xpercent = (int)myRound(xpercent*100.);

	if (dlg.DoModal() == IDOK)
	{
		draw.timeSecName = dlg.m_timeSecName.Trim();
		draw.depthSecName = dlg.m_depthSecName.Trim();
		velMod.velSecName = dlg.m_velname.Trim();
		draw.rayName = dlg.m_rayTracing;
		velMod.flFloatName = dlg.m_floatName;
		cd.coord.m_zmax = dlg.m_zmax;
		cd.coord.m_zmin = dlg.m_zmin;
		velColor.dz = dlg.m_dz;
		vPerturbMin = dlg.m_vPerturbMin;
		vPerturbMax = dlg.m_vPerturbMax;
		vPerturbDv = dlg.m_dv;
		draw.iLayerFocus = dlg.m_iLayerFocus; // note: this is 1-based, while our convention is 0-based
		if (draw.iLayerFocus < 0) draw.iLayerFocus = 0;
		secsmooth = dlg.m_secsmooth;
		isCoh = dlg.m_iscoh;
		numDisplay = dlg.m_numDisplay;
		draw.basePower = dlg.m_basePower;
		raymode = dlg.m_rayMode;
		stackmode = dlg.m_sumMethod;
		xpercent = (float)myFloat(dlg.m_xpercent * 0.01f);
		if (xpercent>1.f) xpercent = 1.f;
		else if (xpercent < 0.01f) xpercent = 0.01f;
	}
	else
	{
		return;
	}


	// fix up for dz, since it cannot be too big
	if (velColor.dz*MIL > USHRT_MAX - 1) velColor.dz = (double)(USHRT_MAX - 1) / (double)MIL;
	if (!isFileExistNotDirectory(draw.timeSecName)) return;
	CString txoutName = _T("tx.outsemb");
	if (raymode == 1) txoutName += _T("ps");
	else if (raymode == 2) txoutName += _T("sp");

	CString astr;

	//make tx.out file in the same directory as velMod.velSecName.
	CString name = velMod.velSecName, txPath, t;
	int pathLen = name.ReverseFind('\\');
	txPath = name.Left(pathLen);
	txPath.MakeLower();
	if (pathLen > (-1))
	{
		SetCurrentDirectory(txPath);
		t = txPath + "\\r.in";
	}
	else {
		t = _T("r.in");
		TCHAR curDir[_MAX_PATH];
		GetCurrentDirectory(_MAX_PATH, curDir);
		txPath = (CString)curDir;
	}

	//##################### now do the raytracing
	if (!CCoords::isXShotDefined(tx.xShotRay)) {
		CSegyMeta::segyHeadInit(draw.timeSecName, &head);
		tx.xShotRay = (float)head.xshotInSegy;
		//CString workingPath = getWorkingPathSlash();
		//tx.xShotRay = (float)CRayHelper::getXPosAll(draw.timeSecName, workingPath);
	}
	//Do not refresh screen in any way until raytracing finished. Otherwise, 
	// it may refresh screen while raytracing is running!
	draw.isSameDataDisplay = TRUE;
	astr.Format(_T("%s\\%s%5.3f"), txPath, txoutName, vPerturbMin);


	int nz = (int)((cd.coord.m_zmax - cd.coord.m_zmin) / velColor.dz + 1.0);
	if (nz > 9999) {
		nz = 9999;  // fortran program has this array limit to impose
		cd.coord.m_zmax = cd.coord.m_zmin + (nz - 1)*velColor.dz;
		AfxMessageBox(_T("Max depth adjusted due to array size limitation of 9999 points. Contact programer to increase size if needed."));
	}

	int np_max = 0;
	np_max = 30;
	for (vPerturb = vPerturbMin, nvPerturb = 0; vPerturb <= vPerturbMax; vPerturb += vPerturbDv, nvPerturb++) {
		astr.Format(_T("%s\\%s%5.3f"), txPath, txoutName, vPerturb);
		if (!isFileExistNotDirectory(astr)) break;
	}
	if (nvPerturb < 2) {
		AfxMessageBox(_T("Less than 2 pertubations read in. pertubations intervals may have changed. Please check."));
		return;
	}
	int nv_max = nvPerturb;






	// ################### Use the raytracing results to form segy output
	segy tr;
	bhed bh;

	CFile file;
	if (!file.Open(draw.timeSecName, CFile::modeRead | CFile::typeBinary | CFile::shareDenyNone)) {
		return;
	}
	file.Seek(0, CFile::begin);
	UINT bytesRead = file.Read(head.ascHead, 3200L);
	if (bytesRead < 3200)
		AfxMessageBox(_T("Ascii section header read wrong"));
	file.Read(&bh, sizeof(bhed));
	if (bytesRead < 400)
		AfxMessageBox(_T("Binary section header read wrong"));
	//The following numbers have to be recalculated everytime,
	//because plotting the depth section will change these numbers.

	int numsamp = bh.hns;
	int format = bh.format;
	// backup the original format since bh.format will be overwritten for output header
	int len = (format != 3) ? (numsamp * 4 + 240) : (numsamp * 2 + 240);
	if (bh.hdt == 0) bh.hdt = bh.dto;
	int tpp = bh.hdt;

	//For progress control, need to know the last bytes no.
	ULONGLONG curBytesRead, totBytesRead = file.GetLength();
	file.Seek(3600, CFile::begin);

	//Begin progress control.
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	pFrame->BeginProgress();

	int nxmax = 0;  // total number of traces in the input segy file
	while (file.Read(&tr, 240) == (UINT)240) {
		file.Seek(len - 240, CFile::current);
		nxmax++;
	}
	file.Seek(3600, CFile::begin);

	// allocate array big enough for storing all the input segy data in memory
	segydynamic *trArr = (segydynamic *)xmalloc(sizeof(segydynamic) * nxmax);
	if (ERROR == trArr) return;
	for (j = 0; j < nxmax; j++) {
		trArr[j].data = (float *)ealloc1float(numsamp);
		if (ERROR == trArr[j].data) {
			// clean up before return
			for (j = 0; j < nxmax; j++) {
				free1float(trArr[j].data);
			}
			AfxMessageBox(_T("Sorry, failed to allocate memory for loading all traces into memory."));
			return;
		}
	}


	int nxStore = 0;
	if (tx.xShotRay <= ERRORVAL) tx.xShotRay = 0.;  // a fix
	while (file.Read(&tr, len) == (UINT)len)
	{
		//Formulating velocity traces first.
		curBytesRead = file.Seek(0, CFile::current);
		int iPos = (int)((double)curBytesRead / (double)totBytesRead*100.);
		if (iPos < 0)iPos = 0;
		if (iPos > 100)iPos = 100;
		pFrame->SetProgress(iPos);

		if (tr.trid == 2) //dead traces.
		{
			file.Seek(len, CFile::current);
			continue;
		}


		// assign only the trace header to the trArr[]
		memcpy((void *)&trArr[nxStore], (void *)&tr, 240L);

		// Note: format points to the original data in time, while bh.format  is already modified for output
		if (format == 3)
			for (j = 0; j < numsamp; j++) trArr[nxStore].data[j] = (float)tr.dat.datashort[j];
		else if (format == 1) {
			ibm_to_float((int *)tr.dat.data, (int *)tr.dat.data, (int)numsamp);
			for (j = 0; j < numsamp; j++) trArr[nxStore].data[j] = (float)tr.dat.data[j];
		}
		else if (format == 2)
			for (j = 0; j<numsamp; j++) trArr[nxStore].data[j] = (float)tr.dat.dataint[j];
		else if (format == 5) {
			for (j = 0; j<numsamp; j++) trArr[nxStore].data[j] = (float)tr.dat.data[j];
		}
		else break;

		if (draw.sphericOrder > 0.f) {
			double a = tr.getTraceDelay();  // a is now the initial time in sec for this trace

			double aGain = pow(a + numsamp *  (double)tpp / (double)MIL, (double)draw.sphericOrder);
			if (aGain > 0.) aGain = 1. / aGain;
			else aGain = 1.;

			double b;
			for (j = 0; j < numsamp; j++) {
				b = a + j* (double)tpp / (double)MIL;      // b is now the actual time in sec for the inidex j
				if (draw.sphericOrder == 2.f)
					trArr[nxStore].data[j] *= (float)(b*b*aGain);
				else
					trArr[nxStore].data[j] *= (float)(aGain* pow(b, (double)draw.sphericOrder));
			}  // for j
		} // if

		nxStore++;
	} // while file.Read
	file.Close();
	pFrame->EndProgress();
	// finished loading all segy data into memory trArr[]

	astr.Format(_T("finished loading all segy data into memory"));
	pFrame->SetMessageText(astr);




	//################################################################################
	//############################ start loading X-T values for velocity perturbation#####
	//################################################################################

	// first, we need to calculate max number of points of (x,t) pair for a certain iz
	int icont;
	int i, iz;
	float f1, f2, f7, f8;



	float ***xwAll = (float ***)ealloc3float(np_max, nz, nv_max);
	float ***twAll = (float ***)ealloc3float(np_max, nz, nv_max);    // data for the floating reflectors.
	int **isei_npAll = (int **)ealloc2int(nz, nv_max);
	float **sei_zAll = (float **)ealloc2int(nz, nv_max);
	memset((void *)xwAll[0][0], 0, sizeof(float)*np_max*nz*nv_max);
	memset((void *)twAll[0][0], 0, sizeof(float)*np_max*nz*nv_max);
	memset((void *)isei_npAll[0], 0, sizeof(int)*nz*nv_max);
	memset((void *)sei_zAll[0], 0, sizeof(float)*nz*nv_max);
	bool isTooMany = false;
	int izmaxTraced = -1;
	bool isProb = false;
	for (vPerturb = vPerturbMin, nvPerturb = 0; vPerturb <= vPerturbMax; vPerturb += vPerturbDv, nvPerturb++) {
		astr.Format(_T("%s\\%s%5.3f"), txPath, txoutName, vPerturb);
		if (!isFileExistNotDirectory(astr)) {
			CString str2;
			str2.Format(_T("Raytracing result file %s does not exist. Please check parameter."), astr);
			AfxMessageBox(str2);
			break;
		}
		CStringArray *txArray = getLinesFromFile(astr);
		for (j = 0; j < txArray->GetSize(); j++) {
			if (_stscanf_s(txArray->ElementAt(j).Trim(), _T("%f%f%d%d%f%f"), &f1, &f2, &iz, &icont, &f7, &f8) == 0) continue;

			if (iz == 0 && !isFloatEqual(f8, (float)cd.coord.m_zmin)) {
				isProb = true;
				cd.coord.m_zmin = f8;
				break;
			}
			if (iz == -1 && !isFloatEqual(f8, (float)cd.coord.m_zmax)) {
				isProb = true;
				cd.coord.m_zmax = f8;
				break;
			}
			if (iz == -2 && !isFloatEqual(f8, (float)velColor.dz)) {
				// this is the last line of a raytracing file
				isProb = true;
				velColor.dz = f8;
				break;
			}
			if (iz == -1 && icont > 0) {
				draw.iLayerFocus = icont;  // update perturbation layer number since it may be different by the user input
			}
			if (iz <= 0 || icont == 0 || iz > nz) continue;  // note: input file has  iz=1:nz.... from Fortran

			if ((i = isei_npAll[nvPerturb][iz - 1]) < np_max) {
				xwAll[nvPerturb][iz - 1][i] = f1;
				twAll[nvPerturb][iz - 1][i] = f2;
				isei_npAll[nvPerturb][iz - 1]++;  // we want array index to be zero based
				sei_zAll[nvPerturb][iz - 1] = f8;
				// so we just ignore the user input
				if (izmaxTraced < iz) izmaxTraced = iz;
			}
			else {
				isTooMany = true;
			}
		}
		txArray->RemoveAll();
		delete txArray;
		txArray = NULL;

		if (izmaxTraced < nz) break;

		// since xw[][] may not be ordered monotonically with distance, we need to reorder it.
		for (iz = 0; iz < nz; iz++) {
			for (j = 0; j < isei_npAll[nvPerturb][iz] - 1; j++) {
				for (int k = j + 1; k < isei_npAll[nvPerturb][iz]; k++) {
					if (xwAll[nvPerturb][iz][j] > xwAll[nvPerturb][iz][k]) {
						// swap the 2 values
						f1 = xwAll[nvPerturb][iz][j];
						xwAll[nvPerturb][iz][j] = xwAll[nvPerturb][iz][k];
						xwAll[nvPerturb][iz][k] = f1;
						f1 = twAll[nvPerturb][iz][j];
						twAll[nvPerturb][iz][j] = twAll[nvPerturb][iz][k];
						twAll[nvPerturb][iz][k] = f1;
					} // if
				} // for k
			} // for j
		} // for iz


		// note: sei_zAll[nvPerturb][iz]  info is only for checking here, not used in later NMO calculation, as we all assume
		//       the depth indece are uniform.
		if (isProb) break;


		astr.Format(_T("finished loading and parsing into memory the raytracing results for %5.3f (%5.3f, %5.3f, %5.3f) km/s"), vPerturb, vPerturbMin, vPerturbMax, vPerturbDv);
		pFrame->SetMessageText(astr);
	} // for vPerturb
	if (isTooMany)
		AfxMessageBox(_T("Too many points found in the raytracing. Will truncate. You may limit number of points per ray <=30 ."));
	if (isProb || izmaxTraced < nz) {
		free3float(xwAll);
		free3float(twAll);
		free2int(isei_npAll);
		free2float(sei_zAll);
		for (j = 0; j < nxmax; j++) {
			free1float(trArr[j].data);
		}
		xfree(trArr);

		astr = _T("Depth in the raytracing mismatches with desired zmin, zmax and dz which are adjusted accordingly. Note that temporary raytracing results cannot be mixed for different running. Please rerun this processing.");
		AfxMessageBox(astr);
		return;
	}




	astr.Format(_T("Start loop for velocity pertubation"));
	pFrame->SetMessageText(astr);


	//################################################################################
	//############################ start loop for velocity perturbation###############
	//################################################################################

	int izShow = 99;
	if (izShow >= nz) izShow = nz - 2;

	CDigitize pDg;
	dig.freeDigAll();
	dig.isZeltFormat = FALSE;
	dig.digName = txPath + "\\_vtcurve.txt";

	if (numDisplay >= 0 && numDisplay < nv_max) {
		dig.initDigitizeArray(np_max, 1);
		dig.totCurve = 1;
		dig.nPoint[0] = isei_npAll[numDisplay][izShow];
		for (j = 0; j < isei_npAll[numDisplay][izShow]; j++) {
			dig.x[j][0] = xwAll[numDisplay][izShow][j];
			dig.t[j][0] = twAll[numDisplay][izShow][j];
		}
	}
	else {
		dig.initDigitizeArray(np_max, nv_max);
		dig.totCurve = nv_max;
		for (vPerturb = vPerturbMin, nvPerturb = 0; vPerturb <= vPerturbMax; vPerturb += vPerturbDv, nvPerturb++) {
			if (nvPerturb >= nv_max) break;
			dig.nPoint[nvPerturb] = isei_npAll[nvPerturb][izShow];
			for (j = 0; j < isei_npAll[nvPerturb][izShow]; j++) {
				dig.x[j][nvPerturb] = xwAll[nvPerturb][izShow][j];
				dig.t[j][nvPerturb] = twAll[nvPerturb][izShow][j];
			}

		} // for vPerturb 
	}


	dig.isSortedX = dig.isSortedY = FALSE;
	pDg.myDigSaveAs2(&dig, false);

	//################################################################################
	//############################ end loop for velocity perturbation###############
	//################################################################################

	//Free up space
	free3float(xwAll);
	free3float(twAll);
	free2int(isei_npAll);
	free2float(sei_zAll);

	for (j = 0; j < nxmax; j++) {
		free1float(trArr[j].data);
	}
	xfree(trArr);

	draw.isSameDataDisplay = FALSE; //indicate display has NOT been changed and do not re-load all data in OnDraw().


	SetModifiedFlag();
	UpdateAllViews(NULL);
	NotifyChanged();
	//	AfxMessageBox(_T("Succesfully converting into depth domain");

}



void CSeisWideDoc::close_unused_documents(const CDocument* const pNotThisOne)
{
	//return;


	////////////////////////////////////////////////////////////////////
	// loop through all of the documents
	// and close the ones that match the criteria of:
	// 1) NOT previously saved ( CDocument::GetPathName() is empty)
	// and
	// 2) NOT Modified	( CDocument::IsModified() is zero )
	// and
	// 3) NOT the document we are in the process of opening (pNotThisOne)
	////////////////////////////////////////////////////////////////////

	POSITION template_pos = AfxGetApp()->GetFirstDocTemplatePosition();
	while (NULL != template_pos) {
		CDocTemplate* pDocTemplate = AfxGetApp()->GetNextDocTemplate(template_pos);
		if (NULL != pDocTemplate) {
			POSITION document_pos = pDocTemplate->GetFirstDocPosition();
			while (NULL != document_pos) {
				CDocument* pDoc_to_check = pDocTemplate->GetNextDoc(document_pos);
				if (pNotThisOne != pDoc_to_check) {
					if ((pDoc_to_check->GetPathName() == BLANK) // If not saved 
						&& (0 == pDoc_to_check->IsModified())){   // and not modified
						pDoc_to_check->OnCloseDocument();     // then close it
					}
				}
			}
		}
	}

	// I constantly have problem of control pressed too often. Hopefully these lines here can help in this
	//CSeisWideApp* pSeiApp = (CSeisWideApp*)AfxGetApp();
	//pSeiApp->statWin.isShiftPressed = FALSE;
	//pSeiApp->statWin.isAPressed = FALSE;
	//pSeiApp->statWin.isControlPressed = FALSE;

}



BOOL CSeisWideDoc::OnOpenDocument(LPCTSTR lpszPathName)
{
	if (!isMyFileReadable(lpszPathName)) return FALSE;
	// this line is quite useful: if a .sei file is locked by another Seiswide 
	// instance, this line prevents crash! 


	if (!COleServerDoc::OnOpenDocument(lpszPathName))
		return FALSE;

	// TODO:  Add your specialized creation code here
			// need to make sure the velCol values are valid for the 9th value, since I inserted them on Aug. 12, 2020
	if (velColor.vmid9 <= velColor.vmid8 || velColor.vmid9 >= velColor.vmax) {
		velColor.vmid9 = (velColor.vmid8 + velColor.vmax) * 0.5;
		velColor.vmidR9 = (int)((velColor.vmidR8 + velColor.vmaxR) * 0.5);
		velColor.vmidG9 = (int)((velColor.vmidG8 + velColor.vmaxG) * 0.5);
		velColor.vmidB9 = (int)((velColor.vmidB8 + velColor.vmaxB) * 0.5);
	}


	// All opening file name issues are dealt with here!
	CString seiFilePath(lpszPathName);
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	// if (!pFrame->gDriveNew.IsEmpty()) myChangeDrive(&pFrame->gDriveNew);

	draw.timeSecName = getSecNameRevised(draw.timeSecName, seiFilePath);
	draw.depthSecName = getSecNameRevised(draw.depthSecName, seiFilePath);
	velMod.velSecName = getSecNameRevised(velMod.velSecName, seiFilePath);
	draw.rayName = getSecNameRevised(draw.rayName, seiFilePath);
//	draw.vrmsTauNameDisabled = getSecNameRevised(draw.vrmsTauNameDisabled, seiFilePath);

	if (cd.coord.isModelingMode()) {
		CVelMod vm;
		//vm.velModSetArrays(&velMod);
	}

	velMod.flFloatName = getSecNameRevised(velMod.flFloatName, seiFilePath);
	digMarker.digName = getSecNameRevised(digMarker.digName, seiFilePath);
	draw.txRaytraceName = getSecNameRevised(draw.txRaytraceName, seiFilePath);
	dig.digName = getSecNameRevised(dig.digName, seiFilePath);
	bmp24.bmpName = getSecNameRevised(bmp24.bmpName, seiFilePath);
	//	draw.velSecNamesEx = getSecNameRevised(draw.velSecNamesEx, seiFilePath);
	// cannot do this properly, so I disable it.

	if (draw.logScaleThreshold < 0 || draw.logScaleThreshold > 100) draw.logScaleThreshold = 70;

	//The following must be reset every time a SEI file is read in.
	draw.TTCurveColor = 4;
	draw.isPrintingW = FALSE;

	if (isnan(draw.distShift) || fabs(draw.distShift) > 99999.) draw.distShift = 0.f;  // sometimes older SEI files have invalid draw.distShift value
	// When opening an older version of .SEI file, some variables are invalid, so we fix them here:
	//if (_isnan(draw.distShift) || fabs(draw.distShift) > 99999.)
	//	draw.distShift = 0.;

	if (pFrame->statMain.bigNodes < 1) pFrame->statMain.bigNodes = 1;
	pFrame->statMain.move = 0;
	pFrame->statMain.remove = 0;
	pFrame->statMain.add = 0;
	pFrame->statMain.pick = 1;
	//pFrame->statMain.pickOld = 0;
	if (cd.coord.isSwapX) pFrame->statMain.isSwapXActive = 1;
	tx.circleCurve = -1;  // this means no circle display
	close_unused_documents(this);

//	draw.isNodeChanged = TRUE;
	this->SetTitle(seiFilePath);

	return TRUE;
}

void CSeisWideDoc::OnDisplaytuneOverwritexlabel()
{
	CdlgLabelOverwrite dlg;
	dlg.m_xLabelNew = (draw.strXLabelOverwrite.IsEmpty()) ? BLANK : draw.strXLabelOverwrite;
	dlg.m_yLabelNew = (draw.strYLabelOverwrite.IsEmpty()) ? BLANK : draw.strYLabelOverwrite;
	if (dlg.DoModal()) {
		draw.strXLabelOverwrite = dlg.m_xLabelNew;
		draw.strYLabelOverwrite = dlg.m_yLabelNew;
		draw.isSameDataDisplay = FALSE; //indicate display has NOT been changed and do not re-load all data in OnDraw().
		SetModifiedFlag();
		UpdateAllViews(NULL);
		NotifyChanged();
	}
}



void CSeisWideDoc::OnModelingDisplaycircle()
{
	if (!cd.coord.isTimeDomain()) return;
	tx.circleCurve++;
	draw.isSameDataDisplay = TRUE;
	UpdateAllViews(NULL);
	//NotifyChanged();
}


void CSeisWideDoc::OnProcessingDatadespike()
{
	long i;
	CString inFile = BLANK, outFile = BLANK;
	static int trace1 = 0;
	static int trace2 = 99999;

	static BOOL isLTZ = FALSE;
	static float ftlength = 0.07f;  // sliding time window size
	static float fgw = 0.14f;  // maximum tolerance of zero-crossings in terms of number of samples. amplitudes will be trimmed if trZ[z+1] > trZ[z]+gw

	static BOOL isSpikeZeroing = TRUE;
	static float tlag = 0.04f;
	static float dac = 2.f;

	// AfxMessageBox(_T("After Trehu/Sutton: Marine Gephysical Researches 16: 91-103, 1994. Spikes are defined by |a[2]-a[1]| + |a[2]-a[3]| > fac * (|a[0]-a[1]| + |a[3]-a[4]|). If spike condition is met, replace a[2] with (a[1]+a[3])/2.");

	segy tr;  // for reading all kind of traces
	segy tr2;  // for output 

	bhed bh;

	CdlgDespiking dlg;
	dlg.m_inFile = draw.timeSecName;
	dlg.m_outFile = getFileNameAppend(draw.timeSecName, _T("Despike"));
	dlg.m_trace1 = trace1;
	dlg.m_trace2 = trace2;
	dlg.m_tlength = ftlength;
	dlg.m_gw = fgw;
	dlg.m_isLTZ = isLTZ;
	dlg.m_isSpikeZeroing = isSpikeZeroing;
	dlg.m_tlag = tlag;
	dlg.m_dac = dac;
	if (dlg.DoModal() == IDOK) {
		inFile = dlg.m_inFile;
		outFile = dlg.m_outFile;
		trace1 = dlg.m_trace1;
		trace2 = dlg.m_trace2;
		if (trace2 == trace1) {
			trace1 = 0;
			trace2 = 99999;
		}
		ftlength = dlg.m_tlength;
		fgw = dlg.m_gw;
		isLTZ = dlg.m_isLTZ;
		isSpikeZeroing = dlg.m_isSpikeZeroing;
		tlag = dlg.m_tlag;
		dac = dlg.m_dac;
	}
	else {
		return;
	}

	if (!isFileExistNotDirectory(inFile)) return;
	if (outFile == BLANK) return;
	if (outFile == inFile) {
		AfxMessageBox(_T("Output file name is the same as the input file name!"));
		return;
	}
	CFile file;
	if (!file.Open(inFile, CFile::modeRead | CFile::typeBinary | CFile::shareDenyNone)) {
		AfxMessageBox(_T("Input time section cannot be read."));
		return;
	}
	outFile = SetFileExtension(outFile, _T("sgy"));

	//put the path onto file2 if it doesn't have it.
	int pathLen = outFile.ReverseFind('\\');
	if (pathLen == (-1))
	{
		TCHAR curDir[_MAX_PATH];
		GetCurrentDirectory(_MAX_PATH, curDir);
		//outFile = (CString)curDir + _T("\\" + outFile;
		outFile.Format(_T("%s\\%s"), (CString)curDir, outFile);
	}


	//For progress control, need to know the last bytes no.
	ULONGLONG curBytesRead, totBytesRead = file.GetLength();
	file.Seek(0, CFile::begin);
	//Begin progress control.
	CMainFrame* pFrame =
		(CMainFrame*)AfxGetMainWnd();
	ASSERT(pFrame);
	ASSERT_KINDOF(CMainFrame, pFrame);
	pFrame->BeginProgress();


	UINT bytesRead = file.Read(head.ascHead, 3200L);
	if (bytesRead < 3200) {
		file.Close();
		AfxMessageBox(_T("Ascii section header read wrong"));
		return;
	}
	bytesRead = file.Read(&bh, 400L);
	if (bytesRead < 400) {
		file.Close();
		AfxMessageBox(_T("Binary section header read wrong"));
		return;
	}
	//The following numbers have to be recalculated everytime,
	//because plotting the depth section will change these numbers.
	int numsamp = bh.hns; // (unsigned short)i2buf[10];
	int len = bh.getTraceLenBytes();
	long headLenOut = numsamp * 4 + 240;  // output in floating point only


	CFile file2;
	if (!file2.Open(outFile, CFile::modeWrite | CFile::modeCreate | CFile::typeBinary)) {
		file.Close();
		return;
	}

	file2.Write(head.ascHead, 3200L);
	int formatOrig = bh.format; // original data format
	bh.format = 1;  // always output in floating format
	file2.Write(&bh, 400L);

	ULONGLONG byteFileEnd = file.SeekToEnd();
	file.Seek(3600L, CFile::begin);

	// for storing adjacent traces
	segydynamic trPrev; // for storing the previous trace
	trPrev.tracl = -99999; // markup for invalid trace
	trPrev.data = (float *)ealloc1float(numsamp);
	if (bh.hdt == 0) bh.hdt = bh.dto;
	double dt = (double)bh.hdt / (double)MIL;
	double odt = 1. / dt;

	segydynamic trAvg; // averaged trace for a small sliding time window of tlength samples
	segydynamic trZ;   // for store times for zero-crossings of trAvg[]
	trAvg.data = (float *)ealloc1float(numsamp);
	trZ.data = (float *)ealloc1float(numsamp);


	while (file.Read(&tr, len) == (UINT)len) {
		// trace1 and trace are already re-conditioned properly
		if (tr.tracl < trace1 || tr.tracl > trace2) continue;

		if (tr.trid == 2) //dead traces.
		{
			continue;
		}
		/* data sample format code:
		1 = floating point (4 bytes)
		2 = fixed point (4 bytes)     long
		3 = fixed point (2 bytes)     short
		4 = fixed point w/gain code (4 bytes) */

		if (formatOrig == 1) {	 // float data
			ibm_to_float((int *)tr.dat.data, (int *)tr.dat.data, (int)numsamp);
			for (i = 0; i < numsamp; i++)
				tr2.dat.data[i] = (float)(tr.dat.data[i]);
		}
		else if (formatOrig == 2) {
			for (i = 0; i < numsamp; i++)
				tr2.dat.data[i] = (float)(tr.dat.dataint[i]);
		}
		else if (formatOrig == 3) {	// short int data
			for (i = 0; i < numsamp; i++)
				tr2.dat.data[i] = (float)(tr.dat.datashort[i]);
		}
		else if (formatOrig == 5) {	 // float data
			for (i = 0; i < numsamp; i++)
				tr2.dat.data[i] = (float)(tr.dat.data[i]);
		}
		else {
			if (file) file.Close();
			if (file2) file2.Close();
			free1float(trPrev.data);
			AfxMessageBox(_T("Unknown Data format"));
			return;
		}
		memcpy((void *)&tr2, (void *)&tr, 240);

		// backup the tr2 data to tr.data before overwriting it soon.
		memcpy((void *)&tr.dat.data[0], (void *)&tr2.dat.data[0], numsamp * 4);


		// debias first
		double sum = 0.;
		for (i = 0; i < numsamp; i++)
			sum += (double)(tr2.dat.data[i]);
		float mean = (float)(sum / (double)numsamp);
		for (i = 0; i < numsamp; i++)
			tr2.dat.data[i] = tr2.dat.data[i] - mean;
		// filterTimeDomain(&tr2.dat.data[0], numsamp,1.f, -1.f, bh.hdt);

		if (isLTZ) {
			int tlength = (int)ceil(ftlength * odt) + 1;  // sliding time window size
			int gw = (int)myRound(fgw * odt);  // maximum tolerance of zero-crossings in terms of number of samples. amplitudes will be trimmed if trZ[z+1] > trZ[z]+gw
			memset((void *)trAvg.data, (int) '\0', sizeof(float)*numsamp);
			int it;
			int ihtlength = tlength / 2; if (ihtlength < 1) ihtlength = 1;
			for (i = 0; i < numsamp; i++) {
				for (it = i - tlength / 2; it <= i + tlength / 2; it++) {
					if (it >= 0 && it < numsamp)
						trAvg.data[i] += tr2.dat.data[it];
				} // for it
			} // for i

			//memset((void *) trZ.data, (int) '\0', sizeof(float)*numsamp);
			int nz = 0; // number of zero crossings
			for (i = 0; i < numsamp - 1; i++) {
				if (!SAME_SIGN(trAvg.data[i], trAvg.data[i + 1])) {
					trZ.data[nz] = (float)i;
					nz++;
				} // if
			} // for i

			// trZ.data[0:nz-1] now indicates the index where sign changes occurs
			for (int z = 0; z < nz - 1; z++) {
				if ((int)(trZ.data[z + 1] - trZ.data[z]) >= gw) {
					for (i = (int)trZ.data[z] + 1; i <= (int)trZ.data[z + 1]; i++) {
						tr2.dat.data[i] = 0.f;
					} // for i
				} // if
			} // for z
		} // if isLTZ






		if (isSpikeZeroing) {
			// we reuse 2 arrays:  trAvg.data[]   and   trZ.data[]
			memset((void *)trAvg.data, (int) '\0', sizeof(float)*numsamp);
			memset((void *)trZ.data, (int) '\0', sizeof(float)*numsamp);
			int numSum;
			int ntlag = (int)ceil(tlag * odt) + 1;  // sliding time window size
			for (i = 0; i < numsamp; i++) {

				numSum = 0;
				for (int t = i - 2 * ntlag; t < i - ntlag; t++) {
					if (t >= 0) {
						trAvg.data[i] += (float)fabs(tr2.dat.data[t]);
						numSum++;
					}
				} // for t
				if (numSum > 1) trAvg.data[i] /= (float)numSum;

				numSum = 0;
				for (int t = i + ntlag; t < i + 2 * ntlag; t++) {
					if (t < numsamp) {
						trZ.data[i] += (float)fabs(tr2.dat.data[t]);
						numSum++;
					}
				} // for t
				if (numSum > 1) trZ.data[i] /= (float)numSum;
			} // for i
			for (i = 0; i<numsamp; i++) {
				float amp = (float)fabs(tr2.dat.data[i]);

				if (amp > dac*trAvg.data[i] && amp > dac*trZ.data[i]) {
					// now we make a last comparision with the previous trace
					float maxPrev = 0.f;
					int j;
					if (trPrev.tracl != -99999) {
						for (j = i - ntlag; j < i + ntlag; j++) {
							if (j >= 0 && j < numsamp && maxPrev < fabs(trPrev.data[j]))
								maxPrev = (float)fabs(trPrev.data[j]);
						} // for j
					} // if
					if (amp > dac*maxPrev) {
						// now it is decided we want to zero the sample at i and around it!
						amp = tr2.dat.data[i]; // backup first before zeroing
						tr2.dat.data[i] = 0.f; // spike zeroing
						for (j = i - 1; j >= 0; j--) {
							if (SAME_SIGN(amp, tr2.dat.data[j]))
								tr2.dat.data[j] = 0.f;
							else break;
						}
						for (j = i + 1; j < numsamp; j++) {
							if (SAME_SIGN(amp, tr2.dat.data[j]))
								tr2.dat.data[j] = 0.f;
							else
								break;
						} // for j
					} // if a
				} // if 
			} // for i

			// now process tr2.data[]
			// Spikes are defined by |a[2]-a[1]| + |a[2]-a[3]| > fac * (|a[0]-a[1]| + |a[3]-a[4]|). 
			// If spike condition is met, replace a[2] with (a[1]+a[3])/2.;
			//for (i=2; i<numsamp-2; i++) {
			//	bool isSpike =
			//		fabs(tr2.dat.data[i]-tr2.dat.data[i-1]) + fabs(tr2.dat.data[i]-tr2.dat.data[i+1]) > dac *
			//		(fabs(tr2.dat.data[i-2]-tr2.dat.data[i-1]) + fabs(tr2.dat.data[i+1]-tr2.dat.data[i+2]));
			//	if (isSpike)
			//		tr2.dat.data[i] = (tr2.dat.data[i-1]+tr2.dat.data[i+1]) * 0.5f;
			//}
		} // if isSpikeZeroing

		tr2.ns = (unsigned short)numsamp;
		
		// assign segy arrays for later usage
		memcpy((void *)&trPrev, (void *)&tr2, 240);
		memcpy((void *)&trPrev.data[0], (void *)&tr.dat.data[0], numsamp * 4);


		if (bh.format == 1) {
			float_to_ibm((int *)tr2.dat.data, (int *)tr2.dat.data, (int)tr2.ns);
		}
		file2.Write(&tr2, headLenOut);



		// progress control. Do not change
		curBytesRead = file.Seek(0, CFile::current);
		int iPos = (int)((double)curBytesRead / (double)totBytesRead*100.);
		if (iPos < 0)iPos = 0;
		if (iPos > 100)iPos = 100;
		pFrame->SetProgress(iPos);
	}	// while


	free1float(trPrev.data);
	free1float(trAvg.data);
	free1float(trZ.data);
	if (file) file.Close();
	if (file2) file2.Close();
	if (pFrame) {
		pFrame->EndProgress();
	}
	draw.timeSecName = outFile;
	//		draw.timeSecOld = BLANK;
	OnToolbarRefreshAll();
}


void CSeisWideDoc::OnToolbarPlus()
{
	CMainFrame* pFrame =
		(CMainFrame*)AfxGetMainWnd();
	ASSERT(pFrame);
	ASSERT_KINDOF(CMainFrame, pFrame);

	pFrame->statMain.fLabelDistance3 *= 1.2f;
	if (pFrame->statMain.fLabelDistance3 > 3.f)
		pFrame->statMain.fLabelDistance3 = 3.f;


	pFrame->statMain.thicknessLines *= 1.5f;
	if (pFrame->statMain.thicknessLines > 3.f)
		pFrame->statMain.thicknessLines = 3.f;


	pFrame->statMain.bigNodes++;
	if (pFrame->statMain.bigNodes > 3) pFrame->statMain.bigNodes = 3;

	draw.isNodeChanged = TRUE;
	UpdateAllViews(NULL);
	myUpdateAllFramesExcept(this);
	//if (pFrame->pViewPrev != NULL) {
	//	// ( (CSeisWideDoc *)pFrame->pDocPrev )->draw.thicknessLines *= 2.f;
	//	this->myUpdatePrevFrame();
	//}

}

void CSeisWideDoc::OnToolbarMinus()
{
	CMainFrame* pFrame =
		(CMainFrame*)AfxGetMainWnd();
	ASSERT(pFrame);
	ASSERT_KINDOF(CMainFrame, pFrame);
	// float xyRatio = (float)pFrame->myLabelNumberHeight / (float)pFrame->myLabelNumberWidth;
	pFrame->statMain.fLabelDistance3 *= 0.667f;
	if (pFrame->statMain.fLabelDistance3 < 0.2f)
		pFrame->statMain.fLabelDistance3 = 0.2f;


	pFrame->statMain.thicknessLines *= 0.667f;
	if (pFrame->statMain.thicknessLines < 0.5f)
		pFrame->statMain.thicknessLines = 0.5f;

	pFrame->statMain.bigNodes--;
	if (pFrame->statMain.bigNodes < 1) pFrame->statMain.bigNodes = 1;

	draw.isNodeChanged = TRUE;
	UpdateAllViews(NULL);

	if (pFrame->pViewPrev != NULL) {
		this->myUpdatePrevFrame();
	}

}

void CSeisWideDoc::OnModelingDumpcmpTwttOld()
{
	long icont;
	if (!velMod.isModelVisible(&cd.coord, 0.)) {
		AfxMessageBox(_T("Please display the model before dumping model values."));
		return;
	}

	FILE *stream;
	CString outName = getSystemTempPathSlash() + _T(".tmpSeisWideModelDump.txt");
	if (_tfopen_s(&stream, outName, _T("w+")) != 0)
	{
		AfxMessageBox(_T("Could not open a temporary file"));
		return;
	}

	CVelMod vm;
	CVelMod::VELMOD_X modX;
	velMod.m_isConvert = true;

	// calculate the proper label to output
	CString strNameLineSB;
	if (isFileExistNotDirectory(draw.timeSecName)) {
		strNameLineSB = draw.timeSecName;
	} // if
	else {
		strNameLineSB = velMod.velSecName;
	}

	int pathLen = strNameLineSB.ReverseFind('.');
	if (pathLen > (-1)) {
		strNameLineSB.Format(_T("%s"), strNameLineSB.Left(pathLen));
		pathLen = strNameLineSB.ReverseFind('\\');
		if (pathLen > (-1))
			strNameLineSB.Format(_T("%s"), strNameLineSB.Mid(pathLen + 1));
	}

	if (!cd.coord.isTimeDomain())
		vm.myModel_Depth2TWTT(&velMod, velColor.dz);

	float x = velMod.xm[0][0]; // xmin in model
	_ftprintf_s(stream, _T("#2D Model dump to overlay onto reflection profile. \n#LineName,        cmp,dpth(km),twtt(s),v_int(km/s),x(km)\n"));
	while (x <= velMod.xm[velMod.nzed[0] - 1][0]) {
		modX.dist = x;
		vm.initModX(&velMod, &modX, cd.coord.isTimeDomain() == TRUE, true, velColor.dz);
		// vm.getTModFromZMod(&modX, velColor.dz);

		// calculate CMP for x
		float aCmp = 0.f;
		for (int i = 0; i<head.numTraces - 1; i++) {
			if (x >= head.dist[i] && x <= head.dist[i + 1]) {
				if (head.dist[i + 1] - head.dist[i] != 0.f)
					aCmp = head.cdp[i] + (head.cdp[i + 1] - head.cdp[i])* (x - head.dist[i]) / (head.dist[i + 1] - head.dist[i]);
				else
					aCmp = (float)head.cdp[i];
				break;
			} // if
		} // for i
		CString strInterpol = BLANK;
		if (myRound(aCmp) == 0) {
			// we need a fix if the segy file does not extend to the full model.
			if (head.numTraces >= 2 &&
				(x > head.dist[head.numTraces - 1] || x < head.dist[0])
				) {
				// we interpolate
				if (head.dist[head.numTraces - 1] - head.dist[head.numTraces - 2] != 0.f)
					aCmp = head.cdp[head.numTraces - 2] + (head.cdp[head.numTraces - 1] - head.cdp[head.numTraces - 2])* (x - head.dist[head.numTraces - 2]) / (head.dist[head.numTraces - 1] - head.dist[head.numTraces - 2]);
				else
					aCmp = (float)head.cdp[head.numTraces - 2];
				strInterpol = _T("CMP_interpolated");
			} // if
		} // if

		// now print out the results
		for (icont = 0; icont < velMod.ncont - 1; icont++) {
			if (aCmp > 0.f) {
				double d1 = modX.depthMod[icont];
				double d2 = modX.depthMod[icont + 1];
				if (icont > 0) d1 += 0.01;
				if (icont < velMod.ncont - 1 - 1) d2 -= 0.01;

				double t1 = modX.timeMod[icont];
				double t2 = modX.timeMod[icont + 1];
				if (icont > 0) t1 += 0.03;
				if (icont < velMod.ncont - 1 - 1) t2 -= 0.03;

				// it turns out
				if (d2 >= d1 + 0.02) {
					_ftprintf_s(stream, _T("%14s %6d  %6.3f  %6.3f %6.3f %8.3f %s\n"), (LPCTSTR)strNameLineSB, (int)myRound(aCmp), d1, t1, modX.vTop[icont], x, (LPCTSTR)strInterpol);
					_ftprintf_s(stream, _T("%14s %6d  %6.3f  %6.3f %6.3f %8.3f %s\n"), (LPCTSTR)strNameLineSB, (int)myRound(aCmp), d2, t2, modX.vBot[icont], x, (LPCTSTR)strInterpol);
				}
				else {
					_ftprintf_s(stream, _T("%14s %6d  %6.3f  %6.3f %6.3f %8.3f %s\n"), (LPCTSTR)strNameLineSB, (int)myRound(aCmp), modX.depthMod[icont], modX.timeMod[icont], modX.vTop[icont], x, (LPCTSTR)strInterpol);
				}
				//_ftprintf_s(stream,"%14s %6d  %6.3f  %6.3f %6.3f %8.3f %s\n",strNameLineSB, (int)myRound(aCmp), depth[icont], twttMod[icont], vTop[icont], x, strInterpol);
				//_ftprintf_s(stream,"%14s %6d  %6.3f  %6.3f %6.3f %8.3f %s\n",strNameLineSB, (int)myRound(aCmp), depth[icont+1], twttMod[icont+1],  vBot[icont], x, strInterpol);

				// but John wanted "interval velocity" outputs, so there is change below:
				//_ftprintf_s(stream,"%14s %6d  %6.3f  %6.3f %6.3f %8.3f %s\n",strNameLineSB, (int)myRound(aCmp), depth[icont], twttMod[icont], (vTop[icont]+vBot[icont])*0.5f, x, strInterpol);
			}
		}
		x = getModelPointNext(x);
	} // while

	if (stream != NULL) fclose(stream);
	showFileInNotePad(outName);
}


void CSeisWideDoc::OnModelingDumpcmpTwtt()
{
	int icont;
	int i, i2;
	if (!velMod.isModelVisible(&cd.coord, 0.) && draw.velSecNamesEx.IsEmpty()) {
		AfxMessageBox(_T("Please display the model before dumping model values."));
		return;
	}

	CString fSection = cd.coord.isTimeDomain() ? draw.timeSecName : draw.depthSecName;
	CString aPath = getWorkingPathSlash();
	setCurrentPathAs(aPath); // we need to set the current path since velms can use relative path
	fSection = getPathAbs(fSection, aPath);  // make it absolute path so that color pallete file can be properly obtained
	CSegyMeta::segyHeadInit(fSection, &head);

	if (!isFileExistNotDirectory(fSection)) {
		AfxMessageBox(_T("Data segy does not exist."));
		return;
	}

	CString tStr;





	// find a CDP jump
	i2 = -1;
	for (i = 1; i < head.numTraces - 1; i++) {
		if (head.cdp[i] != head.cdp[i - 1] + 1) {
			i2 = i;
			break;
		}
	}

	int ntrc = head.numTraces - 1;
	if (i2 < 0) {
		// the section is continuous in CDP
		tStr.Format(_T("_CDP(FFID)_%d(%d)-%d(%d)"), head.cdp[0], head.ffid[0], head.cdp[ntrc], head.ffid[ntrc]);
	}
	else {
		// the section is NOT continuous in CDP
		tStr.Format(_T("_CDP(FFID)_%d(%d)-%d(%d)-%d(%d)-%d(%d)"),
			head.cdp[0], head.ffid[0],
			head.cdp[i2 - 1], head.ffid[i2 - 1],
			head.cdp[i2], head.ffid[i2],
			head.cdp[ntrc], head.ffid[ntrc]);
	}

	aPath = GetPathFromFileSlash(fSection);
	CString outNameVint = aPath + GetBaseFileName(fSection) + _T("_claritas.Vint.nmo") + tStr;
	CString outNameVavg = aPath + GetBaseFileName(fSection) + _T("_claritas.Vavg.nmo") + tStr;
	FILE *streamVint, *streamVavg;
	if (_tfopen_s(&streamVint, outNameVint, _T("w")) != 0) {
		AfxMessageBox(_T("The new velocity file cannot open."));
		return;
	}
	if (_tfopen_s(&streamVavg, outNameVavg, _T("w")) != 0) {
		fclose(streamVint);
		AfxMessageBox(_T("The new velocity file cannot open."));
		return;
	}

	tStr.Format(_T("NMO\n")); 
	_ftprintf_s(streamVavg, tStr);
	_ftprintf_s(streamVint, tStr);

	tStr.Format(_T("PRIMARY KEY : CDP\n"));
	_ftprintf_s(streamVavg, tStr);
	_ftprintf_s(streamVint, tStr);

	tStr.Format(_T("SECONDARY KEY : ???\n"));
	_ftprintf_s(streamVavg, tStr);
	_ftprintf_s(streamVint, tStr);

	tStr.Format(_T("INTERPOLATION KEY : Interpolate/End\n"));
	_ftprintf_s(streamVavg, tStr);
	_ftprintf_s(streamVint, tStr);



	tStr.Format(_T("Created:isovels Wed Oct. 4 08:53:29 2017\n"));
	_ftprintf_s(streamVavg, tStr);
	_ftprintf_s(streamVint, tStr);

	tStr.Format(_T("|KEYVAL|{T1     |V1}     |{T2     |V2}     |{T3     |V3}     |{T4     |V4}...  |\n"));
	_ftprintf_s(streamVavg, tStr);
	_ftprintf_s(streamVint, tStr);

	tStr.Format(_T("\n"));
	_ftprintf_s(streamVavg, tStr);
	_ftprintf_s(streamVint, tStr);

	CVelMod vm;
	if (!cd.coord.isTimeDomain())
		vm.myModel_Depth2TWTT(&velMod, velColor.dz);
	else
		vm.myModel_TWTT2Depth(&velMod, velColor.dz);

	CVelMod::VELMOD_X modX;
	CVelMod::VELMOD_X modX2;
	CVelMod::VELMOD_X modX_Interpol;
	CVelMod::VELMODS velms;
	vm.loadInitVel(&velms, draw.velSecNamesEx, velColor.dz);

	double range;
	for (i = 0; i<head.numTraces - 1; i++) {
		range = head.dist[i] + draw.distShift;  //range here is actually distance.
		modX.dist = range;
		if (!vm.initModX(&velMod, &velms, &modX, &modX2, range, cd.coord.isTimeDomain(), true, velColor.dz)) continue;
		if (modX.ncont == 0 && modX2.ncont > 0) modX2.cloneTo(&modX);

		if (modX.dist == modX2.dist || (modX.ncont>0 && modX2.ncont==0)) {
			// only use the first modX
			modX.cloneTo(&modX_Interpol);
		}
		else if (modX.ncont > 0 && modX2.ncont > 0) {
			// use both modX and modX2
			modX_Interpol.interpol(&modX, &modX2, range);
		}
		else {
			continue; // skip this trace
		}


		// now writeout the numbers for modX_Interpol
/*
120    20       1470     40       1470     60       1470     80       1470
       100      1470     120      1470     140      1470     160      1470
       180      1470     200      1470     220      1470     240      1470
...
       11300    4500     11320    4500     11340    4500     11360    4500
       11380    4500     11400    4500
140    20       1470     40       1470     60       1470     80       1470
       100      1470     120      1470     140      1470     160      1470
...
*/
		register double t;
		register double v;
		int j, j1, j2;
		j1 = 0;
		j2 = 1;
		register bool isFinishedForCDP = false;
		for (icont = 0; icont < modX_Interpol.ncont-2; icont++) {
			if (j2 > modX_Interpol.ncont - 1) j2 = modX_Interpol.ncont - 1;
			if (j2 < j1) break;
			if (j1 == 0) {
				_ftprintf_s(streamVavg, _T(" %-7d"), head.cdp[i]);
				_ftprintf_s(streamVint, _T(" %-7d"), head.cdp[i]);
			}
			else {
				_ftprintf_s(streamVavg, _T("        "));
				_ftprintf_s(streamVint, _T("        "));
			}

			for (j = j1; j <= j2; j++) {
				t = modX_Interpol.timeMod[j]; if (j > 0) t += 0.005;
				v = modX_Interpol.vTop[j];
				if (v < 0.00001) {
					isFinishedForCDP = true;
					break;
				}
				_ftprintf_s(streamVint, _T("%-9d%-9d"), (int)(t * 1000.), (int)(v * 1000.));

				t = modX_Interpol.timeMod[j + 1]; t -= 0.005;
				v = modX_Interpol.vBot[j];
				_ftprintf_s(streamVint, _T("%-9d%-9d"), (int)(t * 1000.), (int)(v * 1000.));
			}
			_ftprintf_s(streamVint, _T("\n"));

			//if (head.cmp[i] == 7287) {
			//	int sdf = 1;
			//}
			for (j = j1; j <= j2; j++) {
				t = modX_Interpol.timeMod[j]; 
				v = (j==0) ? modX_Interpol.vTop[j] : 2. * modX_Interpol.depthMod[j] / t;
				if (v < 0.00001) {
					isFinishedForCDP = true;
					break;
				}
				if (j > 0) t += 0.005;
				_ftprintf_s(streamVavg, _T("%-9d%-9d"), (int)(t * 1000.), (int)(v * 1000.));

				t = modX_Interpol.timeMod[j + 1]; 
				if (t <= 0.) {
					isFinishedForCDP = true;
					break;
				}
				v = 2. * modX_Interpol.depthMod[j + 1] / t;
				t -= 0.005;
				_ftprintf_s(streamVavg, _T("%-9d%-9d"), (int)(t * 1000.), (int)(v * 1000.));
			}
			_ftprintf_s(streamVavg, _T("\n"));

			if (isFinishedForCDP || t >= 10. || modX_Interpol.vBot[j2] >=8.) break;

			j1 += 2;
			j2 += 2;
		} // for icont

	} // for i, traces
	fclose(streamVavg);
	fclose(streamVint);

	AfxMessageBox(_T("Success generating velocity and time pairs in Claritas formats. See .Vint.nmo and .Vavg.nmo files in the same directory."), MB_ICONQUESTION);

}

// get next model control point after the xCurrent along the X-axis
// if the next point is beyond the model max limit, returns 99999.f
float CSeisWideDoc::getModelPointNext(float xCurrent)
{
	int j;
	int icont;
	float x = velMod.xm[velMod.nzed[0] - 1][0];  // the maximum model boundary in X axis
	if (isFloatEqual(x, xCurrent)) return 99999.f; // meaning already going beyond the model max limit

	for (icont = 0; icont < velMod.ncont; icont++)
	{
		for (j = 0; j < velMod.nzed[icont] - 1; j++)
		{
			if (xCurrent >= velMod.xm[j][icont] && xCurrent < velMod.xm[j + 1][icont]) {
				// found the next point for the current boundary
				x = MIN(x, velMod.xm[j + 1][icont]);
				break;
			}
		}  // for j
	} // for icont


	return x;
}

void CSeisWideDoc::OnProcessingDumpsegylatlong()
{
	short nf = 0;
	CString inFileName, inFileNames[999], logFileName;

	//Open file dialog.
	CFileDialog dlg(TRUE, _T("sgy; SEG"), _T("*.sgy"),
		OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT | OFN_ALLOWMULTISELECT | OFN_EXPLORER,
		_T("Input Segy Files (*.sgy)|*.sgy|"));
	TCHAR* buff = (TCHAR*)alloc1(65535, sizeof(TCHAR));

	buff[0] = '\0';
	dlg.m_ofn.lpstrTitle = _T("Select all segy files for dumping lat/lons");
	dlg.m_ofn.lpstrFile = buff;
	dlg.m_ofn.nMaxFile = 65535;//sizeof(buff);


	POSITION Position;

	if (dlg.DoModal() == IDOK) {
		Position = dlg.GetStartPosition();
		while (Position) {
			inFileName = dlg.GetNextPathName(Position);
			if (!inFileName.IsEmpty()) {
				inFileNames[nf] = inFileName;
				nf++;
			}
		}
		delete dlg;

	} //end dlg.DoModal function.
	else {
		free1(buff);
		delete dlg;
		return;
	}

	free1(buff);

	// If data numbers exceed max, just change this number
	int MAX_FILES = 999;
	if (nf > MAX_FILES) {
		AfxMessageBox(_T("Maximum number of files selected is exceeded."));
		return;
	}

	//now reorganize these files sequentially, alphabetically.
	int n;
	CString t;
	for (n = 0; n < nf - 1; n++) {
		for (int i = n + 1; i<nf; i++) {
			if (inFileNames[n]>inFileNames[i]) {
				t = inFileNames[i];
				inFileNames[i] = inFileNames[n];
				inFileNames[n] = t;
			}
		}
	}




	int totShot;
	bhed bh;
	segy tr;

	ULONGLONG bytesRead;
	int iPos;
	TCHAR s[80];
	BOOL isUnix = false;



	//###############initilize output file pointer###################
	if ((n = inFileNames[0].GetLength()) > 4) {
		logFileName = GetFileNameAppendExt(inFileNames[0], _T("Latlon"), _T("log"));

		int pathLen = inFileNames[0].ReverseFind('\\');
		if (pathLen > 2)
			SetCurrentDirectory(inFileNames[0].Left(pathLen));
	}
	else {
		logFileName = _T("Latlon.log");
	}

	FILE *log;
	if (_tfopen_s(&log, logFileName, _T("w")) != 0) {
		AfxMessageBox(_T("Cannot open log file to write."));
		return;
	}
	_ftprintf_s(log, _T("#Dump of all the lat lons for every Trace in many segy files, for gmt plotting\n"));


	//Begin progress control.
	CMainFrame* pFrame =
		(CMainFrame*)AfxGetMainWnd();
	ASSERT(pFrame);
	ASSERT_KINDOF(CMainFrame, pFrame);
	pFrame->BeginProgress();


	//###############loop thru the input files ###################
	totShot = 0;
	//double lat;
	//double lon;
	double div360 = 1. / 360000.;
//	double divMil = 1. / MIL;

	for (n = 0; n < nf; n++) {
		// curBytesRead = file2.Seek(0, CFile::current);
		iPos = (int)((double)n / (double)nf*100.);
		if (iPos < 0)iPos = 0;
		if (iPos > 100)iPos = 100;
		pFrame->SetProgress(iPos);


		if (!isFileExistNotDirectory(inFileNames[n])) continue;
		CFile file;
		if (!file.Open(inFileNames[n], CFile::modeRead | CFile::typeBinary | CFile::shareDenyNone)) {
			continue;
		}

		// first, we processs the tape headers
		bytesRead = file.Read(head.ascHead, 3200L);
		if (bytesRead < 3200) {
			AfxMessageBox(_T("Ascii section header read wrong: ") + inFileNames[n]);
			file.Close();
			continue;  // skip this file and continue to the next file
		}
		// ebc2asc(head.ascHead, 3200);
		_ftprintf_s(log, _T("> %s\n"), (LPCTSTR)inFileNames[n]);
		bytesRead = file.Read(&bh, 400L);
		if (isUnix = IsUnix(bh.format)) SwapTapeHeader(&bh);
		if (bytesRead < 400 || !IsFormatValid(bh.format)) {
			// AfxMessageBox(_T("Binary section header read wrong");
			file.Close();
			continue;  // skip this file and continue to the next file
		}

		// get some parameters from the tape header: note: every file can be different!
		int len = (bh.format == 3) ? (2 * bh.hns) : 4 * bh.hns;

		// we now process the trace data
		while (file.Read(&tr, 240) == (UINT)240) {
			if (isUnix) {
				SwapTraceHeader(false, false, false, &tr);
				// SwapN(&tr, bh.format);
			}
			tr.tracl = totShot + 1;

			register double divFactor = 1.;
			if (tr.counit == 2) divFactor = div360;
			else if (tr.counit == 0) divFactor = OMIL;
			register double lon = tr.gx * divFactor;  
			// if (lon > 180.f) lon -= 360.; // this cause error with UTM
			register double lat = tr.gy * divFactor;
			_ftprintf_s(log, _T("%8.6f %8.6f\n"), lon, lat);
			file.Seek(len, CFile::current);
			totShot++;
		}
		file.Close();
	}
	pFrame->EndProgress();

	if (totShot > 0) {
		//	file2.Seek(3212L, CFile::begin);
		//	file2.Write(&totShot, 2);
		_stprintf_s(s, _T("Success! A total of %d traces processed"), totShot);
		AfxMessageBox(s);
	}
	else
		AfxMessageBox(_T("Not even one trace appended!"));

	fclose(log);
	showFileInNotePad(logFileName);
}

void CSeisWideDoc::OnToolsDumplat()
{
	// Dump all lat/lon for many CTD files
	int nf = 0;
	CString inFileName, inFileNames[999];

	//Open file dialog.
	CFileDialog dlg(TRUE, _T("ctd"), _T("*.ctd"),
		OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT | OFN_ALLOWMULTISELECT | OFN_EXPLORER,
		_T("Input CTD-CNV (Sea-Bird SBE format) Files (*.cnv)|*.cnv|"));
	TCHAR* buff = (TCHAR*)alloc1(65535, sizeof(TCHAR));
	buff[0] = '\0';
	dlg.m_ofn.lpstrTitle = _T("Select all cnv files for dumping lat/lons");
	dlg.m_ofn.lpstrFile = buff;
	dlg.m_ofn.nMaxFile = 65535;//sizeof(buff);

	

	POSITION Position;

	if (dlg.DoModal() == IDOK) {
		Position = dlg.GetStartPosition();
		while (Position) {
			inFileName = dlg.GetNextPathName(Position);
			if (!inFileName.IsEmpty()) {
				inFileNames[nf] = inFileName;
				nf++;
			}
		}
		delete dlg;
	} //end dlg.DoModal function.
	else {
		free1(buff);
		delete dlg;
		return;
	}

	free1(buff);

	// If data numbers exceed max, just change this number
	int MAX_FILES = 999;
	if (nf > MAX_FILES) {
		AfxMessageBox(_T("Maximum number of files selected is exceeded."));
		return;
	}

	//now reorganize these files sequentially, alphabetically.
	int n;
	CString t, str;
	for (n = 0; n < nf - 1; n++) {
		for (int i = n + 1; i<nf; i++) {
			if (inFileNames[n]>inFileNames[i]) {
				t = inFileNames[i];
				inFileNames[i] = inFileNames[n];
				inFileNames[n] = t;
			}
		}
	}



	//###############initilize output file pointer###################
	//if ((n = inFileNames[0].GetLength()) > 4) {
	//	logFileName = GetFileNameAppendExt(inFileNames[0], _T("Latlon"), _T("log"));

	//	int pathLen = inFileNames[0].ReverseFind('\\');
	//	if (pathLen > 2)
	//		SetCurrentDirectory(inFileNames[0].Left(pathLen));
	//}
	//else {
	//	logFileName = _T("Latlon.log");
	//}
	//###############loop thru the input files ###################
	
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	int totFilesSuc = 0;
	double lat;
	double lon;
	double oneo60 = 1. / 60.;
	int ind;

	CStringArray *arrLog = new CStringArray();
	CStringArray *arrLogEx = new CStringArray();
	arrLog->Add(_T("#Dump of all the lat lons for many CTD files\n"));
	for (n = 0; n < nf; n++) {
		if (!isFileExistNotDirectory(inFileNames[n])) continue;
		// bool isEDF = GetFileExtension(inFileNames[n]) == _T("EDF");
		CString inFileNamePure = GetBaseFileName(inFileNames[n]);
		inFileNamePure.Replace(' ', '_');

		CStringArray *sArr = getLinesFromFile(inFileNames[n]);
		if (!sArr) {
			continue;
		}
		if (sArr->GetCount() < 22) {
			// no good
			sArr->RemoveAll();
			delete sArr;
			continue;
		}

		double zmaxDetected = 0.;

		// now read the lat/lon
		for (int r = 0; r < sArr->GetCount(); r++) {
			t = sArr->ElementAt(r);
			ind = t.Find(_T("Latitude"));
			if (ind >= 0) {
				// found it, like:    * NMEA Latitude = 70 30.08 N 
				// or like:       ** Latitude: 74 15.88 N 
				ind = t.Find(_T("=")); 
				if (ind<0) ind = t.Find(_T(":"));
				t = t.Mid(ind + 1).Trim();  // 70 30.08 N
				CStringArray *sArr2 = CString2LinesBySpace(t);
				if (sArr2->GetCount() >= 3) {
					lat = _tstoi(sArr2->ElementAt(0)) + _tstof(sArr2->ElementAt(1)) * oneo60;
				}
				sArr2->RemoveAll();
				delete sArr2;
				continue;
			}
			
			ind = t.Find(_T("Longitude"));
			if (ind >= 0) {
				// found it, like:    * NMEA Longitude = 140 00.01 W 
				// or like:      ** Longitude: 095 23.34 W 
				ind = t.Find(_T("="));
				if (ind<0) ind = t.Find(_T(":"));
				t = t.Mid(ind + 1).Trim();  // 140 00.01 W 
				CStringArray *sArr2 = CString2LinesBySpace(t);
				if (sArr2->GetCount() >= 3) {
					lon = _tstoi(sArr2->ElementAt(0)) + _tstof(sArr2->ElementAt(1)) * oneo60;
					if (sArr2->ElementAt(2) == 'W')
						lon = -lon;
				}
				sArr2->RemoveAll();
				delete sArr2;
			//	break;  // no more needed
			}

			// now read the V-Z profile
			ind = t.Find(_T("*END*"));
			if (ind == 0) {
				// now all the following lines contain the results. we need to parse the V-Z pairs
				double v, z;
				for (int rr = r+1; rr < sArr->GetCount(); rr++) {
					t = sArr->ElementAt(rr);
					CStringArray *sArr2 = CString2LinesBySpace(t);
					INT_PTR num = sArr2->GetCount();
					if (num > 24) {
						z = _tstof(sArr2->ElementAt(1)); // in m
						v = _tstof(sArr2->ElementAt(num - 3)); // in m/s
					}
					else if (num > 14) {
						z = _tstof(sArr2->ElementAt(2)); // in m
						v = _tstof(sArr2->ElementAt(num-2)); // in m/s
					}
					else if (num > 7) {
						z = _tstof(sArr2->ElementAt(1)); // in m
						v = _tstof(sArr2->ElementAt(num - 3)); // in m/s
					}
					else if (num > 2) {
						z = _tstof(sArr2->ElementAt(1)); // in m
						v = _tstof(sArr2->ElementAt(num - 2)); // in m/s
					}
					sArr2->RemoveAll();
					delete sArr2;
					if (v > 0.1) {
						str.Format(_T("%8.6f %8.6f  %s\n"), v*0.001, z*0.001, inFileNamePure);
						arrLogEx->Add(str);
						if (zmaxDetected < z*0.001) zmaxDetected = z*0.001;
					}
				}
				break;
			}
		} // for r
		sArr->RemoveAll();
		delete sArr;

		t.Format(_T("# %8.6f %8.6f  %s   %8.3gkm\n"), lon, lat, inFileNamePure, zmaxDetected);
		arrLog->Add(t);
		totFilesSuc++;
		t.Format(_T("%d of %d. "), n, nf);
		pFrame->myCaption(t);
	} // for n
	
	t.Format(_T("A total of %d files successfully processed."), totFilesSuc);
	AfxMessageBox(t);

	arrLog->Add(_T("\n#Following are dumps of sound velocity (km/s) and all the depth (km) pairs\n"));
	arrLog->Append(*arrLogEx);
	showStringArrayToFile(arrLog);
	arrLog->RemoveAll();
	delete arrLog;
	arrLogEx->RemoveAll();
	delete arrLogEx;
}


void myProcessingDecimateKmlPoints(CStringArray *linesArr, CStringArray *linesArrOut, int decimate)
{
	CString t;
//	CString tOld = BLANK;

	linesArrOut->RemoveAll();
	bool isExamineNextLine = false;
	CStringArray *arr = new CStringArray();
	for (int i = 0; i < linesArr->GetSize(); i++) {
		t = linesArr->ElementAt(i);
		
		if (t.Find(_T("<coordinates>")) >= 0) {
			// now the next line will be examined for decimation
			isExamineNextLine = true;
			linesArrOut->Add(t);
			continue;
		}
		else if (t.Find(_T("</coordinates>")) >= 0) {
			isExamineNextLine = false;
			linesArrOut->Add(t);
			continue;
		}
		else if (!isExamineNextLine) {
			linesArrOut->Add(t);
			continue;
		}

		// now examine
		arr->RemoveAll();
		arr = CString2LinesBySpace(t);
		int idecimate = decimate;
		for (int j = 0; j < arr->GetSize(); j++) {
			if (j == 0 || j == arr->GetSize() - 1 || idecimate == 0) {
				t = arr->ElementAt(j);
				linesArrOut->Add(arr->ElementAt(j));
				idecimate = decimate;
			}
			else {
				idecimate--;
			}
		} // for j
	} // for i

	if (arr) {
		arr->RemoveAll();
		delete arr;
	}
}

void CSeisWideDoc::OnProcessingDecimatedatalines()
{
	static int skip = 0;
	static int decimate = 10;

	CdlgDesimate dlg0;
	dlg0.m_skip = skip;
	dlg0.m_decimate = decimate;
	if (dlg0.DoModal() == IDOK) {
		skip = dlg0.m_skip;
		decimate = dlg0.m_decimate;
	}
	else
		return;

	//
	CString inFile = BLANK, outFile = BLANK;
	CStringArray linesArr, linesArrOut;
	CFileDialog dlg(TRUE, _T("lld; txt; log; kml"), _T("*.lld; *.txt; log; kml"),
		OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT | OFN_ALLOWMULTISELECT | OFN_EXPLORER,
		_T("Input text File (*.lld;*.txt;*.log;*.kml)|*.lld;*.txt;*.log;*.kml|"));

	TCHAR* buff = (TCHAR*)alloc1(65535, sizeof(TCHAR));
	buff[0] = '\0';
	dlg.m_ofn.lpstrTitle = _T("Select all nav data files for conversion in batch");
	dlg.m_ofn.lpstrFile = buff;
	dlg.m_ofn.nMaxFile = 65535;//sizeof(buff);


	POSITION Position;

	CString t;
	CString tOld = BLANK;
	int nf = 0;
	if (dlg.DoModal() == IDOK) {

		Position = dlg.GetStartPosition();
		while (Position) {
			inFile = dlg.GetNextPathName(Position);
			if (!isFileExistNotDirectory(inFile)) continue;

			getLinesFromFile(&linesArr, inFile, true, 0);
			
			if (GetFileExtension(inFile) == _T("kml")) {
				myProcessingDecimateKmlPoints(&linesArr, &linesArrOut, decimate);			
				outFile = getFileNameAppend(inFile, _T("_Deci.kml"));
			}
			else {
				outFile = inFile + _T("_Deci.txt");
				t.Format(_T("#Decimate by %d"), decimate);
				int idecimate = decimate;
				linesArrOut.RemoveAll();
				for (int i = 0; i < linesArr.GetSize(); i++) {
					t.Format(_T("%s"), linesArr.ElementAt(i));
					if (t.GetAt(0) == '#') {
						tOld = BLANK;  // this line does not contain valid data
					}
					else if (t.GetAt(0) == '>') {
						// '>' means a start of the line segment
						// first check if the previous line segment is properly ended
						if (tOld.GetLength() > 0) {
							linesArrOut.Add(tOld);
						}
						linesArrOut.Add(t);
						idecimate = 0; // this indicate that the next line will be needed and reset counter at that time
						tOld = BLANK; // this line does not contain valid data
					}
					else if ((skip == 0 && i == 0) || i < skip || i == linesArr.GetSize() - 1 || idecimate == 0) {
						// if (skip==0 && i==0) here, it means no lines to skip
						// if idecimate==0, it means the decimation is over, and we should take this line
						linesArrOut.Add(t);
						tOld = t;
						idecimate = decimate;
					}
					else {
						tOld = t;
						idecimate--;
					} // else

				} // for i
			}

			if (!saveStringArrayToFile(&linesArrOut, outFile)) {
				AfxMessageBox(_T("Unable to save: %s") + outFile);
			}

			linesArr.RemoveAll();
			nf++;

		} //end the while file POSITION loop.
	} //end dlg.DoModal function.
	free1(buff);

	// now, convert only the last file into KML
	if (nf == 1) {
		if (GetFileExtension(inFile) != _T("kml")) {
			CDigitize pdig;
			CDigitize::DIGITIZE toDig;

			getLinesFromFile(&linesArr, outFile, true, 0);
			CString tt = linesArr.ElementAt(1);
			if (linesArr.GetCount() < 1) return;
			pdig.myDigitizingLoadTXT_GMT(&toDig, &linesArr);
			linesArr.RemoveAll();
			outFile = SetFileExtension(outFile, _T("kml"));
			int iOut = AfxMessageBox(_T("Output the last file as a line; select No for point format"), MB_YESNO | MB_ICONINFORMATION | MB_ICONQUESTION);
			CDigitize::digitize2Kml(&toDig, outFile, iOut == IDYES);
			toDig.freeDigAll();
		}
	}

	showFileInNotePad(outFile);

}

void CSeisWideDoc::OnDigitizingZeltSwapsource()
{
	// only Zelt's format can define source position
	if (!dig.isDigitizing || dig.nPoint == NULL || !dig.isZeltFormat) return;

	if (cd.coord.isDistanceDisplay) {
		// only when displaying as distance should the x be shifted according to source
		float srcNew = (float)cd.coord.xmax;
		for (int i = 0; i < dig.totCurve; i++) {
			for (int j = 0; j < dig.nPoint[i]; j++) {
				dig.x[j][i] = srcNew - dig.x[j][i];
			}
		}
		tx.xShotRay = srcNew;
		CDigitize pDg;
		pDg.myDigSaveAs2(&dig, false);
		CString str;
		str.Format(_T("Source position is changed to %f . As a result, the shifted points will not be displayed until your displayed segy has the same source position."), srcNew);
		AfxMessageBox(str);
	}
	UpdateAllViews(NULL);
	NotifyChanged();
}


void CSeisWideDoc::OnSegyconversionUnixtopcconvert()
{
	// this routine forcefully converts input data file in segy format (see segy.h file for definition) 
	// from big-endian to small-endian or Intel platform. It must consider input data in the 
	// formats of short integer, long integer, and floating point. See file suSwapByte.c for
	// routines of conversion.
	segy tr;
	bhed bh;
	CString tStr (_T("This function assumes segy file header and trace header and data are in Unix format, regardless of how it is detected."));
	if (AfxMessageBox(tStr, MB_YESNO | MB_ICONINFORMATION | MB_ICONQUESTION) == IDNO) return;

	CString inFile = BLANK, outFile = BLANK;

	//Openfiles.
	CFileDialog dlg(TRUE, _T("sgy; SEG"), _T("*.sgy; *.SEG"),
		OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT | OFN_ALLOWMULTISELECT | OFN_EXPLORER,
		_T("Input Segy File (*.sgy;*.SEG)|*.sgy; *.SEG|"));

	TCHAR* buff = (TCHAR*)alloc1(65535, sizeof(TCHAR));
	buff[0] = '\0';
	dlg.m_ofn.lpstrTitle = _T("Select all files for conversion in batch");
	dlg.m_ofn.lpstrFile = buff;
	dlg.m_ofn.nMaxFile = 65535;//sizeof(buff);

	//Begin progress control.
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	pFrame->BeginProgress();

	POSITION Position;

	int k = 0;
	if (dlg.DoModal() == IDOK) {
		Position = dlg.GetStartPosition();
		while (Position) {
			inFile = dlg.GetNextPathName(Position);
			CString tempStr = inFile;
			tempStr.MakeLower();
			// must make it lower case before comparing, in case some file has extension
			// like ".Sgy" or ".sGY".
			outFile = getFileNameAppend(inFile, _T("PC"));
			if (outFile == BLANK) continue;

			if (!isFileExistNotDirectory(inFile)) continue;
			CFile file;
			if (!file.Open(inFile, CFile::modeRead | CFile::typeBinary | CFile::shareDenyNone)) {
				continue;
			}
			//For progress control, need to know the last bytes no.
			ULONGLONG curBytesRead, totBytesRead = file.GetLength();
			file.Seek(0, CFile::begin);

			UINT bytesRead = file.Read(head.ascHead, 3200L);
			autoAsc2ebc(head.ascHead, 3200L);
			if (bytesRead < 3200) {
				file.Close();
				AfxMessageBox(_T("File ") + inFile + _T(" Ascii section header read wrong"));
				continue;
			}
			file.Read(&bh, 400L);
			int formatBeforeSwap = bh.format;
			SwapTapeHeader(&bh);
			if (bh.format < 1 || bh.format>5)
				bh.format = formatBeforeSwap;
			if (bytesRead < 400) {
				file.Close();
				AfxMessageBox(_T("File ") + inFile + _T(" Binary section header read wrong"));
				continue;
			}

			int numsamp = bh.hns;
			int len;
			if (bh.format == 1 || bh.format == 2 || bh.format == 5 || bh.format==4)
				len = numsamp * 4 + 240;
			else if (bh.format == 3)
				len = numsamp * 2 + 240;
			else {
				file.Close();
				AfxMessageBox(_T("File ") + inFile + _T(" has unknown format"));
				continue;
			}
			if (bh.hdt == 0) bh.hdt = bh.dto;
			int tpp = bh.hdt;
			ULONGLONG byteFileEnd = file.SeekToEnd();
			file.Seek(3600L, CFile::begin);

			CFile file2;
			if (!file2.Open(outFile, CFile::modeWrite | CFile::modeCreate | CFile::typeBinary)) {
				file.Close();
				continue;
			}
			// ebc2asc(head.ascHead, 3200L);
			file2.Write(head.ascHead, 3200L);
			file2.Write(&bh, 400L);

			// NOTE: this routine does not convert between IBM and IEEE formats
			while (file.Read(&tr, len) == (UINT)len) {
				SwapTraceHeader(false, false, false, &tr);  // this function does not swap any header, but only swap data
				SwapN(&tr.dat, bh.format, numsamp);

				// test
				//if (bh.format == 1) {
				//	float_to_ibm((int *)tr.dat.data, (int *)tr.dat.data, numsamp); // we always output as floating pt
				//}
				//else if (bh.format == 5) {
				//	ibm_to_float((int *)tr.dat.data, (int *)tr.dat.data, (int)numsamp);
				//}

				if (tr.tracl <= 0) tr.tracl = k;

				file2.Write(&tr, len);
				k++;
				curBytesRead = file.Seek(0, CFile::current);
				int iPos = (int)((double)curBytesRead / (double)totBytesRead*100.);
				if (iPos < 0)iPos = 0;
				if (iPos > 100)iPos = 100;
				pFrame->SetProgress(iPos);
			} //end the while Read loop.

			file.Close();
			file2.Close();
		} //end the while file POSITION loop.
	} //end dlg.DoModal function.
	free1(buff);

	pFrame->EndProgress();

}


void CSeisWideDoc::myToolbarUpOnly()
{
	CVelMod vm;
	CString tStr;
	CSeisWideApp* pSeiApp = (CSeisWideApp*)AfxGetApp();
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	float signThis = cd.coord.isFaceUp ? -1.f : 1.f;

	bool isChanged = false;
	if (
		(cd.coord.drawmode == 2 || cd.coord.drawmode == 3 || cd.coord.drawmode == 4 || cd.coord.drawmode == 9)
		&& velMod.ncont > 1 &&
		draw.iLayerFocus > 0
		) {
		int icont = draw.iLayerFocus;
		if (draw.nodeMode == 1) {
			// boundary mode
			if (icont < 1) return;  // we do not move the top boundary
			if (icont >= velMod.ncont) return;
			float dz2 = (pSeiApp->statWin.getControlPressed()) ? 0.001f : (float)fabs(draw.modelUpInc);
			if (pSeiApp->statWin.getShiftPressed()) {
				double dy = cd.coord.yHeight();
				if (dy<10.) dz2 = 1.;
				else if (dy<20.) dz2 = 2.;
				else if (dy<30.) dz2 = 3.;
				else if (dy<40.) dz2 = 4.;
				else dz2 = 5.;
			}
			dz2 *= signThis;

			int num1 = velMod.nzed[icont - 1] - 1;
			int num2 = velMod.nzed[icont] - 1;
			if (cd.coord.drawmode == 9) {
				// make sure the first point does not cross the adjacent boundary
				bool isTrue = (velMod.tm[0][icont] - velMod.tm[0][icont - 1] < fabs(dz2)) ||
					(velMod.tm[num2][icont] - velMod.tm[num1][icont - 1] < fabs(dz2));
				if (isTrue) {
					pFrame->myCaption(_T("Sorry, model boundary cannot cross the other."));
				}
				else {
					for (int j = 0; j < velMod.nzed[icont]; j++)
						velMod.tm[j][icont] -= dz2;
					isChanged = true;
				}
			}
			else {
				bool isTrue = (velMod.zm[0][icont] - velMod.zm[0][icont - 1] < fabs(dz2)) ||
					(velMod.zm[num2][icont] - velMod.zm[num1][icont - 1] < fabs(dz2));

				if (isTrue) {
					pFrame->myCaption(_T("Sorry, model boundary cannot cross the other."));
				}
				else {
					for (int j = 0; j < velMod.nzed[icont]; j++)
						velMod.zm[j][icont] -= dz2;
					isChanged = true;
				}
			}

		} // if draw
		else if (draw.nodeMode == 2) {
			// velocity editting mode
			if (icont >= velMod.ncont - 1) return;
			// float dv = 0.02f;
			int n;
			n = velMod.nvel[icont][0];
			float dv2;
			if (pSeiApp->statWin.getControlPressed())
				dv2 = 0.01f;
			else if (pSeiApp->statWin.getShiftPressed()) {
				if (velMod.vf[0][icont][0] >= 2.5f) dv2 = 0.5f;
				else dv2 = 0.2f;
			}
			else
				dv2 = velMod.getVelIncNice(velMod.vf[0][icont][0]);
			dv2 *= signThis; // dv2 now can be minus

			for (int j = 0; j < n; j++) {
				velMod.vf[j][icont][0] += (float)dv2;
			}
			n = velMod.nvel[icont][1];
			for (int j = 0; j < n; j++) {
				velMod.vf[j][icont][1] += (float)dv2;
			}
			tStr.Format(_T("Velocity increased by %f. Ctrl key to fine tune."), dv2);
			pFrame->myCaption(tStr);
			isChanged = true;
		} // else

		if (cd.coord.drawmode == 9) {
			vm.myModel_TWTT2Depth(&velMod, velColor.dz);
		}
	} // if
	else if ((cd.coord.drawmode == 0 || cd.coord.drawmode == 7) && fabs(draw.red.rvred) > 0.001) {
		double xUse = (cd.coord.isDistanceDisplay && CCoords::isXShotDefined(tx.xShotRay))
			? tx.xShotRay : cd.coord.xmin;
		double tRed1 = CCoords::getReduceTimeEx2(cd.coord.getOffsetFromXVal(xUse, tx.xShotRay),
			cd.coord.drawmode, &draw.red);

		// if it is digitizing, the previous drag-draw line conflicts with the purpose of draw.dxdyDrawn
		//if ((cd.coord.drawmode == 0 || cd.coord.drawmode == 7) &&
		//	!dig.isDigitizing &&
		//	fabs(draw.tmpDxdyDrawn) > 0.0001 && fabs(draw.tmpDxdyDrawn) < 15.) {
		//	draw.red.rvred = myFloat(1. / draw.tmpDxdyDrawn, 2);
		//	draw.tmpDxdyDrawn = 0.0f; // already used this value and should now be set to zero
		//}
		//else {
			double vred = draw.red.getVred();

			if (pSeiApp->statWin.isAPressed) {
				// we will increase the target depth by 1 km
				float zInc = 1.f;
				if (pSeiApp->statWin.getShiftPressed()) {
					zInc = (float)(int)(cd.coord.yHeight());
					draw.red.targetDepth -= zInc;
					draw.red.targetDepth = (float)(int)(draw.red.targetDepth + 0.5);
				}
				else if (pSeiApp->statWin.getControlPressed()) {
					zInc = (float)(int)(cd.coord.yHeight() * 0.2);
					draw.red.targetDepth -= zInc;
					draw.red.targetDepth = (float)(int)(draw.red.targetDepth + 0.5);
				}
				else
					draw.red.targetDepth -= zInc;
				tStr.Format(_T("Target depth: %g."), draw.red.targetDepth);
				pFrame->myCaptionKeep(tStr);
			}
			else if (pSeiApp->statWin.getShiftPressed()) {
				int i = (int)(vred - 0.01);
				vred = (vred - i <= 0.5) ? (double)i : (double)(i + 0.5);
			}
			else {
				double dv2 = (fabs(vred) >= 2.5 && !pSeiApp->statWin.getControlPressed()) ? -0.1 : -0.01;
				//if (fabs(vred) >= 2.5 && !draw.isControlPressed)
				//	dv2 = -0.1;
				//else
				//	dv2 = -0.01;
				vred += dv2;
			}

			draw.red.rvred = (vred == 0.) ? 0. : 1. / vred;
		//}

		draw.isSameDataDisplay = FALSE;
		isChanged = true;
	}


	if (isChanged) {
		UpdateAllViews(NULL);
		NotifyChanged();
	}
}

void CSeisWideDoc::myToolbarDownOnly()
{
	CVelMod vm;
	CString tStr;
	CSeisWideApp* pSeiApp = (CSeisWideApp*)AfxGetApp();
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	bool isChanged = false;
	float signThis = cd.coord.isFaceUp ? -1.f : 1.f;
	if (
		(cd.coord.drawmode == 2 || cd.coord.drawmode == 3 || cd.coord.drawmode == 4 || cd.coord.drawmode == 9)
		&& velMod.ncont > 1 && draw.iLayerFocus >= 0) {
		int icont = draw.iLayerFocus;
		if (draw.nodeMode == 1) {
			// boundary mode
			if (icont < 1) return;  // we do not move the top boundary
			if (icont >= velMod.ncont) return;
			double dz2 = (pSeiApp->statWin.getControlPressed()) ? 0.001 : fabs(draw.modelUpInc);
			if (pSeiApp->statWin.getShiftPressed()) {
				double dy = cd.coord.yHeight();
				if (dy<10.) dz2 = 1.;
				else if (dy<20.) dz2 = 2.;
				else if (dy<30.) dz2 = 3.;
				else if (dy<40.) dz2 = 4.;
				else dz2 = 5.;
			}
			int num1 = velMod.nzed[icont] - 1;
			int num2 = velMod.nzed[icont + 1] - 1;

			if (cd.coord.drawmode == 9) {
				// make sure the first point does not cross the adjacent boundary
				bool isTrue = (velMod.tm[0][icont + 1] - velMod.tm[0][icont] < dz2) ||
					(velMod.tm[num2][icont + 1] - velMod.tm[num1][icont] < dz2);
				if (isTrue) {
					pFrame->myCaption(_T("Sorry, model boundary cannot cross the other."));
				}
				else {
					dz2 *= signThis;
					for (int j = 0; j < velMod.nzed[icont]; j++)
						velMod.tm[j][icont] += (float)dz2;
					isChanged = true;
				}
			}
			else {
				bool isTrue = (velMod.zm[0][icont + 1] - velMod.zm[0][icont] < dz2) ||
					(velMod.zm[num2][icont + 1] - velMod.zm[num1][icont] < dz2);
				if (isTrue) {
					pFrame->myCaption(_T("Sorry, model boundary cannot cross the other."));
				}
				else {
					dz2 *= signThis;
					for (int j = 0; j < velMod.nzed[icont]; j++)
						velMod.zm[j][icont] += (float)dz2;
					isChanged = true;
				}
			}

		} // if draw
		else if (draw.nodeMode == 2) {
			// velocity editting mode
			if (icont >= velMod.ncont - 1) return;
			float dv = velMod.getVelIncNice(velMod.vf[0][icont][0]);
			if (pSeiApp->statWin.getControlPressed()) dv = 0.01f;
			else if (pSeiApp->statWin.getShiftPressed()) {
				if (velMod.vf[0][icont][0] >= 2.5f) dv = 0.5f;
				else dv = 0.2f;
			}

			int n;
			n = velMod.nvel[icont][0];
			dv *= signThis;
			for (int j = 0; j < n; j++) {
				velMod.vf[j][icont][0] -= (float)dv;
			}
			n = velMod.nvel[icont][1];
			for (int j = 0; j < n; j++) {
				velMod.vf[j][icont][1] -= (float)dv;
			}
			isChanged = true;
			tStr.Format(_T("Velocity decreased by %f. Ctrl key to fine tune."), dv);
			pFrame->myCaption(tStr);
		} // else
		if (cd.coord.drawmode == 9) {
			vm.myModel_TWTT2Depth(&velMod, velColor.dz);
		}
		// OnToolbarSavev();
	//	if (cd.coord.drawmode == 2 || cd.coord.drawmode == 4) {
			// in velocity colormap or contour mode, the screen does not refresh the model, so we need to force it.
			// but in moode=3, it is handled separately.
			//	draw.isSameDataDisplay = FALSE;
	//	}
	} // if

	else if ((cd.coord.drawmode == 0 || cd.coord.drawmode == 7) && fabs(draw.red.rvred) > 0.001) {
		double xUse = (cd.coord.isDistanceDisplay && CCoords::isXShotDefined(tx.xShotRay)) ? tx.xShotRay : cd.coord.xmin;
		float tRed1 = (float)CCoords::getReduceTimeEx2(cd.coord.getOffsetFromXVal(xUse, tx.xShotRay),
			cd.coord.drawmode, &draw.red);

		//if (cd.coord.drawmode == 0 && fabs(draw.tmpDxdyDrawn) > 0.0001 && fabs(draw.tmpDxdyDrawn) < 15.) {
		//	draw.red.rvred = myFloat(1. / draw.tmpDxdyDrawn, 2);
		//	draw.tmpDxdyDrawn = 0.0f; // already used this value and should now be set to zero
		//}
		//else if (cd.coord.drawmode == 7 && fabs(draw.tmpDxdyDrawn) > 0.0001 && fabs(draw.tmpDxdyDrawn) < 15.) {
		//	draw.red.rvred = myFloat(1. / draw.tmpDxdyDrawn, 2);
		//	draw.tmpDxdyDrawn = 0.0f; // already used this value and should now be set to zero
		//}
		//else {
			double vred = draw.red.getVred();
	
			if (pSeiApp->statWin.isAPressed) {
				// we will increase the target depth by 1 km
				float zInc = 1.f;
				if (pSeiApp->statWin.getShiftPressed()) {
					zInc = (float)(int)(cd.coord.yHeight());
					draw.red.targetDepth += zInc;
					draw.red.targetDepth = (float)(int)(draw.red.targetDepth + 0.5);
				}
				else if (pSeiApp->statWin.getControlPressed()) {
					zInc = (float)(int)(cd.coord.yHeight() * 0.2);
					draw.red.targetDepth += zInc;
					draw.red.targetDepth = (float)(int)(draw.red.targetDepth + 0.5);
				}
				else
					draw.red.targetDepth += zInc;
				tStr.Format(_T("Target depth: %g."), draw.red.targetDepth);
				pFrame->myCaptionKeep(tStr);
			}
			else if (pSeiApp->statWin.getShiftPressed()) {
				int i = (int)(vred + 0.01);
				vred = (vred - i < 0.5) ? (double)(i + 0.5) : (double)(i + 1);
			}
			else {
				double dv2 = (fabs(vred) >= 2.5 && !pSeiApp->statWin.getControlPressed()) ? 0.1 : 0.01;
				//if (fabs(vred) >= 2.5 && !draw.isControlPressed)
				//	dv2 = 0.1;
				//else
				//	dv2 = 0.01;
				vred += dv2;
			}
			draw.red.rvred = (vred == 0.) ? 0. : 1. / vred;
		//}

		// draw.isSameDataDisplay = (cd.coord.drawmode == 0 && !isFloatEqual(draw.gDCs.gDC_red.rvred, 0.0)) ? TRUE : FALSE;
		// the above line will force a CDC transform (with varying reducing velocity) in OnDraw() for a very speedy display.
		// But later I found the segy re-display is already very fast, so I disable this.
		// eventually, I will use it when more complex displays are required.

		draw.isSameDataDisplay = FALSE;
		isChanged = true;
	}


	if (isChanged) {
		draw.isNodeChanged = TRUE;
		UpdateAllViews(NULL);
		NotifyChanged();
	}
}

void CSeisWideDoc::OnModelup()
{
	if (!cd.coord.isFaceUp)
		myToolbarUpOnly();
	else
		myToolbarDownOnly();
}

void CSeisWideDoc::OnModeldown()
{
	if (!cd.coord.isFaceUp)
		myToolbarDownOnly();
	else
		myToolbarUpOnly();
}

BOOL CSeisWideDoc::setGainCorr(segy *tr, int dformat, int tpp)
{
	return setGainCorr(tr, dformat, tpp, draw.sphericOrder,
		draw.attenuationCorr, draw.attenuationSeafloor);
}

BOOL CSeisWideDoc::setGainCorr(segy *tr, int dformat, int tpp, float sphericOrder,
	float attenuationCorr, float attenuationSeafloor)
{
	//Correct for amptitude of spherical correction, and attenuation
	// will use global varioables:  
	//  numsamp, tpp, cd.coord.tmin, cd.coord.tmax

	// 		BOOL isTrue = setGainCorr(&tr, dformat);

	if (sphericOrder <= 0.f && attenuationCorr <= 0.f) return TRUE;  // no need to correct anything, normal.
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();

	if (dformat != 1) {
		pFrame->myCaption(_T("Sorry, spherical correction is only for float data."));
		return FALSE;
	}

	int i;
	double t, tbs;
	float b;

	double attenuation = pow(10., attenuationCorr / 20.);
	float tShift = tr->getTraceDelay();
	double tppSEC = (double)tpp / (double)MIL;
	int numsamp = tr->ns;

	for (i = 0; i < numsamp; i++) {
		t = tShift + i*tppSEC; // t now the absolute time in sec
		if (sphericOrder > 0.f) {
			b = (float)pow(t, (double)sphericOrder) + 1.f;
			tr->dat.data[i] *= b;
		} // if para.spherical

		if (attenuationCorr > 0.f) {	//apply trace attenuation correction. If para.attenuationCorr==0., the gain should be 1.0
			tbs = t - attenuationSeafloor;  // tbs is now the time in sec below the seafloor
			if (tbs > 0.f) {
				b = (float)(pow(attenuation, tbs));
				tr->dat.data[i] *= b;
			} // if tbs
		} // if para.attenuan
	} // for i

	// final auto gains down by 1000 since the overal amp can be too high 
	float norm = 0.001f;
	for (i = 0; i < numsamp; i++) {
		tr->dat.data[i] *= norm;
	}

	return TRUE;
}

void CSeisWideDoc::OnModelingTogglepeglet()
{
	if (!cd.coord.isTimeDomain()) {
		if (draw.iModelPeglet == draw.iLayerFocus) {
			// this means that the model peglet has been activated
			draw.iModelPeglet = -1;
		}
		else {
			draw.iModelPeglet = draw.iLayerFocus;
		}
		UpdateAllViews(NULL);
	}
}


void CSeisWideDoc::OnModelingTheoreticalcurves()
{
	draw.isShowTheoryModel = !draw.isShowTheoryModel;

	if (draw.isShowTheoryModel) {
		CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
		if (!pFrame) return;
		CdlgRegionalModel dlg;
		dlg.m_regionalModelA = pFrame->psei->regionalModelA;
		dlg.m_regionalModelB = pFrame->psei->regionalModelB;
		dlg.m_regionalModelAlpha = pFrame->psei->regionalModelAlpha;
		//dlg.m_regionalModelBeta = pFrame->psei->regionalModelV0;
		if (dlg.DoModal()) {
			pFrame->psei->regionalModelA = dlg.m_regionalModelA;
			pFrame->psei->regionalModelB = dlg.m_regionalModelB;
			pFrame->psei->regionalModelAlpha = dlg.m_regionalModelAlpha;
			//pFrame->psei->regionalModelBeta = dlg.m_regionalModelBeta;
		}
	}

	UpdateAllViews(NULL);
}


void CSeisWideDoc::myUpdatePrevFrame(void)
{
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	if (!pFrame) return;
	if (pFrame->pViewPrev != NULL && pFrame->pViewCurr != pFrame->pViewPrev) {
		TRY{
			pFrame->pViewPrev->Invalidate();
			// pFrame->pDocPrev->UpdateAllViews(NULL);
		} // TRY 
			CATCH_ALL(e)
		{
			// it's ok to be here
		}
		END_CATCH_ALL
			//AfxMessageBox( ((CSeisWideDoc *)pFrame->pDocPrev)->GetTitle() + _T(" was also updated.");
	}
}

int CSeisWideDoc::myCountAllFrames() {
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	if (!pFrame) return 0;
	int count = 0;
	CMDIChildWnd* pChild = pFrame->GetNextMDIChildWnd();
	while (pChild) {
		count++;
		pChild = pFrame->GetNextMDIChildWnd();
	}
	return count;
}

int CSeisWideDoc::myUpdateAllFramesExcept(CDocument *aDoc)
{
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	if (!pFrame) return 0;
	int count = 0;
	CMDIChildWnd* pChild = pFrame->GetNextMDIChildWnd();
	
	while (pChild)
	{
		if (pChild->GetActiveDocument() != this) {
			count++;
			pChild->GetActiveView()->Invalidate(FALSE);
		}
		pChild = pFrame->GetNextMDIChildWnd();
	}
	return count;
}


void CSeisWideDoc::OnModelingToggleswavelabels()
{
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	if (!cd.coord.isModelingMode()) {
		pFrame->myCaption(_T("No valid model displayed."));
	}
	else {
		pFrame->statMain.isDisplayVsModel = !pFrame->statMain.isDisplayVsModel;

		if (pFrame->statMain.isDisplayVsModel && !isFileExistNotDirectory(draw.rayName)) {
			// since the rayName file is not defined, the user will wonder why S-info cannot be shown. 
			// So let's select that file
			CString tStr;
			tStr.Format(_T("S velocity labeling will be based on a raytracing parameter file, which may differ from the actual model values, so use with care."));
			AfxMessageBox(tStr);

			CFileDialog dlg(TRUE, _T("in; IN"), _T("*.in; *.IN"),
				OFN_EXPLORER,
				_T("Ray parameter file (*.in;*.IN)|*.in; *.IN|"));

			TCHAR* buff = (TCHAR*)alloc1(65535, sizeof(TCHAR));
			buff[0] = '\0';
			dlg.m_ofn.lpstrTitle = _T("Please select a valid ray parameter file for S velocity calculation");
			dlg.m_ofn.lpstrFile = buff;
			dlg.m_ofn.nMaxFile = 65535;//sizeof(buff);

			if (dlg.DoModal() == IDOK) {
				draw.rayName = dlg.GetPathName();
			}
			else {
				free1(buff);
				return;
			}

			free1(buff);
		}
		UpdateAllViews(NULL);
	}
}

void CSeisWideDoc::OnProcessingDatasplit()
{
	if (AfxMessageBox(_T("Split into 2 files. Entered trace number will be in the 2nd file. If enter -1, spliting will be based on positive or negative offsets. Continue?"), MB_YESNO | MB_ICONINFORMATION|MB_ICONQUESTION) != IDYES) {
		return;
	}

	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	if (!isFileExistNotDirectory(draw.timeSecName)) {
		pFrame->myCaption(_T("Please display a valid segy file to split."));
		return;
	}

	static float xSplit = 0.f;
	CdlgInputValie dlg;
	dlg.m_value = xSplit;
	if (dlg.DoModal() == IDOK) {
		xSplit = dlg.m_value;
	}
	else return;
	delete dlg;

	CFile file;
	if (!file.Open(draw.timeSecName, CFile::modeRead | CFile::typeBinary | CFile::shareDenyNone)) {
		return;
	}
	ULONGLONG bytesRead = file.Read(head.ascHead, 3200L);
	if (bytesRead < 3200) {
		file.Close();
		AfxMessageBox(_T("Ascii section header read wrong"), MB_ICONQUESTION);
		return;
	}
	CString tStr;

	bhed bh;
	bytesRead = file.Read(&bh, 400);
	//int format = bh.format;
	BOOL isUnix = IsUnix(bh.format);
	if (isUnix) {
		// NOTE: this function works well with Unix format.But I still disable it since the unix format segy may contain traces not in sequential order
		//       and if continue, the split will not work since it is based on trace number!!!
		file.Close();
		tStr.Format(_T("Sorry, please convert to PC format (small-endian) before continue."));
		AfxMessageBox(tStr, MB_ICONQUESTION);
		return;
	}

	if (bytesRead < 400) {
		file.Close();
		AfxMessageBox(_T("Binary section header read wrong"), MB_ICONQUESTION);
		return;
	}
	if (isUnix) SwapTapeHeader(&bh);


	int numsamp = bh.hns;
	//int len = (bh.format != 3) ? numsamp * 4 + 240 : numsamp * 2 + 240;
	int len = bh.getTraceLenBytes();
	if (bh.hdt == 0) bh.hdt = bh.dto;
	int tpp = bh.hdt;

	CFile filez;
	CString outFile = getFileNameAppend(draw.timeSecName, _T("_split1"));
	if (!filez.Open(outFile, CFile::modeReadWrite | CFile::modeCreate | CFile::typeBinary)) {
		file.Close();
		return;
	}
	filez.Write(head.ascHead, 3200L);
	filez.Write(&bh, 400);

	CString outFile2 = getFileNameAppend(draw.timeSecName, _T("_split2"));
	CFile filez2;
	if (!filez2.Open(outFile2, CFile::modeReadWrite | CFile::modeCreate | CFile::typeBinary)) {
		file.Close();
		filez.Close();
		return;
	}
	filez2.Write(head.ascHead, 3200L);
	filez2.Write(&bh, 400);

	segy tr;
	int atrc;
	int count1 = 0;
	int count2 = 0;
	// NOTE: here in reading/writing, we do not convert between IBM and IEEE float at all, since no processing involved.
	while (file.Read(&tr, len) == (UINT)len) {
		if (isUnix) {
			SwapTraceHeader(false, false, false, &tr);
			SwapN(&tr.dat, bh.format, numsamp);  // trace header was already swapped
		}

		atrc = tr.tracl;

		if (xSplit < 0.f) {
			register float anOffset = tr.getOffset();
			if (anOffset < 0.f) {
				filez.Write(&tr, len);
				count1++;
			}
			else {
				filez2.Write(&tr, len);
				count2++;
			}
		}
		else {
			if (atrc < xSplit) {
				filez.Write(&tr, len);
				count1++;
			}
			else {
				filez2.Write(&tr, len);
				count2++;
			}
		}
	} //end of while loop.


	if (count1 > 0)
		CSegyMeta::setSegyTotalTrace(&filez, count1);
	if (count2 > 0)
		CSegyMeta::setSegyTotalTrace(&filez2, count2);

	file.Close();
	filez.Close();
	filez2.Close();
	pFrame->myCaption(_T("Finished segy file split. Please check files: ") + outFile + _T(" and ") + outFile2);
}



int CSeisWideDoc::writeHeader4ZeroTrcNum(CString f)
{
	if (!isFileExistNotDirectory(f)) return 0;

	segy tr;

	int sampByte = (head.formatFile != 3) ? 4 : 2;
	int trcDataBytes = head.numsampFiles *sampByte;

	CFile file;
	CString t;

	// segy already existing
	if (!file.Open(f, CFile::modeReadWrite | CFile::typeBinary)) {
		return 0;
	}
	file.Seek(3600L, CFile::begin);

	int itrcFile = 0;
	int trc1, trc2;
	file.Read(&tr, 4);
	trc1 = tr.tracl;
	if (head.isUnixFile) {
		swap_int_4(&trc1);
	}
	file.Seek(trcDataBytes + 240 - 4, CFile::current);
	file.Read(&tr, 4);
	trc2 = tr.tracl;
	if (head.isUnixFile) {
		swap_int_4(&trc2);
	}

	if (trc1 == 0 && trc2 == 0) {
		t.Format(_T("Traces are numbered zero. Suggest you number the traces properly. OK ?"));
		if (AfxMessageBox(t, MB_YESNO | MB_ICONINFORMATION) == IDYES) {
			file.Seek(3600L, CFile::begin);
			while (file.Read(&tr, 4) == (UINT)4) {
				itrcFile++;
				if (head.isUnixFile) {
					swap_int_4(&tr.tracl);
				}

				if (tr.tracl != 0) {
					file.Seek(trcDataBytes + 240 - 4, CFile::current); // skip this trace
					continue;
				}
				tr.tracl = itrcFile;
				file.Seek(-4, CFile::current);
				if (head.isUnixFile) {
					swap_int_4(&tr.tracl);
				}
				file.Write(&tr.tracl, 4);
				file.Seek(trcDataBytes + 240 - 4, CFile::current); // skip the data section to point to the next trace
			} // while
		}
	}



	file.Close();
	return itrcFile;
}


void CSeisWideDoc::OnProcessingIdProcessingTracedub()
{
	CString t;
	if (!cd.coord.isTimeDomain() || !isFileExistNotDirectory(draw.timeSecName))  {
		t.Format(_T("To double the trace length, please show a segy file in time domain first."));
		AfxMessageBox(t);
		return;
	}

	t.Format(_T("Seiswide will double trace length based on trace time in header. This should be done after correction of airgun delay. One or two valid firing rates should be used.  Continue?"));
	if (AfxMessageBox(t, MB_YESNO | MB_ICONQUESTION) == IDNO) {
		return;
	}

	writeHeader4ZeroTrcNum(draw.timeSecName);

	// here, the program will double the trace length for sonobuoy data, based on the information of time in the header
	bool isFiringRateManual = false;

	static float aFireRate1 = 20.f;
	static float aFireRate2 = 0.f;
	static int   aTraceSplit = 0;

	isFiringRateManual = false;  // auto firing rate is disabled for now.

	//t.Format(_T("Do you want to manually set a firing rate (in sec) ? If not sure, click No to automatically calculate firing rate.");
	//if (AfxMessageBox(t, MB_YESNO |MB_ICONINFORMATION) == IDYES) {
	isFiringRateManual = true;

	CdlgTraceDub dlg;
	dlg.m_fireRate1 = aFireRate1;
	dlg.m_fireRate2 = aFireRate2;
	dlg.m_traceSplit = aTraceSplit;
	if (dlg.DoModal() == IDOK)
	{
		aFireRate1 = dlg.m_fireRate1;
		aFireRate2 = dlg.m_fireRate2;
		aTraceSplit = dlg.m_traceSplit;
	}
	else return;
	delete dlg;

	if (aFireRate1 <= 0.f) {
		t.Format(_T("To double the trace length, a valid firing rate is needed."));
		AfxMessageBox(t);
		return;
	}
	//}

	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	bhed bh;
	segy tr, tr2;
	BOOL isUnix = false;
	char ascHead[3200];


	CFile file;
	if (!file.Open(draw.timeSecName, CFile::modeRead | CFile::typeBinary | CFile::shareDenyNone)) {
		return;
	}

	LONGLONG bytesRead = file.Read(&ascHead, 3200);
	if (bytesRead < 3200)
	{
		file.Close();
		t.Format(_T("Ascii section header read wrong."));
		AfxMessageBox(t);
		return;
	}

	bytesRead = file.Read(&bh, 400);
	if (bytesRead < 400)
	{
		file.Close();
		t.Format(_T("Binary section header read wrong."));
		AfxMessageBox(t);
		return;
	}

	//if (bh.format != 1 ) {
	//	file.Close();
	//	t.Format(_T("Sorry, this routine only works for float data. You may convert to float by using 'Data Reduction and Filter'");
	//	AfxMessageBox(t);
	//	return;
	//}

	if (isUnix = IsUnix(bh.format)) {
		file.Close();
		t.Format(_T("Sorry, please convert to PC format (small-endian) before continue."));
		AfxMessageBox(t);
		return;
	}

	int numSamp1 = bh.hns;
	int len1 = (bh.format == 3) ? (2 * bh.hns) + 240 : 4 * bh.hns + 240;

	int i;
	int k;
	double firingRateSecOld = 0.;
	double firingRateSec = 0.;
	if (bh.hdt == 0) bh.hdt = bh.dto;
	double dt = (double)bh.hdt / (double)MIL;
	double odt = 1. / dt;

	// we double the trace length
	if (aTraceSplit > 0 && aFireRate2 > 0) {
		float aFireRateMax = max(aFireRate1, aFireRate2);
		bh.hns = (unsigned short)ceil(aFireRateMax*odt*2.0) + 1;
	}
	else {
		//bh.hns *= 2;
		bh.hns = (unsigned short)ceil(aFireRate1*odt*2.0) + 1;
	}


	int len2 = (bh.format == 3) ? (2 * bh.hns) + 240 : 4 * bh.hns + 240;  // output trace length


	// write to the output file
	CString fname2 = getFileNameAppend(draw.timeSecName, _T("Dub"));
	CFile file2;
	if (!file2.Open(fname2, CFile::modeWrite | CFile::modeCreate | CFile::typeBinary)) {
		file.Close();
		t.Format(_T("Failed to open a file to write to."));
		AfxMessageBox(t);
		return;
	}

	file2.Write(&ascHead[0], 3200);
	file2.Write(&bh, 400);



	// NOTE: here in reading/writing, we do not convert between IBM and IEEE float at all, since no processing involved.
	while (file.Read(&tr, len1) == len1) {
		// now, we calculate offset between (obslong,obslat) and (gx,gy); assuming (gx,gy) already in long/lat degrees:
		double aitime = tr.day * 24 + tr.hour + tr.minute / 60.0 + (tr.sec + tr.timbas / 1000.0) / 3600.0;
		if (file.Read(&tr2, len1) == len1) {

			// this is a special case for SB18, 2008, where the firing rate changed along. Be sure to remove these lines after that!
			//if (tr.hour >= 10 && tr.minute == 25) {
			//	this->m_value = 19.505;
			//}
			if (isFiringRateManual) {
				if (aTraceSplit > 0 && tr.tracl >= aTraceSplit && aFireRate2 > 0.f) {
					firingRateSec = aFireRate2;
				}
				else {
					// normally it should be this part working
					firingRateSec = aFireRate1;
				}
			}
			else {
				double aitime2 = tr2.day * 24 + tr2.hour + tr2.minute / 60.0 + (tr2.sec + tr2.timbas / 1000.0) / 3600.0;
				firingRateSec = (aitime2 - aitime)*3600.;
				if (firingRateSecOld > 0. && fabs(firingRateSecOld - firingRateSec) > 0.4) {
					file.Close();
					file2.Close();
					t.Format(_T("firingRateSecOld-firingRateSec= %f . Firing rate seems to fluctuate too much. You may try manually set the firing rate."), firingRateSecOld - firingRateSec);
					AfxMessageBox(t);
					return;
				}
				firingRateSecOld = firingRateSec;
			}

			int iDubStart = (int)myRound(firingRateSec*odt); // this is the start of the appended trace length
			memset((void *)&tr.dat.data[numSamp1], (int) '\0', (len2 - len1)); //   len1---> numSamp1;  len2---> numSamp1*2
			if (bh.format == 1 || bh.format == 5)
			{
				// float data
				for (i = 0; i < numSamp1; i++) {
					k = i + iDubStart; 

					// note: if trace initial time is minus, we will have k<numSamp1, and we just ignore those samples
					if (k >= numSamp1 && k < bh.hns)
						tr.dat.data[k] = tr2.dat.data[i];
				} // for i
			}
			else if (bh.format == 2)
			{
				// long data
				for (i = 0; i < numSamp1; i++) {
					k = i + iDubStart;
					if (k >= 0 && k < bh.hns)
						tr.dat.dataint[k] = tr2.dat.dataint[i];
				}
			}
			else if (bh.format == 3)
			{
				// short int data
				for (i = 0; i < numSamp1; i++) {
					k = i + iDubStart;
					if (k >= 0 && k < bh.hns)
						tr.dat.datashort[k] = tr2.dat.datashort[i];
				}
			}

			file.Seek(-len1, CFile::current);  // point to the next trace
		}
		else {
			// if here, the next trace is not valid.   len1--->numSamp1;  len2--->numSamp1*2
			memset((void *)&tr.dat.data[numSamp1], (int) '\0', (len2 - len1));
		}



		tr.ns = (unsigned short)(numSamp1 * 2);
		file2.Write(&tr, len2);
	}
	file.Close();
	file2.Close();

	t.Format(_T("Success in doubling the trace length in %s."), fname2);
	pFrame->myCaption(t);

	draw.timeSecName = fname2;
	OnToolbarRefreshAll(); // need to do it at the last line

}

/*
************* convert a big file from TWTT to depth using a polynomial function
************* Need to consider:
*************
*************
*************
*************
*
*
*/
void CSeisWideDoc::OnToolsMapconverttime()
{
	//new file dialog.
	CFileDialog dlg(TRUE, _T("txt;lstpc"), _T("*.txt; *.lstpc"),
		OFN_HIDEREADONLY | OFN_ALLOWMULTISELECT | OFN_EXPLORER,
		_T("Input text File (*.txt;*.lstpc)|*.txt;*.lstpc|"));
	dlg.m_ofn.lpstrTitle = _T("Select all valid ascii files. lstpc format is a special CMP-TWTT format from John");
	TCHAR* buff = (TCHAR*)alloc1(65535, sizeof(TCHAR));
	buff[0] = '\0';
	dlg.m_ofn.lpstrFile = buff;
	dlg.m_ofn.nMaxFile = 99;//sizeof(buff);

	bool isJohnLstpc = false;
	CDigitize pDg;
	if (dlg.DoModal() == IDOK) {
		POSITION position = dlg.GetStartPosition();
		dig.digName = dlg.GetNextPathName(position);
		isJohnLstpc = GetFileExtension(dig.digName) == _T("lstpc");
		if (isJohnLstpc) {
			// in the case of .lstpc format, we need to make a new name for the digitizing format, with the same extension of .txt
			if ((AfxMessageBox(_T("lstpc format will compare the CMP of lstpc and current segy file to obtain distance info. If segy file does not match lstpc in CMP, it will result in wrong distance info. The processing can take minutes to finish. Continue?"), MB_YESNO | MB_ICONINFORMATION) != IDYES))
				free1(buff);
			return;

			CString fileSegy;
			if (isFileExistNotDirectory(draw.timeSecName))  {
				fileSegy = draw.timeSecName;
			}
			else {
				fileSegy = draw.depthSecName;
			}
			dig.digName = GetFileNameAppendExt(fileSegy, _T("_lstTWTT"), _T("txt"));

			dig.freeDigAll();
			position = dlg.GetStartPosition();
			while (position)
			{
				CString lstFile = dlg.GetNextPathName(position);
				if (!MyLoadDistTwttDrawings4John(fileSegy, lstFile, dig.digName)) {
					// when it fails, we do not want any digitized points, and return
					dig.digName.Format(BLANK);
					free1(buff);
					return;
				}
			} //end the while file POSITION loop.
			dig.isSortedX = dig.isSortedY = FALSE;
			int isXInt = cd.coord.isTraceMode();
			pDg.myDigSaveAs2(&dig, isXInt);
		} // if isJohnLstpc
	}
	else
	{
		return;
	}
	free1(buff);
	delete dlg;




}

void CSeisWideDoc::OnProcessingSphericalcorrection()
{
	CString outFile = BLANK;
	CString tempStr = draw.timeSecName;
	tempStr.MakeLower();
	if (tempStr.Right(4) == _T(".sgy"))
		outFile = getFileNameAppend(draw.timeSecName, _T("Spher"));
	else
		outFile = draw.timeSecName + _T("Spher.sgy");


	CdlgAttenuationCorr dlg;
	dlg.m_inFile = draw.timeSecName;
	dlg.m_outFile = outFile;
	dlg.m_sphericOrder = draw.sphericOrder;
	dlg.m_attenuationCorr = draw.attenuationCorr;
	dlg.m_attenuationSeafloor = draw.attenuationSeafloor;
	if (dlg.DoModal() == IDOK)
	{
		draw.timeSecName = dlg.m_inFile.Trim();
		outFile = dlg.m_outFile;
		draw.sphericOrder = dlg.m_sphericOrder;
		draw.attenuationCorr = dlg.m_attenuationCorr;
		draw.attenuationSeafloor = dlg.m_attenuationSeafloor;
	}
	else
	{
		return;
	}
	if (head.isUnixFile) {
		CString tStr;
		tStr.Format(_T("Sorry, this routine only deals with PC format."));
		AfxMessageBox(tStr);
		return;
	}

	if (!isFileExistNotDirectory(draw.timeSecName)) return;
	if (outFile == BLANK) return;
	if (outFile == draw.timeSecName)
	{
		AfxMessageBox(_T("Output file name is the same as the input file name!"));
		return;
	}


	outFile = SetFileExtension(outFile, _T("sgy"));

	//put the path onto file2 if it doesn't have it.
	int pathLen = outFile.ReverseFind('\\');
	if (pathLen == (-1))
	{
		TCHAR curDir[_MAX_PATH];
		GetCurrentDirectory(_MAX_PATH, curDir);
		outFile.Format(_T("%s\\%s"), (CString)curDir, outFile);
	}

	CFile file;
	if (!file.Open(draw.timeSecName, CFile::modeRead | CFile::typeBinary | CFile::shareDenyNone)) {
		return;
	}



	segy tr, tr2;
	bhed bh;
	int i;

	//For progress control, need to know the last bytes no.
	ULONGLONG curBytesRead, totBytesRead = file.GetLength();
	file.Seek(0, CFile::begin);
	//Begin progress control.
	CMainFrame* pFrame =
		(CMainFrame*)AfxGetMainWnd();
	ASSERT(pFrame);
	ASSERT_KINDOF(CMainFrame, pFrame);
	pFrame->BeginProgress();


	UINT bytesRead = file.Read(head.ascHead, 3200L);
	if (bytesRead < 3200)
		AfxMessageBox(_T("Ascii section header read wrong"));
	bytesRead = file.Read(&bh, 400L);
	if (bytesRead < 400)
		AfxMessageBox(_T("Binary section header read wrong"));

	if (bh.format < 1 || bh.format>3) {
		AfxMessageBox(_T("Data is Fixed Point w/ Gain Code, not supported, or unknown format."));
		if (file) file.Close();
		return;
	}
	int numsamp = bh.hns; // (unsigned short)i2buf[10];
	int len = bh.getTraceLenBytes();
	//int len;
	//if (bh.format != 3)  {
	//	len = numsamp * 4 + 240;
	//}
	//else {
	//	len = numsamp * 2 + 240;
	//}


	CFile file2;
	if (!file2.Open(outFile, CFile::modeWrite | CFile::modeCreate | CFile::typeBinary)) {
		file.Close();
		return;
	}
	file2.Write(head.ascHead, 3200L);
	int formatInput = bh.format;
	bh.format = 1;  // always output in floating format
	// bh.format = pFrame->statMain.gIsIBMFloatSegy2 ? 1 : 5; // only floating is adopted for output
	file2.Write(&bh, 400L);

	ULONGLONG byteFileEnd = file.SeekToEnd();
	file.Seek(3600L, CFile::begin);


	if (bh.hdt == 0) bh.hdt = bh.dto;
	double aratio = (double)bh.hdt / (double)MIL;
	while (file.Read(&tr, len) == (UINT)len)
	{
		memcpy((void *)&tr2, (const void *)&tr, 240);
		if (formatInput == 1) {
			// float data
			ibm_to_float((int *)tr.dat.data, (int *)tr.dat.data, (int)numsamp);
			for (i = 0; i < numsamp; i++) {
				tr2.dat.data[i] = (float)(tr.dat.data[i]);
			}
		}
		else if (formatInput == 2) {
			for (i = 0; i < numsamp; i++)
			{
				tr2.dat.data[i] = (float)(tr.dat.dataint[i]);
			}
		}
		else if (formatInput == 3) {
			// short int data
			for (i = 0; i < numsamp; i++)
			{
				tr2.dat.data[i] = (float)(tr.dat.datashort[i]);
			}
		}
		else if (formatInput == 5) {
			// float data
			for (i = 0; i < numsamp; i++) {
				tr2.dat.data[i] = (float)(tr.dat.data[i]);
			}
		}


		BOOL isTrue = setGainCorr(&tr2, bh.format, bh.hdt, draw.sphericOrder, draw.attenuationCorr, draw.attenuationSeafloor);
		// note: here we should use bh.format instead of formatInput since tr2 is already floating point

		if (bh.format == 1) {
			float_to_ibm((int *)tr2.dat.data, (int *)tr2.dat.data, (int)numsamp);
		}
		file2.Write(&tr2, numsamp * 4 + 240);

		// progress control. Do not change
		curBytesRead = file.Seek(0, CFile::current);
		int iPos = (int)((double)curBytesRead / (double)totBytesRead*100.);
		if (iPos < 0)iPos = 0;
		if (iPos > 100)iPos = 100;
		pFrame->SetProgress(iPos);
	}	// while


	if (file) file.Close();
	if (file2) file2.Close();
	if (pFrame) {
		pFrame->EndProgress();
	}

	// now finished work. Clean up
	draw.timeSecName = outFile;

	// now we do not want the spherical corr for this file
	draw.sphericOrder = 0.f;
	draw.attenuationCorr = 0.f;


	SetModifiedFlag();
	UpdateAllViews(NULL);
	NotifyChanged();
}





void CSeisWideDoc::OnTimeRmsvelocityanalysis()
{
	if (!CheckTime(100))
	{
		return;
	}

	//static float stackWidth = 2.0f;
	//static float stackWidth2 = 3.0f;

	static int dtratio = 5;
	static float dv_out = 0.05f;
	static float secsmooth = 0.1f;
	static float percMute = 0.9f;
	static BOOL isNmoPanels = FALSE;
	static BOOL isNorm = FALSE;
	static float xmax = 0.f;
	static float vmax = 4.5f;
	static float pwr = 1.5f;      /* power of semblance */
	CString outfile;
	CString tstr;

	dlgRmsVelocityAnalysis dlg;
	dlg.m_timeSecName = draw.timeSecName;
	dlg.m_outfile = getFileNameSubdir(draw.timeSecName, _T("rms"), _T("RmsVelocity.sgy"), true);
	dlg.m_velSecName = velMod.velSecName;
	dlg.m_dtRatio = dtratio;
	dlg.m_tmax = (float)cd.coord.m_tmax;
	dlg.m_tmin = (float)cd.coord.m_tmin;
	dlg.m_vmin = 1.4f;
	dlg.m_vmax = vmax; // usually bigger velocity is not needed for rms
	dlg.m_dv = dv_out;
	dlg.m_xmax = xmax;
	dlg.m_secsmooth = secsmooth;
	dlg.m_percMute = percMute;
	dlg.m_isNmoPanels = isNmoPanels;
	dlg.m_isNorm = isNorm;
	dlg.m_pwr = pwr;

	if (dlg.DoModal() == IDOK)
	{
		draw.timeSecName = dlg.m_timeSecName.Trim();
		outfile = dlg.m_outfile;
		velMod.velSecName = dlg.m_velSecName.Trim();
		dtratio = dlg.m_dtRatio;
		cd.coord.m_tmin = dlg.m_tmin;
		cd.coord.m_tmax = dlg.m_tmax;
		vmax = dlg.m_vmax;
		velColor.vmin = dlg.m_vmin;
		dv_out = dlg.m_dv;
		xmax = dlg.m_xmax;
		secsmooth = dlg.m_secsmooth;
		percMute = dlg.m_percMute;
		isNmoPanels = dlg.m_isNmoPanels;
		isNorm = dlg.m_isNorm;
		pwr = dlg.m_pwr;
	}
	else
	{
		return;
	}
	if (!isFileExistNotDirectory(draw.timeSecName)) return;
	delete dlg;
	if (outfile.IsEmpty()) return;
	CFile fileout;
	if (!fileout.Open(outfile, CFile::modeCreate | CFile::modeReadWrite | CFile::typeBinary)) {
		tstr.Format(_T("Outfile cannot be created"));
		AfxMessageBox(tstr, MB_ICONQUESTION);
		return;
	}
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();

	tstr.Format(_T("Loading data..."));
	pFrame->myCaption(tstr);
	SegyWrapper sw(draw.timeSecName);
	if (CSegyMeta::segyHeadInit(draw.timeSecName, &head) != 1) return;
	//sw.m_tminFile = head.tminFile;
	//sw.m_tmaxFile = head.tmaxFile;
	if (!sw.open(&head, 0)) {
		fileout.Close();
		tstr.Format(_T("Input file cannot be opened properly."));
		AfxMessageBox(tstr, MB_ICONQUESTION);
		return;
	}

	CSegyMeta::segyHeadInit(draw.timeSecName, &head);
	CRayHelper::setXShotAll(head.xshotInSegy, draw.rayName, &tx);

	//	int tpp = sw.bh.hdt; // input samp rate
	int numsamp = sw.headRead.bh.nso;
	double dt = head.dtFile;
	double odt = 1. / dt;
	int nsmooth = (int)ceil(secsmooth * odt) + 1;
	if ((int)(nsmooth / 2) == nsmooth * 2) nsmooth++;  // we want odd numbers for nsmooth
	segy tr;
	bhed bhout;
	fileout.Write(head.ascHead, 3200L);
	memcpy((void *)&bhout, (void *)&sw.headRead.bh, 400L);
	double dt_out = dt*dtratio;
	int nsout = bhout.hns = (unsigned short)ceil((cd.coord.m_tmax - cd.coord.m_tmin) / dt_out) + 1;
	bhout.hdt = (unsigned short)myRound(dt_out * MIL);
	bhout.hns = (unsigned short)nsout;
	//	bhout.format = 1; // only floating is adopted for output
	bhout.format = 1; // only floating is adopted for output
	bhout.setnx((int)myRound((vmax - velColor.vmin) / dv_out));
	fileout.Write(&bhout, 400);

	segydynamic tTrc;
	tTrc.data = (float *)ealloc1float(nsout);
	segydynamic ampTrc;
	ampTrc.data = (float *)ealloc1float(nsout);

	int iv;
	int it0;
	float t0; // intercept time
	float x, v, t;
	int countTrc = 1;
	int nxStore; // for loop index

	float *numi = ealloc1float(nsmooth); // semblence nominator
	float *deno = ealloc1float(nsmooth); // semblence denominator
	float *nnz = ealloc1float(nsmooth);  // counting non-zero samples.
	float *amp = ealloc1float(nsmooth);
	float *timew = ealloc1float(nsmooth); // at each iz and ix, we produce a time window timew[] for velocity analysis
	//	int nsmoothHalf = (int)(nsmooth*0.5);

	for (iv = 0; iv < bhout.getnx(); iv++) {
		// perform NMO for v
		v = (float)(velColor.vmin + iv * dv_out);
		memset((void *)&ampTrc.data[0], (int)'\0', sizeof(float)*nsout);
		double oneov2 = 1. / (v*v);

		if (isNmoPanels) {
			for (nxStore = 0; nxStore < sw.headRead.getnx(); nxStore++) {
				x = sw.headRead.trArr[nxStore].getOffset();
				if (xmax>0.00001f && fabs(x) > xmax) continue;
				for (it0 = 0; it0<nsout; it0++) {
					tTrc.data[it0] = -1.f; // this is to initilize
					t0 = (float)(cd.coord.Y1() + it0 * dt_out);
					// muting
					t = (float)sqrt(t0*t0 + x*x*oneov2);
					if (t0 > 0.00001f && (t - t0) / t0 > percMute) {
						// need to mute this sample for rms velocity calc
						continue;
					}
					tTrc.data[it0] = t;
				} // for it0

				ints8r((int)numsamp, // ntin
					(float)dt,   // dtin
					sw.headRead.trArr[nxStore].getTraceDelay(),   // ftin
					&sw.headRead.trArr[nxStore].data[0], // yin[t=ntin], with yin[0] = y(fxin)
					0.f,  // yinl    value used to extrapolate yin values to left of yin[0]
					0.f,  // yinr	 value used to extrapolate yin values to right of yin[ntin-1]
					nsout,   // nxout
					(float *)&tTrc.data[0],  // ntout
					(float *)&ampTrc.data[0]);    // tout
				memcpy((void *)&tr, (void *)&sw.headRead.trArr[nxStore], 240L);
				tr.tracl = countTrc;
				// tr.cdp = countStack;
				tr.cdpt = 1;
				tr.ns = (unsigned short)nsout;
				tr.dt = (unsigned short)myRound(dt_out*MIL);
				tr.setTraceDelayF(cd.coord.m_tmin);

				if (bhout.format == 1) {
					float_to_ibm((int *)&ampTrc.data[0], (int *)&ampTrc.data[0], (int)nsout);
				}

				fileout.Write(&tr, 240);
				fileout.Write(&ampTrc.data[0], nsout*sizeof(float));
				countTrc++;
			} // for nxStore
		} // if isNmoPanels
		else {
			/*
			" Semblance is defined by the following quotient:			",
			"									",
			"		 n-1		 					",
			"		[ sum q(t,j) ]^2					",
			"		 j=0		 					",
			"	s(t) = ------------------					",
			"		 n-1		 					",
			"		n sum [q(t,j)]^2					",
			"		 j=0		 					",
			"									",
			" where n is the number of non-zero samples after muting.		",
			" Smoothing (nsmooth) is applied separately to the numerator and denominator",
			" before computing this semblance quotient.				",
			*/
			//################################ semblance ############################
			//########################################################################
			for (it0 = 0; it0 < nsout; it0++) {
				//tTrc.data[it0] = -1.f; // this is to initilize
				t0 = (float)(cd.coord.m_tmin + it0 * dt_out);
				memset((void *)numi, (int) '\0', sizeof(float)*nsmooth);
				memset((void *)deno, (int) '\0', sizeof(float)*nsmooth);
				memset((void *)nnz, (int) '\0', sizeof(float)*nsmooth);
				for (nxStore = 0; nxStore < sw.headRead.getnx(); nxStore++) {

					//trArr[nxStore].data[it0] = 0.f; // test line

					x = sw.headRead.trArr[nxStore].getOffset();
					if (xmax>0.00001f && fabs(x) > xmax) continue;
					// muting
					t = (float)sqrt(t0*t0 + x*x*oneov2);
					if (t0 > 0.00001f && (t - t0) / t0 > percMute) {
						// need to mute this sample for rms velocity calc
						continue;
					}

					// start interpolation of trace data for the time window (length nsmooth) around t
					for (int iw = 0; iw < nsmooth; iw++) {
						//	timew[iw] = (float)( t - dt*(nsmoothHalf-iw) );
						timew[iw] = (float)(t + dt*iw);
					}
					ints8r((int)numsamp, // ntin
						(float)dt,   // dtin
						sw.headRead.trArr[nxStore].getTraceDelay(),   // ftin
						&sw.headRead.trArr[nxStore].data[0], // yin[t=ntin], with yin[0] = y(fxin)
						0.f,  // yinl    value used to extrapolate yin values to left of yin[0]
						0.f,  // yinr	 value used to extrapolate yin values to right of yin[ntin-1]
						nsmooth,   // nxout
						(float *)&timew[0],  // ntout
						(float *)&amp[0]);    // tout
					if (isNorm) {
						// normalize before stacking
						float amax = (float)getMedianAbsolute(&amp[0], nsmooth);
						if (amax > MIL) {
							amax = 1.f / amax;
							for (int iw = 0; iw < nsmooth; iw++) amp[iw] *= amax;
						}
					}

					for (int iw = 0; iw < nsmooth; iw++) {
						if (fabs(amp[iw]) > MINAMP) {
							numi[iw] += (float)amp[iw];
							deno[iw] += (float)(amp[iw] * amp[iw]);
							nnz[iw] += 1.f;
						} // if
					} // for iw

					// test line
					//trArr[nxStore].data[it0] = amp[nsmoothHalf];

				} // for nxStore

				double nsum = 0.; // semblence numerator sum
				double dsum = 0.; // semblence denominator sum
				for (int iw = 0; iw < nsmooth; iw++) {
					nsum += numi[iw] * numi[iw];
					// dsum += nnz[iw] * deno[iw];
					dsum += deno[iw];
				} // for iw
				double weight = getMedian3(&nnz[0], nsmooth);  // weight not tested !!!!!!!
				ampTrc.data[it0] = (dsum > MINAMP) ? (float)(nsum / dsum * weight) : 0.0f;

				if (pwr != 1.0) {
					ampTrc.data[it0] = (float)pow(ampTrc.data[it0], pwr);
				};

			} // for t0
			//################################ end semblence ########################
			//########################################################################
			memcpy((void *)&tr, (void *)&sw.headRead.trArr[0], 240L);
			tr.cdp = iv;
			tr.cdpt = 1;
			tr.ns = (unsigned short)nsout;
			tr.dt = (unsigned short)myRound(dt_out * MIL);
			tr.setTraceDelayF(cd.coord.m_tmin);
			tr.setDistance((float)v);
			tr.setOffset(0.f); // zero offset in output

			tr.tracl = countTrc;  countTrc++;
			if (bhout.format == 1) {
				float_to_ibm((int *)&ampTrc.data[0], (int *)&ampTrc.data[0], (int)tr.ns);
			}
			fileout.Write(&tr, 240);
			fileout.Write(&ampTrc.data[0], bhout.hns*sizeof(float));

			// testing
			//for (j=0; j<sw.headRead.nxmax; j++) {
			//	tr.tracl = countTrc;  countTrc++;
			//	if ( ((CMainFrame*)AfxGetMainWnd())->gIsIBMFloatSegy ) {
			//		tr.idistopt = 8;
			//		float_to_ibm((int *) &trArr[j].data[0], (int *) &trArr[j].data[0], (int)tr.ns);
			//	}
			//	fileout.Write(&tr, 240);
			//	fileout.Write(&trArr[j].data[0], bhout.hns*sizeof(float));
			//} // for j

		} // if semblence

		tstr.Format(_T("v%4.3f..."), v);
		pFrame->myCaption(tstr);
	} // for iv

	free1float(numi);
	free1float(deno);
	free1float(nnz);
	free1float(amp);
	free1float(timew);

	draw.timeSecName = outfile;
	if (isNmoPanels) {
		cd.coord.drawmodeOld = cd.coord.drawmode;
		cd.coord.drawmode = 6;
		cd.coord.xmin = 0;
		cd.coord.xmax = countTrc;
		cd.coord.xTick = countTrc / 10;
		cd.coord.xTick = cd.coord.xTick / 100 * 100;
		draw.strXLabelOverwrite = _T("NMO Panels");
	}
	else {
		cd.coord.drawmodeOld = cd.coord.drawmode;
		cd.coord.drawmode = 10;	//show time section.
		cd.coord.xmin = velColor.vmin;
		cd.coord.xmax = vmax;
		cd.coord.xTick = 1;
		// draw.strXLabelOverwrite = _T("RMS Velocity (km/s)";
	}
	//if (!isFileExistNotDirectory(draw.colFileName))
	//	draw.colFileName = GetPathFromFileSlash(draw.timeSecName) + _T("colPalette.txt");
	draw.wiggle = 2;
	CSegyMeta::setSegyTotalTrace(&fileout, countTrc);

	fileout.Close();

	free1float(ampTrc.data);
	ampTrc.data = NULL;
	free1float(tTrc.data);

	draw.isRayShowing = FALSE;
	draw.red.rvred = 0.;
	cd.coord.tTick = 1;

	CVelMod vm;
	CDigitize pDg;
	velMod.m_isConvert = true;

	// now overlay with velocity model curve
	if (!isNmoPanels && isFileExistNotDirectory(velMod.velSecName)) {
		bool isSimple = false;
		CVelMod::VELMOD_X modX;
		modX.dist = tx.xShotRay;
		vm.initModX(&velMod, &modX, cd.coord.isTimeDomain() == TRUE, true, velColor.dz);


		if (!isSimple) {
			int nzmaxModelAll = (int)(modX.depthMod[velMod.ncont - 1] / velColor.dz + 2.0); // only plus 2 makes it complete
			float *twttTrc = (float *)ealloc1float(nzmaxModelAll);
			float *VrmsTrc = (float *)ealloc1float(nzmaxModelAll);
			vm.getVelocityRmsTrc(&modX, velColor.dz, nzmaxModelAll, &twttTrc[0], &VrmsTrc[0]);
			dig.initDigitizeArray(nzmaxModelAll, 1);
			dig.isZeltFormat = FALSE;
			dig.totCurve = 1;
			dig.nPoint[0] = 0;
			for (int icont = 0; icont < nzmaxModelAll; icont++) {
				int ip = dig.nPoint[0];
				dig.x[ip][0] = (float)VrmsTrc[icont];
				dig.t[ip][0] = (float)twttTrc[icont];
				dig.nPoint[0] ++;
			} // for icont
			free1float(twttTrc);
			free1float(VrmsTrc);
		}
		else {
			double *twttMod = (double *)ealloc1double(velMod.ncont);
			float *VrmsTopMod = (float *)ealloc1float(velMod.ncont);
			float *VrmsBotMod = (float *)ealloc1float(velMod.ncont);
			vm.getVelocityRmsMod(&modX, velColor.dz, x, twttMod, VrmsTopMod, VrmsBotMod);

			dig.initDigitizeArray(MOD_LAYER_MAX * 2, 1);
			dig.isZeltFormat = FALSE;
			dig.totCurve = 1;
			dig.nPoint[0] = 0;

			for (int icont = 0; icont < velMod.ncont - 1; icont++) {
				int ip = dig.nPoint[0];
				dig.x[ip][0] = (float)VrmsTopMod[icont];
				dig.t[ip][0] = (float)twttMod[icont];
				if (twttMod[icont] < cd.coord.m_tmax && twttMod[icont + 1] > cd.coord.m_tmax) {
					// we need to add a point at the axis 
					dig.x[ip + 1][0] = (float)(VrmsTopMod[icont] +
						(VrmsBotMod[icont] - VrmsTopMod[icont]) / (twttMod[icont + 1] - twttMod[icont])*(cd.coord.m_tmax - twttMod[icont]));
					dig.t[ip + 1][0] = (float)cd.coord.m_tmax;
					dig.t[ip + 2][0] = (float)twttMod[icont + 1];
					dig.x[ip + 2][0] = (float)VrmsBotMod[icont];
					dig.nPoint[0] += 3;
				}
				else {
					dig.x[ip + 1][0] = (float)VrmsBotMod[icont];
					dig.t[ip + 1][0] = (float)twttMod[icont + 1];
					dig.nPoint[0] += 2;
				}
			} // for icont

			free1double(twttMod);
			free1float(VrmsTopMod);
			free1float(VrmsBotMod);
		}




		dig.digName = digMarker.digName = GetFileNameAppendExt(velMod.velSecName, _T("_rmsVelTwttNotAni"), _T("txt"));
		CDigitize pDg;
		dig.isSortedX = dig.isSortedY = FALSE;
		pDg.myDigSaveAs2(&dig, false);
		dig.freeDigAll();
		dig.isDigitizing = FALSE;
		showFileInNotePad(dig.digName);
	} // if isNmoPanels

	draw.isSameDataDisplay = FALSE;
	SetModifiedFlag();
	UpdateAllViews(NULL);
	NotifyChanged();

}



void CSeisWideDoc::OnModelconversionRmsToIntNotUsingModel()
{
	if (velMod.velSecName.IsEmpty()) return;

	//Open file dialog.
	CFileDialog dlg(TRUE, _T("txt"), _T("*.txt"),
		OFN_HIDEREADONLY | OFN_EXPLORER,
		_T("Input file for RMS velocity vs TWTT (*.txt)|*.txt|"));

	int pathLen = draw.vrmsTauNameDisabled.ReverseFind('\\');
	CString t = draw.vrmsTauNameDisabled.Left(pathLen);
	LPCTSTR lpszFileName = t.GetBufferSetLength(t.GetLength());
	if (pathLen > (-1))
	{
		dlg.m_ofn.lpstrInitialDir = lpszFileName;
	}

	if (dlg.DoModal() == IDOK)
	{
		draw.vrmsTauNameDisabled = dlg.GetPathName();
	}
	else {
		t.ReleaseBuffer();
		return;
	}
	t.ReleaseBuffer();
	delete dlg;

	int tpp = 4000;  // will need to let user enter value



	CString tstr;
	CPoint p;
	float dt = (tpp < 1 || tpp > 70000) ? 0.008f : (float)((double)tpp / (double)MIL);
	int j;

	// first need to determine the tmin and max
	CDigitize pDg;
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	CDigitize::DIGITIZE dig2;
	dig2.digName = draw.vrmsTauNameDisabled;
	if (!pDg.myDigitizingLoadTXTUnix2(&dig2, FALSE)) {
		tstr.Format(_T("Failed to load %s"), draw.vrmsTauNameDisabled);
		pFrame->myCaption(tstr);
		return;
	}
	float tmin = dig2.t[0][0];
	float tmax = dig2.t[dig2.nPoint[0] - 1][0];
	int nt = (int)ceil((tmax - tmin) / dt) + 1;

	float *tau = (float *)ealloc1float(dig2.nPoint[0]);
	float *vrms = (float *)ealloc1float(dig2.nPoint[0]);
	float *depthTrc = (float *)ealloc1float(nt);
	float *vint = (float *)ealloc1float(nt);



	for (j = 0; j < dig2.nPoint[0]; j++) {
		tau[j] = dig2.t[j][0];
		vrms[j] = dig2.x[j][0];
	} // for j
	CVelMod vm;
	vm.getVelocityIntFromRms(dig2.nPoint[0], &tau[0], &vrms[0], nt, dt, (float)tmin, &vint[0]);
	free1float(tau);
	free1float(vrms);



	//double depth[MOD_LAYER_MAX],vTop[MOD_LAYER_MAX],vBot[MOD_LAYER_MAX];
	//getVZCurveAtDist(tx.xShotInSegy, &depth[0], &vTop[0], &vBot[0], true);
	//getDepthTrcAtTwttIntervals(velMod.ncont, (double *)&depth[0], (double *)&vTop[0], 
	//	(double *)&vBot[0], nt, (float)tmin, dt, depthTrc); 

	// we need to replace depthTrc[0:nt-1]  using  vint[0:nt-1]
	depthTrc[0] = vint[0] * tmin * 0.5f;
	for (j = 1; j < nt; j++) {
		depthTrc[j] = depthTrc[j - 1] + vint[j] * dt * 0.5f;
	}



 
	// now save to file
	dig2.initDigitizeArray(nt, 1);

	dig2.isZeltFormat = FALSE;
	dig2.totCurve = 1;
	dig2.nPoint[0] = 0;
	for (j = 0; j < nt; j++) {
		int ip = dig2.nPoint[0];
		dig2.x[ip][0] = (float)vint[j];
		dig2.t[ip][0] = (float)depthTrc[j];
		dig2.nPoint[0]++;
	} // for j
	dig2.digName = tstr = GetFileNameAppendExt(velMod.velSecName, _T("_intVel-DepthFromRmsNotUsingModel"), _T("txt"));
	dig2.isSortedX = dig2.isSortedY = FALSE;
	int isXInt = cd.coord.isTraceMode();
	pDg.myDigSaveAs2(&dig2, isXInt);
	if (!cd.coord.isTimeDomain()) draw.vrmsTauNameDisabled = tstr;
	dig2.freeDigAll();

	free1float(vint);
	free1float(depthTrc);
	showFileInNotePad(draw.vrmsTauNameDisabled);
}



void CSeisWideDoc::OnModelconversionRmsToIntUsingModel()
{
	if (velMod.velSecName.IsEmpty()) return;

	//Open file dialog.
	CFileDialog dlg(TRUE, _T("txt"), _T("*.txt"),
		OFN_HIDEREADONLY | OFN_EXPLORER,
		_T("Input file for RMS velocity vs TWTT (*.txt)|*.txt|"));

	int pathLen = draw.vrmsTauNameDisabled.ReverseFind('\\');
	CString t = draw.vrmsTauNameDisabled.Left(pathLen);
	LPCTSTR lpszFileName = t.GetBufferSetLength(t.GetLength());
	if (pathLen > (-1)) {
		dlg.m_ofn.lpstrInitialDir = lpszFileName;
	}

	if (dlg.DoModal() == IDOK) {
		draw.vrmsTauNameDisabled = dlg.GetPathName();
	}
	else {
		t.ReleaseBuffer();
		return;
	}
	t.ReleaseBuffer();
	delete dlg;

	int tpp = 4000;  // will need to let user enter value



	CString tstr;
	CPoint p;
	float dt = (tpp < 1 || tpp > 70000) ? 0.008f : (float)((double)tpp / (double)MIL);
	// this, in addition to tx.xShotInSegy, should be put input parameters
	int j;

	// first need to determine the tmin and max
	CDigitize pDg;
	CDigitize::DIGITIZE dig2;
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	dig2.digName = draw.vrmsTauNameDisabled;
	if (!pDg.myDigitizingLoadTXTUnix2(&dig2, FALSE)) {
		tstr.Format(_T("Failed to load %s"), draw.vrmsTauNameDisabled);
		pFrame->myCaption(tstr);
		return;
	}
	float tmin = dig2.t[0][0];
	float tmax = dig2.t[dig2.nPoint[0] - 1][0];
	int nt = (int)ceil((tmax - tmin) / dt) + 1;

	float *tau = (float *)ealloc1float(dig2.nPoint[0]);
	float *vrms = (float *)ealloc1float(dig2.nPoint[0]);
	float *depthTrc = (float *)ealloc1float(nt);
	float *vint = (float *)ealloc1float(nt);

	//	double depth[MOD_LAYER_MAX],vTop[MOD_LAYER_MAX],vBot[MOD_LAYER_MAX];
	CVelMod vm;
	velMod.m_isConvert = true;
	CVelMod::VELMOD_X modX;
	modX.dist = tx.xShotRay;
	vm.initModX(&velMod, &modX, cd.coord.isTimeDomain() == TRUE, true, velColor.dz);
	// vm.getZtFromZmod(&modX, nt, tmin, dt, depthTrc);

	for (j = 0; j < dig2.nPoint[0]; j++) {
		tau[j] = dig2.t[j][0];
		vrms[j] = dig2.x[j][0];
	} // for j
	vm.getVelocityIntFromRms(dig2.nPoint[0], &tau[0], &vrms[0], nt, dt, (float)tmin, &vint[0]);
	free1float(tau);
	free1float(vrms);

	// now save to file
	dig2.initDigitizeArray(nt, 1);
	dig2.isZeltFormat = FALSE;
	dig2.totCurve = 1;
	dig2.nPoint[0] = 0;
	for (j = 0; j < nt; j++) {
		int ip = dig2.nPoint[0];
		dig2.x[ip][0] = (float)vint[j];
		dig2.t[ip][0] = (float)depthTrc[j];
		dig2.nPoint[0]++;
	} // for j
	dig2.digName = tstr = GetFileNameAppendExt(velMod.velSecName, _T("_intVel-DepthFromRmsUsingModel"), _T("txt"));
	dig2.isSortedX = dig2.isSortedY = FALSE;
	int isXInt = cd.coord.isTraceMode();
	pDg.myDigSaveAs2(&dig2, isXInt);

	free1float(vint);
	free1float(depthTrc);
	showFileInNotePad(draw.vrmsTauNameDisabled);
	if (!cd.coord.isTimeDomain()) draw.vrmsTauNameDisabled = tstr;

}


void CSeisWideDoc::OnModelconversionRmsToIntTwtt()
{
	CFileDialog dlg(TRUE, _T("txt"), _T("*.txt"),
		OFN_HIDEREADONLY | OFN_EXPLORER,
		_T("Input file for RMS velocity vs TWTT (*.txt)|*.txt|"));

	int pathLen = draw.vrmsTauNameDisabled.ReverseFind('\\');
	CString t = draw.vrmsTauNameDisabled.Left(pathLen);
	LPCTSTR lpszFileName = t.GetBufferSetLength(t.GetLength());
	if (pathLen > (-1)) {
		dlg.m_ofn.lpstrInitialDir = lpszFileName;
	}

	if (dlg.DoModal() == IDOK) {
		draw.vrmsTauNameDisabled = dlg.GetPathName();
	}
	else {
		t.ReleaseBuffer();
		return;
	}
	t.ReleaseBuffer();
	delete dlg;

	// int tpp = 4000;  // will need to let user enter value

	CString tstr;
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	CDigitize pDg;
	CDigitize::DIGITIZE dig2;
	dig2.digName = draw.vrmsTauNameDisabled;
	if (!pDg.myDigitizingLoadTXTUnix2(&dig2, FALSE)) {
		tstr.Format(_T("Failed to load %s"), draw.vrmsTauNameDisabled);
		pFrame->myCaption(tstr);
		return;
	}
	int np = dig2.nPoint[0];
	float tmin = dig2.t[0][0];
	float tmax = dig2.t[np - 1][0];
	//	float dt = (tpp<1 || tpp > 70000) ?  0.008f  :   (float)( 2. * (double)tpp / (double)MIL); 
	// this should be put input parameters

	//	int nt = (int)myRound( (tmax - tmin) / dt);
	int j;
	float *tau = (float *)ealloc1float(np);
	float *vrms = (float *)ealloc1float(np);
	float *vint = (float *)ealloc1float(np);
	for (j = 0; j < np; j++) {
		tau[j] = dig2.t[j][0];
		vrms[j] = dig2.x[j][0];
	} // for j
	// getVelocityIntFromRms(dig.nPoint[0], &tau[0], &vrms[0], nt, dt, (float)tmin, &vint[0]);
	CVelMod vm;
	vm.getVelocityIntFromRms(np, &tau[0], &vrms[0], &vint[0]);
	free1float(tau);
	free1float(vrms);

	// now save to file
	dig2.initDigitizeArray(np*2, 1);
	dig2.isZeltFormat = FALSE;
	dig2.totCurve = 1;
	for (j = 0; j < np - 1; j++) {
		dig2.x[j * 2][0] = vint[j];
		dig2.t[j * 2][0] = tau[j];
		dig2.x[j * 2 + 1][0] = vint[j];
		dig2.t[j * 2 + 1][0] = tau[j + 1];
	} // for j
	dig2.nPoint[0] = np * 2;

	free1float(vint);
	dig2.digName = tstr = GetFileNameAppendExt(velMod.velSecName, _T("_intVel-TwttFromRms"), _T("txt"));
	dig2.isSortedX = dig2.isSortedY = FALSE;
	int isXInt = cd.coord.isTraceMode();
	pDg.myDigSaveAs2(&dig2, isXInt);
	showFileInNotePad(tstr);
	if (cd.coord.isTimeDomain()) draw.vrmsTauNameDisabled = tstr;
}


void CSeisWideDoc::OnModelconversionIntToRmsvelocity()
{
	if (cd.coord.isTimeDomain()) {
		AfxMessageBox(_T("Please show a model first."));
		return;
	}
	if (!isFileExistNotDirectory(velMod.velSecName)) return;
	if (velMod.ncont < 2) return;

	// tx.xShotInSegy, should be put input parameters
	if (velColor.dz < 0.00001 || velColor.dz > 1.) velColor.dz = 0.008;
	CString tStr;

	CdlgVZCurve dlg;
	dlg.m_xShot = (float)tx.xShotRay;
	if (dlg.DoModal() == IDOK)
		tx.xShotRay = dlg.m_xShot;
	else
		return;

	bool isSimple = false;
	//double depth[MOD_LAYER_MAX],vTop[MOD_LAYER_MAX],vBot[MOD_LAYER_MAX];
	CVelMod::VELMOD_X modX;
	CVelMod vm;
	velMod.m_isConvert = true;
	modX.dist = tx.xShotRay;
	vm.initModX(&velMod, &modX, cd.coord.isTimeDomain() == TRUE, true, velColor.dz);
	int numWaterLayers = (modX.vTop[1] > 1.55 || modX.vBot[1] > 1.55) ? 1 : 2;
	double *twttMod = (double *)ealloc1double(velMod.ncont);
	float *VrmsTopMod = (float *)ealloc1float(velMod.ncont);
	float *VrmsBotMod = (float *)ealloc1float(velMod.ncont);
	vm.getVelocityRmsMod(&modX, velColor.dz, tx.xShotRay, twttMod, VrmsTopMod, VrmsBotMod);
	CDigitize pDg;
	double tsf = twttMod[numWaterLayers];
	dig.initDigitizeArray(MOD_LAYER_MAX * 2, 1);
	dig.isZeltFormat = FALSE;
	dig.totCurve = 1;
	dig.nPoint[0] = 0;

	for (int icont = 1; icont < velMod.ncont - 1; icont++) {
		register int ip = dig.nPoint[0];
		dig.x[ip][0] = (float)myRound(1000.f * VrmsTopMod[icont]);
		dig.t[ip][0] = (float)myRound(1000.f * (twttMod[icont] - tsf));
		dig.nPoint[0] ++;
	} // for icont
	free1double(twttMod);
	free1float(VrmsTopMod);
	free1float(VrmsBotMod);
	digMarker.digName = getFileNameSubdir(velMod.velSecName, _T("rms"), _T("RmsVelocityAtMod.txt"), true);
	tStr.Format(_T("#RmsVelocity(m/s)  TWTT_Below_Seafloor(ms) calculated at %f km at model boundary only; %s"), tx.xShotRay, velMod.velSecName);
	dig.digName = digMarker.digName;
	dig.strComment += tStr;
	dig.isSortedX = dig.isSortedY = FALSE;
	int isXInt = cd.coord.isTraceMode();
	pDg.myDigSaveAs2(&dig, isXInt);


	showFileInNotePad(digMarker.digName);

	draw.isSameDataDisplay = FALSE; //internal control and not saved.
	SetModifiedFlag();
	UpdateAllViews(NULL);
	NotifyChanged();
}




void CSeisWideDoc::OnModelconversionTormsvelocity2()
{
	// convert model to RMS velocity without considering anisotropy
	if (cd.coord.isTimeDomain()) {
		AfxMessageBox(_T("Please show a model first."));
		return;
	}
	if (!isFileExistNotDirectory(velMod.velSecName)) return;

	// tx.xShotInSegy, should be put input parameters
	if (velColor.dz < 0.00001 || velColor.dz > 1.) velColor.dz = 0.008;

	CdlgVZCurve dlg;
	dlg.m_xShot = (float)tx.xShotRay;
	if (dlg.DoModal() == IDOK)
		tx.xShotRay = dlg.m_xShot;
	else
		return;

	CString tStr;
	bool isSimple = false;
	// double depth[MOD_LAYER_MAX],vTop[MOD_LAYER_MAX],vBot[MOD_LAYER_MAX];
	CVelMod::VELMOD_X modX;
	CVelMod vm;
	velMod.m_isConvert = true;
	modX.dist = tx.xShotRay;
	vm.initModX(&velMod, &modX, cd.coord.isTimeDomain() == TRUE, false, velColor.dz);

	float *VrmsTopMod = (float *)ealloc1float(velMod.ncont);
	float *VrmsBotMod = (float *)ealloc1float(velMod.ncont);
	vm.getVelocityRmsMod(&modX, velColor.dz, tx.xShotRay, modX.timeMod, VrmsTopMod, VrmsBotMod);
	//int numWaterLayers = (modX.vTop[1] > 1.55 || modX.vBot[1] > 1.55) ? 1 : 2;
	double tsf = modX.timeMod[NUM_WATER_LAYER];
	//



	if (!isSimple) {
		int nzmaxModelAll = (int)(modX.depthMod[velMod.ncont - 1] / velColor.dz + 2.0); // only plus 2 makes it complete
		float *twttTrc = (float *)ealloc1float(nzmaxModelAll);
		float *VrmsTrc = (float *)ealloc1float(nzmaxModelAll);
		vm.getVelocityRmsTrc(&modX, velColor.dz, nzmaxModelAll, &twttTrc[0], &VrmsTrc[0]);
		dig.initDigitizeArray(nzmaxModelAll, 1);
		dig.isZeltFormat = FALSE;
		dig.totCurve = 1;
		dig.nPoint[0] = 0;
		for (int j = 0; j < nzmaxModelAll; j++) {
			if (twttTrc[j] < tsf) continue;
			int ip = dig.nPoint[0];
			dig.x[ip][0] = (float)myRound(1000.f * VrmsTrc[j]);
			dig.t[ip][0] = (float)myRound(1000.f * (twttTrc[j] - tsf));
			dig.nPoint[0] ++;
		} // for icont
		free1float(twttTrc);
		free1float(VrmsTrc);
	}
	else {
		// this part not tested
		dig.initDigitizeArray(MOD_LAYER_MAX * 2, 1);
		dig.isZeltFormat = FALSE;
		dig.totCurve = 1;
		dig.nPoint[0] = 0;

		for (int icont = 0; icont < velMod.ncont - 1; icont++) {
			int ip = dig.nPoint[0];
			dig.x[ip][0] = (float)VrmsTopMod[icont];
			dig.t[ip][0] = (float)modX.timeMod[icont];
			dig.nPoint[0] ++;
		} // for icont
	}

	free1float(VrmsTopMod);
	free1float(VrmsBotMod);

	tStr.Format(_T("#RmsVelocity(m/s)  TWTT_Below_Seafloor(ms) calculated at %f km; %s. No Anisotrophy considered."), 
		velMod.wells[0].wellDist, velMod.velSecName);
	// dig.digName = velMod.markerName = GetFileNameAppendExt(velMod.velSecName, _T("_rmsVelTwttNoAnisotropy", _T("txt");
	dig.digName = digMarker.digName = getFileNameSubdir(velMod.velSecName, _T("rms"), _T("RmsVelocityNoAni.txt"), true);
	dig.strComment += tStr;
	dig.isSortedX = dig.isSortedY = FALSE;
	int isXInt = cd.coord.isTraceMode();
	CDigitize pDg;
	pDg.myDigSaveAs2(&dig, isXInt);
	showFileInNotePad(dig.digName);

	draw.isSameDataDisplay = FALSE; //internal control and not saved.
	SetModifiedFlag();
	UpdateAllViews(NULL);
	NotifyChanged();

}

void CSeisWideDoc::OnSonobuoyAutocalculateoffsetfromlat()
{
	static double xlong_sb = -148.268178;
	static double ylat_sb = 77.260971;
	static float aFactor = 1.f;
	static BOOL isFactorMIL = TRUE;
	CString tstr;
	BOOL isMarkupError = FALSE;

	CdlgSonobuoyAutoOffset dlg2;
	dlg2.m_timeSecName = draw.timeSecName;
	dlg2.m_long = xlong_sb;
	dlg2.m_lat = ylat_sb;
	dlg2.m_factor = aFactor;
	dlg2.m_markupError = isMarkupError;
	if (dlg2.DoModal() == IDOK) {
		draw.timeSecName = dlg2.m_timeSecName.Trim();
		xlong_sb = dlg2.m_long;
		ylat_sb = dlg2.m_lat;
		aFactor = dlg2.m_factor;
		isMarkupError = dlg2.m_markupError;
	}
	else return;

	bool isHeaderOnly = !head.isUnixFile && (head.formatFile == 1 || head.formatFile == 5);

	SegyWrapper sw(draw.timeSecName, isHeaderOnly);
	if (CSegyMeta::segyHeadInit(draw.timeSecName, &head) != 1) return;
	if (sw.open(&head, 0)) {
		if (sw.headRead.getnx() < 2) return;

		int gx, gy;
		for (int ix = 0; ix < sw.headRead.getnx(); ix++) {
			gx = sw.headRead.trArr[ix].gx;
			gy = sw.headRead.trArr[ix].gy;

			register double oFactor = 1.;
			if (isMarkupError) {
				if (sw.headRead.trArr[ix].counit == 2) {
					sw.headRead.trArr[ix].counit = 0;
				}
				else if (sw.headRead.trArr[ix].counit == 0) {
					sw.headRead.trArr[ix].counit = 2;
				}
			}
			if (sw.headRead.trArr[ix].counit == 2) oFactor = 1. / 360000.;
			else if (sw.headRead.trArr[ix].counit == 0) oFactor = OMIL;

			register double xlong = gx*oFactor*aFactor;
			register double ylat = gy*oFactor*aFactor;
			register double anOffset = (double)calcDist(xlong_sb, ylat_sb, xlong, ylat);
			sw.headRead.trArr[ix].setOffset((float)anOffset);
		}

		bool isHeaderUpdNeeded = false;
		for (int ix = 0; ix < sw.headRead.getnx(); ix++) {
			gx = sw.headRead.trArr[ix].gx;
			gy = sw.headRead.trArr[ix].gy;
			if (abs(gx) == 0 && abs(gy) == 0) {
				// we have an invalid lat/long. let's fix it

				// we search the correct lat/long on the left
				int i1 = -1;
				for (int i = ix - 1; i >= 0; i--) {
					if (abs(sw.headRead.trArr[i].gx) > 0 || abs(sw.headRead.trArr[i].gy) > 0) {
						i1 = i;
						break;
					}
				} // for i

				// we search the correct lat/long on the right
				int i2 = -1;
				for (int i = ix + 1; i < sw.headRead.getnx(); i++) {
					if (abs(sw.headRead.trArr[i].gx) > 0 || abs(sw.headRead.trArr[i].gy) > 0) {
						i2 = i;
						break;
					}
				} // for i

				if (i1 < 0 && i2>0 && i2<sw.headRead.getnx()-1) {
					// this situ actually happens
					i1 = i2;
					i2 += 1;
				}
				
				if (i1 >= 0 && i2 > i1) {
					// let's interpolate
					int trace1 = sw.headRead.trArr[i1].tracl;
					int trace2 = sw.headRead.trArr[i2].tracl;
					sw.headRead.trArr[ix].gx = sw.headRead.trArr[i1].gx + (int)myRound((double)(sw.headRead.trArr[i2].gx - sw.headRead.trArr[i1].gx) * (double)(sw.headRead.trArr[ix].tracl - trace1) / (double)(trace2 - trace1));
					sw.headRead.trArr[ix].gy = sw.headRead.trArr[i1].gy + (int)myRound((double)(sw.headRead.trArr[i2].gy - sw.headRead.trArr[i1].gy) * (double)(sw.headRead.trArr[ix].tracl - trace1) / (double)(trace2 - trace1));
					sw.headRead.trArr[ix].offset = sw.headRead.trArr[i1].offset + (int)myRound((double)(sw.headRead.trArr[i2].offset - sw.headRead.trArr[i1].offset) * (double)(sw.headRead.trArr[ix].tracl - trace1) / (double)(trace2 - trace1));
					isHeaderUpdNeeded = true;
				}
				else
					continue;
			} // if

		} // for ix


		//int num = 0;
		//if (sw.getCountNonMonoOffset(1) > 0) {
		//	sw.sortDistance(1);
		//	num = sw.writeDataAll(sw.m_f);
		//}
		//else
		int num = sw.writeHeaderOnly();

		tstr.Format(_T("%d traces are successfully updated in offsets."), num);
		CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
		pFrame->myCaption(tstr);
	} // if sw.open
}


void CSeisWideDoc::OnSonobuoyPolyTrace()
{
	if (cd.coord.drawmode != 6) return OnSonobuoyPoly();
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();

	CString tStr;
	if (!isFileExistNotDirectory(draw.timeSecName))  {
		tStr.Format(_T(" To assign offsets for sonobuoy data, please display a time section with trace or km or NMO."));
		AfxMessageBox(tStr, MB_ICONQUESTION);
		return;
	}
	if (!dig.isDigitizing) {
		// the user is not digitizing. 
		tStr.Format(_T(" To assign offsets for sonobuoy data, please display a time section with trace or km or NMO, and digitize 1 segment only for the water wave, and then try again."));
		AfxMessageBox(tStr, MB_ICONQUESTION);
		return;
	}



	if (dig.nPoint == NULL || dig.nPoint[0] < 2) {
		tStr.Format(_T(" At least 2 points are needed on the direct water wave to obtain distance"));
		AfxMessageBox(tStr, MB_ICONQUESTION);
		return;
	}


	static float polyA = -0.006f; // typical for Arctic area
	static float polyB = draw.red.waterVelocityAboveObs; // this value is the one GSCA used, in km
	static float polyC = 0.00075f;
	static float gunDelay = 0.051f; // these values are the ones GSCA used, in km, sec
	static BOOL isInterpol4Zero = FALSE;
	static BOOL isMono = true;

	// static float VavgWater = 1.44f; // this water velocity is for hyperbola formula only, not for Nina's
	static float xHyperbola = 1.f;
	// static BOOL isUpdatePartial = FALSE;
	BOOL isGunDelayCorr = FALSE;

	CdlgSonobuoyPoly dlg;
	dlg.m_polyA = polyA;
	dlg.m_polyB = polyB;
	dlg.m_polyC = polyC;
	dlg.m_gunDelay = gunDelay;
	dlg.m_isGunDelayCorr = isGunDelayCorr;
	dlg.m_isIntopol4Zero = isInterpol4Zero;
	dlg.m_isMono = isMono;
	// addition on Apr 12, 2012
	dlg.m_vred = draw.red.waterVelocityAboveObs;
	dlg.m_buoydepth = draw.red.obsDepth;
	dlg.m_xHyperbola = xHyperbola;

	if (dlg.DoModal() == IDOK)
	{
		polyA = dlg.m_polyA;
		polyB = dlg.m_polyB;
		polyC = dlg.m_polyC;
		gunDelay = dlg.m_gunDelay;
		isGunDelayCorr = dlg.m_isGunDelayCorr;
		isInterpol4Zero = dlg.m_isIntopol4Zero;
		isMono = dlg.m_isMono;
		draw.red.waterVelocityAboveObs = dlg.m_vred;
		draw.red.obsDepth = dlg.m_buoydepth;
		xHyperbola = dlg.m_xHyperbola;
	}
	else return;

	//	digIsUpdatePartial = FALSE;  // disable it since it cuts digitized points, need to fix it first.

	if (fabs(xHyperbola) > 0.f && draw.red.waterVelocityAboveObs < 0.00001f) {
		tStr.Format(_T(" For hyperbola formula, water velocity cannot be zero."));
		AfxMessageBox(tStr, MB_ICONQUESTION);
		return;
	}

	// first check if the digitized points have odds
	int iUserRes = -1;
	for (register int i = 0; i < dig.nPoint[0] - 1; i++) {
		if (!SAME_SIGN(dig.x[i][0], dig.x[i + 1][0])) continue;  // if the points are on both sides of SB/OBS, ignore comparison
		// if (digIsUpdatePartial &&  !isInsideFloat(dig.x[i][0], (float)cd.coord.X1(), (float)cd.coord.X2())) continue;

		// 0.13 sec would correspond 200 m trace spacing
		register double aDeltaX = fabs(dig.x[i + 1][0] - dig.x[i][0]);
		if (aDeltaX < MINAMP) continue;
		if (fabs(dig.t[i + 1][0] - dig.t[i][0]) / aDeltaX > 0.13) {
			tStr.Format(_T(" Picked times are irregular: (%f, %f)sec at traces (%d, %d). Ignore? No to ignore all"),
				dig.t[i][0], dig.t[i + 1][0], (int)dig.x[i][0], (int)dig.x[i + 1][0]);
			if (iUserRes != IDNO) {
				iUserRes = AfxMessageBox(tStr, MB_YESNOCANCEL | MB_ICONINFORMATION | MB_ICONQUESTION);
				if (iUserRes == IDCANCEL) {
					showFileInNotePad(dig.digName);
					return;
				}
			}
		}
	} // for i

	CDigitize pDg;
	CDigitize::DIGITIZE dig2;
	if (!dig2.initDigitizeArray(dig.nPoint[0], 1)) return;

	float range;
	float tw; // water wave travel time
	float offset;


	// before opening the segy file, we want to mark up some traces that have invalid offset info, and fix them up, otherwise
	// those traces will never have any valid offset info written by this routine! This has been found to be happening in some segys!
	SegyWrapper sw(draw.timeSecName, false);
	if (CSegyMeta::segyHeadInit(draw.timeSecName, &head) != 1) return;
	//sw.m_tminFile = head.tminFile;
	//sw.m_tmaxFile = head.tmaxFile;
	if (sw.open(&head, 0)) {
		if (sw.headRead.getnx() < 2) return;
	}

	// dig must already be sorted along X-axis
	pDg.myDigSortX2(&dig, cd.coord.X1(), cd.coord.X2());
	dig2.nPoint[0] = 0;
	dig2.isZeltFormat = FALSE;
	//	dig2.digName = isEndWith(dig.digName, _T("_Poly.txt")) ? dig.digName : GetFileNameAppendExt(dig.digName, _T("_Poly"), _T("txt")); // this name is needed before the following loop since it will auto write once the limit is reached
	//	bool isPrompt = true;
	int num = dig.nPoint[0];


	// sometimes the raw data contains no trace numbers, which must be corrected
	if (sw.headRead.trArr[0].tracl == 0) {
		for (int ix = 0; ix < sw.headRead.getnx(); ix++) {
			sw.headRead.trArr[ix].tracl = ix + 101;
		}
	}
	for (int ix = 0; ix < sw.headRead.getnx(); ix++) {
		range = (float)sw.headRead.trArr[ix].tracl;
		//		dig.x[][0] is actually digitized shot number
		//		dig.t[][0] is digitized absolute time in sec.

		if (range < dig.x[0][0]) {
			tw = dig.t[0][0] + (dig.t[1][0] - dig.t[0][0])
				/ (dig.x[1][0] - dig.x[0][0])*(range - dig.x[0][0]);
		}
		else if (range > dig.x[num - 1][0]) {
			tw = dig.t[num - 2][0] + (dig.t[num - 1][0] - dig.t[num - 2][0])
				/ (dig.x[num - 1][0] - dig.x[num - 2][0])*(range - dig.x[num - 2][0]);
		}
		else {
			for (register int i = 0; i < num - 1; i++) {
				if (range >= dig.x[i][0] && range <= dig.x[i + 1][0]) {
					if (dig.x[i][0] != dig.x[i + 1][0])
						tw = dig.t[i][0] + (dig.t[i + 1][0] - dig.t[i][0])
						/ (dig.x[i + 1][0] - dig.x[i][0])*(range - dig.x[i][0]);
					else
						tw = dig.t[i][0];
					break;
				} // if range
			} // for i
		} // else

		// do a static shift to correect for airgun delay
		if (isGunDelayCorr) {
			// range is now the travel time (sec) of the direct water wave. We apply source delay time
			tw -= gunDelay;
			sw.headRead.trArr[ix].setTraceDelayF(sw.headRead.trArr[ix].getTraceDelay() - gunDelay);
		}


		//convert time to range in km.
		offset = polyA + polyB*tw + polyC*tw*tw;
		if (fabs(offset) < xHyperbola) {
			// now we use our conventional formula of hyperbola
			float aPositive = (tw*tw*draw.red.waterVelocityAboveObs*draw.red.waterVelocityAboveObs) -
				draw.red.obsDepth * draw.red.obsDepth;
			if (aPositive >= 0.f)
				offset = (float)sqrt(aPositive);
		}

		bool isPositiveOffset = range >= 0;
		if (!isPositiveOffset) offset = -(float)fabs(offset);
		sw.headRead.trArr[ix].setOffset(offset);  // I give up on negative offsets
		int aInt = 0;
		pDg.myDigAddPoint(&dig2, aInt, offset, tw);

		tStr.Format(_T("T%d."), sw.headRead.trArr[ix].tracl);
		pFrame->myCaption(tStr);
	} // for ix

	if (isMono) {
		// note: dig2 contains the same num of points as trace numbers, and 
		//       dig2 is not sorted yet. So we need to find all its irregularities and correct for them
		int nxDig = min(dig2.nPoint[0], sw.headRead.getnx());
		for (int ix = 0; ix < nxDig - 1; ix++) {
			if (dig2.x[ix][0] >= dig2.x[ix + 1][0]) {
				register float xRef = dig2.x[ix][0]; // this is a good ref
				register int nxInterpol = -1;

				// irregularity found. Look for the end of the irregulary
				for (register int i = ix + 2; i < nxDig - 1; i++) {
					if (dig2.x[i][0] > xRef) {
						// found it
						nxInterpol = i;
						break;
					}
				}

				if (nxInterpol > ix) {
					// now we need to interpolate for traces of [ix+1, nxInterpol-1]
					register float xRef2 = dig2.x[nxInterpol][0];
					register float dx = (xRef2 - xRef) / (float)(nxInterpol - ix + 1);
					for (register int i = ix + 1; i < nxInterpol; i++) {
						dig2.x[i][0] = xRef + (i - ix)*dx;
						sw.headRead.trArr[i].setOffset(dig2.x[i][0]);
					}
				}
			} // if dig2.x
		} // for ix
	}

	sw.writeDataAll(draw.timeSecName);
	pDg.myDigSortX2(&dig2);	// this must be done for each loop!  prob: after this sort, na should be changed!
	dig.isSortedX = TRUE;
	dig.isSortedY = FALSE;
	int isXInt = cd.coord.isTraceMode();
	pDg.myDigSaveAs2(&dig2, isXInt);
	if (!isEndWith(dig.digName, _T("_PolyTrc.txt")))
		dig2.digName = getFileNameAppend(dig.digName, _T("_PolyTrc"));
	else
		dig2.digName = dig.digName;
	dig.digName = dig2.digName;  // this will make the display to show the newer version with _Poly.txt
	pDg.myDigitizingLoadTXTUnix2(&dig);


	tStr.Format(_T("Offset information is assigned successfully."));
	if (isGunDelayCorr)
		tStr += _T(" Correction for gun delay is also applied.");

	tStr += _T(" Revised offset vs direct arrival time is stored in: ") + dig2.digName;
	tStr += _T(" You may revise the digitization and assign offsets again.");

	static bool isShowMsgBox = true;
	if (isShowMsgBox) {
		AfxMessageBox(tStr, MB_ICONQUESTION);
		isShowMsgBox = false;
	}
	else
		pFrame->myCaption(tStr);


	register int i = dig2.nPoint[0];
	if (i > 0) {
		// with trace display, we need to switch distance display
		
		cd.coord.xmin = (float)myRound(dig2.getXmin(0));
		cd.coord.xmax = (float)myRound(dig2.getXmax(0));
		cd.coord.m_tmin = -.2;
		cd.coord.m_tmax = .5;
		cd.coord.isDistanceDisplay = FALSE;
		cd.coord.trace1 = 0;
		cd.coord.trace2 = 99999;
		cd.coord.xTick = (float)(myRound((cd.coord.xmax - cd.coord.xmin) / 100)*10.);
		draw.red.rvred = 1. / (.01 + draw.red.waterVelocityAboveObs);
		cd.coord.drawmodeOld = cd.coord.drawmode;
		cd.coord.drawmode = 0;
		draw.basePower = 1.0;
		draw.gainDist = TRUE;
		areaFill.gain *= 0.01;  // since the variable gain is used, the gain must be smaller
		dig2.freeDigAll(); //  we need destroy whatever in there first
		dig.freeDigAll();
		dig.isDigitizing = FALSE;  // must stop digitizing, otherwise the trace and offset domains are messed up!
		cd.zoom.isZooming = 0; // zoom paras will not make sense when display mode changes
	}

	//	draw.timeSecOld = BLANK;  // this will re-calc for amp inilization
	draw.isSameDataDisplay = FALSE;

	//	SetModifiedFlag();
	UpdateAllViews(NULL);
	NotifyChanged();

}

void CSeisWideDoc::OnSonobuoyPoly()
{
	/*
	Nina's empirical formula for offset X  vs direct water wave time Tw.
	X = 1.441Tw + 0.00075Tw*Tw - 0.006
	with an error estimates of
	<20m for X<35km
	*/
	if (cd.coord.drawmode == 6) return OnSonobuoyPolyTrace();
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();

	CString tStr;
	if (!isFileExistNotDirectory(draw.timeSecName) ||
		(cd.coord.drawmode != 0 && cd.coord.drawmode != 6 && cd.coord.drawmode != 7))  {
		tStr.Format(_T(" To assign offsets for sonobuoy data, please display a time section with trace or km or NMO."));
		AfxMessageBox(tStr, MB_ICONQUESTION);
		return;
	}
	if (!dig.isDigitizing) {
		// the user is not digitizing. 
		tStr.Format(_T(" To assign offsets for sonobuoy data, please display a time section with trace or km or NMO, and digitize 1 segment only for the water wave, and then 'Associate km to Sonobuoy Traces' to obtain the distance"));
		AfxMessageBox(tStr, MB_ICONQUESTION);
		return;
	}
	if (cd.coord.isDistanceDisplay) {
		tStr.Format(_T(" Sorry, cannot assign offsets with distance display"));
		AfxMessageBox(tStr, MB_ICONQUESTION);
		return;
	}



	if (dig.nPoint == NULL || dig.nPoint[0] < 2) {
		tStr.Format(_T(" At least 2 points are needed on the direct water wave to obtain distance"));
		AfxMessageBox(tStr, MB_ICONQUESTION);
		return;
	}


	static float polyA = -0.006f; // typical for Arctic area
	static float polyB = draw.red.waterVelocityAboveObs; // this value is the one GSCA used, in km
	static float polyC = 0.00075f;
	static float gunDelay = 0.051f; // these values are the ones GSCA used, in km, sec
	static BOOL isInterpol4Zero = FALSE;
	static BOOL isMono = true;

	// static float VavgWater = 1.44f; // this water velocity is for hyperbola formula only, not for Nina's
	static float xHyperbola = 4.f;
	// static BOOL isUpdatePartial = FALSE;
	BOOL isGunDelayCorr = FALSE;

	CdlgSonobuoyPoly dlg;
	dlg.m_polyA = polyA;
	dlg.m_polyB = polyB;
	dlg.m_polyC = polyC;
	dlg.m_gunDelay = gunDelay;
	dlg.m_isGunDelayCorr = isGunDelayCorr;
	dlg.m_isIntopol4Zero = isInterpol4Zero;
	dlg.m_isMono = isMono;

	// addition on Apr 12, 2012
	dlg.m_vred = draw.red.waterVelocityAboveObs;
	dlg.m_buoydepth = draw.red.obsDepth;
	dlg.m_xHyperbola = xHyperbola;

	if (dlg.DoModal() == IDOK)
	{
		polyA = dlg.m_polyA;
		polyB = dlg.m_polyB;
		polyC = dlg.m_polyC;
		gunDelay = dlg.m_gunDelay;
		isGunDelayCorr = dlg.m_isGunDelayCorr;
		isInterpol4Zero = dlg.m_isIntopol4Zero;
		isMono = dlg.m_isMono;

		draw.red.waterVelocityAboveObs = dlg.m_vred;
		draw.red.obsDepth = dlg.m_buoydepth;
		xHyperbola = dlg.m_xHyperbola;
	}
	else return;

	if (fabs(xHyperbola) > 0.f && draw.red.waterVelocityAboveObs < 0.00001f) {
		tStr.Format(_T(" For hyperbola formula, water velocity cannot be zero."));
		AfxMessageBox(tStr, MB_ICONQUESTION);
		return;
	}

	// first check if the digitized points have odds
	// this->OnDigitizingSavedig(); // save first
	CDigitize pDg;
	int isXInt = cd.coord.isTraceMode();
	pDg.myDigSaveAs2(&dig, isXInt);

	int iUserRes = -1;
	for (int i = 0; i < dig.nPoint[0] - 1; i++) {
		if (!SAME_SIGN(dig.x[i][0], dig.x[i + 1][0])) continue;  // if the points are on both sides of SB/OBS, ignore comparison
		// register double deltat = fabs(dig.t[i + 1][0] - dig.t[i][0]);
		if (fabs(dig.t[i + 1][0] - dig.t[i][0]) > 0.01) {
			if (iUserRes != IDNO) {
				tStr.Format(_T(" Picked times are irregular: (%f, %f)sec at (%f, %f)km. Ignore? No to ignore all."),
					dig.t[i][0], dig.t[i + 1][0], dig.x[i][0], dig.x[i + 1][0]);
				iUserRes = AfxMessageBox(tStr, MB_YESNOCANCEL | MB_ICONINFORMATION | MB_ICONQUESTION);
				if (iUserRes == IDCANCEL) {
					showFileInNotePad(dig.digName);
					return;
				}
			}
		}
	} // for i




	// before opening the segy file, we want to mark up some traces that have invalid offset info, and fix them up, otherwise
	// those traces will never have any valid offset info written by this routine! This has been found to be happening in some segys!
	SegyWrapper sw(draw.timeSecName, false);
	if (CSegyMeta::segyHeadInit(draw.timeSecName, &head) != 1) return;
	if (sw.open(&head, 0)) {
		if (sw.headRead.getnx() < 2) return;
	}

	float offset;
	if (isInterpol4Zero) {
		register int gx, gy;
		//	bool isHeaderUpdNeeded = false;
		for (register int ix = 0; ix < sw.headRead.getnx(); ix++) {
			gx = sw.headRead.trArr[ix].gx;
			gy = sw.headRead.trArr[ix].gy;
			if (abs(gx) == 0 && abs(gy) == 0) {
				// we have an invalid lat/long. let's fix it

				// we search the correct lat/long on the left
				register int i1 = -1;
				for (register int i = ix - 1; i >= 0; i--) {
					if (abs(sw.headRead.trArr[i].gx) > 0 || abs(sw.headRead.trArr[i].gy) > 0) {
						i1 = i;
						break;
					}
				} // for i

				// we search the correct lat/long on the right
				register int i2 = -1;
				for (register int i = ix + 1; i < sw.headRead.getnx(); i++) {
					if (abs(sw.headRead.trArr[i].gx) > 0 || abs(sw.headRead.trArr[i].gy) > 0) {
						i2 = i;
						break;
					}
				} // for i

				if (i1 >= 0 && i2 > i1) {
					// let's interpolate
					register int trace1 = sw.headRead.trArr[i1].tracl;
					register int trace2 = sw.headRead.trArr[i2].tracl;
					sw.headRead.trArr[ix].gx = sw.headRead.trArr[i1].gx +
						(int)myRound((double)(sw.headRead.trArr[i2].gx - sw.headRead.trArr[i1].gx) * (double)(sw.headRead.trArr[ix].tracl - trace1) / (double)(trace2 - trace1));
					sw.headRead.trArr[ix].gy = sw.headRead.trArr[i1].gy +
						(int)myRound((double)(sw.headRead.trArr[i2].gy - sw.headRead.trArr[i1].gy) * (double)(sw.headRead.trArr[ix].tracl - trace1) / (double)(trace2 - trace1));
					offset = sw.headRead.trArr[i1].getOffset() +
						(sw.headRead.trArr[i2].getOffset() - sw.headRead.trArr[i1].getOffset()) * (float)(sw.headRead.trArr[ix].tracl - trace1) / (float)(trace2 - trace1);
					sw.headRead.trArr[ix].setOffset(offset);
				}
				else
					continue;
			} // if
		} // for ix
	} // if isInterpol4Zero

	// Fix invalid offsets if any
	for (int ix = 0; ix < sw.headRead.getnx(); ix++) {
		if (abs(sw.headRead.trArr[ix].offset) > MIL) {
			if (ix == 0) {
				if (abs(sw.headRead.trArr[ix + 1].offset) < MIL) {
					sw.headRead.trArr[ix].offset = sw.headRead.trArr[ix + 1].offset - 1;
				}
			}
			else if (ix == sw.headRead.getnx() - 1) {
				if (abs(sw.headRead.trArr[ix - 1].offset) < MIL) {
					sw.headRead.trArr[ix].offset = sw.headRead.trArr[ix - 1].offset + 1;
				}
			}
			else {
				int x1 = sw.headRead.trArr[ix - 1].offset;
				int x2 = sw.headRead.trArr[ix + 1].offset;
				if (abs(x1) < MIL && abs(x2) < MIL) {
					sw.headRead.trArr[ix].offset = (x1 + x2) / 2;
				}
			}
		} // if
	} // for ix

	// dig must now be sorted along X-axis
	pDg.myDigSortX2(&dig);


	// now there is a prob: if the first traces are like:
	//  0.41, 0.25, 0.23, 0.19, 0.16, 0.13, 0.09, 0.06, 0.04, 0.06, 0.09, 0.14, ....
	//  the first 8 traces will have invalid offsets. So we will need to set fake offsets 
	//  to these traces otherwise their offsets will not be assigned properly 
	//for (i = 0; i < head.numTraces - 1; i++) {
	//	if (fabs(head.offsets[i]) < fabs(head.offsets[i + 1])) {
	//		// found the correct 
	//		break;
	//	}
	//}
	//if (i > 0) {
	//	// we set the first trace to be 0, the trace at i to be head.offsets[i]
	//	float dx = head.offsets[i + 1] - head.offsets[i];
	//	for (j = 0; j < i; j++) {
	//		// head.offsets[j] = (float)j / (float)i * head.offsets[i];
	//		head.offsets[j] = head.offsets[j] - dx;
	//		if (head.offsets[j] < 0.f) head.offsets[j] = 0.f;
	//	}
	//}

	//float rangeSBIn = 0.f;
	// it is not displaying by trace, so the SB must be at 0 km offset

	CDigitize::DIGITIZE dig2;
	if (!dig2.initDigitizeArray(dig.nPoint[0], 1)) return;
	dig2.isZeltFormat = FALSE;

	// sometimes the raw data contains no trace numbers, which must be corrected. this already is corrected 
	//    in &head struct now. But we still put it here just in case
	if (sw.headRead.trArr[0].tracl == 0) {
		for (int ix = 0; ix < sw.headRead.getnx(); ix++) {
			sw.headRead.trArr[ix].tracl = ix + 101;
		}
	}

	float range;

	// fix some situ 
	int aInt = 0;
	// here we have a problem: if the offset is minus and yet dig.x[0][0] is positive, no interpolation can be extended.
	for (int ix = 0; ix < sw.headRead.getnx(); ix++) {
		range = sw.headRead.trArr[ix].getOffset();

		register int num = dig.nPoint[0];
		if (!SAME_SIGN(range, dig.x[0][0]) && range < dig.x[0][0]) {
			// we need to insert 3 points at 0, -dig.x[0][0], -dig.x[1][0], and then sort
			double a = dig.t[0][0] + (dig.t[1][0] - dig.t[0][0]) / (dig.x[1][0] - dig.x[0][0])*(0.f - dig.x[0][0]);
			pDg.myDigAddPoint(&dig, aInt, 0., a);
			pDg.myDigAddPoint(&dig, aInt, -dig.x[0][0], dig.t[0][0]);
			pDg.myDigAddPoint(&dig, aInt, -dig.x[1][0], dig.t[1][0]);
			pDg.myDigSortX2(&dig);	// this must be done for each loop!  
		}
		else if (!SAME_SIGN(range, dig.x[num - 1][0]) && range > dig.x[num - 1][0]) {
			// we need to insert 3 points at 0, -dig.x[i-1][0], -dig.x[i-2][0], and then sort
			double a = dig.t[num - 2][0] +
				(dig.t[num - 1][0] - dig.t[num - 2][0]) / (dig.x[num - 1][0] - dig.x[num - 2][0])*(0.f - dig.x[num - 2][0]);
			pDg.myDigAddPoint(&dig, aInt, 0., a);
			pDg.myDigAddPoint(&dig, aInt, -dig.x[num - 1][0], dig.t[num - 1][0]);
			pDg.myDigAddPoint(&dig, aInt, -dig.x[num - 2][0], dig.t[num - 2][0]);
			pDg.myDigSortX2(&dig);	// this must be done for each loop!  
		}
	}

	float tw; // water wave travel time
	register int num = dig.nPoint[0];
	for (int ix = 0; ix < sw.headRead.getnx(); ix++) {
		range = sw.headRead.trArr[ix].getOffset();

		// fix some situ 
		// here we have a problem: if the offset is minus and yet dig.x[0][0] is positive, no interpolation can be extended.
		if (range < dig.x[0][0]) {
			tw = dig.t[0][0] + (dig.t[1][0] - dig.t[0][0])
				/ (dig.x[1][0] - dig.x[0][0])*(range - dig.x[0][0]);
		}
		else if (range > dig.x[num - 1][0]) {
			tw = dig.t[num - 2][0] + (dig.t[num - 1][0] - dig.t[num - 2][0])
				/ (dig.x[num - 1][0] - dig.x[num - 2][0])*(range - dig.x[num - 2][0]);
		}
		else {
			for (register int i = 0; i < num - 1; i++) {
				if (range >= dig.x[i][0] && range <= dig.x[i + 1][0]) {
					if (dig.x[i][0] != dig.x[i + 1][0])
						tw = dig.t[i][0] + (dig.t[i + 1][0] - dig.t[i][0])
						/ (dig.x[i + 1][0] - dig.x[i][0])*(range - dig.x[i][0]);
					else
						tw = dig.t[i][0];
					break;
				} // if range
			} // for i
		} // else

		// do a static shift to correect for airgun delay
		if (isGunDelayCorr) {
			// range is now the travel time (sec) of the direct water wave. We apply source delay time
			tw -= gunDelay;
			sw.headRead.trArr[ix].setTraceDelayF(sw.headRead.trArr[ix].getTraceDelay() - gunDelay);
		}


		//convert time to range in km.
		offset = polyA + polyB*tw + polyC*tw*tw;
		if (fabs(offset) < xHyperbola) {
			// now we use our conventional formula of hyperbola
			register double aPositive = (tw*tw*draw.red.waterVelocityAboveObs*draw.red.waterVelocityAboveObs) -
				draw.red.obsDepth * draw.red.obsDepth;
			if (aPositive >= 0.f)
				offset = (float)sqrt(aPositive);
		}

		register bool isPositiveOffset = range >= 0;
		if (!isPositiveOffset) offset = -(float)fabs(offset);
		sw.headRead.trArr[ix].setOffset(offset);
		int aInt = 0;
		pDg.myDigAddPoint(&dig2, aInt, offset, tw);

		tStr.Format(_T("T%d."), sw.headRead.trArr[ix].tracl);
		pFrame->myCaption(tStr);
	} // for ix


	if (isMono) {
		// note: dig2 contains the same num of points as trace numbers, and 
		//       dig2 is not sorted yet. So we need to find all its irregularities and correct for them
		float dxMedium = dig2.getMedianInterval(0);
		int nxDig = min(dig2.nPoint[0], sw.headRead.getnx());
		for (int ix = 0; ix < nxDig - 1; ix++) {
			if (dig2.x[ix][0] >= dig2.x[ix + 1][0]) {
				register float xRef = dig2.x[ix][0]; // this is a good ref
				register int nxInterpol = -1;

				// irregularity found. Look for the end of the irregulary
				for (register int i = ix + 2; i < nxDig - 1; i++) {
					if (dig2.x[i][0] > xRef) {
						// found it
						nxInterpol = i;
						break;
					}
				}

				if (nxInterpol > ix) {
					// now we need to interpolate for traces of [ix+1, nxInterpol-1]
					register float xRef2 = dig2.x[nxInterpol][0];
					register float dx = (xRef2 - xRef) / (float)(nxInterpol - ix + 1);
					if (dx < dxMedium * 3) {
						for (register int i = ix + 1; i < nxInterpol; i++) {
							dig2.x[i][0] = xRef + (i - ix)*dx;
							sw.headRead.trArr[i].setOffset(dig2.x[i][0]);
						}
					} // if
				} // if
			} // if dig2.x
		} // for ix
	}

	if (sw.getCountNonMonoOffset(1) > 0) {
		sw.sortDistance(1);
	}
	sw.writeDataAll(sw.m_f);

	pDg.myDigSortX2(&dig2);	// this must be done for each loop!  prob: after this sort, na should be changed!

	if (!isEndWith(dig.digName, _T("_Poly.txt")))
		dig2.digName = getFileNameAppend(dig.digName, _T("_Poly"));
	else
		dig2.digName = dig.digName;
	//dig2.digName = isEndWith(dig.digName, _T("_Poly.txt"))  ?  
	//	dig.digName  :  
	//	GetFileNameAppendExt(dig.digName, _T("_Poly"), _T("txt")); // this name is needed before the following loop since it will auto write once the limit is reached
	dig.isSortedX = TRUE;
	dig.isSortedY = FALSE;
	pDg.myDigSaveAs2(&dig2, isXInt);
	dig.digName = dig2.digName;  // this will make the display to show the newer version with _Poly.txt
	pDg.myDigitizingLoadTXTUnix2(&dig);


	tStr.Format(_T("Offset information is assigned successfully."));
	if (isGunDelayCorr)
		tStr += _T(" Correction for gun delay is also applied.");

	tStr += _T(" Revised offset vs direct arrival time is stored in: ") + dig2.digName;
	tStr += _T(" You may revise the digitization and assign offsets again.");

	static bool isShowMsgBox = true;
	if (isShowMsgBox) {
		AfxMessageBox(tStr, MB_ICONQUESTION);
		isShowMsgBox = false;
	}
	else
		pFrame->myCaption(tStr);

	dig2.freeDigAll();


	//	draw.timeSecOld = BLANK;  // this will re-calc for amp inilization
	draw.isSameDataDisplay = FALSE;

	//	SetModifiedFlag();
	UpdateAllViews(NULL);
	NotifyChanged();

}




void CSeisWideDoc::OnSegyconversionIeeetoibmfloat()
{
	bhed bh;
	BOOL isUnix = false;

	CString tStr;
	tStr.Format(_T("This will take many selected floating point (either Unix or PC) segys, forcefully swap the format markup between IBM and IEEE in the header section. \nNon-floating segys will be ignored."));
	int iResult = AfxMessageBox(tStr, MB_YESNO | MB_ICONINFORMATION | MB_ICONQUESTION);
	if (iResult  != IDYES) return;
	//bool isIBM = (iResult == IDYES);

	CString inFile;
	CFileDialog dlg(TRUE, _T("sgy; SEG"), _T("*.sgy; *.SEG"),
		OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT | OFN_ALLOWMULTISELECT | OFN_EXPLORER,
		_T("Input Segy File (*.sgy;*.SEG)|*.sgy; *.SEG|"));

	TCHAR* buff = (TCHAR*)alloc1(65535, sizeof(TCHAR));
	buff[0] = '\0';
	dlg.m_ofn.lpstrTitle = _T("Select all floating point segy files with wrong markup between IEEE and IBM formats.");
	dlg.m_ofn.lpstrFile = buff;
	dlg.m_ofn.nMaxFile = 65535;//sizeof(buff);

	POSITION Position;

	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	int count = 0;
	CString str;
	if (dlg.DoModal() == IDOK)
	{
		Position = dlg.GetStartPosition();
		while (Position)
		{
			inFile = dlg.GetNextPathName(Position);
			//CSegyMeta::swapIbmIeee
			if (!CSegyMeta::swapIbmIeee(inFile))
				pFrame->myCaption(_T("File ") + inFile + _T(" swapping between IBM and IEEE failed."));
			else
				count++;

		} //end the while file POSITION loop.
	} //end dlg.DoModal function.
	free1(buff);
	tStr.Format(_T("A total of %d files are successfully swapped between IBM and IEEE floating format markup in their file headers. Others ignored."), count);

	AfxMessageBox(tStr);
}



/*
void CSeisWideDoc::OnSegyconversionIeeetoibmfloat()
{
	long k;
	segy tr;
	bhed bh;
	BOOL isUnix = false;

	CString tStr;
	tStr.Format(_T("This will take inputs in floating point Unix or PC format, swap data between IBM and IEEE (to correct for wrong markup). Non-floating data will be ignored."));
	if (AfxMessageBox(tStr, MB_YESNO | MB_ICONINFORMATION | MB_ICONQUESTION) == IDNO) return;
	//bool isIeee2Ibm = (ifeedback == IDYES);
	//CString strAppend = isIeee2Ibm  ?  _T("IBM")  :  _T("IEEE");
	CString strAppend = _T("Swap");


	//BOOL isDeadTrcExist, isUseReducedTime, GSCformat, trcRenum;
	//BOOL isBackupCDP = false;
	CString inFile = BLANK, outFile = BLANK;

	//short *i2buf;
	//long *i4buf;
	//i2buf = (short *) &tr;
	//i4buf = (long *) &i2buf[0];

	CFileDialog dlg(TRUE, _T("sgy; SEG"), _T("*.sgy; *.SEG"),
		OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT | OFN_ALLOWMULTISELECT | OFN_EXPLORER,
		_T("Input Segy File (*.sgy;*.SEG)|*.sgy; *.SEG|"));

	TCHAR* buff = (TCHAR*)alloc1(65535, sizeof(TCHAR));
	buff[0] = '\0';
	dlg.m_ofn.lpstrTitle = _T("Select all floating point segy files with wrong markup between IEEE and IBM formats.");
	dlg.m_ofn.lpstrFile = buff;
	dlg.m_ofn.nMaxFile = 65535;//sizeof(buff);

	POSITION Position;

	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	int count = 0;
	if (dlg.DoModal() == IDOK)
	{
		//Begin progress control.
		ASSERT(pFrame);
		ASSERT_KINDOF(CMainFrame, pFrame);
		pFrame->BeginProgress();
		Position = dlg.GetStartPosition();
		while (Position)
		{
			inFile = dlg.GetNextPathName(Position);
			// must make it lower case before comparing, in case some file has extension
			// like ".Sgy" or ".sGY".
			outFile = getFileNameAppend(inFile, strAppend);
			CString tempStr = outFile;
			tempStr.MakeLower();
			if (tempStr.Right(4) != _T(".sgy"))
				outFile += _T(".sgy");
			if (outFile == BLANK) {
				free1(buff);
				return;
			}

			if (!isFileExistNotDirectory(inFile)) continue;
			CFile file;
			if (!file.Open(inFile, CFile::modeRead | CFile::typeBinary | CFile::shareDenyNone)) {
				continue;
			}

			//For progress control, need to know the last bytes no.
			ULONGLONG curBytesRead, totBytesRead = file.GetLength();
			file.Seek(0, CFile::begin);

			UINT bytesRead = file.Read(head.ascHead, 3200L);
			file.Read(&bh, 400L);
			if (bytesRead < 400) {
				file.Close();
				pFrame->myCaption(_T("File ") + inFile + _T(" Binary section header read wrong"));
				continue;
			}

			if (isUnix = IsUnix(bh.format)) SwapTapeHeader(&bh);

			int numsamp = bh.hns;
			if (bh.format != 1 && bh.format != 5) {
				file.Close();
				AfxMessageBox(_T("Not floating point segy: ") + inFile);
				continue;
			}

			// now only floating point data come to here.
			int len = numsamp * 4 + 240;
			if (bh.hdt == 0) bh.hdt = bh.dto;
			int tpp = bh.hdt;
			ULONGLONG byteFileEnd = file.SeekToEnd();
			file.Seek(3600L, CFile::begin);

			CFile file2;
			if (!file2.Open(outFile, CFile::modeWrite | CFile::modeCreate | CFile::typeBinary)) {
				file.Close();
				continue;
			}
			//ebc2asc(head.ascHead, 3200L);
			file2.Write(head.ascHead, 3200L);

			//bool isIeee = bh.format == 5;

			if (bh.format == 1) bh.format = 5;
			else if (bh.format == 5) bh.format = 1;
			file2.Write(&bh, 400L);

			k = 0;
			while (file.Read(&tr, len) == (UINT)len) {
				k++; //trace counter

				if (isUnix) {
					SwapTraceHeader(false, false, false, &tr);
					SwapN(&tr.dat, bh.format, numsamp);
				}

				tr.idistopt = 8;
				tr.ns = (unsigned short)numsamp;

				if (bh.format == 5)
					ibm_to_float((int *)tr.dat.data, (int *)tr.dat.data, (int)numsamp);
				else
					float_to_ibm((int *)tr.dat.data, (int *)tr.dat.data, (int)numsamp);
				file2.Write(&tr, len);

				curBytesRead = file.Seek(0, CFile::current);
				int iPos = (int)((double)curBytesRead / (double)totBytesRead*100.);
				if (iPos < 0)iPos = 0;
				if (iPos > 100)iPos = 100;
				pFrame->SetProgress(iPos);
			} //end the while Read loop.
			file.Close();
			file2.Close();
			count++;

		} //end the while file POSITION loop.
		pFrame->EndProgress();
	} //end dlg.DoModal function.
	free1(buff);

	tStr.Format(_T("A total of %d files are successfully swapped with data between IEEE and IBM floating point."), count);
	pFrame->myCaption(tStr);
}
*/


void CSeisWideDoc::OnProcessingFilterOffsetvarying()
{
	// testing

	//processing.filterxt.ta = 4.f;
	//processing.filterxt.tb = 10.f;
	//processing.filterxt.fLowa = 3.f;
	//processing.filterxt.fHigha = 60.f;
	//processing.filterxt.fLowb = 3.f;
	//processing.filterxt.fHighb = 16.f;
	//processing.filterxt.x1 = 1.f;

	//processing.filterxt.tax2 = 5.f;
	//processing.filterxt.tbx2 = 11.f;
	//processing.filterxt.fLowax2 = 3.f;
	//processing.filterxt.fHighax2 = 50.f;
	//processing.filterxt.fLowbx2 = 3.f;
	//processing.filterxt.fHighbx2 = 15.f;
	//processing.filterxt.x2 = 2.f;

	//processing.filterxt.tax3 = 6.f;
	//processing.filterxt.tbx3 = 12.f;
	//processing.filterxt.fLowax3 = 3.f;
	//processing.filterxt.fHighax3 = 40.f;
	//processing.filterxt.fLowbx3 = 3.f;
	//processing.filterxt.fHighbx3 = 14.f;
	//processing.filterxt.x3 = 3.f;

	//processing.filterxt.num_tfilter = 2;

	CString tstr;
	int trc, i;
	CString outFile = BLANK;

	//		float dt;		/* sample spacing			*/
	float nyq;		/* nyquist frequency			*/


	CdlgFilterOffset dlg;
	dlg.m_nameIn = draw.timeSecName;
	dlg.m_nameOut = getFileNameAppend(draw.timeSecName, _T("FX"));
	dlg.m_fLowa = processing.filterxt.fLowa;
	dlg.m_fLowax2 = processing.filterxt.fLowax2;
	dlg.m_fLowax3 = processing.filterxt.fLowax3;
	dlg.m_fLowb = processing.filterxt.fLowb;
	dlg.m_fLowbx2 = processing.filterxt.fLowbx2;
	dlg.m_fLowbx3 = processing.filterxt.fLowbx3;

	dlg.m_fHigha = processing.filterxt.fHigha;
	dlg.m_fHighax2 = processing.filterxt.fHighax2;
	dlg.m_fHighax3 = processing.filterxt.fHighax3;
	dlg.m_fHighb = processing.filterxt.fHighb;
	dlg.m_fHighbx2 = processing.filterxt.fHighbx2;
	dlg.m_fHighbx3 = processing.filterxt.fHighbx3;
	dlg.m_numTFilter = processing.filterxt.num_tfilter;
	dlg.m_ta = processing.filterxt.ta;
	dlg.m_tax2 = processing.filterxt.tax2;
	dlg.m_tax3 = processing.filterxt.tax3;
	dlg.m_tb = processing.filterxt.tb;
	dlg.m_tbx2 = processing.filterxt.tbx2;
	dlg.m_tbx3 = processing.filterxt.tbx3;
	dlg.m_x1 = processing.filterxt.x1;
	dlg.m_x2 = processing.filterxt.x2;
	dlg.m_x3 = processing.filterxt.x3;
	if (dlg.DoModal() == IDOK)
	{
		draw.timeSecName = dlg.m_nameIn.Trim();
		outFile = dlg.m_nameOut;
		processing.filterxt.fLowa = dlg.m_fLowa;
		processing.filterxt.fLowax2 = dlg.m_fLowax2;
		processing.filterxt.fLowax3 = dlg.m_fLowax3;
		processing.filterxt.fLowb = dlg.m_fLowb;
		processing.filterxt.fLowbx2 = dlg.m_fLowbx2;
		processing.filterxt.fLowbx3 = dlg.m_fLowbx3;

		processing.filterxt.fHigha = dlg.m_fHigha;
		processing.filterxt.fHighax2 = dlg.m_fHighax2;
		processing.filterxt.fHighax3 = dlg.m_fHighax3;
		processing.filterxt.fHighb = dlg.m_fHighb;
		processing.filterxt.fHighbx2 = dlg.m_fHighbx2;
		processing.filterxt.fHighbx3 = dlg.m_fHighbx3;
		processing.filterxt.num_tfilter = dlg.m_numTFilter;
		processing.filterxt.ta = dlg.m_ta;
		processing.filterxt.tax2 = dlg.m_tax2;
		processing.filterxt.tax3 = dlg.m_tax3;
		processing.filterxt.tb = dlg.m_tb;
		processing.filterxt.tbx2 = dlg.m_tbx2;
		processing.filterxt.tbx3 = dlg.m_tbx3;
		processing.filterxt.x1 = dlg.m_x1;
		processing.filterxt.x2 = dlg.m_x2;
		processing.filterxt.x3 = dlg.m_x3;
	} // if
	else return;

	delete dlg;
	if (processing.filterxt.fLowa >= processing.filterxt.fHigha) {
		AfxMessageBox(_T(" fLowa>=fHigha. Please correct this."), MB_ICONQUESTION);
		return;
	}
	if (processing.filterxt.fLowb == 0.f || processing.filterxt.fHighb == 0.f) {
		// not time varying filter for X1
		processing.filterxt.ta = processing.filterxt.tb = 0.f;
	}
	if (processing.filterxt.fLowbx2 == 0.f || processing.filterxt.fHighbx2 == 0.f) {
		// not time varying filter for X2
		processing.filterxt.tax2 = processing.filterxt.tbx2 = 0.f;
	}
	if (processing.filterxt.fLowbx3 == 0.f || processing.filterxt.fHighbx3 == 0.f) {
		// not time varying filter for X3
		processing.filterxt.tax3 = processing.filterxt.tbx3 = 0.f;
	}

	if (processing.filterxt.x2 < processing.filterxt.x1) processing.filterxt.x2 = processing.filterxt.x1;
	if (processing.filterxt.x3 < processing.filterxt.x2) processing.filterxt.x3 = processing.filterxt.x2;

	SegyWrapper sw(draw.timeSecName);
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	if (CSegyMeta::segyHeadInit(draw.timeSecName, &head) != 1) return;
	if (!sw.open(&head, 0)) {
		tstr.Format(_T("Valid input file cannot be opened"));
		AfxMessageBox(tstr, MB_ICONQUESTION);
		return;
	}
	bhed bhout;
	memcpy((void *)&bhout, (void *)&sw.headRead.bh, 400L);
	int nsout = bhout.hns;
	tstr.Format(_T("Loaded segy header with %d traces. Distance adjusting..."), sw.headRead.getnx());
	pFrame->myCaption(tstr);

	double *tData = NULL;
	tData = (double *)ealloc1double((size_t)nsout);
	if (tData == NULL) {
		AfxMessageBox(_T("Insufficient memory available"), MB_ICONQUESTION);
		return;
	}

	CFile fileout;
	if (!fileout.Open(outFile, CFile::modeCreate | CFile::modeWrite | CFile::typeBinary)) {
		tstr.Format(_T("Outfile cannot be created"));
		AfxMessageBox(tstr, MB_ICONQUESTION);
		return;
	}
	segy tr;
	fileout.Write(head.ascHead, 3200L);
	bhout.format = 1; // only floating is adopted for output
	//bhout.format = pFrame->statMain.gIsIBMFloatSegy2 ? 1 : 5; // only floating is adopted for output
	fileout.Write(&bhout, 400);

	int format = bhout.format;
	int sampByte = (bhout.format == 3) ? 2 : 4;
	int len = sampByte*bhout.hns + 240;

	// dt = head.dt;
	double odt = 1. / head.dtFile;
	nyq = (float)(0.5 / head.dtFile);
	if (processing.filterxt.fLowa <= 0.f) processing.filterxt.fLowb = processing.filterxt.fLowa = 0.00001f;
	if (processing.filterxt.fHigha > nyq) processing.filterxt.fHighb = processing.filterxt.fHigha = nyq;

	CStringArray *strArr = new CStringArray();

	double temp = 0.;
	for (int nxStore = 0; nxStore < sw.headRead.getnx(); nxStore++) {
		segydynamic *ptr = &sw.headRead.trArr[nxStore];

		// debias first
		temp = 0.;
		for (i = 0; i<nsout; i++)
			temp += ptr->data[i];
		if (fabs(temp)>MINAMP){
			temp /= (double)nsout;
			for (i = 0; i < nsout; i++) ptr->data[i] -= (float)temp;
		}

		memset((void *)tr.dat.data, (int) '\0', sampByte*nsout);
		trc = ptr->tracl;
		float offset = (float)fabs(ptr->getOffset());  // negative offset is found to be causing problems!
		float aDelay = ptr->getTraceDelay();

		int ita = 0;
		int itb = 0;
		double aRatioA;
		double aRatioB;
		float aLowa;
		float aHigha;
		bool isTimeVaryingFilter = false;
		if (processing.filterxt.x2 == processing.filterxt.x1 || offset <= processing.filterxt.x1) {
			aLowa = processing.filterxt.fLowa;
			aHigha = processing.filterxt.fHigha;
			ita = (int)myRound((processing.filterxt.ta - aDelay) * odt);
			itb = (int)myRound((processing.filterxt.tb - aDelay) * odt);
			isTimeVaryingFilter = (itb > ita);
			if (isTimeVaryingFilter) {
				aRatioA = (processing.filterxt.fLowb - aLowa) / (double)(itb - ita);
				aRatioB = (processing.filterxt.fHighb - aHigha) / (double)(itb - ita);
			}
		} // if
		else if (processing.filterxt.x3 == processing.filterxt.x2 || offset <= processing.filterxt.x2) {
			float slope = (offset - processing.filterxt.x1) / (processing.filterxt.x2 - processing.filterxt.x1);
			aLowa = processing.filterxt.fLowa + (processing.filterxt.fLowax2 - processing.filterxt.fLowa) * slope;
			aHigha = processing.filterxt.fHigha + (processing.filterxt.fHighax2 - processing.filterxt.fHigha) * slope;
			ita = (int)myRound((processing.filterxt.ta + (processing.filterxt.tax2 - processing.filterxt.ta)*slope - aDelay) * odt);
			itb = (int)myRound((processing.filterxt.tb + (processing.filterxt.tbx2 - processing.filterxt.tb)*slope - aDelay) * odt);
			isTimeVaryingFilter = (itb > ita);
			if (isTimeVaryingFilter) {
				float aLowb = processing.filterxt.fLowb + (processing.filterxt.fLowbx2 - processing.filterxt.fLowb) * slope;
				float aHighb = processing.filterxt.fHighb + (processing.filterxt.fHighbx2 - processing.filterxt.fHighb) * slope;
				aRatioA = (aLowb - aLowa) / (double)(itb - ita);
				aRatioB = (aHighb - aHigha) / (double)(itb - ita);
			}
		}
		else if (offset <= processing.filterxt.x3) {
			float slope = (offset - processing.filterxt.x2) / (processing.filterxt.x3 - processing.filterxt.x2);
			aLowa = processing.filterxt.fLowax2 + (processing.filterxt.fLowax3 - processing.filterxt.fLowax2)*slope;
			aHigha = processing.filterxt.fHighax2 + (processing.filterxt.fHighax3 - processing.filterxt.fHighax2)*slope;
			ita = (int)myRound((processing.filterxt.tax2 + (processing.filterxt.tax3 - processing.filterxt.tax2)*slope - aDelay) * odt);
			itb = (int)myRound((processing.filterxt.tbx2 + (processing.filterxt.tbx3 - processing.filterxt.tbx2)*slope - aDelay) * odt);
			isTimeVaryingFilter = (itb > ita);
			if (isTimeVaryingFilter) {
				float aLowb = processing.filterxt.fLowbx2 + (processing.filterxt.fLowbx3 - processing.filterxt.fLowbx2) * slope;
				float aHighb = processing.filterxt.fHighbx2 + (processing.filterxt.fHighbx3 - processing.filterxt.fHighbx2) * slope;
				aRatioA = (aLowb - aLowa) / (double)(itb - ita);
				aRatioB = (aHighb - aHigha) / (double)(itb - ita);
			}
		}
		else {
			aLowa = processing.filterxt.fLowax2;
			aHigha = processing.filterxt.fHighax2;
			ita = (int)myRound((processing.filterxt.tax3 - aDelay) * odt);
			itb = (int)myRound((processing.filterxt.tbx3 - aDelay) * odt);
			isTimeVaryingFilter = (itb > ita);
			if (isTimeVaryingFilter) {
				aRatioA = (processing.filterxt.fLowbx3 - aLowa) / (double)(itb - ita);
				aRatioB = (processing.filterxt.fHighbx3 - aHigha) / (double)(itb - ita);
			}
		}

		double a, b, c0, c1, c2, d1, d2;
		for (int n = 0; n < processing.filterxt.num_tfilter; n++) {
			if (isTimeVaryingFilter) {
				a = tan(PI*aLowa*head.dtFile);
				b = tan(PI*aHigha*head.dtFile);
				c0 = -b / (1. + a) / (1. + b);
				c1 = 0.;
				c2 = -c0;
				d1 = ((1. + a)*(1. - b) + (1. - a)*(1. + b)) / ((1. + a)*(1. + b));
				d2 = -((1. - a)*(1. - b)) / ((1. + a)*(1. + b));

				// prepare for time varying filter
				tData[0] = c0*ptr->data[0];
				tData[1] = c0*ptr->data[1] + c1*ptr->data[0] + d1*tData[0];
				for (i = 2; i < nsout; i++) {
					if (i >= ita && i <= itb) {
						float fLow = aLowa + (float)((i - ita) *  aRatioA);
						float fHigh = aHigha + (float)((i - ita) *  aRatioB);
						if ((int)(i / 100) * 100 == i || i == ita || i == itb) {
							//tstr.Format(_T("%d  %f(km)  %d  %f(s)  %f-%f(Hz); At %f(s) calc freq is %f-%f", 
							//	trc, offset, i, (float)(i*dt+aDelay), fLow, fHigh, 
							//	(float)(ita*dt+aDelay), aLowa, aHigha);
							tstr.Format(_T("Trc%d  X=%f(km)  %d  T=%f(s)  %f-%f(Hz)"),
								trc, offset, i, (float)(i*head.dtFile + aDelay), fLow, fHigh);
							strArr->Add(tstr);
						}
						a = tan(PI*fLow*head.dtFile);
						b = tan(PI*fHigh*head.dtFile);
						c0 = -b / (1. + a) / (1. + b);
						c1 = 0.;
						c2 = -c0;
						d1 = ((1. + a)*(1. - b) + (1. - a)*(1. + b)) / ((1. + a)*(1. + b));
						d2 = -((1. - a)*(1. - b)) / ((1. + a)*(1. + b));
					}
					tData[i] = c0*ptr->data[i] +
						c1*ptr->data[i - 1] +
						c2*ptr->data[i - 2] +
						d1*tData[i - 1] + d2*tData[i - 2];
					if (fabs(tData[i]) > 100000.0) {
						int dfs = 1;
					}

				} // for i
			} // if
			else {
				a = tan(PI*aLowa*head.dtFile);
				b = tan(PI*aHigha*head.dtFile);
				c0 = -b / (1. + a) / (1. + b);
				c1 = 0.;
				c2 = -c0;
				d1 = ((1. + a)*(1. - b) + (1. - a)*(1. + b)) / ((1. + a)*(1. + b));
				d2 = -((1. - a)*(1. - b)) / ((1. + a)*(1. + b));
				tData[0] = c0*ptr->data[0];
				tData[1] = c0*ptr->data[1] + c1*ptr->data[0] + d1*tData[0];
				for (i = 2; i < nsout; i++)
					tData[i] = c0*ptr->data[i] +
					c1*ptr->data[i - 1] +
					c2*ptr->data[i - 2] +
					d1*tData[i - 1] + d2*tData[i - 2];
			}

			for (i = 0; i < nsout; i++)
				ptr->data[i] = -(float)tData[i];
		} // for n
		memcpy((void *)&tr.dat, (void *)&ptr->data[0], sampByte*nsout);
		if (bhout.format == 1) {
			float_to_ibm((int *)tr.dat.data, (int *)tr.dat.data, nsout); // we always output as floating pt
		}

		fileout.Write(ptr, 240);
		fileout.Write(&tr.dat.data[0], bhout.hns*sizeof(float));
		if ((int)(nxStore / 10) * 10 == nxStore) {
			tstr.Format(_T("F%d...."), nxStore);
			pFrame->myCaption(tstr);
		}
	} // for nxStore

	fileout.Close();

	tstr = getFileNameTemp(draw.timeSecName, _T("_freqCalc.txt"), TRUE);
	saveStringArrayToFile(strArr, tstr);
	strArr->RemoveAll();
	delete strArr;
	showFileInNotePad(tstr);
	draw.timeSecName = outFile;
	if (tData != NULL) free1double(tData);
	OnToolbarRefreshAll();
}

void CSeisWideDoc::OnSonobuoyAssignoffsetfromsegy()
{
	CString tStr;
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	if (!isFileExistNotDirectory(draw.timeSecName)) {
		tStr.Format(_T(" To assign distances/offsets, please display a time section, and allows it wrtitable."));
		AfxMessageBox(tStr, MB_ICONQUESTION);
		return;
	}

	tStr.Format(_T("Do you want to copy offsets as opposed to distances?"));
	int ifeedback = AfxMessageBox(tStr, MB_YESNOCANCEL | MB_ICONQUESTION);
	if (ifeedback == IDCANCEL) return;
	bool isCopyOffset = ifeedback == IDYES;

	tStr.Format(_T("If a trace num or FFID is not found in the 2nd file, the offset in the 1st file will not be modified. Trace length can differ between input files. No statics are copied. \nYES=use FFID (recommended), \nNO=use trace number (trace num changes after offset assignment) \nto assign offsets."));
	ifeedback = AfxMessageBox(tStr, MB_YESNOCANCEL | MB_ICONQUESTION);
	if (ifeedback == IDCANCEL) return;
	bool isFFIDBased = (ifeedback == IDYES);

	//open file dialog.
	CString file2;
	CFileDialog dlg2(FALSE, BLANK, _T("*.sgy"), OFN_EXPLORER,
		_T("Copy offsets from a second segy file (*.sgy)|*.sgy|"));
	dlg2.m_ofn.lpstrTitle = _T("Select the 2nd segy file");
	if (dlg2.DoModal() == IDOK)
		file2 = dlg2.GetPathName();
	else {
		return;
	}
	delete dlg2;

	if (file2 == draw.timeSecName) {
		tStr.Format(_T("Sorry. your first file is the same as the second file."));
		AfxMessageBox(tStr, MB_ICONQUESTION);
		return;
	}

	SegyWrapper sw(draw.timeSecName);
	sw.m_isHeadersOnly = false;
	if (CSegyMeta::segyHeadInit(draw.timeSecName, &head) != 1) return;
	//if (head.isUnixFile) {
	//	tStr.Format(_T("Sorry, this routine only deals with PC format."));
	//	AfxMessageBox(tStr, MB_ICONQUESTION);
	//	return;
	//}
	if (!sw.open(&head, 0)) {
		tStr.Format(_T("Input file cannot be opened properly."));
		AfxMessageBox(tStr, MB_ICONQUESTION);
		return;
	}


	HEAD head2;
	SegyWrapper sw2(file2);
	sw2.m_isHeadersOnly = true;
	if (CSegyMeta::segyHeadInit(file2, &head2) != 1) return;
	bool isTrue = sw2.open(&head2, 0);
	CSegyMeta::segyHeadFree(&head2);  // head2 must free manually, but head should not free
	if (!isTrue) {
		tStr.Format(_T("Input file cannot be opened properly."));
		AfxMessageBox(tStr, MB_ICONQUESTION);
		return;
	}

	int i;
	int numTracesNotFound = 0;
	int numTracesModified = 0;
	for (int ix = 0; ix < sw.headRead.getnx(); ix++) {
		if (!isFFIDBased)
			i = sw2.getArrIndexAtTrace(sw.headRead.trArr[ix].tracl);
		else
			i = sw2.getArrIndexAtFFID(sw.headRead.trArr[ix].fldr);

		if (i >= 0) {
			if (!isCopyOffset)
				sw.headRead.trArr[ix].setDistance(sw2.headRead.trArr[i].getDistance());
			else
				sw.headRead.trArr[ix].setOffset(sw2.headRead.trArr[i].getOffset());
			numTracesModified++;
		}
		else
			numTracesNotFound++;
	}
	sw.writeDataAll();
	tStr.Format(_T("Successfully updated %d traces, with %d traces unmodified. Please make sure the results are correct!"), numTracesModified, numTracesNotFound);
	pFrame->myCaption(tStr);
}

void CSeisWideDoc::OnProcessingGainadjust()
{
	CString tStr;
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();

	static float gain_mult = 1.f;
	int i, ii, j;

	CdlgGainAdjust dlg2;
	dlg2.m_trace1 = 0;
	dlg2.m_trace2 = 0;
	dlg2.m_multiply = gain_mult;
	if (dlg2.DoModal() == IDOK) {
		gain_mult = dlg2.m_multiply;
	}
	else return;
	if (gain_mult == 1.f) return;

	//Open file dialog.
	CFileDialog dlg(TRUE, _T("sgy; SEG; segy"), _T("*.sgy; *.SEG; *.segy"),
		OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT | OFN_ALLOWMULTISELECT | OFN_EXPLORER,
		_T("Input Segy File (*.sgy;*.SEG; *.segy)|*.sgy; *.SEG; *.segy|"));
	TCHAR* buff = (TCHAR*)alloc1(65535, sizeof(TCHAR));
	buff[0] = '\0';
	dlg.m_ofn.lpstrTitle = _T("Select all files for batch processing");
	dlg.m_ofn.lpstrFile = buff;
	dlg.m_ofn.nMaxFile = 65535;//sizeof(buff);

	int nf = 0;
	const int MAX_FILES = 999;
	CString inFileName, inFileNames[MAX_FILES];
	POSITION Position;
	if (dlg.DoModal() == IDOK) {
		Position = dlg.GetStartPosition();
		while (Position) {
			inFileName = dlg.GetNextPathName(Position);
			if (!inFileName.IsEmpty()) {
				inFileNames[nf] = inFileName;
				nf++;
			}
		}
	} //end dlg.DoModal function.
	else {
		free1(buff);
		return;
	}
	free1(buff);
	delete dlg;

	// If data numbers exceed max, just change this number
	if (nf > MAX_FILES) {
		AfxMessageBox(_T("Maximum number of files selected is exceeded."));
		return;
	}
	if (nf < 1) return;


	if (dlg2.m_trace1 == 0) dlg2.m_trace1 = -999999;
	if (dlg2.m_trace2 == 0) dlg2.m_trace2 = 999999;

	pFrame->statMain.myCursor(true);
	int count = 0;
	for (int indf = 0; indf < nf; indf++) {
		SegyWrapper sw(inFileNames[indf]);
		//	sw.m_isIBMFloatSegy2 = pFrame->gIsIBMFloatSegy2==TRUE;
		if (CSegyMeta::segyHeadInit(inFileNames[indf], &head) != 1) continue;
		if (!sw.open(&head, 0)) {
			continue;
		}

		for (i = 0; i < sw.headRead.getnx(); i++) {
			ii = sw.headRead.trArr[i].tracl;
			if (ii >= dlg2.m_trace1 && ii <= dlg2.m_trace2) {
				for (j = 0; j < sw.headRead.getns(); j++)
					sw.headRead.trArr[i].data[j] *= gain_mult;
			} // if i
		} // for i

		ii = sw.writeDataAll();
		tStr.Format(_T("%d traces updated on %s."), ii, inFileNames[indf]);
		pFrame->myCaption(tStr);
		count++;
	}
	pFrame->statMain.myCursor(false);

	if (count == 1) {
		tStr.Format(_T("%d traces updated."), ii);
	}
	else
		tStr.Format(_T("%d files updated."), count);

	AfxMessageBox(tStr);
}




void CSeisWideDoc::OnProcessingTracesubtractalongcurve()
{
	CString tStr;
	tStr.Format(_T("Removal of noise that is slightly curved with offset and nearly cyclic in time. \nYES=Continue, \nNO=Show Help. \nTraces not covered by digitized points will not be affected. Can run this multiple times with each time a different digitizing file."));
	int ifeedback = AfxMessageBox(tStr, MB_YESNOCANCEL | MB_ICONINFORMATION | MB_ICONQUESTION);
	if (ifeedback == IDCANCEL) return;
	else if (ifeedback == IDNO) {
		myShowHelp("index.html");
		return;
	}

	if (!isFileExistNotDirectory(draw.timeSecName) || cd.coord.isDistanceDisplay || !dig.isDigitizing)  {
		tStr.Format(_T(" Please display a time section in offset mode only, and digitize one curve along which the subtraction will be performed. Reduction velocity is fully considered."));
		AfxMessageBox(tStr, MB_ICONQUESTION);
		return;
	}
	// backup segy file first

	//if (!draw.isDigitizing) {
	//	// the user is not digitizing. 
	//	tStr.Format(_T(" To do trace subtraction, digitize some curves indicating the subtraction curvatures, and then re-run this function.");
	//	AfxMessageBox(tStr);
	//	return;
	//}

	if (dig.totCurve < 1 || dig.nPoint[0] < 2)
	{
		tStr.Format(_T(" At least 2 points are needed for each digitized curve."));
		AfxMessageBox(tStr, MB_ICONQUESTION);
		return;
	}

	SegyWrapper sw(draw.timeSecName);
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	//sw.m_isIBMFloatSegy2 = pFrame->gIsIBMFloatSegy2==TRUE;
	if (CSegyMeta::segyHeadInit(draw.timeSecName, &head) != 1) return;
	if (!sw.open(&head, 0) || sw.headRead.getnx() < 2) {
		tStr.Format(_T("Input segy file cannot be opened properly."));
		AfxMessageBox(tStr, MB_ICONQUESTION);
		return;
	}


	int i, j; // for trace indeces
	int ic, ip; // for digitized curve indexes
	float offset1, offset2;
	segy tr;


	double dt = sw.headRead.getdt();
	double odt = 1. / dt;
	float slope;
	float dx;
	float *tTrace = ealloc1float(head.numsampFiles);
	int count = 0;

	pFrame->statMain.myCursor(true);
	for (i = 0; i < sw.headRead.getnx() - 1; i++) {
		// calc offset1, offset2
		if (cd.coord.drawmode == 6) {
			offset1 = (float)sw.headRead.trArr[i].tracl;
			offset2 = (float)sw.headRead.trArr[i + 1].tracl;
		}
		else {
			offset1 = (cd.coord.isDistanceDisplay) ? sw.headRead.trArr[i].getDistance() : 
				sw.headRead.trArr[i].getOffset();
			offset2 = (cd.coord.isDistanceDisplay) ? sw.headRead.trArr[i + 1].getDistance() :
				sw.headRead.trArr[i + 1].getOffset();
		}

		// now calc the delta time of the second trace (at i+1) relative to the first trace (at i)
		slope = ERRORVAL;
		for (ic = 0; ic < dig.totCurve; ic++) {
			for (ip = 0; ip < dig.nPoint[ic] - 1; ip++) {
				if (isInsideFloat(offset1, dig.x[ip][ic], dig.x[ip + 1][ic])) {
					dx = dig.x[ip + 1][ic] - dig.x[ip][ic];
					slope = (dx == 0.f) ? 0.f : (dig.t[ip + 1][ic] - dig.t[ip][ic]) / dx;
					break;
				} // if
			} // for ip
			if (slope != ERRORVAL) break;
		} // for ic
		if (slope == ERRORVAL) {
			// if here, we had problems in getting the slope.
			continue;
		} // if

		// now calc the trace delay
		float tDelta = slope*(offset2 - offset1);
		// float tTraceRef = (float)(getTraceDelay(&sw.headRead.trArr[i + 1]));
		tTrace[0] = (float)(sw.headRead.trArr[i].getTraceDelay() + tDelta);
		for (j = 1; j < sw.headRead.getns(); j++) {
			tTrace[j] = tTrace[j - 1] + (float)dt;
		} // for i

		ints8r(sw.headRead.getns(), // ntin
			(float)dt,   // dtin
			sw.headRead.trArr[i + 1].getTraceDelay(),   // ftin
			&sw.headRead.trArr[i + 1].data[0], // yin[t=ntin], with yin[0] = y(fxin)
			0.f,  // yinl    value used to extrapolate yin values to left of yin[0]
			0.f,  // yinr	 value used to extrapolate yin values to right of yin[ntin-1]
			sw.headRead.getns(),   // nxout
			(float *)&tTrace[0],  // 
			(float *)&tr.dat.data[0]);    // tout
		// now, tr.dat.data[] is interpolated data of trace [i+1] with each sample 

		for (j = 0; j < sw.headRead.getns(); j++)
			//sw.headRead.trArr[i].data[j] = tr.dat.data[j];
			sw.headRead.trArr[i].data[j] -= tr.dat.data[j];
		count++;
	} // for i
	pFrame->statMain.myCursor(false);
	free1float(tTrace);

	for (j = 0; j < sw.headRead.getns(); j++)
		sw.headRead.trArr[sw.headRead.getnx() - 1].data[j] = sw.headRead.trArr[sw.headRead.getnx() - 2].data[j];
	sw.headRead.trArr[sw.headRead.getnx() - 1].delrt = sw.headRead.trArr[sw.headRead.getnx() - 2].delrt;
	sw.headRead.trArr[sw.headRead.getnx() - 1].delrtEx = sw.headRead.trArr[sw.headRead.getnx() - 2].delrtEx;

	tStr = getFileNameAppend(draw.timeSecName, _T("Subtract"));
	pFrame->myCaption(_T("Saving"));
	int ii = sw.writeDataAll(tStr);
	draw.timeSecName = tStr;
	tStr.Format(_T("%d out of %d traces affected in output."), count, ii);
	AfxMessageBox(tStr, MB_ICONQUESTION);
	this->OnDigitizeFinishdigitizing();
	OnToolbarRefreshAll();
	pFrame->myCaption(_T("Done"));
}

void CSeisWideDoc::OnProcessingSplitoddeventraces()
{
	CString tStr;
	if (AfxMessageBox(_T("This will split an on screen segy file into two based on odd and even traces. Continue?"), 
		MB_YESNO | MB_ICONINFORMATION | MB_ICONQUESTION) != IDYES) {
		return;
	}

	if (head.isUnixFile) {
		CString tStr;
		tStr.Format(_T("Sorry, this routine only deals with PC format."));
		AfxMessageBox(tStr);
		return;
	}
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	if (!isFileExistNotDirectory(draw.timeSecName)) {
		pFrame->myCaption(_T("Please display a valid segy file to split."));
		return;
	}
	SegyWrapper sw(draw.timeSecName);
	//	sw.m_isIBMFloatSegy2 = pFrame->gIsIBMFloatSegy2==TRUE;
	if (CSegyMeta::segyHeadInit(draw.timeSecName, &head) != 1) return;
	if (!sw.open(&head, 0) || sw.headRead.getnx() < 2) {
		tStr.Format(_T("Input file cannot be opened properly."));
		AfxMessageBox(tStr, MB_ICONQUESTION);
		return;
	}


	CFile filez;
	CString outFile = getFileNameAppend(draw.timeSecName, _T("Even"));
	if (!filez.Open(outFile, CFile::modeReadWrite | CFile::modeCreate | CFile::typeBinary)) {
		return;
	}
	filez.Write(head.ascHead, 3200L);
	filez.Write(&sw.headRead.bh, 400);

	CString outFile2 = getFileNameAppend(draw.timeSecName, _T("Odd"));
	CFile filez2;
	if (!filez2.Open(outFile2, CFile::modeReadWrite | CFile::modeCreate | CFile::typeBinary)) {
		filez.Close();
		return;
	}
	filez2.Write(head.ascHead, 3200L);
	filez2.Write(&sw.headRead.bh, 400);

	int count1 = 0;
	int count2 = 0;
	int sampByte = (head.formatFile != 3) ? 4 : 2;
	int lenByte = head.numsampFiles*sampByte;

	for (int i = 0; i < sw.headRead.getnx(); i++) {
		if ((int)(i / 2) * 2 == i) {
			// this is even case
			filez.Write(&sw.headRead.trArr[i], 240);
			filez.Write(&sw.headRead.trArr[i].data[0], lenByte);
			count1++;
		}
		else {
			filez2.Write(&sw.headRead.trArr[i], 240);
			filez2.Write(&sw.headRead.trArr[i].data[0], lenByte);
			count2++;
		}
	} //end of for loop.


	if (count1 > 0)
		CSegyMeta::setSegyTotalTrace(&filez, count1);
	if (count2 > 0)
		CSegyMeta::setSegyTotalTrace(&filez, count2);

	filez.Close();
	filez2.Close();
	tStr.Format(_T("Finished segy file split. Please check files: \n%s \nand \n%s ."), outFile, outFile2);
	AfxMessageBox(tStr, MB_ICONQUESTION);

}

void CSeisWideDoc::OnReflectionFaultenhancingOld_simpleSubtract()
{
	CString tStr;
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	bool isSquared = true;
	tStr.Format(_T("Fault enhancement shall be done by subtracting nearby traces. Do you want to the output segy squared? "));
	int ifeedback = AfxMessageBox(tStr, MB_YESNOCANCEL | MB_ICONINFORMATION | MB_ICONQUESTION);
	if (ifeedback == IDCANCEL) {
		// myShowHelp("proc_DigitizingLinearNoiseRemoval.html");
		pFrame->myCaption(_T("Help file to be constructed."));
		return;
	}
	else if (ifeedback == IDNO) {
		isSquared = false;
	}

	if (!isFileExistNotDirectory(draw.timeSecName)) {
		tStr.Format(_T(" Please display a time section first."));
		AfxMessageBox(tStr, MB_ICONQUESTION);
		return;
	}

	SegyWrapper sw(draw.timeSecName);
	//sw.m_isIBMFloatSegy2 = pFrame->gIsIBMFloatSegy2 == TRUE;
	if (CSegyMeta::segyHeadInit(draw.timeSecName, &head) != 1) return;
	if (!sw.open(&head, 0) || sw.headRead.getnx() < 2) {
		tStr.Format(_T("Input file cannot be opened properly."));
		AfxMessageBox(tStr, MB_ICONQUESTION);
		return;
	}


	int i, j; // for trace indeces
	segy tr;


	//	double dt = 1./odt;
	double odt = 1. / head.dtFile;
	float *tTrace = ealloc1float(head.numsampFiles);
	float tdelay1;
	float tdelay2;
	for (i = 0; i < sw.headRead.getnx() - 1; i++) {
		tdelay1 = sw.headRead.trArr[i].getTraceDelay();
		tdelay2 = sw.headRead.trArr[i + 1].getTraceDelay();
		if (tdelay1 != tdelay2) {
			for (j = 0; j < head.numsampFiles; j++) {
				tTrace[j] = (float)(tdelay1 + (float)j*head.dtFile);
			} // for i
			ints8r((int)head.numsampFiles, // ntin
				(float)head.dtFile,   // dtin
				tdelay2,   // ftin
				&sw.headRead.trArr[i + 1].data[0], // yin[t=ntin], with yin[0] = y(fxin)
				0.f,  // yinl    value used to extrapolate yin values to left of yin[0]
				0.f,  // yinr	 value used to extrapolate yin values to right of yin[ntin-1]
				(int)head.numsampFiles,   // nxout
				(float *)&tTrace[0],  // 
				(float *)&tr.dat.data[0]);    // tout
											  // now, tr.dat.data[] is interpolated data of trace [i+1] with each sample 
			for (j = 0; j < (int)head.numsampFiles; j++)
				sw.headRead.trArr[i].data[j] -= tr.dat.data[j];
		}
		else {
			// trace delay is not changed for traces at i and i+1, so we just subtract directly.
			for (j = 0; j < (int)head.numsampFiles; j++)
				sw.headRead.trArr[i].data[j] -= sw.headRead.trArr[i + 1].data[j];
		}

		// finally, make it energy only
		if (isSquared) {
			for (j = 0; j < (int)head.numsampFiles; j++)
				sw.headRead.trArr[i].data[j] = sw.headRead.trArr[i].data[j] * (float)fabs(sw.headRead.trArr[i].data[j]);
		}

	} // for i
	free1float(tTrace);

	for (j = 0; j < (int)head.numsampFiles; j++)
		sw.headRead.trArr[sw.headRead.getnx() - 1].data[j] = sw.headRead.trArr[sw.headRead.getnx() - 2].data[j];
	sw.headRead.trArr[sw.headRead.getnx() - 1].delrt = sw.headRead.trArr[sw.headRead.getnx() - 2].delrt;
	sw.headRead.trArr[sw.headRead.getnx() - 1].delrtEx = sw.headRead.trArr[sw.headRead.getnx() - 2].delrtEx;

	tStr = getFileNameAppend(draw.timeSecName, _T("FaultEnh"));
	int ii = sw.writeDataAll(tStr);
	draw.timeSecName = tStr;
	tStr.Format(_T("%d traces written."), ii);
	AfxMessageBox(tStr, MB_ICONQUESTION);
}

void CSeisWideDoc::OnReflectionFaultenhancing()
{
	CString tStr;
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	//bool isSquared = true;
	//tStr.Format(_T("Fault enhancement shall be done by subtracting nearby traces. Do you want to the output segy squared? "));
	//int ifeedback = AfxMessageBox(tStr, MB_YESNOCANCEL | MB_ICONINFORMATION | MB_ICONQUESTION);
	//if (ifeedback == IDCANCEL) {
	//	// myShowHelp("proc_DigitizingLinearNoiseRemoval.html");
	//	pFrame->myCaption(_T("Help file to be constructed."));
	//	return;
	//}
	//else if (ifeedback == IDNO) {
	//	isSquared = false;
	//}

	tStr.Format(_T("Fault enhancement by LoG edge enhancer."));
	AfxMessageBox(tStr, MB_ICONQUESTION);
	if (cd.coord.isTraceMode()) return;

	if (!isFileExistNotDirectory(draw.timeSecName))  {
		tStr.Format(_T(" Please display a time section first."));
		AfxMessageBox(tStr, MB_ICONQUESTION);
		return;
	}

	double tmin = cd.coord.Y1();
	double tmax = cd.coord.Y2();
	double xmin = cd.coord.X1() - draw.distShift;
	double xmax = cd.coord.X2() - draw.distShift;
	if (CSegyMeta::segyHeadInit(draw.timeSecName, &head) != 1) return;

	SegyWrapperEx sw(draw.timeSecName, xmin, xmax, tmin, tmax, cd.coord.drawmode);
	sw.m_dxMin = sw.m_dyMin = 0.; // read all traces
	draw.red.clone(&sw.red2);
	if (!sw.openDistance(!cd.coord.isDistanceDisplay, head.numTraces, &head) || sw.headRead.getnx() < 2) {
		tStr.Format(_T("Input file cannot be opened properly."));
		pFrame->myCaption(tStr);
		AfxMessageBox(tStr, MB_ICONQUESTION);
		return;
	}

	pFrame->statMain.myCursor(true);
	HEAD_READ headDx;  // will hold gradient along X-axis
	SegyWrapper::headReadCopyReset(&sw.headRead, &headDx);
	HEAD_READ headDt;  // will hold gradient along T-axis
	SegyWrapper::headReadCopyReset(&sw.headRead, &headDt);

	bool isSuc = SegyWrapperEx::processingGradientKm(&sw.headRead, &headDx, &headDt, cd.coord.isDistanceDisplay==TRUE);
	if (isSuc) {
		// now do a mix and then output
		for (int it = 0; it < headDx.getns(); it++)
			for (int ix = 0; ix < headDx.getnx(); ix++)
				sw.headRead.trArr[ix].data[it] = (float)(fabs(headDx.trArr[ix].data[it]) + fabs(headDt.trArr[ix].data[it]));


		tStr = getFileNameAppendTemp(draw.timeSecName, _T("_gradientMix"));
		SegyWrapper::saveToSegyFile(&sw.headRead, tStr, head.ascHead, TRUE);

		// now save the gradient data to disk
		tStr = getFileNameAppendTemp(draw.timeSecName, _T("_dt"));
		SegyWrapper::saveToSegyFile(&headDt, tStr, head.ascHead, TRUE);
		tStr = getFileNameAppendTemp(draw.timeSecName, _T("_dx"));
		SegyWrapper::saveToSegyFile(&headDx, tStr, head.ascHead, TRUE);
		draw.timeSecName = tStr;
	}
	SegyWrapper::freeSegyArray(&headDx);
	SegyWrapper::freeSegyArray(&headDt);
	pFrame->statMain.myCursor(false);

	tStr.Format(_T("Success."));
	pFrame->myCaption(tStr);
	OnToolbarRefreshAll();
}




#include "pfafft.h"
bool CSeisWideDoc::processingCoherencyCenterTrc(HEAD_READ *headRead, int multByCohMode, int numSmooth,
	int numTraceMix1, int numTraceMix2,
	double ymin, double ymax, double tWinCenter,
	double slopeMin, double slopeMax)
{
	// for cd.coord.drawmode==6 only
	CString tStr;
	static const int NVELMAX = 10;
	int i;
	float nsum[NVELMAX];
	float dsum[NVELMAX];

	// int NDISTMAX = numTraceMix;
	int numMixMax = max(numTraceMix1, numTraceMix2);
	if (numMixMax > 100) numMixMax = 100;
	segy tr;

	int nx = headRead->getnx();
	int numsamp = headRead->getns();
	float ***amp = (float***)ealloc3float(numsamp, numMixMax, NVELMAX);
	if (ERROR == amp) return false;

	float **numi = (float**)ealloc2float(numsamp, NVELMAX);
	float **deno = (float**)ealloc2float(numsamp, NVELMAX);
	float **nnz = (float**)ealloc2float(numsamp, NVELMAX);

	float *famRange = (float*)ealloc1float(numMixMax);
	float *weights = (float*)ealloc1float(numMixMax);
	float *tTrace = ealloc1float(numsamp);
	float *cohTrace = ealloc1float(numsamp);

	int lWinCenter = (int)ceil(tWinCenter*0.5 / headRead->getdt()) + 1;
	double deltaSlope = (slopeMax - slopeMin) / (double)(NVELMAX - 1);
	int lenBytes = numsamp * ((headRead->bh.format != 3) ? 4 : 2);

	/*
	C.....Coherency filtering:
	C     I:      index of samples for the output trace
	C     IV:     counter in a loop for scanning velocities from VELMIN to
	C             VELMAX km/sec. The increment of calculation is 0.5 km/sec
	C     fam(I,IX): Array storing data of the gather (NUM traces)
	C     VELMIN:    Minimum scanning velocity for calculating coherency/stacking
	C     VELMAX:    Minimum scanning velocity for calculating coherency/stacking
	C     numi(I,IV): Temparory array storing the total energy
	C     deno(I,IV):  Temparory array storing the similarity of traces of the
	C                  gather
	numRed= (VELMAX-VELMIN)*2.+1.5 ! Number of scanning velocities
	km=FLOAT(NUM)*.5+.5          ! Index of the middle trace of the gather
	lwindow=TWINDOW*INTRATE*.5     ! Calculate half window length in records
	reci=1./FLOAT((2*LWINDOW+1)*NUM) ! Reciprocal of N*M
	*/
	HEAD_READ headTo;  // will hold the output data
	SegyWrapper::headReadCopy(headRead, &headTo, 0, false);
	int tracl1 = headRead->trArr[0].tracl;
	int tracl2 = headRead->trArr[nx - 1].tracl;
	if (tracl2 == tracl1) tracl2 = tracl1 + 1; // this should not happen
	for (int iTrc = 0; iTrc < nx; iTrc++) {
		register double xCenter = headRead->trArr[iTrc].tracl;
		register double tminCalcCenter = headRead->trArr[iTrc].getTraceDelay();
		register double nMixThis = numTraceMix1 + (numTraceMix2 - numTraceMix1) *
			(xCenter - tracl1) / (tracl2 - tracl1);
		register int ixStart = iTrc - (int)(nMixThis / 2.0);
		if (ixStart < 0) ixStart = 0;
		register double  x1 = headRead->trArr[ixStart].tracl;
		for (int ix = ixStart; ix <= iTrc; ix++) {
			if (headRead->trArr[ix].tracl >= xCenter - nMixThis * 0.5) {
				ixStart = ix;  // found the starting trace index for mix
				break;
			}
		} // for ix

		int numMix = 0;
		for (int ix = ixStart; ix<iTrc + nMixThis / 2; ix++) {
			if (numMix >= nMixThis || ix >= nx) break; // this is important to avoid crash
			famRange[numMix] = (float)headRead->trArr[ix].tracl;
			if (famRange[numMix] >(float)(xCenter + nMixThis * 0.5)) break;
			numMix++;
		}
		// now, the mix should start at trace number of ix1 and span numTrcMix traces

		// now the rule of thumb: if we have reducing velocity, we have to scan slopes using offset, otherwise the reducing time is different from adjancent mixing window.
		// If we do not have reducing velocity, we can use the current cd.coord.isDistanceDisplay to use either offset or distance for mixing window
		for (int iv = 0; iv < NVELMAX; iv++) {
			// note: the segy data itself does not know about reducing velocity; only display cares about Vred.

			// slope is actually the slope: dt/dx. Must consider reducing velocities!!!
			register double slope = slopeMin + (double)iv*deltaSlope;
			for (int ix = 0; ix < numMix; ix++) {
				tTrace[0] = (float)tminCalcCenter; // initialize
				tTrace[0] += (float)((famRange[ix] - xCenter) * slope);
				for (i = 1; i < numsamp; i++) {
					tTrace[i] = tTrace[i - 1] + (float)headRead->getdt();
				} // for i

				register float vl = headRead->trArr[ixStart + ix].data[0];
				register float vr = headRead->trArr[ixStart + ix].data[numsamp - 1];
				ints8r(numsamp, // ntin
					(float)headRead->getdt(),   // dtin
					headRead->trArr[ixStart + ix].getTraceDelay(), // ftin
					&headRead->trArr[ixStart + ix].data[0], // yin[t=ntin], with yin[0] = y(fxin)
					vl,  // yinl    value used to extrapolate yin values to left of yin[0]
					vr,  // yinr	 value used to extrapolate yin values to right of yin[ntin-1]
					numsamp,   // nxout
					(float *)&tTrace[0],  // 
					(float *)&amp[iv][ix][0]);    // tout
			} // for ix

			memset((void *)&numi[iv][0], (int) '\0', numsamp*sizeof(float));
			memset((void *)&deno[iv][0], (int) '\0', numsamp*sizeof(float));
			memset((void *)&nnz[iv][0], (int) '\0', numsamp*sizeof(float));
			for (int ix = 0; ix < numMix; ix++) {
				for (i = 0; i < numsamp; i++) {
					if (fabs(amp[iv][ix][i]) > MINAMP) {
						numi[iv][i] += amp[iv][ix][i];
						deno[iv][i] += amp[iv][ix][i] * amp[iv][ix][i];
						nnz[iv][i] += 1.f;
					}
				}
			} // for ix
		} // for iv

		for (i = 0; i < numsamp; i++) {
			memset((void *)&nsum[0], (int) '\0', NVELMAX*sizeof(float));
			memset((void *)&dsum[0], (int) '\0', NVELMAX*sizeof(float));

			for (int iv = 0; iv < NVELMAX; iv++) {
				for (int iw = i - lWinCenter; iw < i + lWinCenter; iw++) {
					if (iw >= 0 && iw < numsamp) {
						nsum[iv] += numi[iv][iw] * numi[iv][iw];
						dsum[iv] += deno[iv][iw];
					}
				} // for iw
				nsum[iv] = (dsum[iv] > MINAMP) ? (float)(nsum[iv] / dsum[iv]) : 0.0f;
			} // for iv

			register int ind = getMaxIndex(nsum, NVELMAX);
			if (ind >= 0 && nnz[ind][i] > 0.f) {
				register float reci = (float)(6000. / (double)(2 * lWinCenter + 1 * nnz[ind][i])); //Reciprocal of N*M 
				// why divide by 1000? Because it can be too big

				switch (multByCohMode) {
				case 0:
					tr.dat.data[i] = numi[ind][i];
					cohTrace[i] = 1.f;  // will not need max coh any more
					break;
				case 1:
					tr.dat.data[i] = numi[ind][i];  // a sum along optimal slope
					cohTrace[i] = nsum[ind] / reci; // optimal cohency
					break;
				case 2:
					// if here, it will output the max coherency at each sample at the last counterCoh
					tr.dat.data[i] = 1.f; // will only need max coh
					cohTrace[i] = nsum[ind] / reci; // optimal cohency
					break;
				default:
					tr.dat.data[i] = amp[ind][numMix / 2][i]; // will multiply by max coh
					cohTrace[i] = nsum[ind] / reci; // optimal cohency
				}  // end switch
			}
		} // for i


		// now do a running mean for the computed cohenrency, since it may be very irregular
		gaussian1d_smoothing(numsamp, numSmooth, cohTrace);

		// obtain final results
		for (i = 0; i < numsamp; i++) {
			tr.dat.data[i] *= cohTrace[i];
		} // for i

		float ampLimit = (float)(1000. * getMedianAbsolute(&tr.dat.data[0], (long)numsamp));
		for (i = 0; i<numsamp; i++) {
			if (_isnan(tr.dat.data[i])) tr.dat.data[i] = 0.f;
			else if (tr.dat.data[i] > ampLimit)
				tr.dat.data[i] = ampLimit;
			else if (tr.dat.data[i] < -ampLimit)
				tr.dat.data[i] = -ampLimit;
		}
		memcpy((void *)&headTo.trArr[iTrc].data[0], (void *)&tr.dat.data[0], lenBytes);
	}  // for iTrc

	free3float(amp);
	free2float(numi);
	free2float(deno);
	free2float(nnz);
	free1float(famRange);
	free1float(weights);
	free1float(tTrace);
	free1float(cohTrace);

	SegyWrapper::headReadCopy(&headTo, headRead, 0, false);
	SegyWrapper::freeSegyArray(&headTo);

	return true;
}


bool CSeisWideDoc::processingCoherencyCenter(HEAD_READ *headRead,
	int drawmode, bool isDistanceDisplay, int multByCohMode, int numSmooth,
	double dxMix1, double dxMix2, double dxAvgInterval, double ymin, double ymax, double tWinCenter,
	double slopeMin, double slopeMax)
{
	// for cd.coord.drawmode!=6 only
	if (drawmode == 6)
		return processingCoherencyCenterTrc(headRead, multByCohMode, numSmooth, (int)dxMix1, (int)dxMix2,
		ymin, ymax, tWinCenter, slopeMin, slopeMax);

	// Note: this function will assume that the *headRead is already sorted properly according to isDistanceDisplay!!!
	//		dxMix1 will be used for trace1, and dxMix2 will be for the last trace!!!
	//		which is not checked for here!!!

	CString tStr;
	static const int NVELMAX = 10;
	int i, ix, iv;
	float nsum[NVELMAX];
	float dsum[NVELMAX];
	if (dxAvgInterval < MINAMP) dxAvgInterval = 1.;
	int NDISTMAX = (int)ceil(max(dxMix1, dxMix2) / dxAvgInterval) + 1;
	if (NDISTMAX > 100) NDISTMAX = 100;
	segy tr;

	int nx = headRead->getnx();
	int numsamp = headRead->getns();
	float ***amp = (float***)ealloc3float(numsamp, NDISTMAX, NVELMAX);
	if (ERROR == amp) return false;

	float **numi = (float**)ealloc2float(numsamp, NVELMAX);
	float **deno = (float**)ealloc2float(numsamp, NVELMAX);
	float **nnz = (float**)ealloc2float(numsamp, NVELMAX);

	float *famRange = (float*)ealloc1float(NDISTMAX);
	float *famOffset = (float*)ealloc1float(NDISTMAX);
	float *weights = (float*)ealloc1float(NDISTMAX);
	float *tTrace = ealloc1float(numsamp);
	float *cohTrace = ealloc1float(numsamp);

	double dt = headRead->getdt();
	int lWinCenter = (int)ceil(tWinCenter*0.5 / dt) + 1;
	double deltaSlope = (slopeMax - slopeMin) / (double)(NVELMAX - 1);
	int lenBytes = numsamp * ((headRead->bh.format != 3) ? 4 : 2); 
	double PI2 = PI * 2.;

	/*
	C.....Coherency filtering:
	C     I:      index of samples for the output trace
	C     IV:     counter in a loop for scanning velocities from VELMIN to
	C             VELMAX km/sec. The increment of calculation is 0.5 km/sec
	C     fam(I,IX): Array storing data of the gather (NUM traces)
	C     VELMIN:    Minimum scanning velocity for calculating coherency/stacking
	C     VELMAX:    Minimum scanning velocity for calculating coherency/stacking
	C     numi(I,IV): Temparory array storing the total energy
	C     deno(I,IV):  Temparory array storing the similarity of traces of the
	C                  gather
	numRed= (VELMAX-VELMIN)*2.+1.5 ! Number of scanning velocities
	km=FLOAT(NUM)*.5+.5          ! Index of the middle trace of the gather
	lwindow=TWINDOW*INTRATE*.5     ! Calculate half window length in records
	reci=1./FLOAT((2*LWINDOW+1)*NUM) ! Reciprocal of N*M
	*/
	HEAD_READ headTo;  // will hold the output data
	SegyWrapper::headReadCopy(headRead, &headTo, 0, false);

	double xCenter1 = headRead->trArr[0].getTraceXVal(drawmode, isDistanceDisplay);
	double xCenter2 = headRead->trArr[nx - 1].getTraceXVal(drawmode, isDistanceDisplay);
	if (fabs(xCenter2 - xCenter1) < MINAMP) xCenter2 = xCenter1 + MINAMP;  // this cannot happen but just in case
	if (!isDistanceDisplay && fabs(xCenter1) < fabs(xCenter2)) {
		// a simple catch when in offset display, not never happen
		if (fabs(xCenter1) < fabs(xCenter2) && dxMix1 > dxMix2) {
			// we just want to swap the dxMin values
			double ftemp = dxMix1;
			dxMix1 = dxMix2;
			dxMix2 = ftemp;
		}
	}


	CCoords::REDUCE redDynamic;
	draw.red.clone(&redDynamic);
	double dxMixOCenter = (dxMix2 - dxMix1) / (xCenter2 - xCenter1);

	for (int iTrc = 0; iTrc < nx; iTrc++) {
		register double xCenter = headRead->trArr[iTrc].getTraceXVal(drawmode, isDistanceDisplay);
		register double offsetCenter = headRead->trArr[iTrc].getOffset();  // negative offset is found to be causing problems!
		register double tminCalcCenter = headRead->trArr[iTrc].getTraceDelay();
		register double dxMixThis = dxMix1 + dxMixOCenter * (xCenter - xCenter1);
		// centered around the famXXX arrays for all semblance calculations

		register int ixStart = iTrc - NDISTMAX / 2;
		if (ixStart < 0) ixStart = 0;
		// float x1 = getTraceXVal(&headRead->trArr[ixStart], drawmode, isDistanceDisplay);
		for (ix = ixStart; ix <= iTrc; ix++) {
			register double x = headRead->trArr[ix].getTraceXVal(drawmode, isDistanceDisplay);
			if (x >= xCenter - dxMixThis * 0.5) {
				ixStart = ix;  // found the starting trace index for mix
				break;
			}
		} // for ix

		int numMix = 0;
		for (ix = ixStart; ix<iTrc + NDISTMAX / 2; ix++) {
			if (numMix >= NDISTMAX || ix >= nx) break; // this is important to avoid crash
			famRange[numMix] = headRead->trArr[ix].getTraceXVal(drawmode, isDistanceDisplay);
			if (famRange[numMix] >(float)(xCenter + dxMixThis * 0.5)) break;
			famOffset[numMix] = headRead->trArr[ix].getOffset(); //this is truly offset, range can be either offset or distance.
			// negative offset is found to be causing problems!
			numMix++;
		}
		// now, the mix should start at trace number of ix1 and span numMix traces
		for (ix = 0; ix < numMix; ix++) {
			// apply Hanning window to each side of the center
			// wn = 0.5 * [1. - cos(pi2 * n / (N-1)], and center is at n = (N-1)/2
			register double wn = 1. - fabs(famRange[ix] - xCenter) / dxMixThis;
			if (wn < 0.) wn = 0.;
			else if (wn > 1.) wn = 1.;
			weights[ix] = (float)(0.5 * (1. - cos(PI * wn)));
		}

		// now the rule of thumb: if we have reducing velocity, we have to scan slopes using offset, otherwise the reducing time is different from adjancent mixing window.
		// If we do not have reducing velocity, we can use the current cd.coord.isDistanceDisplay to use either offset or distance for mixing window
		register double slopeThis; // slope is actually the slope: dt/dx. Must consider reducing velocities!!!
		for (iv = 0; iv < NVELMAX; iv++) {
			// note: the segy data itself does not know about reducing velocity; only display cares about Vred.
			slopeThis = slopeMin + (double)iv*deltaSlope; // slope is actually the slope: dt/dx. Must consider reducing velocities!!!
			for (ix = 0; ix < numMix; ix++) {
				// initialize  first point of tTrace[]
				if (!isFloatEqual(slopeThis, 0.0)) {
					redDynamic.rvred = slopeThis;
					tTrace[0] = (float)tminCalcCenter +
						(float)(
						CCoords::getReduceTimeEx2(famOffset[ix], cd.coord.drawmode, &redDynamic) -
						CCoords::getReduceTimeEx2(offsetCenter, cd.coord.drawmode, &redDynamic)
						);
				}
				else
					tTrace[0] = (float)tminCalcCenter;

				for (i = 1; i < numsamp; i++) {
					tTrace[i] = tTrace[i - 1] + (float)dt;
				} // for i

				register float vl = headRead->trArr[ixStart + ix].data[0];
				register float vr = headRead->trArr[ixStart + ix].data[numsamp - 1];
				ints8r(numsamp, // ntin
					(float)dt,   // dtin
					headRead->trArr[ixStart + ix].getTraceDelay(), // ftin
					&headRead->trArr[ixStart + ix].data[0], // yin[t=ntin], with yin[0] = y(fxin)
					vl,  // yinl    value used to extrapolate yin values to left of yin[0]
					vr,  // yinr	 value used to extrapolate yin values to right of yin[ntin-1]
					numsamp,   // nxout
					(float *)&tTrace[0],  // 
					(float *)&amp[iv][ix][0]);    // tout
			} // for ix

			// now, for each iv and it, we need to smooth data across ix before stacking
			float *ampsX = ealloc1float(numMix);
			for (i = 0; i < numsamp; i++) {
				memset((void *)&ampsX[0], (int) '\0', numMix*sizeof(float));
				for (ix = 0; ix<numMix; ix++) {
					ampsX[ix] = (float)fabs(amp[iv][ix][i]);
				} // for i

				// conditioning the data before mixing calc
				register float maxAmp = getMaxValue(ampsX, numMix);
				register float avgAmp = getMedianValue(ampsX, numMix);
				if (maxAmp > avgAmp*5.f) maxAmp = avgAmp*5.f;
				for (ix = 0; ix < numMix; ix++) {
					if (amp[iv][ix][i] > maxAmp) amp[iv][ix][i] = (float)maxAmp;
					else if (amp[iv][ix][i] < -maxAmp)  amp[iv][ix][i] = -(float)maxAmp;

					// apply Hanning window to each side of the center
					// wn = 0.5 * [1. - cos(pi2 * n / (N-1)], and center is at n = (N-1)/2
					amp[iv][ix][i] *= weights[ix];
				}
			}
			free1float(ampsX);



			// now sum up
			memset((void *)&numi[iv][0], (int) '\0', numsamp*sizeof(float));
			memset((void *)&nnz[iv][0], (int) '\0', numsamp*sizeof(float));
			memset((void *)&deno[iv][0], (int) '\0', numsamp*sizeof(float));
			for (i = 0; i < numsamp; i++) {
				for (ix = 0; ix < numMix; ix++) {
					if (fabs(amp[iv][ix][i]) > MINAMP) {
						numi[iv][i] += amp[iv][ix][i];
						deno[iv][i] += amp[iv][ix][i] * amp[iv][ix][i];
						nnz[iv][i] += 1.f;
					}
				} // for ix
			} // for i
		} // for iv

		memset((void *)&cohTrace[0], (int) '\0', numsamp*sizeof(float));
		memset((void *)&tr.dat.data[0], (int) '\0', numsamp*sizeof(float));
		for (i = 0; i < numsamp; i++) {
			memset((void *)&nsum[0], (int) '\0', NVELMAX*sizeof(float));
			memset((void *)&dsum[0], (int) '\0', NVELMAX*sizeof(float));

			for (iv = 0; iv < NVELMAX; iv++) {
				for (int iw = i - lWinCenter; iw < i + lWinCenter; iw++) {
					if (iw >= 0 && iw < numsamp) {
						nsum[iv] += numi[iv][iw] * numi[iv][iw];
						dsum[iv] += deno[iv][iw];
					}
				} // for iw
				nsum[iv] = (dsum[iv] > MINAMP) ? (float)(nsum[iv] / dsum[iv]) : 0.0f;
			} // for iv

			register int ind = getMaxIndex(nsum, NVELMAX);
			if (ind >= 0 && nnz[ind][i] > 0.f) {
				register float reci = (float)(6000. / (double)(2 * lWinCenter + 1 * nnz[ind][i])); //Reciprocal of N*M 
				// why divide by 1000? Because it can be too big

				switch (multByCohMode) {
				case 0:
					tr.dat.data[i] = numi[ind][i];  // a sum along optimal slope
					cohTrace[i] = 1.f;  // will not need max coh any more
					break;
				case 1:
					tr.dat.data[i] = numi[ind][i];  // a sum along optimal slope
					cohTrace[i] = nsum[ind] / reci; // optimal cohency
					break;
				case 2:
					// if here, it will output the max coherency at each sample at the last counterCoh
					tr.dat.data[i] = 1.f; // will only need max coh
					cohTrace[i] = nsum[ind] / reci; // optimal cohency
					break;
				default:
					tr.dat.data[i] = amp[ind][numMix / 2][i]; // will multiply by max coh
					cohTrace[i] = nsum[ind] / reci; // optimal cohency
				}
			} // if
		} // for i

		// now do a running mean for the computed cohenrency, since it may be very irregular
		gaussian1d_smoothing(numsamp, numSmooth, cohTrace);

		// obtain final results
		for (i = 0; i < numsamp; i++) {
			tr.dat.data[i] *= cohTrace[i];
		} // for i


		float ampLimit = (float)(1000. * getMedianAbsolute(&tr.dat.data[0], (long)numsamp));
		for (i = 0; i<numsamp; i++) {
			if (_isnan(tr.dat.data[i])) tr.dat.data[i] = 0.f;
			else if (tr.dat.data[i] > ampLimit)
				tr.dat.data[i] = ampLimit;
			else if (tr.dat.data[i] < -ampLimit)
				tr.dat.data[i] = -ampLimit;
		}
		memcpy((void *)&headTo.trArr[iTrc].data[0], (void *)&tr.dat.data[0], lenBytes);
	}  // for iTrc

	free3float(amp);
	free2float(numi);
	free2float(deno);
	free2float(nnz);
	free1float(famRange);
	free1float(famOffset);
	free1float(weights);
	free1float(tTrace);
	free1float(cohTrace);

	SegyWrapper::headReadCopy(&headTo, headRead, 0, false);
	SegyWrapper::freeSegyArray(&headTo);

	return true;
}


// Note: this function will assume that the *headRead is already sorted properly according to isDistanceDisplay!!!
//		dxMix1 will be used for trace1, and dxMix2 will be for the last trace!!!
//		which is not checked for here!!!
// (slopeMin1, slopeMax1) is for 
bool CSeisWideDoc::processingCoherencyCenter(HEAD_READ *headRead,
	int drawmode, bool isDistanceDisplay, int multByCohMode, int numSmooth,
	double dxMix1, double dxMix2, double dxAvgInterval, double ymin, double ymax, double tWinCenter,
	double slopeMin1, double slopeMax1,  // for the smallest offset
	double slopeMin2, double slopeMax2)  // for the max offset
{
	// for cd.coord.drawmode!=6 only
	if (drawmode == 6)
		return processingCoherencyCenterTrc(headRead, multByCohMode, numSmooth, (int)dxMix1, (int)dxMix2,
			ymin, ymax, tWinCenter, slopeMin1, slopeMax1);

	CString tStr;
	static const int NVELMAX = 10;
	int i, ix, iv;
	float nsum[NVELMAX];
	float dsum[NVELMAX];
	float weightv[NVELMAX];
	for (iv = 0; iv < NVELMAX; iv++) {
		weightv[iv] = 1.0f - 0.5f * (float)iv / 9.f;
	}
	if (dxAvgInterval < MINAMP) dxAvgInterval = 1.;
	int NDISTMAX = (int)ceil(max(dxMix1, dxMix2) / dxAvgInterval) + 1;
	if (NDISTMAX > 100) NDISTMAX = 100;
	segy tr;

	int nx = headRead->getnx();
	int numsamp = headRead->getns();
	float ***amp = (float***)ealloc3float(numsamp, NDISTMAX, NVELMAX);
	if (ERROR == amp) return false;

	float **numi = (float**)ealloc2float(numsamp, NVELMAX);
	float **deno = (float**)ealloc2float(numsamp, NVELMAX);
	float **nnz = (float**)ealloc2float(numsamp, NVELMAX);

	float *famRange = (float*)ealloc1float(NDISTMAX);
	float *famOffset = (float*)ealloc1float(NDISTMAX);
	float *weights = (float*)ealloc1float(NDISTMAX);
	float *tTrace = ealloc1float(numsamp);
	float *cohTrace = ealloc1float(numsamp);

	double dt = headRead->getdt();
	int lWinCenter = (int)ceil(tWinCenter*0.5 / dt) + 1;
	int lenBytes = numsamp * ((headRead->bh.format != 3) ? 4 : 2);
	double PI2 = PI * 2.;

	/*
	C.....Coherency filtering:
	C     I:      index of samples for the output trace
	C     IV:     counter in a loop for scanning velocities from VELMIN to
	C             VELMAX km/sec. The increment of calculation is 0.5 km/sec
	C     fam(I,IX): Array storing data of the gather (NUM traces)
	C     VELMIN:    Minimum scanning velocity for calculating coherency/stacking
	C     VELMAX:    Minimum scanning velocity for calculating coherency/stacking
	C     numi(I,IV): Temparory array storing the total energy
	C     deno(I,IV):  Temparory array storing the similarity of traces of the
	C                  gather
	numRed= (VELMAX-VELMIN)*2.+1.5 ! Number of scanning velocities
	km=FLOAT(NUM)*.5+.5          ! Index of the middle trace of the gather
	lwindow=TWINDOW*INTRATE*.5     ! Calculate half window length in records
	reci=1./FLOAT((2*LWINDOW+1)*NUM) ! Reciprocal of N*M
	*/
	HEAD_READ headTo;  // will hold the output data
	SegyWrapper::headReadCopy(headRead, &headTo, 0, false);

	double xCenter1 = headRead->trArr[0].getTraceXVal(drawmode, isDistanceDisplay);
	double xCenter2 = headRead->trArr[nx - 1].getTraceXVal(drawmode, isDistanceDisplay);
	if (fabs(xCenter2 - xCenter1) < MINAMP) xCenter2 = xCenter1 + MINAMP;  // this cannot happen but just in case
	if (!isDistanceDisplay && fabs(xCenter1) < fabs(xCenter2)) {
		// a simple catch when in offset display, not never happen
		if (fabs(xCenter1) < fabs(xCenter2) && dxMix1 > dxMix2) {
			// we just want to swap the dxMin values
			double ftemp = dxMix1;
			dxMix1 = dxMix2;
			dxMix2 = ftemp;
		}
	}


	CCoords::REDUCE redDynamic;
	draw.red.clone(&redDynamic);
	double dxMixOCenter = (dxMix2 - dxMix1) / (xCenter2 - xCenter1);


	double dsMinMix = (slopeMin2 - slopeMin1) / (xCenter2 - xCenter1);  // starting slope for xmin
	double deltaSlope1 = (slopeMax1 - slopeMin1) / (double)(NVELMAX - 1);  // slope spanning for xmin
	double deltaSlope2 = (slopeMax2 - slopeMin2) / (double)(NVELMAX - 1);  // slope spanning for xmax
	double deltaS = (deltaSlope2 - deltaSlope1) / (xCenter2 - xCenter1);  

	// CStringArray *outprint = new CStringArray();
	for (int iTrc = 0; iTrc < nx; iTrc++) {
		register double xCenter = headRead->trArr[iTrc].getTraceXVal(drawmode, isDistanceDisplay);
		register double offsetCenter = headRead->trArr[iTrc].getOffset();  // negative offset is found to be causing problems!
		register double tminCalcCenter = headRead->trArr[iTrc].getTraceDelay();
		register double dxMixThis = dxMix1 + dxMixOCenter * (xCenter - xCenter1);
		// centered around the famXXX arrays for all semblance calculations

		register double slopeMinThis = slopeMin1 + dsMinMix * (xCenter - xCenter1); // starting slope for this trace (xCenter)
		register double deltaSlopeThis = deltaSlope1 + deltaS * (xCenter - xCenter1); // slope increment for each iteration of iv


		register int ixStart = iTrc - NDISTMAX / 2;
		if (ixStart < 0) ixStart = 0;
		// float x1 = getTraceXVal(&headRead->trArr[ixStart], drawmode, isDistanceDisplay);
		for (ix = ixStart; ix <= iTrc; ix++) {
			register double x = headRead->trArr[ix].getTraceXVal(drawmode, isDistanceDisplay);
			if (x >= xCenter - dxMixThis * 0.5) {
				ixStart = ix;  // found the starting trace index for mix
				break;
			}
		} // for ix

		int numMix = 0;
		for (ix = ixStart; ix<iTrc + NDISTMAX / 2; ix++) {
			if (numMix >= NDISTMAX || ix >= nx) break; // this is important to avoid crash
			famRange[numMix] = headRead->trArr[ix].getTraceXVal(drawmode, isDistanceDisplay);
			if (famRange[numMix] >(float)(xCenter + dxMixThis * 0.5)) break;
			famOffset[numMix] = headRead->trArr[ix].getOffset(); //this is truly offset, range can be either offset or distance.
																 // negative offset is found to be causing problems!
			numMix++;
		}
		// now, the mix should start at trace number of ix1 and span numMix traces
		for (ix = 0; ix < numMix; ix++) {
			// apply Hanning window to each side of the center
			// wn = 0.5 * [1. - cos(pi2 * n / (N-1)], and center is at n = (N-1)/2
			register double wn = 1. - fabs(famRange[ix] - xCenter) / dxMixThis;
			if (wn < 0.) wn = 0.;
			else if (wn > 1.) wn = 1.;
			weights[ix] = (float)(0.5 * (1. - cos(PI * wn)));
		}

		// now the rule of thumb: if we have reducing velocity, we have to scan slopes using offset, otherwise the reducing time is different from adjancent mixing window.
		// If we do not have reducing velocity, we can use the current cd.coord.isDistanceDisplay to use either offset or distance for mixing window
		register double slopeThis; // slope is actually the slope: dt/dx. Must consider reducing velocities!!!
		for (iv = 0; iv < NVELMAX; iv++) {
			// note: the segy data itself does not know about reducing velocity; only display cares about Vred.
			slopeThis = slopeMinThis + (double)iv*deltaSlopeThis; // slope is actually the slope: dt/dx. Must consider reducing velocities!!!
			//tStr.Format(_T("Stacking at %2.3f km/s,  %3.3f km"), (float)(1./slopeThis), xCenter);
			//outprint->Add(tStr);

			for (ix = 0; ix < numMix; ix++) {
				// initialize  first point of tTrace[]
				if (!isFloatEqual(slopeThis, 0.0)) {
					redDynamic.rvred = slopeThis;
					tTrace[0] = (float)tminCalcCenter +
						(float)(
							CCoords::getReduceTimeEx2(famOffset[ix], cd.coord.drawmode, &redDynamic) -
							CCoords::getReduceTimeEx2(offsetCenter, cd.coord.drawmode, &redDynamic)
							);
				}
				else
					tTrace[0] = (float)tminCalcCenter;

				for (i = 1; i < numsamp; i++) {
					tTrace[i] = tTrace[i - 1] + (float)dt;
				} // for i

				register float vl = headRead->trArr[ixStart + ix].data[0];
				register float vr = headRead->trArr[ixStart + ix].data[numsamp - 1];
				ints8r(numsamp, // ntin
					(float)dt,   // dtin
					headRead->trArr[ixStart + ix].getTraceDelay(), // ftin
					&headRead->trArr[ixStart + ix].data[0], // yin[t=ntin], with yin[0] = y(fxin)
					vl,  // yinl    value used to extrapolate yin values to left of yin[0]
					vr,  // yinr	 value used to extrapolate yin values to right of yin[ntin-1]
					numsamp,   // nxout
					(float *)&tTrace[0],  // 
					(float *)&amp[iv][ix][0]);    // tout
			} // for ix

			  // now, for each iv and it, we need to smooth data across ix before stacking
			float *ampsX = ealloc1float(numMix);
			for (i = 0; i < numsamp; i++) {
				memset((void *)&ampsX[0], (int) '\0', numMix * sizeof(float));
				for (ix = 0; ix<numMix; ix++) {
					ampsX[ix] = (float)fabs(amp[iv][ix][i]);
				} // for i

				  // conditioning the data before mixing calc
				register float maxAmp = getMaxValue(ampsX, numMix);
				register float avgAmp = getMedianValue(ampsX, numMix);
				if (maxAmp > avgAmp*5.f) maxAmp = avgAmp*5.f;
				for (ix = 0; ix < numMix; ix++) {
					if (amp[iv][ix][i] > maxAmp) amp[iv][ix][i] = (float)maxAmp;
					else if (amp[iv][ix][i] < -maxAmp)  amp[iv][ix][i] = -(float)maxAmp;

					// apply Hanning window to each side of the center
					// wn = 0.5 * [1. - cos(pi2 * n / (N-1)], and center is at n = (N-1)/2
					amp[iv][ix][i] *= weights[ix];
				}
			}
			free1float(ampsX);



			// now sum up
			memset((void *)&numi[iv][0], (int) '\0', numsamp * sizeof(float));
			memset((void *)&nnz[iv][0], (int) '\0', numsamp * sizeof(float));
			memset((void *)&deno[iv][0], (int) '\0', numsamp * sizeof(float));
			for (i = 0; i < numsamp; i++) {
				for (ix = 0; ix < numMix; ix++) {
					if (fabs(amp[iv][ix][i]) > MINAMP) {
						numi[iv][i] += amp[iv][ix][i];
						deno[iv][i] += amp[iv][ix][i] * amp[iv][ix][i];
						nnz[iv][i] += 1.f;
					}
				} // for ix
			} // for i
		} // for iv

		memset((void *)&cohTrace[0], (int) '\0', numsamp * sizeof(float));
		memset((void *)&tr.dat.data[0], (int) '\0', numsamp * sizeof(float));
		for (i = 0; i < numsamp; i++) {
			memset((void *)&nsum[0], (int) '\0', NVELMAX * sizeof(float));
			memset((void *)&dsum[0], (int) '\0', NVELMAX * sizeof(float));

			for (iv = 0; iv < NVELMAX; iv++) {
				for (int iw = i - lWinCenter; iw < i + lWinCenter; iw++) {
					if (iw >= 0 && iw < numsamp) {
						nsum[iv] += numi[iv][iw] * numi[iv][iw];
						dsum[iv] += deno[iv][iw];
					}
				} // for iw
				nsum[iv] = (dsum[iv] > MINAMP) ? (float)(nsum[iv] / dsum[iv] * weightv[iv]) : 0.0f;
			} // for iv

			register int ind = getMaxIndex(nsum, NVELMAX);
			if (ind >= 0 && nnz[ind][i] > 0.f) {
				register float reci = (float)(6000. / (double)(2 * lWinCenter + 1 * nnz[ind][i])); //Reciprocal of N*M 
																								   // why divide by 1000? Because it can be too big

				switch (multByCohMode) {
				case 0:
					tr.dat.data[i] = numi[ind][i];  // a sum along optimal slope
					cohTrace[i] = 1.f;  // will not need max coh any more
					break;
				case 1:
					tr.dat.data[i] = numi[ind][i];  // a sum along optimal slope
					cohTrace[i] = nsum[ind] / reci; // optimal cohency
					break;
				case 2:
					// if here, it will output the max coherency at each sample at the last counterCoh
					tr.dat.data[i] = 1.f; // will only need max coh
					cohTrace[i] = nsum[ind] / reci; // optimal cohency
					break;
				default:
					tr.dat.data[i] = amp[ind][numMix / 2][i]; // will multiply by max coh
					cohTrace[i] = nsum[ind] / reci; // optimal cohency
				}
			} // if
		} // for i

		  // now do a running mean for the computed cohenrency, since it may be very irregular
		gaussian1d_smoothing(numsamp, numSmooth, cohTrace);

		// obtain final results
		for (i = 0; i < numsamp; i++) {
			tr.dat.data[i] *= cohTrace[i];
		} // for i


		float ampLimit = (float)(1000. * getMedianAbsolute(&tr.dat.data[0], (long)numsamp));
		for (i = 0; i<numsamp; i++) {
			if (_isnan(tr.dat.data[i])) tr.dat.data[i] = 0.f;
			else if (tr.dat.data[i] > ampLimit)
				tr.dat.data[i] = ampLimit;
			else if (tr.dat.data[i] < -ampLimit)
				tr.dat.data[i] = -ampLimit;
		}

		// testing
		//for (i = 0; i < numsamp; i++) {
		//	tr.dat.data[i] = 0.f;
		//	for (ix = 0; ix < numMix; ix++)
		//		tr.dat.data[i] += amp[0][ix][i];

		//	tr.dat.data[i] /= (float)numMix;
		//} // for i



		memcpy((void *)&headTo.trArr[iTrc].data[0], (void *)&tr.dat.data[0], lenBytes);
	}  // for iTrc

	free3float(amp);
	free2float(numi);
	free2float(deno);
	free2float(nnz);
	free1float(famRange);
	free1float(famOffset);
	free1float(weights);
	free1float(tTrace);
	free1float(cohTrace);

	SegyWrapper::headReadCopy(&headTo, headRead, 0, false);
	SegyWrapper::freeSegyArray(&headTo);

	//showStringArrayToFile(outprint);
	//outprint->RemoveAll();
	//delete outprint;

	return true;
}

void CSeisWideDoc::OnReflectionCoherencyplot()
{
	//	if (cd.coord.drawmode == 6) return;
	CString tStr;

	// actually the following should also work for cd.coord.drawmode==6, but not sure if it is ok when no distance info is defined?
	if (!isFileExistNotDirectory(draw.timeSecName)) {
		tStr.Format(_T("Valid segy time section not found. "));
		AfxMessageBox(tStr);
		return;
	}

	double slopeMin, slopeMin2;
	double slopeMax, slopeMax2;
	bool isNotReduced = (cd.coord.drawmode == 6) ||
		(cd.coord.drawmode != 6 && isFloatEqual(draw.red.rvred, 0.0));
	if (!cd.coord.isDistanceDisplay || !isNotReduced) {
		slopeMin = 1./3.;
		slopeMax = 1./2.;
		slopeMin2 = 1./8.;
		slopeMax2 = 1./5.;
	}
	else {
		slopeMin = -0.2;
		slopeMax = 0.2;
		slopeMin2 = -0.2;
		slopeMax2 = 0.2;
	}

	double dxMix1 = (cd.coord.drawmode == 6) ? 11 : 0.25; // in km, mixing window width1 (offset or distance)
	if (cd.coord.isDistanceDisplay && isFloatEqual(draw.red.rvred, 0.0)) {
		dxMix1 = 1.0; // in distance display, we do not want to have different dxMix1 and dxMix2, although it is ok to have
	}
	double dxMix2 = (cd.coord.drawmode == 6) ? 11 : 1.0; // in km, mixing window width2 (offset or distance)
	double tWindowFull = 1.; // in sec, full mixing time window multiplied by 1 center cycle

	static int outputMethod = 3; 
	// 0: sum
	// 1: sum and multiplied by cohenrency
	// 2: output cohenrency only
	// outputMethod=3, multiply output by coherency.
	// 

	static int nBigloop = 1;

	CString outFile = BLANK, inFile = BLANK;

	static double f1 = 0.;
	static double f2 = 0.;
	static int num_filters = 10;
	static int numSmooth = 3;

	CdlgCohMix dlg;
	dlg.m_dxMix1 = (float)dxMix1;
	dlg.m_dxMix2 = (float)dxMix2;
	dlg.m_procVelmin = (float)slopeMin;
	dlg.m_procVelmax = (float)slopeMax;
	dlg.m_procTWindow = (float)tWindowFull;
	dlg.m_procNameIn = draw.timeSecName;
	dlg.m_procNameOut = getFileNameAppend(draw.timeSecName, _T("Coh"));

	dlg.m_procTmax = (float)cd.coord.Y2();
	dlg.m_procTmin = (float)cd.coord.Y1();
	dlg.m_outputMethod = outputMethod;
	dlg.m_xmin = (float)cd.coord.X1();
	dlg.m_xmax = (float)cd.coord.X2();
	dlg.m_f1 = (float)f1;
	dlg.m_f2 = (float)f2;
	dlg.m_numDivision = num_filters;
	dlg.m_nSmooth = numSmooth;
	dlg.m_nBigLoop = nBigloop;
	if (dlg.DoModal() == IDOK) {
		dxMix1 = dlg.m_dxMix1;
		dxMix2 = dlg.m_dxMix2;
		inFile = dlg.m_procNameIn;
		outFile = dlg.m_procNameOut;

		if (cd.coord.isTraceMode()) {
			cd.coord.trace1 = (int)(dlg.m_xmin+0.5);
			cd.coord.trace2 = (int)(dlg.m_xmax+0.5);
		}
		else {
			cd.coord.xmin = dlg.m_xmin;
			cd.coord.xmax = dlg.m_xmax;
		}

		// but cd.coord.tmin/tmax are changed here
		cd.coord.setY2(dlg.m_procTmax);
		cd.coord.setY1(dlg.m_procTmin);
		tWindowFull = dlg.m_procTWindow;
		slopeMin = dlg.m_procVelmin;
		slopeMax = dlg.m_procVelmax;
		outputMethod = dlg.m_outputMethod;
		f1 = dlg.m_f1;
		f2 = dlg.m_f2;
		num_filters = dlg.m_numDivision;
		numSmooth = dlg.m_nSmooth;
		nBigloop = dlg.m_nBigLoop;
	}
	else {
		return;
	}
	// delete dlg;
	if (num_filters < 1) num_filters = 1;
	if (nBigloop < 1) nBigloop = 1;
	if (numSmooth < 1) numSmooth = 3; // this cannot be zero or negative
	if (!isFileExistNotDirectory(inFile) || outFile.IsEmpty()) return;

	CSegyMeta::segyHeadInit(inFile, &head);

	double dxAvgInterval = cd.coord.isDistanceDisplay ? head.distIntervalFile : head.offsetIntervalFile;
	int NDISTMAX = (int)ceil(max(dxMix1, dxMix2) / dxAvgInterval) + 1;
	if (NDISTMAX > 100) NDISTMAX = 100;
	if (cd.coord.drawmode == 6)
		tStr.Format(_T("Mixing shall span <=%d traces for a sliding window [%g, %g] at first and last traces."),
		NDISTMAX, dxMix1, dxMix2);
	else if (!cd.coord.isDistanceDisplay)
		tStr.Format(_T("Mixing shall span <=%d traces for a sliding window [%g, %g] km at offsets [%g, %g] km."),
		NDISTMAX, dxMix1, dxMix2, cd.coord.X1(), cd.coord.X2());
	else
		tStr.Format(_T("Mixing shall span <=%d traces for a sliding window [%g, %g] km at distance [%g, %g] km."),
		NDISTMAX, dxMix1, dxMix2, cd.coord.X1(), cd.coord.X2());

	if (nBigloop > 1) {
		CString tStr2;
		tStr2.Format(_T(" Coherency computation will repeat %d times, with intermediate results stored as files."), nBigloop);
		tStr += tStr2;
	}
	tStr += _T(" Long CPU time expected. Continue?");

	if (AfxMessageBox(tStr, MB_YESNO | MB_ICONINFORMATION) != IDYES) return;

	CString tempStr = outFile;
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();

	static const int NVELMAX = 10;
	double ymin = (cd.coord.Y1() > 0.) ? cd.coord.Y1() - 1. : 0.;
	if (ymin < 0.) ymin = 0.;

	double ymax = cd.coord.Y2() + 1.;
	if (ymax <= ymin) ymax = ymin + .1;
	
	SegyWrapperEx sw(inFile, cd.coord.X1(), cd.coord.X2(), ymin, ymax, cd.coord.drawmode);
	sw.m_dxMin = sw.m_dyMin = 0.; // read all traces
	draw.red.clone(&sw.red2);
	if (!sw.openDistance(!cd.coord.isDistanceDisplay, head.numTraces, &head) || sw.headRead.getnx() < 2) {
		tStr.Format(_T("Input file cannot be opened properly."));
		pFrame->myCaption(tStr);
		return;
	}
	if (cd.coord.drawmode != 6)
		sw.sortDistance(!cd.coord.isDistanceDisplay);  // we do need this. After this the trace number is not in sequencial order any more
	// after the sorting, the first trace should have the m_xmin, and we can correctly use mixing function


	myCursorsAll(true);

	HEAD_READ headFilt;  // will hold each freq band data
	HEAD_READ headRes;  // will hold the result, added for each freq band processing, 
	// headFilt will be copied back to the headRead at the last minute

	double dfFilters = (f2 - f1) / (double)num_filters;
	if (isFloatEqual(dfFilters, 0.))
		num_filters = 1;  // make sure if does not dead loop
	register double fCenter;


	SetTimer(NULL, 1, 5000, 0); // this timer's only purpose 
	// is to make the Seiswide window responsive!
	for (int countBigloop = 0; countBigloop < nBigloop; countBigloop++) {
		SegyWrapper::headReadCopy(&sw.headRead, &headRes, 0, true);
		SegyWrapper::headReadZero(&headRes);
		for (int countFilt = 0; countFilt < num_filters; countFilt++) {
			tStr.Format(_T("Cohmix %d | %d"),
				countBigloop*num_filters + countFilt + 1,
				nBigloop*num_filters);
			pFrame->myCaption(tStr);
			register double fThis = f1 + countFilt*dfFilters;
			SegyWrapper::headReadCopy(&sw.headRead, &headFilt, 0, false);

			if (isFloatEqual(dfFilters, 0.)) {
				fCenter = isFloatEqual(f1, 0.) ? 10. : f1;
			}
			else {
				if (!processingFilterTimeDomain(&headFilt, fThis, fThis + dfFilters))
					continue;  // failed filtering?
				fCenter = fThis + dfFilters*0.5;
			}

			//auto i1 = WC<int, int, int>::WaitCall(nullptr, L"Waiting...", 
			//	processingCoherencyCenter, 10, 20);

			bool isTrue = processingCoherencyCenter(&headFilt,
				cd.coord.drawmode, cd.coord.isDistanceDisplay == TRUE,
				(countBigloop < nBigloop - 1) ? 3 : outputMethod, numSmooth,
				dxMix1, dxMix2, dxAvgInterval, ymin, ymax, tWindowFull / fCenter,
				slopeMin, slopeMax,
				slopeMin2, slopeMax2);

			if (isTrue) {
				// now add headFilt  to  headRes
				for (int i = 0; i < headFilt.getnx(); i++)
					for (int j = 0; j < headRes.getns(); j++)
						headRes.trArr[i].data[j] += headFilt.trArr[i].data[j];
			}
		} // for countFilt
		SegyWrapper::headReadCopy(&headRes, &sw.headRead, 0, false);
		if (countBigloop < nBigloop - 1) {
			// save intermediate result to file
			if (cd.coord.drawmode != 6)
				SegyWrapper::sortTraceNum(&headRes); // because we already used sortDistance()
			// note: &headRes header is changed because of sorting. We have to assign it again!
			tStr.Format(_T("_Loop%d"), countBigloop + 1);
			SegyWrapper::saveToSegyFile(&headRes, getFileNameAppend(outFile, tStr), 
				head.ascHead, TRUE);
		}

	} // for countBigloop

	SegyWrapper::freeSegyArray(&headFilt);
	SegyWrapper::freeSegyArray(&headRes);
	KillTimer(NULL, 1);



	// now do the writing
	if (cd.coord.drawmode != 6)
		SegyWrapper::sortTraceNum(&sw.headRead); // because we already used sortDistance()

	if (outputMethod==2)
		outFile = getFileNameAppend(draw.timeSecName, _T("_Cohr"));

	if (SegyWrapper::saveToSegyFile(&sw.headRead, outFile, 
		head.ascHead, TRUE)) {
		draw.timeSecName = outFile;
		OnToolbarRefreshAll();
	}

	myCursorsAll(false);

}


void CSeisWideDoc::OnToolDumppolynomialpoints()
{
	CString tStr;
	static float polyA = 1.472443f;
	static float polyB = 0.050237f;
	static float polyC = 0.0466364347460489f;
	static float dt = 0.008f;
	static float tmax = 10.f;
	static float tsf = 5.172f;

	CdlgToolPoly dlg;
	dlg.m_polyA = polyA;
	dlg.m_polyB = polyB;
	dlg.m_polyC = polyC;
	dlg.m_dt = dt;
	dlg.m_tmax = tmax;
	dlg.m_tsf = tsf;
	if (dlg.DoModal() == IDOK) {
		polyA = dlg.m_polyA;
		polyB = dlg.m_polyB;
		polyC = dlg.m_polyC;
		dt = dlg.m_dt;
		tmax = dlg.m_tmax;
		tsf = dlg.m_tsf;
	}
	else return;

	CStringArray *xtArray = new CStringArray();
	tStr.Format(_T("#Computed results at discrete points for Polynomial formula with a=%f, b=%f c=%f assuming seafloor at %f"), polyA, polyB, polyC, tsf);
	xtArray->Add(tStr);
	tStr.Format(_T("#Y   X or T listed below:"));
	xtArray->Add(tStr);

	float y;
	for (float t = 0.f; t <= tmax; t += dt) {
		y = polyA + polyB*t + polyC*t*t;
		tStr.Format(_T("%.3f  %.3f"), y, t + tsf);
		xtArray->Add(tStr);
	} // for t

	CString aName = getFileNameSubdir(draw.timeSecName, _T("rms"), _T("polyDiscretePoints.txt"), true);
	if (saveStringArrayToFile(xtArray, aName)) {
		showFileInNotePad(aName);
		dig.digName = aName;
	}
	else {
		tStr.Format(_T("Sorry, failed to save to file %s"), aName);
	}

	// clean up
	xtArray->RemoveAll();
	delete xtArray;
	xtArray = NULL;

}

void CSeisWideDoc::OnWideNmostretching()
{
	CString tStr;
	tStr.Format(_T("NMO stretching with a RMS velocity file loaded. \nYES=Continue, \nNO=Show Help."));
	int ifeedback = AfxMessageBox(tStr, MB_YESNOCANCEL | MB_ICONINFORMATION | MB_ICONQUESTION);
	if (ifeedback == IDCANCEL) return;
	else if (ifeedback == IDNO) {
		myShowHelp("index.html");
		return;
	}

	if (!isFileExistNotDirectory(draw.timeSecName))  {
		tStr.Format(_T(" Please display a time section in offset mode."));
		AfxMessageBox(tStr, MB_ICONQUESTION);
		return;
	}
	if (cd.coord.drawmode != 6 && cd.coord.isDistanceDisplay) {
		tStr.Format(_T(" Sorry, cannot work with distance display."));
		AfxMessageBox(tStr, MB_ICONQUESTION);
		return;
	}
	// backup segy file first

	if (!dig.isDigitizing) {
		// the user is not digitizing. 
		tStr.Format(_T(" Digitize a X-Y curve with RMS velocity (km/s) and TWTT time (sec)."));
		AfxMessageBox(tStr, MB_ICONQUESTION);
		return;
	}

	if (dig.totCurve < 1 || dig.nPoint[0] < 2)
	{
		tStr.Format(_T(" At least 2 points are needed."));
		AfxMessageBox(tStr, MB_ICONQUESTION);
		return;
	}

	SegyWrapper sw(draw.timeSecName);
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	//sw.m_isIBMFloatSegy2 = pFrame->gIsIBMFloatSegy2 == TRUE;
	if (CSegyMeta::segyHeadInit(draw.timeSecName, &head) != 1) return;
	if (!sw.open(&head, 0) || sw.headRead.getnx() < 2) {
		tStr.Format(_T("Input file cannot be opened properly."));
		AfxMessageBox(tStr, MB_ICONQUESTION);
		return;
	}

	static float percMute = 0.9f;
	// static float xmax = 7.f; 

	int i, j; // for trace indeces
	float offset;
	float t;
	float tDelay;
	segy tr;


	double odt = 1. / head.dtFile;
	//double dt = 1./odt;
	float x2;
	float *tTrace = ealloc1float((int)head.numsampFiles);
	CDigitize pDg;
	for (i = 0; i < sw.headRead.getnx(); i++) {
		offset = sw.headRead.trArr[i].getOffset();
		tDelay = sw.headRead.trArr[i].getTraceDelay();
		x2 = offset*offset;
		for (j = 0; j<(int)head.numsampFiles; j++) {
			t = tDelay + (float)(j*head.dtFile);
			register double vt = pDg.getDigXfromTSpline(&dig, t);
			tTrace[j] = (float)sqrt(t*t + x2 / (vt*vt));

			// muting
			if (t>0.00001f && (tTrace[j] - t) / t > percMute)
				tTrace[j] = -1.f;
		} // for i

		ints8r((int)head.numsampFiles, // ntin
			(float)head.dtFile,   // dtin
			sw.headRead.trArr[i].getTraceDelay(),   // ftin
			&sw.headRead.trArr[i].data[0], // yin[t=ntin], with yin[0] = y(fxin)
			0.f,  // yinl    value used to extrapolate yin values to left of yin[0]
			0.f,  // yinr	 value used to extrapolate yin values to right of yin[ntin-1]
			(int)head.numsampFiles,   // nxout
			(float *)&tTrace[0],  // 
			(float *)&tr.dat.data[0]);    // tout
		// now, tr.dat.data[] is interpolated data of trace [i+1] with each sample 

		for (j = 0; j < (int)head.numsampFiles; j++)
			sw.headRead.trArr[i].data[j] = tr.dat.data[j];
	} // for i
	free1float(tTrace);

	tStr = getFileNameAppend(draw.timeSecName, _T("NMOStretched"));
	int ii = sw.writeDataAll(tStr);
	draw.timeSecName = tStr;
	tStr.Format(_T("%d traces updated."), ii);
	pFrame->myCaption(tStr);
	// this->OnDigitizeFinishdigitizing();
	OnToolbarRefreshAll();
}

/*
this function is the standard for reading and writing ....... Deping, Jan. 20, 2011
*/
void CSeisWideDoc::OnMenuProcessingTrcBalancing()
{
	CString tstr;

	dlgAgc dlg;
	dlg.m_inFile = draw.timeSecName;
	CString outfile = getFileNameAppend(draw.timeSecName, _T("TrcBalanced"));
	static float winSliding = 0.3f;
	dlg.m_window_sliding = winSliding;
	dlg.m_outFile = outfile;

	if (dlg.DoModal() == IDOK)	{
		draw.timeSecName = dlg.m_inFile.Trim();
		outfile = dlg.m_outFile;
		winSliding = dlg.m_window_sliding;
	}
	else  {
		return;
	}

	if (!isFileExistNotDirectory(draw.timeSecName)) return;
	if (outfile == BLANK) return;
	if (outfile == draw.timeSecName) {
		tstr.Format(_T("Output file name is the same as the input file name!"));
		AfxMessageBox(tstr, MB_ICONQUESTION);
		return;
	}
	SegyWrapper sw(draw.timeSecName);
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	if (CSegyMeta::segyHeadInit(draw.timeSecName, &head) != 1) return;
	if (!sw.open(&head, 0)) {
		tstr.Format(_T("Input file cannot be opened"));
		AfxMessageBox(tstr, MB_ICONQUESTION);
		return;
	}
	tstr.Format(_T("Loaded segy with %d traces."), sw.headRead.getnx());
	pFrame->myCaption(tstr);

	CFile fileout;
	if (!fileout.Open(outfile, CFile::modeCreate | CFile::modeWrite | CFile::typeBinary)) {
		tstr.Format(_T("Outfile cannot be created"));
		AfxMessageBox(tstr, MB_ICONQUESTION);
		return;
	}

	// double dt = (double) sw.bh.hdt /(double)MIL;

	int i;
	bhed bhout;
	fileout.Write(head.ascHead, 3200L);
	memcpy((void *)&bhout, (void *)&sw.headRead.bh, 400L);
	int nsout = bhout.hns;
	bhout.format = 1; // only floating is adopted for output
	// bhout.format = pFrame->statMain.gIsIBMFloatSegy2 ? 1 : 5; // only floating is adopted for output
	fileout.Write(&bhout, 400);

	// isTrue = setGainCorr(&tr2, bh.format, bh.hdt, para.sphericOrder, para.attenuationCorr, para.attenuationSeafloor);
	// now calculate how many points are needed for storing AGC points
	int nWinLen = (int)ceil(winSliding / head.dtFile) + 1;
	//int iLen = iHalf*2+1;
	int numMaxWin = (int)ceil(bhout.hns * head.dtFile / (winSliding*0.5)) + 1;
	float *tt = (float*)ealloc1(numMaxWin, sizeof(float));
	float *agc = (float*)ealloc1(numMaxWin, sizeof(float));
	float aGain;

	CStringArray *strArr = new CStringArray();
	for (int nxStore = 0; nxStore < sw.headRead.getnx(); nxStore++) {
		float x = sw.headRead.trArr[nxStore].getOffset();
		int count = 0;
		float aMinValue = getAvgValueAbsolute(&sw.headRead.trArr[nxStore].data[0], bhout.hns) * 0.001f;  // we treat anything below average/1000 will not be considered
		for (i = 0; i<bhout.hns; i += nWinLen) {
			int iStart = i;
			//if (iStart < 0) iStart = 0;
			if (iStart > bhout.hns - nWinLen) iStart = bhout.hns - nWinLen;
			agc[count] = (float)getMedianAbsolute(&sw.headRead.trArr[nxStore].data[iStart], nWinLen);
			agc[count] = (agc[count] > aMinValue) ? aMinValue*1000.f / agc[count] : 1.f;
			if (agc[count] > 10.f || agc[count] < 0.1f) {
				agc[count] = 1.f; // unstable here
			}
			tt[count] = (float)i;
			tstr.Format(_T("%f %f %d"), i*head.dtFile, agc[count], nxStore);
			strArr->Add(tstr);
			count++;
			if (count >= numMaxWin) break; // to be safe
		} // for i


		// now do the AGC gaining
		for (i = 0; i < bhout.hns; i++) {
			aGain = -1.f;
			for (int iw = 0; iw < count - 1; iw++) {
				if (i <= tt[0]) {
					aGain = agc[0];
					break;
				}
				else if (i >= tt[count - 1]) {
					aGain = agc[count - 1];
					break;
				} // if
				else if (i >= tt[iw] && i < tt[iw + 1]) {
					aGain = agc[iw] + (agc[iw + 1] - agc[iw]) * (i - tt[iw]) / (tt[iw + 1] - tt[iw]);
					//aGain = agc[iw]; 
					// tt[iw+1] is already diff from tt[iw] for sure
					break;
				}
			} // for iw

			if (aGain >= 0.f)
				sw.headRead.trArr[nxStore].data[i] *= aGain;
		} // for i


		if (bhout.format == 1) {
			float_to_ibm((int *)&sw.headRead.trArr[nxStore].data[0], (int *)&sw.headRead.trArr[nxStore].data[0], (int)bhout.hns);
		}

		fileout.Write(&sw.headRead.trArr[nxStore], 240);
		fileout.Write(&sw.headRead.trArr[nxStore].data[0], bhout.hns*sizeof(float));
		if (nxStore / 10 * 10 == nxStore) {
			tstr.Format(_T("A%d...."), nxStore);
			pFrame->myCaption(tstr);
		}
	} // for nxStore
	showStringArrayToFile(strArr);
	strArr->RemoveAll();
	delete strArr;
	free1float(tt);
	free1float(agc);
	fileout.Close();


	// now finished work. Clean up
	draw.timeSecName = outfile;
	draw.isSameDataDisplay = FALSE;
	//	para.gainDist = FALSE;
	draw.sphericOrder = 0.f;
	draw.attenuationCorr = 0.f;


	SetModifiedFlag();
	UpdateAllViews(NULL);
	NotifyChanged();
}

void CSeisWideDoc::OnMenuTracebalanceXt()
{
	if (!cd.coord.isTimeDomain()) return;

	CString tstr;
	static float winSliding = 0.3f;
	static float dxMix = 0.25f;  // this will be ignored in trace display
	static int numTraceMix = 5;

	CdlgTraceBalanceXT dlg;
	dlg.m_inFile = draw.timeSecName;
	CString outfile = getFileNameAppend(draw.timeSecName, _T("TrcBalancedXT"));
	dlg.m_outFile = outfile;

	dlg.m_window_sliding = winSliding;
	dlg.m_numTraceMix = numTraceMix;
	dlg.m_dxMix = dxMix;

	if (dlg.DoModal() == IDOK)
	{
		draw.timeSecName = dlg.m_inFile.Trim();
		outfile = dlg.m_outFile;
		winSliding = dlg.m_window_sliding;
		numTraceMix = dlg.m_numTraceMix;
		if (numTraceMix < 3) return;
		dxMix = dlg.m_dxMix;
	}
	else  {
		return;
	}

	if (!isFileExistNotDirectory(draw.timeSecName)) return;
	if (outfile == BLANK) return;
	if (outfile == draw.timeSecName) {
		tstr.Format(_T("Output file name is the same as the input file name!"));
		AfxMessageBox(tstr, MB_ICONQUESTION);
		return;
	}
	SegyWrapper sw(draw.timeSecName);
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	//	sw.m_isIBMFloatSegy2 = pFrame->gIsIBMFloatSegy2 == TRUE;
	if (CSegyMeta::segyHeadInit(draw.timeSecName, &head) != 1) return;
	if (!sw.open(&head, 0)) {
		tstr.Format(_T("Input file cannot be opened"));
		AfxMessageBox(tstr, MB_ICONQUESTION);
		return;
	}
	tstr.Format(_T("Loaded segy with %d traces."), sw.headRead.getnx());
	pFrame->myCaption(tstr);

	CFile fileout;
	if (!fileout.Open(outfile, CFile::modeCreate | CFile::modeWrite | CFile::typeBinary)) {
		tstr.Format(_T("Outfile cannot be created"));
		AfxMessageBox(tstr, MB_ICONQUESTION);
		return;
	}

	//	double dt = (double) sw.bh.hdt /(double)MIL;

	int i;
	bhed bhout;
	fileout.Write(head.ascHead, 3200L);
	memcpy((void *)&bhout, (void *)&sw.headRead.bh, 400L);
	int nsout = bhout.hns;
	bhout.format = 1; // only floating is adopted for output
	// bhout.format = pFrame->statMain.gIsIBMFloatSegy2 ? 1 : 5; // only floating is adopted for output
	fileout.Write(&bhout, 400);

	// isTrue = setGainCorr(&tr2, bh.format, bh.hdt, para.sphericOrder, para.attenuationCorr, para.attenuationSeafloor);
	// now calculate how many points are needed for storing AGC points
	int nWinLen = (int)ceil(winSliding / head.dtFile) + 1;
	//int iLen = iHalf*2+1;
	int numMaxWin = (int)ceil(bhout.hns * head.dtFile / (winSliding*0.5)) + 1;
	float *tt = (float*)ealloc1float(numMaxWin);
	float *weights = (float *)ealloc1float(numTraceMix);
	float **agcXT = (float**)ealloc2float(numMaxWin, sw.headRead.getnx());
	float *minTrcValues = (float *)ealloc1float(sw.headRead.getnx());
	float aGain;


	CStringArray *strArr = new CStringArray();
	for (int nxStore = 0; nxStore < sw.headRead.getnx(); nxStore++) {
		float x = sw.headRead.trArr[nxStore].getOffset();
		int count = 0;
		minTrcValues[nxStore] = getAvgValueAbsolute(&sw.headRead.trArr[nxStore].data[0], bhout.hns) * 0.001f;  // we treat anything below average/1000 will not be considered
		for (i = 0; i<bhout.hns; i += nWinLen) {
			int iStart = i;
			if (iStart > bhout.hns - nWinLen) iStart = bhout.hns - nWinLen;
			agcXT[nxStore][count] = (float)getMedianAbsolute(&sw.headRead.trArr[nxStore].data[iStart], nWinLen);
			agcXT[nxStore][count] = (agcXT[nxStore][count] > minTrcValues[nxStore]) ? minTrcValues[nxStore] * 1000.f / agcXT[nxStore][count] : 1.f;
			if (agcXT[nxStore][count] > 10.f || agcXT[nxStore][count] < 0.1f) {
				agcXT[nxStore][count] = 1.f; // unstable here
			}
			tt[count] = (float)i;
			tstr.Format(_T("%f %f %d"), i*head.dtFile, agcXT[nxStore][count], nxStore);
			strArr->Add(tstr);
			count++;
			if (count >= numMaxWin) break; // to be safe
		} // for i
		numMaxWin = count;  // to be sure we have the right limit
	} // for nxStore

	// now we do a balance along X axis for  agcXT[nxStore][0:numMaxWin-1]
	int nx1;
	int nx2;
	int iTrc;
	float xCenter;
	float xLoop;
	float **agcXT2 = (float**)ealloc2float(numMaxWin, sw.headRead.getnx());
	for (int nxStore = 0; nxStore < sw.headRead.getnx(); nxStore++) {
		nx1 = nxStore - numTraceMix / 2;
		nx2 = nxStore + numTraceMix / 2 + 1;
		if (nx1 < 0) nx1 = 0;
		if (nx2 > sw.headRead.getnx()) nx2 = sw.headRead.getnx();

		if (cd.coord.drawmode != 6) {
			// consider X-axis limits
			xCenter = sw.headRead.trArr[nxStore].getTraceXVal(cd.coord.drawmode, cd.coord.isDistanceDisplay);
			for (iTrc = nx1; iTrc < nx2; iTrc++) {
				xLoop = sw.headRead.trArr[iTrc].getTraceXVal(cd.coord.drawmode, cd.coord.isDistanceDisplay);
				if (xLoop <= xCenter - dxMix * 0.5f) {
					nx1 = iTrc;
					break;
				}
			}
			for (iTrc = nx2 - 1; iTrc >= nx1; iTrc--) {
				xLoop = sw.headRead.trArr[iTrc].getTraceXVal(cd.coord.drawmode, cd.coord.isDistanceDisplay);
				if (xLoop <= xCenter + dxMix * 0.5f) {
					nx2 = iTrc;
					break;
				}
			}
		} // if

		for (i = 0; i < numMaxWin; i++) {
			for (int nxLoop = 0; nxLoop<nx2 - nx1; nxLoop++)
				weights[nxLoop] = agcXT[nxLoop + nx1][i];
			if (agcXT[nxStore][i] > minTrcValues[nxStore])
				agcXT2[nxStore][i] = (float)getMedianValue(weights, nx2 - nx1) / agcXT[nxStore][i];
			else
				agcXT2[nxStore][i] = agcXT[nxStore][i];
		}
	} // for nxStore
	for (int nxStore = 0; nxStore < sw.headRead.getnx(); nxStore++)
		for (i = 0; i < numMaxWin; i++)
			agcXT[nxStore][i] = agcXT2[nxStore][i];

	free2float(agcXT2);



	// now do the AGC gaining
	for (int nxStore = 0; nxStore < sw.headRead.getnx(); nxStore++) {
		for (i = 0; i < bhout.hns; i++) {
			aGain = -1.f;
			for (int iw = 0; iw < numMaxWin - 1; iw++) {
				if (i <= tt[0]) {
					aGain = agcXT[nxStore][0];
					break;
				}
				else if (i >= tt[numMaxWin - 1]) {
					aGain = agcXT[nxStore][numMaxWin - 1];
					break;
				} // if
				else if (i >= tt[iw] && i < tt[iw + 1]) {
					aGain = agcXT[nxStore][iw] + (agcXT[nxStore][iw + 1] - agcXT[nxStore][iw]) * (i - tt[iw]) / (tt[iw + 1] - tt[iw]);
					//aGain = agc[iw]; 
					// tt[iw+1] is already diff from tt[iw] for sure
					break;
				}
			} // for iw

			if (aGain >= 0.f)
				sw.headRead.trArr[nxStore].data[i] *= aGain;
		} // for i


		if (bhout.format == 1) {
			float_to_ibm((int *)&sw.headRead.trArr[nxStore].data[0], (int *)&sw.headRead.trArr[nxStore].data[0], (int)bhout.hns);
		}

		fileout.Write(&sw.headRead.trArr[nxStore], 240);
		fileout.Write(&sw.headRead.trArr[nxStore].data[0], bhout.hns*sizeof(float));
		if (nxStore / 10 * 10 == nxStore) {
			tstr.Format(_T("A%d...."), nxStore);
			pFrame->myCaption(tstr);
		}
	} // for nxStore
	fileout.Close();

	showStringArrayToFile(strArr);
	strArr->RemoveAll();
	delete strArr;
	free1float(tt);
	free1float(weights);
	free2float(agcXT);
	free1float(minTrcValues);


	// now finished work. Clean up
	draw.timeSecName = outfile;
	draw.isSameDataDisplay = FALSE;
	draw.sphericOrder = 0.f;
	draw.attenuationCorr = 0.f;


	SetModifiedFlag();
	UpdateAllViews(NULL);
	NotifyChanged();
}

void CSeisWideDoc::OnSonobuoyShifttracenumber()
{
	CString tstr;
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	tstr.Format(_T("This will shift the trace numbers of the current segy by a constant amount as entered after"));
	AfxMessageBox(tstr);

	static int trShift = 0;
	CdlgInputValie dlg;
	dlg.m_value = (float)trShift;

	if (dlg.DoModal() == IDOK)
	{
		trShift = (int)dlg.m_value;
	}
	else
	{
		return;
	}

	if (!isFileExistNotDirectory(draw.timeSecName)) return;
	// bool isHeaderOnly = !head.isUnixFile && (head.formatFile == 1 || head.formatFile == 5);
	bool isHeaderOnly = false;
	SegyWrapper sw(draw.timeSecName, isHeaderOnly);
	if (CSegyMeta::segyHeadInit(draw.timeSecName, &head) != 1) return;
	if (!sw.open(&head, 0)) {
		tstr.Format(_T("Input file cannot be opened"));
		AfxMessageBox(tstr);
		return;
	}
	tstr.Format(_T("Loaded segy with %d traces."), sw.headRead.getnx());
	pFrame->myCaption(tstr);

	//if (head.traces[0] == 0 && head.traces[1] == 0 && head.traces[2] == 0) {
	//	// if here, the trace headers have all zero trace numbering
	//	for (int nxStore = 0; nxStore < sw.headRead.nxmax; nxStore++) {
	//		sw.headRead.trArr[nxStore].tracl = nxStore + 1;
	//	} // for nxStore
	//}

	for (int nxStore = 0; nxStore < sw.headRead.getnx(); nxStore++) {
		sw.headRead.trArr[nxStore].tracl += trShift;
	} // for nxStore
	sw.writeDataAll();

	tstr.Format(_T("Updated segy with %d traces."), sw.headRead.getnx());
	pFrame->myCaption(tstr);
}


void CSeisWideDoc::OnProcessingDistanceadjustment()
{
	CString tstr;
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();

	static float x0 = 0.f;
	static float factor = 1.f;

	CdlgDistanceAdjust dlg;
	dlg.x0 = x0;
	dlg.m_timeSecName = draw.timeSecName;
	dlg.m_factor = factor;
	if (dlg.DoModal() == IDOK)
	{
		x0 = dlg.x0;
		factor = dlg.m_factor;
	}
	else
	{
		return;
	}

	if (!isFileExistNotDirectory(draw.timeSecName)) return;
	bool isHeaderOnly = !head.isUnixFile && (head.formatFile == 1 || head.formatFile == 5);
	SegyWrapper sw(draw.timeSecName, isHeaderOnly);
	if (CSegyMeta::segyHeadInit(draw.timeSecName, &head) != 1) return;
	if (!sw.open(&head, 0)) {
		tstr.Format(_T("Input file cannot be opened"));
		AfxMessageBox(tstr);
		return;
	}
	tstr.Format(_T("Loaded segy with %d traces."), sw.headRead.getnx());
	pFrame->myCaption(tstr);

	float x;
	for (int nxStore = 0; nxStore < sw.headRead.getnx(); nxStore++) {
		x = sw.headRead.trArr[nxStore].getDistance();
		x = x0 + (x - x0)*factor;
		sw.headRead.trArr[nxStore].setDistance(x);
	} // for nxStore
	sw.writeHeaderOnly();

	tstr.Format(_T("Finished updating segy with %d traces."), sw.headRead.getnx());
	pFrame->myCaption(tstr);
}

void CSeisWideDoc::DrawRayPathTwtt(CDC * pDC)
{
	if (!draw.isRayShowing
		|| draw.isNoBoundary) return;
	if (!cd.coord.isTimeDomain()) return;

	int i, j;
	CPoint *plt;
	CPen aPen;
	CString tStr;

	//CSegyMeta::segyHeadInit(draw.timeSecName, &head);
	//CRayHelper::setXShotAll(head.xshotInSegy, draw.rayName, &tx);

	//make rPath.out file in the same directory as velMod.velSecName.
	CString dirRef = getWorkingPathSlash();

	int irrcol = 0;
	//if (!CRayHelper::loadRayPathFromDepth2TWTT(_T("rPath.out"), 
	//	&raypaths,
	//	_T("rPath.out.twtt"), &this->raypathsTwtt, 
	//	(float)velColor.dxVDesired, (float)velColor.dz, &velMod)) return;

	this->raypaths.rayFileName = dirRef + _T("rPath.out");
	this->raypathsTwtt.rayFileName = dirRef + _T("rPath.out.twtt");

	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	CSeisWideApp* pSeiApp = (CSeisWideApp*)AfxGetApp();

	if (!CRayHelper::loadRayPathFromDepth2TWTT(
		&raypaths,
		&raypathsTwtt,
		(float)velColor.dxVDesired, (float)velColor.dz, &velMod,
		pFrame->statMain.isShowDetails)) return;

	int irrcolOld = -1;
	COLORREF colorThis = RGB(rand() * 205, rand() * 205, rand() * 205);

	//CString cstr;
	CPen* pOldPen;
	int nptsMax = raypathsTwtt.getNptsMax();
	
//	return; // test
	
	register int nLimit = raypathsTwtt.npMax * 2;
	double* xtemp = (double *)ealloc1double((size_t)nLimit);
	double* ztemp = (double *)ealloc1double((size_t)nLimit);
	plt = (CPoint *)alloc1CPoint(nLimit);

	// addition on Jan 2, 2019
	int ic;
	int curveStart = 0;
	int curveEnd = this->raypathsTwtt.getTotCurve() - 1;
	float x0 = ERRORVAL;
	if (raypathsTwtt.iShot >= 0) {
		int count = 0;
		for (ic = 0; ic < this->raypathsTwtt.getTotCurve(); ic++) {
			if (!isFloatEqual3(raypathsTwtt.xr[ic][0], x0)) {
				x0 = raypathsTwtt.xr[ic][0];
				count++;
			}
			if (raypathsTwtt.iShot + 1 == count) {
				curveStart = ic;
				break;
			}
		}

		x0 = raypathsTwtt.xr[curveStart][0];
		for (ic = curveStart + 1; ic < this->raypathsTwtt.getTotCurve(); ic++) {
			if (!isFloatEqual3(raypathsTwtt.xr[ic][0], x0)) {
				curveEnd = ic;
				break;
			}
		}
	}
	// end addition

	if (raypathsTwtt.rayCodeShow >= 0) {
		// to avoid the screen not displaying any raypaths for ic inside [curveStart, curveEnd], 
		// we may need to adjust raypathsTwtt.rayCodeShow
		bool isRaypathsFound = false;
		for (ic = curveStart; ic <= curveEnd; ic++) {
			if (raypathsTwtt.irrcol[ic] == raypathsTwtt.rayCodeShow) {
				isRaypathsFound = true;
				break;
			}
		}
		if (!isRaypathsFound) {
			// increment raypathsTwtt.rayCodeShow so that some raypaths can show
			for (ic = curveStart; ic <= curveEnd; ic++) {
				if (raypathsTwtt.irrcol[ic] > raypathsTwtt.rayCodeShow) {
					isRaypathsFound = true;
					raypathsTwtt.rayCodeShow = raypathsTwtt.irrcol[ic];
					break;
				}
			}
		}
		if (!isRaypathsFound) {
			// still not found, so we need to set raypathsTwtt.rayCodeShow to show all
			raypathsTwtt.rayCodeShow = -1;
		}
	} // if tx

	int iLineThickness = (int)myRound(40.0* pFrame->statMain.thicknessLines);
	int icSkipped = 0;
	

	pSeiApp->statWin.xPrev = ERRORVAL;
	for (ic = curveStart; ic <= curveEnd; ic++) {
		register int npts = raypathsTwtt.npts[ic];
		if (npts < 2) continue;
		if (!pFrame->raysKept.isXInsideKeepZones(raypathsTwtt.xr[ic][npts - 1], raypathsTwtt.xr[ic][0])) {
			icSkipped++;
			continue;
		}
		if (ic!= curveStart && ic!= curveEnd && !pSeiApp->statWin.isXKeep(raypaths.xr[ic][npts - 1]))
			continue;
		irrcol = raypathsTwtt.irrcol[ic];
		if (irrcolOld != irrcol) {
			// a new ray group encountered. Need to change color
			colorThis = this->getRaycodeColor(irrcol);
			irrcolOld = irrcol;
		}

		// now decide if we should plot this ray path
		BOOL isPlotThisRay = TRUE;
		if (raypathsTwtt.rayCodeShow >= 0) {
			//register int rayCodeCurr = (irrcol > 20) ? (int)(irrcol / 20) * 20 : irrcol;
			//isPlotThisRay = rayCodeCurr == traypathsTwttx.rayCodeShow;
			isPlotThisRay = irrcol == raypathsTwtt.rayCodeShow;
		}

		if (isPlotThisRay) {
			for (i = 0; i < npts; i++) {
				xtemp[i] = raypathsTwtt.xr[ic][i];
				ztemp[i] = raypathsTwtt.zr[ic][i];

				if (draw.ncontFlatten > 0) {
					// need to set arrays for xFlatten[] and yFlatten[], and nFlatten. 
					// no need to free them since destructor will do it automatically
					// but must use eAllocFloat to allocate
					ztemp[i] -=
						interpolLinear(velMod.xmFlatten, velMod.zmFlatten, velMod.nFlatten, (float)xtemp[i])
						- velMod.tShotDatum;
				}

			}
			npts = myClipPoints2(npts, nLimit, xtemp, ztemp, cd.coord.X12Y12());
			if (npts > 0) {
				for (j = 0; j < npts; j++) {
					plt[j] = cd.coord.mm_coord(xtemp[j], ztemp[j]);
				}
				if (draw.TTCurveColor < 4) {
					aPen.CreatePen(PS_SOLID, iLineThickness, getRayColor(draw.TTCurveColor));
				}
				else {
					aPen.CreatePen(PS_SOLID, iLineThickness, colorThis);
				}
				pOldPen = pDC->SelectObject(&aPen);
				pDC->Polyline(plt, npts);
				pDC->SelectObject(pOldPen);
				aPen.DeleteObject();
			}
		} // if isPlotThisRay
	} // for
	free1CPoint(plt);
	free1double(xtemp);
	free1double(ztemp);

	if (icSkipped > 0) {
		CString tStr;
		tStr.Format(_T("%s:\n %d raypaths skipped due to matched pattens as defined in _rayKept.txt in the working folder."), this->GetTitle(), icSkipped);
		pFrame->myCaption(tStr);
	}
}


//
//// This function is disabled!
//void CSeisWideDoc::OnReflectionFlattenboundary()
//{
//	CString tStr;
//	tStr.Format(_T("Flatten any digitized curve in a time section.\n First, digitize 1 segment above which all amplitudes will be zero-ed."));
//	AfxMessageBox(tStr);
//
//	if (!cd.coord.isTimeMode() || cd.coord.drawmode != 6) {
//		AfxMessageBox(_T("Please show a time section in trace mode."));
//		return;
//	}
//	if (!dig.isDigitizing || dig.nPoint[0] < 2) {
//		// the user is not digitizing. 
//		tStr.Format(_T("Pleaser digitize 1 segment with >= 2 points."));
//		AfxMessageBox(tStr);
//		return;
//	}
//
//	SegyWrapper sw(draw.timeSecName);
//	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
//	// sw.m_isIBMFloatSegy2 = pFrame->gIsIBMFloatSegy2 == TRUE;
//	if (CSegyMeta::segyHeadInit(draw.timeSecName, &head) != 1) return;
//	if (!sw.open(&head, 0) || sw.headRead.nx() < 2) {
//		tStr.Format(_T("Input segy file cannot be opened properly."));
//		AfxMessageBox(tStr);
//		return;
//	}
//
//	int i, j; // for trace indeces
//	int ic, ip; // for digitized curve indexes
//	segy tr;
//
//
//	double odt = 1. / head.dtFile;
//	double dt = head.dtFile;
//	float slope;
//	float dx;
//	float offset1 = 0.f, offset2 = 0.f;
//	float *tTrace = ealloc1float(head.numsampFile);
//	for (i = 0; i < sw.headRead.nx() - 1; i++) {
//		// offset1 = (cd.coord.isDistanceDisplay)  ?  sw.headRead.trArr[i].getDistance()  :  getOffset(&sw.headRead.trArr[i]);
//
//		slope = ERRORVAL;
//
//
//		// now calc the delta time of the second trace (at i+1) relative to the first trace (at i)
//		for (ic = 0; ic < dig.totCurve; ic++) {
//			for (ip = 0; ip < dig.nPoint[ic] - 1; ip++) {
//				if (isInsideFloat(offset1, dig.x[ip][ic], dig.x[ip + 1][ic])) {
//					dx = dig.x[ip + 1][ic] - dig.x[ip][ic];
//					slope = (dx == 0.f) ? 0.f : (dig.t[ip + 1][ic] - dig.t[ip][ic]) / dx;
//					break;
//				} // if
//			} // for ip
//			if (slope != ERRORVAL) break;
//		} // for ic
//
//		if (slope == ERRORVAL) {
//			// if here, we had problems in getting the slope.
//			continue;
//		} // if
//
//		float tDelta = slope*(offset2 - offset1);
//		tTrace[0] = (float)(sw.headRead.trArr[i].getTraceDelay() + tDelta);
//		for (j = 1; j < head.numsampFile; j++) {
//			tTrace[j] = tTrace[j - 1] + (float)dt;
//		} // for i
//
//		ints8r(head.numsampFile, // ntin
//			(float)dt,   // dtin
//			sw.headRead.trArr[i + 1].getTraceDelay(),   // ftin
//			&sw.headRead.trArr[i + 1].data[0], // yin[t=ntin], with yin[0] = y(fxin)
//			0.f,  // yinl    value used to extrapolate yin values to left of yin[0]
//			0.f,  // yinr	 value used to extrapolate yin values to right of yin[ntin-1]
//			head.numsampFile,   // nxout
//			(float *)&tTrace[0],  // 
//			(float *)&tr.dat.data[0]);    // tout
//		// now, tr.dat.data[] is interpolated data of trace [i+1] with each sample 
//
//		for (j = 0; j < head.numsampFile; j++)
//			sw.headRead.trArr[i].data[j] -= tr.dat.data[j];
//	} // for i
//	free1float(tTrace);
//
//	for (j = 0; j < head.numsampFile; j++)
//		sw.headRead.trArr[sw.headRead.nx() - 1].data[j] = sw.headRead.trArr[sw.headRead.nx() - 2].data[j];
//	sw.headRead.trArr[sw.headRead.nx() - 1].delrt = sw.headRead.trArr[sw.headRead.nx() - 2].delrt;
//	sw.headRead.trArr[sw.headRead.nx() - 1].delrtEx = sw.headRead.trArr[sw.headRead.nx() - 2].delrtEx;
//
//	tStr = getFileNameAppend(draw.timeSecName, _T("Subtract"));
//	int ii = sw.writeDataAll(tStr);
//	draw.timeSecName = tStr;
//	tStr.Format(_T("%d traces updated."), ii);
//	pFrame->myCaption(tStr);
//	this->OnDigitizeFinishdigitizing();
//	OnToolbarRefreshAll();
//
//}

//GetProcAddresses
//Argument1: hLibrary - Handle for the Library Loaded
//Argument2: lpszLibrary - Library to Load
//Argument3: nCount - Number of functions to load
//[Arguments Format]
//Argument4: Function Address - Function address we want to store
//Argument5: Function Name -  Name of the function we want
//[Repeat Format]
//
//Returns: FALSE if failure
//Returns: TRUE if successful
BOOL GetProcAddresses(HINSTANCE *hLibrary,
	LPCWSTR lpszLibrary, INT nCount, ...)
{
	va_list va;
	va_start(va, nCount);

	if ((*hLibrary = LoadLibrary(lpszLibrary))
		!= NULL)
	{
		FARPROC * lpfProcFunction = NULL;
		LPSTR lpszFuncName = NULL;
		INT nIdxCount = 0;
		while (nIdxCount < nCount)
		{
			lpfProcFunction = va_arg(va, FARPROC*);
			lpszFuncName = va_arg(va, LPSTR);
			if ((*lpfProcFunction =
				GetProcAddress(*hLibrary,
				lpszFuncName)) == NULL)
			{
				lpfProcFunction = NULL;
				return FALSE;
			}
			nIdxCount++;
		}
	}
	else
	{
		va_end(va);
		return FALSE;
	}
	va_end(va);
	return TRUE;
}

// a routine to handle new empty view, such as the user dropped a new file to SeisWide frame
// return true if the file has been properly handled.
bool CSeisWideDoc::myOpenNewFile(CString fName) {
	CString tStr;
	// note: if fName is xxx.sgy, and I SetPathName(fName), the child window has a name xxx.sgy and when saving, 
	// it will try to overwrite xxx.sgy. I have to avoid that.
	//tStr = removeFileExtension(fName);
	//SetPathName((LPCTSTR)tStr, TRUE);  // this line cannot work with tStr, but work with fName, why???
//	setCurrentPathAs(fName); // when a new file is dropped in, it needs to set to be in the current dir, otherwise other related files may have path issues!
	int type;
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	cd.coord.isDistanceDisplay = TRUE;  // only if not SEI file, we will have to use distance display

	// if(cd.coord.drawmode >= 0) return false;
	CString t = GetFileExtension(fName).MakeLower();
	bool isTrue = false;
	cd.coord.drawmodeOld = -1;
	if (t == _T("sei")) {
		this->OnOpenDocument(fName);
		isTrue = true;
	}
	else if (t.CompareNoCase(_T("seiProj"))==0) {
		pFrame->myFileOpenproject(fName);
		return true; // no need to process further since this is a proj file
	}
	else if (t == _T("bin") || t == _T("vxml") || fName == _T("v.in")) {
		// if here, the user has dropped a .bin file in the blank seiswide window, and we should display the whole velocity model
		CVelMod vm;
		if (vm.loadInitVel(&velMod, fName, velColor.dz, tStr)) {
			cd.coord.drawmode = 2;
			cd.coord.xmin = velMod.getXmin();
			cd.coord.xmax = velMod.getXmax();
			if (cd.coord.xmin < -MIL) cd.coord.xmin = 0.;
			if (cd.coord.xmax < cd.coord.xmin + 0.00001) cd.coord.xmax = cd.coord.xmin + 0.00001;
			if (velMod.wells[0].wellDist == ERRORVAL) {
				velMod.wells[0].wellDist = velMod.deploys[0].deployDist;
				//if (velMod.wells[0].wellDist > velMod.getXmax()) velMod.wells[0].wellDist = 0.f;
				velMod.wells[0].wellLatLong[0] = velMod.deploys[0].deployLatLong[0];
				velMod.wells[0].wellLatLong[1] = velMod.deploys[0].deployLatLong[1];
			}
			cd.coord.m_zmin = velMod.zmin;
			cd.coord.m_zmax = velMod.zmax + 1.;
			cd.coord.xTick = getTickRounded(cd.coord.xmin, cd.coord.xmax, 2, 50, 0.0);
			cd.coord.zTick = getTickRounded(cd.coord.m_zmin, cd.coord.m_zmax, 2, 50, 0.0);
			if (velMod.ncontMaxConstrained == 0)
				velMod.ncontMaxConstrained = velMod.ncont - 1;
			isTrue = true;
		}
		else {
			velMod.velSecName = BLANK;
			isTrue = false;
			pFrame->myCaption(tStr);
		}
	}
	else if (t == _T("sgy") || t == _T("segy") || t == _T("seg")
		//		|| t == _T("jp2")
		// jp2 format has not been working yet, so I do not use it for now
		) {
		// if here, the user has dropped a segy file in the blank seiswide window, and we should display trc by trc
		// note: since  dlg.CalcSegyInfo()  is inside OnViewTimesectrc(), I cannot call it directly from CView.

		if (CSegyMeta::segyHeadInit(fName, &head) && head.numTraces > 0) {
			//char ascHead[24];
			//memset(ascHead, (int) '\0', 11 * sizeof(wchar_t));
			//memcpy(ascHead, &head.ascHead, 11);
			// CString tt = CString(head.ascHead);
			cd.coord.trace1 = head.traces[0] - 1;  // if I do not minus 1 here, the first trace is plotted on the axis, which is not good
			cd.coord.trace2 = head.traces[head.numTraces - 1] + 2;

			// note: there are cases the computed bounds are wierd, so we do need a check up otherwise it may crash
			if (cd.coord.trace1 < 0) cd.coord.trace1 = 1;
			if (cd.coord.trace2 > 60000) cd.coord.trace2 = 60000;
			if (cd.coord.trace2 < cd.coord.trace1 + 2) cd.coord.trace2 = cd.coord.trace1 + 2;

			if (head.isSegyTaupDomain()) {
				//cd.coord.tmin = head.tminFile;
				//cd.coord.tmax = head.tmaxFile;
				//cd.coord.xmin = 0.;
				//cd.coord.xmax = head.offsets[head.numTraces - 1];
				cd.coord.set(0., head.tminFile, head.offsets[head.numTraces - 1], head.tmaxFile);
				cd.coord.drawmodeOld = cd.coord.drawmode = 0;
				cd.coord.isDistanceDisplay = false;  // slowness is stored as offsets
				draw.strXLabelOverwrite = _T("Slowness");
			}
			else if (head.isSegySpectrumDomain()) {
				//cd.coord.zmin = head.tminFile;
				//cd.coord.zmax = head.tmaxFile;
				//cd.coord.xmin = head.dist[0];
				//cd.coord.xmax = head.dist[head.numTraces - 1];
				cd.coord.set(head.dist[0], head.tminFile, head.dist[head.numTraces - 1], head.tmaxFile);
				cd.coord.drawmodeOld = cd.coord.drawmode = 1;
				cd.coord.isDistanceDisplay = true;
				draw.depthSecName = fName;
				draw.strYLabelOverwrite = _T("Frequency (x1000)");
				draw.strXLabelOverwrite = _T("Distance/Trace");
				draw.plotTitle = _T("Frequency Spectrum for All Traces");
			}
			else if (head.isSegyDepthDomain()) {
				cd.coord.m_zmin = head.tminFile;
				cd.coord.m_zmax = head.tmaxFile;
				cd.coord.xmin = head.dist[0];
				cd.coord.xmax = head.dist[head.numTraces - 1];
				cd.coord.drawmodeOld = cd.coord.drawmode = 1;
				cd.coord.isDistanceDisplay = true;
				draw.depthSecName = fName;
				draw.strYLabelOverwrite = _T("Depth");
			}
			else {
				cd.coord.m_tmin = head.tminFile;
				cd.coord.m_tmax = head.tmaxFile;
				cd.coord.xmin = head.traces[0];  // this will be overwritten during actuall plotting
				cd.coord.xmax = head.traces[head.numTraces - 1];
				cd.coord.drawmodeOld = cd.coord.drawmode = 6;
			}

			// fixup a few problems
			double dx = cd.coord.xmax - cd.coord.xmin;
			if (dx < 0. || dx > MIL) {
				cd.coord.xmax = cd.coord.xmin + 10;
				cd.coord.trace2 = cd.coord.trace1 + 10;
			}
			double deltat = cd.coord.Y2() - cd.coord.Y1();
			if (deltat < 0. || deltat > MIL)
				cd.coord.setY2(cd.coord.Y1() + 5);

			// calc ticks
			draw.wiggle = 4;
			cd.coord.tTick = getTickRounded(cd.coord.Y1(), cd.coord.Y2(), 2, 50, 0.0);
			cd.coord.xTick = getTickRounded(cd.coord.xmin, cd.coord.xmax, 2, 10, 100.0);
			isTrue = true;
			draw.timeSecName = fName;
		}
	}
	else if (t == _T("txt")) {
		//###################testing
		if (isTxtMedicalLocus(fName)) {
			cd.coord.drawmode = 0; // this will prevent dialog messages until finished processing
			this->SetTitle(_T("Medical LOCUS format: ") + GetBaseFileName(fName));
			CString newName = CIniWriter::convTxtMedicalLotus2Excel(fName);
			showFileInDefaultProg(newName);
			return false;
		}
		else  if (isTxtFile6Columns(fName)) {
			// since it is 6 columns, we need to convert it to proper digitizing format for properly displaying
			tStr.Format(_T("Convert 6 columns to 3 columns.\nYes=Depth in Sub-basement; \nNo=Sub-seafloor;\nCancel=Depth as is."));
			int idSatt = AfxMessageBox(tStr, MB_YESNOCANCEL | MB_ICONINFORMATION | MB_ICONQUESTION);
			if (idSatt == IDYES)
				tStr = conv6ColTo3ColSubBasement(fName);
			else if (idSatt == IDNO)
				tStr = conv6ColTo3ColSubSeafloor(fName);
			else
				tStr = conv6ColTo3Col(fName);

			if (tStr.Compare(fName) == 0) {
				AfxMessageBox(_T("6 columns detected, but cannot convert or save to 3 columns digitizing format."), MB_ICONQUESTION);
			}
			else {
				AfxMessageBox(_T("6 columns are converted and saved to 3 columns in digitizing format."), MB_ICONQUESTION);
				fName = tStr;
			}
			showFileInNotePad(fName);
		}

		//draw.markerName = fName;
		CDigitize dg;
		dig.digName = fName;
		if (dg.myDigitizingLoadTXTUnix2(&dig, FALSE) && dig.totCurve > 0) {
			this->cd.coord.drawmode = 0;
			if (dig.totCurve > NP_MAX) dig.totCurve = NP_MAX;  // a measure to prevent mal atempt!

			// Note: if here, I have a MessageBox() shows up, it will fire the ondraw() and try to display it 
			//       without its content read in.
			//tStr.Format(_T("Detected %d curves to plot. Continue? \nYes=Plot in digitize format; \nOtherwise will show in Notepad."), this->dig.totCurve);
			//if(AfxMessageBox(tStr, MB_YESNO |MB_ICONINFORMATION) == IDYES) {
			dg.getDigLimits(&dig, cd.coord.xmin, cd.coord.xmax, cd.coord.m_tmin, cd.coord.m_tmax);
			if (cd.coord.xmin > -MIL*100. &&
				cd.coord.xmax<MIL*100. &&
				//cd.coord.tmin>-9999. &&
				//cd.coord.tmin<9999. &&
				cd.coord.xmax > cd.coord.xmin &&
				cd.coord.Y2() > cd.coord.Y1()) {
				this->cd.coord.xTick = getTickRounded(this->cd.coord.xmin, this->cd.coord.xmax, 2, 50, 0.0);
				this->cd.coord.tTick = getTickRounded(this->cd.coord.Y1(), this->cd.coord.Y2(), 2, 50, 0.0);
				this->cd.coord.isFaceUp = 0;
				isTrue = true;

				// there is a catch: if all curves have only 1 point, we should draw it as symbols
				// otherwise you do not see anything on screen
				if (dig.isOnePointPerCurve()) {
					dig.copyDig(&digMarker);
					dig.digName = BLANK;
				//	CDigitize::freeDigDataOnly(&draw.dig);  
						// cannot delete the draw.dig array since other programs will check for it
				}
			}
			else
				showFileInNotePad(fName);
		}
		else {
			showFileInNotePad(fName);
		}
	}
	else if (t == _T("shp") || t == _T("shx") || t == _T("dbf")) {
		// processing shape files
		this->cd.coord.drawmode = 0;
		CDigitize dg;
		dig.digName = fName;
		SEI_PAIR pmin, pmax;
		if (dg.SHPOpenToDig(fName, &dig, pmin, pmax) && dig.totCurve > 0) {
			this->cd.coord.drawmode = 0;
			if (dig.totCurve > NP_MAX) dig.totCurve = NP_MAX;  // a measure to prevent mal atempt!
			if (dig.nShapeType == 1) {
				dig.freeDigAll();
				dig.digName = BLANK;
				digMarker.digName = fName;
				dg.SHPOpenToDig(fName, &digMarker, pmin, pmax);
				if (digMarker.totCurve > NP_MAX) digMarker.totCurve = NP_MAX;  // a measure to prevent mal atempt!
				digMarker.modifiedtime = getFileModifiedTime(fName);
				AfxMessageBox(_T("Shape file successfully converted to X-Y pairs, assuming a Cartesian coordinate system, and may not be realistic for lat/lon pairs."));
			}
			else {
				dig.modifiedtime = getFileModifiedTime(fName);
			}
			cd.coord.xmin = pmin.x;
			cd.coord.setY1(pmin.y);
			cd.coord.xmax = pmax.x;
			cd.coord.setY2(pmax.y);
			isTrue = true;
		}
		else {
			showFileInNotePad(fName);
		}
	}
	else if (t == _T("in")) {
		// assuming Zelt's format
		CDigitize dg;
		dig.digName = fName;
		dg.myDigLoadZelt(&dig, ERRORVAL, false);
		if (CCoords::isXShotDefined(dig.xShotCache) && dig.totCurve > 0) {
			if (dig.totCurve > NP_MAX) dig.totCurve = NP_MAX;  // a measure to prevent mal atempt!

			// Note: if here, I have a MessageBox() shows up, it will fire the ondraw() and try to display it 
			//       without its content read in.
			//tStr.Format(_T("Detected %d curves to plot. Continue? \nYes=Plot in digitize format; \nOtherwise will show in Notepad."), this->dig.totCurve);
			//if(AfxMessageBox(tStr, MB_YESNO |MB_ICONINFORMATION) == IDYES) {
			this->cd.coord.drawmode = 0;
			dg.getDigLimits(&dig, cd.coord.xmin, cd.coord.xmax, cd.coord.m_tmin, cd.coord.m_tmax);
			this->cd.coord.xTick = getTickRounded(this->cd.coord.xmin, this->cd.coord.xmax, 2, 50, 0.0);
			this->cd.coord.tTick = getTickRounded(this->cd.coord.Y1(), this->cd.coord.Y2(), 2, 50, 0.0);
			this->cd.coord.isFaceUp = 0;
			dig.isZeltFormat = TRUE;
			dig.isDigitizing = TRUE;
			isTrue = true;

		}
		else {
			showFileInNotePad(fName);
		}
	}
	else if ((type = CxImage::GetTypeIdFromName(t)) != 0) {
		// if here, the user has dropped a bitmap file in the blank seiswide window, and we should display trc by trc
		cd.coord.drawmode = -2; // this will prevent dialog messages until finished processing
		// otherwise a new file dialogbox likely fireup.

		bmp24.ximage = new CxImage(fName, type);
		if (bmp24.ximage && !bmp24.ximage->IsValid()){
			return false;
		}

		if (t == _T("jp2") && bmp24.isInitializeNeeded == 1) {
			if (AfxMessageBox(_T("Open the JP2 file as Segy"), MB_YESNO | MB_ICONINFORMATION) == IDYES) {
				pFrame->myCaption(_T("Converting..."));
				pFrame->statMain.myCursor(true);
				jp2_segy jp2;
				tStr = GetFileNameAppendExt(fName, _T("_Conv"), _T("sgy"));
				CString strXml = jp2.getJp2XML(fName);
				if (!strXml.IsEmpty() && jp2.saveJp2AsSegy(bmp24.ximage, tStr, strXml)) {
					bmp24.bmpName = BLANK;
					delete bmp24.ximage;
					bmp24.isInitializeNeeded = 1;
					return myOpenNewFile(tStr);
				}
				else {
					pFrame->myCaption(_T("Sorry, failed to convert to segy. Will try to open as JP2."));
				}
				pFrame->statMain.myCursor(false);
			}
		}
		else if (t == _T("tif") && bmp24.isInitializeNeeded == 1) {
			static BOOL isNotShowAgain = FALSE;
			if (!isNotShowAgain && AfxMessageBox(_T("Convert to Segy for further processing?"),
				MB_YESNO | MB_ICONINFORMATION) == IDYES) {
				CdlgBitmap2sgy dlg;
				dlg.m_tmin = 0.f;
				dlg.m_tmax = 8.f;
				dlg.m_isNotShowAgain = isNotShowAgain;
				if (dlg.DoModal() == IDOK) {
					isNotShowAgain = dlg.m_isNotShowAgain;
					tStr = GetFileNameAppendExt(fName, _T("_Conv"), _T("sgy"));
					if (SegyWrapper::saveTifAsSegy2(bmp24.ximage, tStr, 1, bmp24.ximage->GetWidth(), dlg.m_tmin, dlg.m_tmax, 2, false)) {
						bmp24.bmpName = BLANK;
						delete bmp24.ximage;
						bmp24.isInitializeNeeded = 1;
						return myOpenNewFile(tStr);
					}
				}
				else
					isNotShowAgain = dlg.m_isNotShowAgain;
			}
			else
				isNotShowAgain = TRUE;
		}


		// now open the image as usual
		if (bmp24.ximage && bmp24.ximage->IsValid()){
			this->cd.coord.drawmode = 6; // this will prevent ondraw() to fire up a dialogbox.

			// mapping of bitmap to coords
			this->bmp24.xmin = (float)(this->cd.coord.trace1 = 0);
			this->bmp24.xmax = (float)(this->cd.coord.trace2 = bmp24.ximage->GetWidth());
			this->bmp24.ymin = (float)(this->cd.coord.m_tmin = 0.);
			this->bmp24.ymax = (float)(this->cd.coord.m_tmax = bmp24.ximage->GetHeight());

			this->cd.coord.xTick = getTickRounded(this->cd.coord.X1(), this->cd.coord.X2(), 2, 50, 0.0);
			this->cd.coord.tTick = getTickRounded(this->cd.coord.Y1(), this->cd.coord.Y2(), 2, 50, 0.0);
			this->cd.coord.isFaceUp = false;

			this->bmp24.bmpName = fName;
			this->bmp24.isInitializeNeeded = 0;
			this->draw.isNoLableOutside = TRUE;
			
			isTrue = true;
		}
		
		pFrame->statMain.myCursor(false);
	}
	else {
		tStr.Format(_T("Cannot recognize the format %s within SeisWide. Trying default program."), t);
		pFrame->myCaption(tStr);
		ShellExecute(0, _T("open"), fName, 0, 0, SW_SHOWNORMAL);
	}

	if (!isTrue)
		this->cd.coord.drawmode = -2;
	else {
		this->SetTitle(GetBaseFileName(fName));
		UpdateAllViews(NULL);
		NotifyChanged();
	}

	//	close_unused_documents(this);
	return isTrue;
}


void CSeisWideDoc::OnModelPerturbvel()
{
	if (!cd.coord.isModelingMode() || !cd.coord.isTimeDomain()) {
		AfxMessageBox(_T(" Please show model in time domain on screen as percentage perterbation is meanful only in time domain."));
		return;
	}

	//velMod.
	double xpos;

	static double deltavPercent = 3.0;
	static int layer1 = 1;
	static int layer2 = 99;
	static CString strLines = BLANK;
	CdlgVelocityPerturb dlg;
	dlg.m_vValue = (float)deltavPercent;
	dlg.m_layer1 = layer1;
	dlg.m_layer2 = layer2;
	dlg.m_strLines = strLines;
	if (dlg.m_layer2 > velMod.ncont - 1)
		dlg.m_layer2 = velMod.ncont - 1;

	velMod.m_isConvert = true;
	CVelMod vm;
	CVelMod::VELMOD velm1, velm2;
	velMod.cloneTo(&velm1, getFileNameAppendTemp(velMod.velSecName, _T("PertMinus")));
	velMod.cloneTo(&velm2, getFileNameAppendTemp(velMod.velSecName, _T("PertPositive")));
	dlg.m_xshot = (float)velMod.wells[0].wellDist;
	if (dlg.DoModal() == IDOK) {

		deltavPercent = dlg.m_vValue;
		layer1 = dlg.m_layer1;
		layer2 = dlg.m_layer2;
		strLines = dlg.m_strLines;


		if (strLines.GetLength() < 5) {
			if (!vm.velModVelocityPerturb(&velm1, deltavPercent, layer1, layer2, true))
				return;
			if (!vm.velModVelocityPerturb(&velm2, deltavPercent, layer1, layer2, false))
				return;
		}
		else {
			if (!vm.velModVelocityPerturb(&velm1, strLines, true)) 
				return;
			if (!vm.velModVelocityPerturb(&velm2, strLines, false))
				return;
		}
		xpos = dlg.m_xshot;
	}
	else return;
	vm.saveModelAs(&velm1, velm1.velSecName, velColor.dz, FALSE, 0);
	vm.saveModelAs(&velm2, velm2.velSecName, velColor.dz, FALSE, 0);
	CVelMod::VELMOD_X modX, modX1, modX2;
	modX.dist = xpos;
	modX1.dist = xpos;
	modX2.dist = xpos;
	vm.initModX(&velMod, &modX, true, true, velColor.dz);
	vm.initModX(&velm1, &modX1, true, true, velColor.dz);
	vm.initModX(&velm2, &modX2, true, true, velColor.dz);

	// now we start construct the output
	CString tStr;
	CStringArray *arr = new CStringArray();
	tStr.Format(_T("#Perturbation of layer velocities and depths. dV and dZ are velocity and depth at maximum deviation from average within each layer.")); 
	arr->Add(tStr);
	tStr.Format(_T("#V1-V2 and Z1-Z2 are range of average velocity and depth for the two perturbed models. Ztop and Ttop are depth and time of top horizon of each layer for the un-perturbed model."));
	arr->Add(tStr);
	// 
	arr->Add(velMod.velSecName);
	tStr.Format(_T("#Layer dV(km/s) dV/V(%%) dZ/Z(%%) (V1-V2)(km/s)  dZ(km) Ztop(km) Ttop(s)"));
	arr->Add(tStr);
	double dV, V, dZ, Z;
	double Vavg1, Vavg2;
	double Zavg1, Zavg2;
	for (int icont = 0; icont < velm1.ncont-1; icont++) {
		dV = (modX2.vTop[icont] - modX1.vTop[icont])*0.5; // input from user
		if (fabs(dV) < 0.00001) continue;
		Vavg1 = (modX1.vTop[icont] + modX1.vBot[icont]) * 0.5;
		Vavg2 = (modX2.vTop[icont] + modX2.vBot[icont]) * 0.5;
		V = (Vavg1 + Vavg2)*0.5;

		Zavg1 = (modX1.depthMod[icont] + modX1.depthMod[icont+1]) * 0.5;
		Zavg2 = (modX2.depthMod[icont] + modX2.depthMod[icont + 1]) * 0.5;
		dZ = (Zavg2 - Zavg1)*0.5; // error bar of depth
		Z = (Zavg2 + Zavg1)*0.5;  // average depth of layer

		tStr.Format(_T(" %2d    %5.3f    %5.3f   %5.3f   (%5.3f-%5.3f)  %5.3f  %5.3f %5.3f")
			, icont+1
			, dV
			, dV/V*100.
			, dZ / Z * 100.
			, Vavg1, Vavg2
			, (Zavg2-Zavg1)
			, modX.depthMod[icont]
			, modX.timeMod[icont]
		);
		arr->Add(tStr);
	}
	showStringArrayToFile(arr);
	arr->RemoveAll();
	delete arr;

	SetModifiedFlag();
	UpdateAllViews(NULL);
	NotifyChanged();
}

void CSeisWideDoc::OnModelToggledetails()
{
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	pFrame->statMain.isShowDetails = !pFrame->statMain.isShowDetails;
	UpdateAllViews(NULL);
	NotifyChanged();

}

// this is tricky, more complex than yminFile
double CSeisWideDoc::getXminFile(void)
{
	double xminFile = 0.;
	if (head.numTraces > 1) {
		if (this->cd.coord.drawmode == 6)
			xminFile = head.traces[0];
		else if (cd.coord.isDistanceDisplay)
			xminFile = head.dist[0];
		else
			xminFile = head.offsets[0];
	}
	else if (velMod.isVelModValid())
		xminFile = velMod.getXmin();

	return xminFile;
}

double CSeisWideDoc::getXmaxFile(void)
{
	double xmaxFile = 100.;
	if (head.numTraces > 1) {
		int n = head.numTraces - 1;
		if (this->cd.coord.drawmode == 6)
			xmaxFile = head.traces[n];
		else if (cd.coord.isDistanceDisplay)
			xmaxFile = head.dist[n];
		else
			xmaxFile = head.offsets[n];
	}
	else if (velMod.isVelModValid())
		xmaxFile = velMod.getXmax();

	return xmaxFile;
}

void CSeisWideDoc::OnViewGravityCont2()
{
	cd.coord.drawmode = 8;
	SetModifiedFlag();
	UpdateAllViews(NULL);
	NotifyChanged();


	//if (draw.printX<1.f || draw.printX>10.f) draw.printX = 1.f;
	//if (draw.printY<1.f || draw.printY>10.f) draw.printY = 1.f;

	//CdlgPrint dlg;
	//dlg.m_printX = draw.printX;
	//dlg.m_printY = draw.printY;
	//dlg.m_compactToOnePerTrace = areaFill.isFillSmall;
	//dlg.m_memoryMax = draw.memMaxMB;
	//dlg.m_removeLabels = draw.isNoLableOutside;

	//if (dlg.DoModal() == IDOK) {
	//	draw.printX = dlg.m_printX;
	//	draw.printY = dlg.m_printY;
	//	areaFill.isFillSmall = dlg.m_compactToOnePerTrace;
	//	draw.memMaxMB = dlg.m_memoryMax;
	//	draw.isNoLableOutside = dlg.m_removeLabels;
	//	SetModifiedFlag();
	//	UpdateAllViews(NULL);
	//	NotifyChanged();
	//}
}




void CSeisWideDoc::OnProcessAsciiheader()
{
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	if (!isFileExistNotDirectory(draw.timeSecName)) {
		pFrame->myCaption(_T("Please show a valid segy file first."));
		return;
	}

	bhed bh;

	CFile file;
	if (!file.Open(draw.timeSecName, CFile::modeReadWrite | CFile::typeBinary)) {
		AfxMessageBox(_T("The segy file must be writable in order to continue."));
		return;
	}


	file.Seek(0, CFile::begin);
	UINT bytesRead = file.Read(head.ascHead, 3200L);
	if (bytesRead < 3200)
		AfxMessageBox(_T("Ascii section header read wrong"));
	file.Read(&bh, 400L);
	if (bytesRead < 400)
		AfxMessageBox(_T("Binary section header read wrong"));

	BOOL isUnixInFile = IsUnix(bh.format);
	if (isUnixInFile) SwapTapeHeader(&bh);

	if (!isAsciiPure(head.ascHead, 3200)) {
		ebc2asc(head.ascHead, 3200);
		if (!isAsciiPure(head.ascHead, 3200)) {
			asc2ebc(head.ascHead, 3200); // wrong conversion, so undo
			asc2ebc(head.ascHead, 3200); // after undo, convert the other direction
		}
	}

	// segy ascii header: every line starts with C with only 80 ascii characters
	// so we have 40 lines, and 40x80=3200

	// LPTSTR p = tStr.GetBuffer(3200);
	//char *pInput = new char[3200];
	//ZeroMemory(pInput, 3200);
	//strcpy_s(pInput, 3200, CT2A(szInput));
	for (int i = 1; i < 40; i++) {
		if (head.ascHead[i * 80] == 'C')
			head.ascHead[i * 80] = '\t';
	}

	CString tStr = CA2T((char *)head.ascHead);
	tStr.Replace(TAB, CARRAGE);

	//strncpy(p, head.ascHead, 3200);
	//tStr.ReleaseBuffer();
	CdlgAsciiHead dlg;


	dlg.m_text = tStr;
	if (dlg.DoModal() == IDOK) {
		tStr = dlg.m_text;
		tStr.Replace(CARRAGE, _T("C"));

		size_t nLeng = (tStr.GetLength() + 1)*sizeof(TCHAR);
		if (nLeng < 3200)
			nLeng = 3200;  // this is important: otherwise it may have exception
		char *pOutput = (char*)alloc1(nLeng, sizeof(char));
		ZeroMemory(pOutput, nLeng);
		strcpy_s(pOutput, nLeng, CT2A(tStr));

		if (bh.format < 5)
			asc2ebc((unsigned char *)pOutput, 3200);

		file.Seek(0, CFile::begin);
		file.Write(pOutput, 3200L);
		free1(pOutput);
	}


	file.Close();


}



/*********************** self documentation **********************/
static const char *sdoc[] = {
	"                                                                       ",
	" SUTAUP - forward and inverse T-X and F-K global slant stacks		",
	"                                                                       ",
	"    sutaup <infile >outfile  [optional parameters]                 	",
	"                                                                       ",
	" Optional Parameters:                                                  ",
	" option=1			=1 for forward F-K domian computation	",
	"				=2 for forward T-X domain computation	",
	"				=3 for inverse F-K domain computation	",
	"				=4 for inverse T-X domain computation	",
	" dt=tr.dt (from header) 	time sampling interval (secs)           ",
	" nx=ntr   (counted from data)	number of horizontal samples (traces)	",
	" dx=1				horizontal sampling interval (m)	",
	" npoints=71			number of points for rho filter		",
	" pmin=0.0			minimum slope for Tau-P transform (s/m)	",
	" pmax=.006			maximum slope for Tau-P transform (s/m)	",
	" np=nx				number of slopes for Tau-P transform	",
	" ntau=nt			number of time samples in Tau-P domain  ",
	" fmin=3			minimum frequency of interest 	        ",
	" xmin=0			offset on first trace	 	        ",
	"                                                                       ",
	" verbose=0	verbose = 1 echoes information				",
	"									",
	" tmpdir= 	 if non-empty, use the value as a directory path	",
	"		 prefix for storing temporary files; else if the	",
	"	         the CWP_TMPDIR environment variable is set use		",
	"	         its value for the path; else use tmpfile()		",
	" 									",
	" Notes:                                                                ",
	" The cascade of a forward and inverse  tau-p transform preserves the	",
	" relative amplitudes in a data panel, but not the absolute amplitudes  ",
	" meaning that a scale factor must be applied to data output by such a  ",
	" a cascade before the output may be compared to the original data.	",
	" This is a characteristic of the algorithm employed in this program.	",
	" (Suradon does not have this problem.)					",
	"                                                                       ",
	NULL };

/*
* Credits: CWP: Gabriel Alvarez, 1995.
*
* Reference:
*    Levin, F., editor, 1991, Slant-Stack Processing, Geophysics Reprint
*         Series #14, SEG Press, Tulsa.
*
* Trace header fields accessed: ns, dt
* Trace header fields modified: dt,d2,f2
*/
#include "taup.h"
#include "dlgTaup.h"
void CSeisWideDoc::OnProcessingTaupslantstack()
{
	CString tStr;

	if (cd.coord.drawmode != 0 || cd.coord.isDistanceDisplay) {
		tStr.Format(_T("Segy section must be displayed in offset-time (non-NMO) mode to continue for Taup stack. "));
		AfxMessageBox(tStr, MB_ICONQUESTION);
		return;
	}

	if (!isFileExistNotDirectory(draw.timeSecName) ||
		!isDirectoryWritable(GetPathFromFileSlash(draw.timeSecName))) {
		tStr.Format(_T("Valid segy time section not found or directory not writable. "));
		AfxMessageBox(tStr, MB_ICONQUESTION);
		return;
	}

	CString inFile = draw.timeSecName;
	if (!isFileExistNotDirectory(inFile)) return;
	if (!dig.isDigitizing || dig.totCurve != 2
		|| dig.nPoint[0] < 2 || dig.nPoint[1] < 2) {
		tStr.Format(_T("For defining Radon filter, please digitize 2 curves that define the desired slope bounds, with each curve having 2 points only. "));
		AfxMessageBox(tStr, MB_ICONQUESTION);
		return;
	}


	bool isForwardOnly = false;
	float ppMin = 0.0f;             /* Minimum slope for Tau-P transform */
	float ppMax = 1.2f;             /* Maximum slope for Tau-P transform */
	static double freqMax = 30.;
	double xIntervalFile = !cd.coord.isDistanceDisplay ? head.offsetIntervalFile : head.distIntervalFile;

	double pmaxAliasLimit = ppMin + 1. / (xIntervalFile * freqMax);
	if (ppMax > pmaxAliasLimit) ppMax = (float)pmaxAliasLimit;
	int npoints = 71;		/* number of points for rho filter */
	bool isInBetweenRetained = true;

	// obtain the 2 slowness' defined by the user
	float dxDig = dig.x[1][0] - dig.x[0][0];
	float pp2 = dxDig == 0.f ? 0.f : (dig.t[1][0] - dig.t[0][0]) / dxDig;
	dxDig = dig.x[1][1] - dig.x[0][1];
	float pp3 = dxDig == 0.f ? 1.f : (dig.t[1][1] - dig.t[0][1]) / dxDig;
	if (pp2 > pp3) {
		// need to swap
		dxDig = pp2;
		pp2 = pp3;
		pp3 = dxDig;
	}

	float pp1 = pp2 - 0.02f;
	float pp4 = pp3 + 0.02f;

	//tStr.Format(_T("pmin, pmax, p1, p2: %f %f %f  %f. Retain data in between the digitized slopes?"),
	//	pmin, pmax, (float)p1, (float)p2);
	//int id = AfxMessageBox(tStr, MB_YESNOCANCEL | MB_ICONINFORMATION);
	//if (id  == IDCANCEL) return;
	//else if (id == IDNO) isInBetweenRetained = false;
	isInBetweenRetained = true;

	double dpAliasLimit = 1. / (cd.coord.xWidth() * freqMax);
	float dp = (float)dpAliasLimit / 3.f; // slope sampling interval. if dp is too big, it causes more aliasing
	int np = (int)ceil((ppMax - ppMin) / dp) + 1;	/* number of slopes for slant stack ########*/
	CString outFile = getFileNameAppend(draw.timeSecName, _T("_Taup"));
	CString outFile2 = getFileNameAppend(draw.timeSecName, _T("_FiltTP"));
	SegyWrapper sw(inFile, false);
	CSegyMeta::segyHeadInit(inFile, &head);
	sw.m_tmin = 0.;  // if not from zero, it may have extra aliasing
	sw.m_tmax = cd.coord.Y2() + 1. + CCoords::getReduceTimeEx2(cd.coord.X2(), cd.coord.drawmode, &draw.red);

	CdlgTaup dlg;
	dlg.m_timeSecName = inFile;
	dlg.m_taupName = outFile;
	dlg.m_FiltTaupName = outFile2;
	dlg.m_dp = (float)dp;
	dlg.m_isForwardOnly = isForwardOnly;
	dlg.m_isInBetween = isInBetweenRetained;
	dlg.m_npoints = npoints;
	dlg.m_ppMin = (float)ppMin;
	dlg.m_pp1 = (float)pp1;
	dlg.m_pp2 = (float)pp2;
	dlg.m_pp3 = (float)pp3;
	dlg.m_pp4 = (float)pp4;
	dlg.m_ppMax = (float)ppMax;
	dlg.m_fMax = (float)freqMax;
	dlg.m_dx = (float)head.offsetIntervalFile; // read-only
	dlg.m_tmin = (float)sw.m_tmin; // read-only
	dlg.m_tmax = (float)sw.m_tmax;
	if (dlg.DoModal() == IDOK) {
		if (inFile != dlg.m_timeSecName) {
			// input file changed
			inFile = dlg.m_timeSecName;
			CSegyMeta::segyHeadInit(inFile, &head);
		}
		outFile = dlg.m_taupName;
		outFile2 = dlg.m_FiltTaupName;
		dp = dlg.m_dp;
		isForwardOnly = dlg.m_isForwardOnly == TRUE;
		isInBetweenRetained = dlg.m_isInBetween == TRUE;
		npoints = dlg.m_npoints;
		ppMin = dlg.m_ppMin;
		pp1 = dlg.m_pp1;
		pp2 = dlg.m_pp2;
		pp3 = dlg.m_pp3;
		pp4 = dlg.m_pp4;
		ppMax = dlg.m_ppMax;
		freqMax = dlg.m_fMax;
		sw.m_tmin = dlg.m_tmin;
		sw.m_tmax = dlg.m_tmax;
	}
	else {
		return;
	}

	if (pp1 <= ppMin) pp1 = ppMin + 0.0001f;
	if (pp2 <= pp1) pp2 = pp1 + 0.0001f;
	if (pp3 <= pp2) pp3 = pp2 + 0.0001f;
	if (pp4 <= pp3) pp4 = pp3 + 0.0001f;
	if (pp4 >= ppMax) pp4 = ppMax - 0.0001f;

	// revise parameters since inputs are changed
	pmaxAliasLimit = ppMin + 1. / (head.offsetIntervalFile * freqMax);
	if (ppMax > pmaxAliasLimit) ppMax = (float)pmaxAliasLimit;
	np = (int)ceil((ppMax - ppMin) / dp) + 1;	/* number of slopes for slant stack ########*/



	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	myCursorsAll(true);
	if (sw.open(&head, 0)) {
		if (sw.headRead.getnx() < 2) {
			tStr.Format(_T("Input file cannot be opened properly."));
			pFrame->myCaption(tStr);
			return;
		}
	}
	if (cd.coord.drawmode != 6)
		sw.sortDistance(!cd.coord.isDistanceDisplay);  // we do need this. After this the trace number is not in sequencial order any more

	int option = 2;		/* flag for requested opeartion */
	HEAD_READ headRes;  // will hold the result, added for each freq band processing, 

	/* do requested operation */
	//if (option == 1) {
	//	/* compute F-K forward slant stack */
	//	fwd_FK_sstack(dt, nt, nx, xmin, dx, np, pmin, dp, fmin,
	//		in_traces, out_traces);
	//}
	if (option == 2) {
		/* compute t-x forward slant stack */
		//fwd_tx_sstack(dt, nt, nx, xmin, dx, np, pmin, dp,
		//	in_traces, out_traces);
		fwd_tx_sstack(&sw.headRead, &headRes, np, ppMin, dp, cd.coord.isDistanceDisplay == TRUE);

		unsigned char ascHead[3200];
		if (!outFile.IsEmpty()) {
			memcpy(&ascHead, &head.ascHead, 3200);
			ascHead[0] = 'X';
			ascHead[1] = 'X';
			ascHead[2] = '8';
			ascHead[3] = 'S';
			ascHead[4] = 'l';
			ascHead[5] = 'o';
			ascHead[6] = 'w';
			ascHead[7] = 'n';
			ascHead[8] = 'e';
			ascHead[9] = 's';
			ascHead[10] = 's';
			// head.setAscHead(_T("XX8Slowness")); // we do not want to overwrite the entire ascHead
			SegyWrapper::saveToSegyFile(&headRes, outFile, ascHead, FALSE);
		}

		if (!isForwardOnly) {
			for (int ip = 0; ip < headRes.getnx(); ip++) {
				register float p = cd.coord.isDistanceDisplay ?
					headRes.trArr[ip].getDistance() :
					headRes.trArr[ip].getOffset();
				register float taperWeight = 1.f;
				if (isInBetweenRetained) {
					if (p < pp1) taperWeight = 0.f;
					else if (p < pp2)  taperWeight = (p - pp1) / (pp2 - pp1);
					else if (p < pp3) taperWeight = 1.f;
					else if (p < pp4) taperWeight = (pp4 - p) / (pp4 - pp3);
					else taperWeight = 0.f;
				}
				else {
					if (p < pp1) taperWeight = 1.f;
					else if (p < pp2) taperWeight = (pp2 - p) / (pp2 - pp1);
					else if (p < pp3) taperWeight = 0.f;
					else if (p < pp4) taperWeight = (p - pp3) / (pp4 - pp3);
					else taperWeight = 1.f;
				}

				if (taperWeight == 0.f) {
					memset((void *)&headRes.trArr[ip].data[0], (int) '\0', headRes.getns() * sizeof(float));
				}
				else if (taperWeight != 1.f) {
					for (int j = 0; j < headRes.getns(); j++)
						headRes.trArr[ip].data[j] *= taperWeight;
				}
			} // for ip

			CString outFile3 = getFileNameAppend(outFile, _T("Cut"));
			SegyWrapper::saveToSegyFile(&headRes, outFile3, ascHead, FALSE);

			inv_tx_sstack(&headRes, &sw.headRead, npoints, cd.coord.isDistanceDisplay == TRUE);

			SegyWrapper::freeSegyArray(&headRes);
		}  // if !isForwardOnly
	}
	if (!isForwardOnly &&
		!outFile2.IsEmpty() &&
		SegyWrapper::saveToSegyFile(&sw.headRead, outFile2, head.ascHead, FALSE)) {
		draw.timeSecName = outFile2;
		OnToolbarRefreshAll();
	}



	myCursorsAll(false);
}

#include "dlgTaupInv.h"
void CSeisWideDoc::OnProcessingTaupinv()
{
	CString tStr;
	bool isTaupFile = head.isSegyTaupDomain();
	if (cd.coord.drawmode != 0 || !isTaupFile) {
		tStr.Format(_T("Cannot find input taup file for inverse conversion. "));
		AfxMessageBox(tStr, MB_ICONQUESTION);
		return;
	}

	if (!isDirectoryWritable(GetPathFromFileSlash(draw.timeSecName))) {
		tStr.Format(_T("Directory not writable. "));
		AfxMessageBox(tStr, MB_ICONQUESTION);
		return;
	}

	int npoints = 71;		/* number of points for rho filter */
	CString inFile = draw.timeSecName;
	int pathLen = inFile.ReverseFind('_');
	if (pathLen < 0) return;
	CString inFileRef = inFile.Left(pathLen) + _T(".sgy");
	if (isEndWith(inFileRef, _T("_TaupCut.sgy"))) {
		// need to cut again
		pathLen = inFileRef.ReverseFind('_');
		inFileRef = inFileRef.Left(pathLen) + _T(".sgy");
	}
	CString outFile = getFileNameAppend(inFileRef, _T("_FiltTP"));


	CdlgTaupInv dlg;
	dlg.m_taupName = inFile;
	dlg.m_timeSecName = inFileRef;
	dlg.m_FiltTaupName = outFile;
	dlg.m_npoints = npoints;
	if (dlg.DoModal() == IDOK) {
		// inFile not allowed to change
		inFileRef = dlg.m_timeSecName;
		outFile = dlg.m_FiltTaupName;
		npoints = dlg.m_npoints;
	}
	else {
		return;
	}


	if (!isFileExistNotDirectory(inFileRef)) {
		tStr.Format(_T("Original segy file %s not found."), inFileRef);
		AfxMessageBox(tStr, MB_ICONQUESTION);
		return;
	}
	HEAD headRef;
	CSegyMeta::segyHeadInit(inFileRef, &headRef);
	if (head.isSegyTaupDomain()) {
		CSegyMeta::segyHeadFree(&headRef);
		tStr.Format(_T("Input reference file is in Taup domain, but original segy file is needed."));
		AfxMessageBox(tStr, MB_ICONQUESTION);
		return;
	}

	SegyWrapper sw(inFile, false);
	CSegyMeta::segyHeadInit(inFile, &head);
	//sw.m_tmin = cd.coord.tmin;  // if not from zero, it may have extra aliasing
	//sw.m_tmax = cd.coord.tmax;

	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	myCursorsAll(true);
	if (sw.open(&head, 0)) {
		if (sw.headRead.getnx() < 2) {
			tStr.Format(_T("Input Taup file cannot be opened properly."));
			pFrame->myCaption(tStr);
			CSegyMeta::segyHeadFree(&headRef);
			return;
		}
	}
	if (cd.coord.drawmode != 6)
		sw.sortDistance(!cd.coord.isDistanceDisplay);  // we do need this. After this the trace number is not in sequencial order any more


	SegyWrapper swRef(inFileRef, true);  // only header needs to read in
	int nx = headRef.numTraces;
	if (!swRef.open(&headRef, 0)) {
		// failed
		swRef.freeSegyArray(&swRef.headRead);
		CSegyMeta::segyHeadFree(&headRef);
		return;
	}

	// need to allocate proper data array here
	// data length is the same as the input taup file
	int nt = head.numsampFiles;
	swRef.m_tmin = sw.m_tmin;
	swRef.m_tmax = sw.m_tmax;
	SegyWrapper::headReadReallocateArray(&swRef.headRead, nt, (float)sw.m_tmin, (float)sw.headRead.getdt());

	inv_tx_sstack(&sw.headRead, &swRef.headRead, npoints, cd.coord.isDistanceDisplay == TRUE);

	if (SegyWrapper::saveToSegyFile(&swRef.headRead, outFile, head.ascHead, FALSE)) {
		draw.timeSecName = outFile;
		cd.coord.xmin = cd.coord.isDistanceDisplay ?
			swRef.headRead.trArr[0].getDistance() :
			swRef.headRead.trArr[0].getOffset();
		cd.coord.xmax = cd.coord.isDistanceDisplay ?
			swRef.headRead.trArr[nx - 1].getDistance() :
			swRef.headRead.trArr[nx - 1].getOffset();
		cd.coord.setY1(swRef.m_tmin);
		cd.coord.setY2(swRef.m_tmax);
		draw.strXLabelOverwrite = BLANK;
		OnToolbarRefreshAll();
	}
	swRef.freeSegyArray(&swRef.headRead);
	CSegyMeta::segyHeadFree(&headRef);


	myCursorsAll(false);


}

#include "pfafft.h"
#include "dlgTfdn.h"
void CSeisWideDoc::OnProcessingTfdn()
{
	CString tStr;
	static double xWinMix = (cd.coord.drawmode == 6) ? 11 : 0.25; // in km, mixing window width (offset or distance)
	static double fCenter = 15.;
	double tWinMix = 2. / fCenter; // in sec, full mixing time window multiplied by 1 center cycle
	//static double f1 = 2.;
	//static double f2 = 30.;
	static double specThreshald = 30.;
	static int NDISTMAX = 11;
	static BOOL isAllTraces = TRUE;

	CString outFile = BLANK, inFile = BLANK;
	inFile = draw.timeSecName;
	outFile = getFileNameAppend(inFile, _T("_Tfdn"));
	CString outFileDiff = getFileNameAppend(inFile, _T("_TfdnDiff"));

	CdlgTfdn dlg;
	dlg.m_infile = inFile;
	dlg.m_outFile = outFile;
	dlg.m_outFile2 = outFileDiff;
	dlg.m_specThreshald = (float)specThreshald;
	dlg.m_numMax = NDISTMAX;
	dlg.m_xWinMix = (cd.coord.drawmode == 6) ? (float)NDISTMAX : (float)xWinMix;
	dlg.m_tWinMix = (float)tWinMix;
	dlg.m_isAllTraces = isAllTraces;

	if (dlg.DoModal() == IDOK) {
		inFile = dlg.m_infile;
		outFile = dlg.m_outFile;
		outFileDiff = dlg.m_outFile2;
		specThreshald = dlg.m_specThreshald;
		NDISTMAX = dlg.m_numMax;
		xWinMix = dlg.m_xWinMix;
		tWinMix = dlg.m_tWinMix;
		isAllTraces = dlg.m_isAllTraces;
	}
	else return;


	if (!isFileExistNotDirectory(inFile) || outFile.IsEmpty()) return;

	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	CSegyMeta::segyHeadInit(inFile, &head);

	//tStr.Format(_T("TFDN De-noising: Mixing window shall span <= %f km and %f sec. Continue?"),
	//	(float)xWinMix, (float)tWinMix);
	//if (AfxMessageBox(tStr, MB_YESNO | MB_ICONINFORMATION) != IDYES) return;


	tStr.Format(_T("Input file cannot be opened properly."));
	SegyWrapperEx sw(inFile);
	sw.m_dxMin = sw.m_dyMin = 0.; // read all traces
	if (isAllTraces) {
		sw.m_tmin = head.tminFile;
		sw.m_tmax = head.tmaxFile;
		if (!sw.openTraceNoAlign(&head, head.traces[0], (int)MIL, 0) || sw.headRead.getnx() < 2) {
			pFrame->myCaption(tStr);
			return;
		}
	}
	else {
		sw.m_xmin = cd.coord.X1() - draw.distShift;
		sw.m_xmax = cd.coord.X2() - draw.distShift;
		sw.m_tmin = cd.coord.Y1();
		sw.m_tmax = cd.coord.Y2();
		sw.m_drawMode = cd.coord.drawmode;
		draw.red.clone(&sw.red2);
		if (!sw.openDistance(!cd.coord.isDistanceDisplay, head.numTraces, &head) || sw.headRead.getnx() < 2) {
			pFrame->myCaption(tStr);
			return;
		}
	}
	HEAD_READ headRes;  // will hold the result, added for each freq band processing, 
	SegyWrapper::headReadCopy(&sw.headRead, &headRes, 0, false);
	//float a = getTraceDelay(&sw.headRead.trArr[0]);
	if (cd.coord.drawmode != 6)
		sw.sortDistance(!cd.coord.isDistanceDisplay);  // we do need this. But remember that after this the trace number is not in sequencial order any more
	// after the sorting, the first trace should have the m_xmin, and we can correctly use mixing function
	myCursorsAll(true);


	double xmin;
	double xmax;
	if (isAllTraces) {
		// we must re-calculate xmin and xmax to continue
		if (cd.coord.drawmode == 6) {
			xmin = head.traces[0];
			xmax = head.traces[head.numTraces - 1];
		}
		else if (cd.coord.isDistanceDisplay) {
			xmin = getMinValue(head.dist, head.numTraces, MAXAMP);
			xmax = getMaxValue(head.dist, head.numTraces);
		}
		else {
			xmin = getMinValue(head.offsets, head.numTraces, MAXAMP);
			xmax = getMaxValue(head.offsets, head.numTraces);
		}
	}
	else {
		xmin = sw.m_xmin;
		xmax = sw.m_xmax;
	}
	for (double x = xmin; x < xmax; x += xWinMix*.5) {
		register int perc = (int)(x / xmax * 100.);
		tStr.Format(_T("%d%%; "), perc);
		pFrame->myCaption(tStr);
		for (double t = sw.m_tmin; t < sw.m_tmax; t += tWinMix*.5) {
			bool isTrue = processingTfdn(&sw.headRead, cd.coord.drawmode, cd.coord.isDistanceDisplay,
				x, xWinMix, t, tWinMix, specThreshald, NDISTMAX);
		}
	}

	if (cd.coord.drawmode != 6)
		SegyWrapper::sortTraceNum(&sw.headRead); // because we already used sortDistance()

	pFrame->myCaption(_T("Saving"));


	if (SegyWrapper::saveToSegyFile(&sw.headRead, outFile, head.ascHead, FALSE)) {
		draw.timeSecName = outFile;
		OnToolbarRefreshAll();
	}

	// now save the difference
	for (int ix = 0; ix < sw.headRead.getnx(); ix++) {
		for (int it = 0; it < sw.headRead.getns(); it++) {
			//if (abs(headRes.trArr[ix].data[it] - sw.headRead.trArr[ix].data[it]) > 0.0001) {
			//	int dsadasds = 1;
			//}
			headRes.trArr[ix].data[it] = headRes.trArr[ix].data[it] - sw.headRead.trArr[ix].data[it];
		}
	}
	SegyWrapper::saveToSegyFile(&headRes, outFileDiff, head.ascHead, TRUE);

	SegyWrapper::freeSegyArray(&headRes);

	myCursorsAll(false);
}



// in this routine, no reduction velocity should be considered!!!
bool CSeisWideDoc::processingTfdn(HEAD_READ *headRead, int drawmode, BOOL isDistanceDisplay,
	double x1, double xWinMix, double t1, double tWinMix, double specThreshald, int numTrcMax)
{
	// *headRead must already be sorted according to dist or offset, assumed
	if (headRead->getdt() < MINAMP) return false;
	if (numTrcMax < 1) numTrcMax = 11;
	segy tr;
	double tDelayInTrace = headRead->trArr[0].getTraceDelay() -
		CCoords::getReduceTimeEx2(headRead->trArr[0].getOffset(), cd.coord.drawmode, &draw.red);  // every trace must have the same delay
	int j1 = (int)myRound((t1 - tDelayInTrace) / headRead->getdt());
	int nj = (int)ceil(tWinMix / headRead->getdt()) + 1;
	int j2 = nj + j1 - 1;  // note that j1 and j2 could be negative
	if (nj < 4 || j2 <= 0) return false;
	if (j1 < 0) {
		j1 = 0;
		j2 = nj + j1 - 1;
	}
	if (j2 > headRead->getns() - 1) {
		j2 = headRead->getns() - 1;
		j1 = j2 - nj + 1;
		if (j1 <= 0) return false;
	}



	int njAppended = npfar(nj);
	if (njAppended < 2) return false;

	float **ampl = (float**)ealloc2float(njAppended, numTrcMax); if (ERROR == ampl) return false;
	memset((void *)&ampl[0][0], (int) '\0', njAppended*numTrcMax*sizeof(float));

	int nx = 0;
	int iTrc1 = -1;




	for (int iTrc = 0; iTrc < headRead->getnx(); iTrc++) {
		register double x = headRead->trArr[iTrc].getTraceXVal(drawmode, isDistanceDisplay);
		if (x < x1) continue;
		if (iTrc1 < 0) iTrc1 = iTrc;
		if (x > x1 + xWinMix) break;

		// now need to calculate j1 and j2 for the de-noising window
		memcpy(&ampl[nx][0], &headRead->trArr[iTrc].data[j1], nj*sizeof(float));
		nx++;
		if (nx >= numTrcMax) break;
	}





	if (nx < 2) {
		// too few traces to process
		free2float(ampl);
		return false;
	}

	// get the best estimate trace
	int ix;
	double specThreshald2 = specThreshald*specThreshald;
	memset((void *)&tr.dat.data[0], (int) '\0', njAppended*sizeof(float));
	float *ampsX = ealloc1float(nx);
	for (int j = 0; j < njAppended; j++) {
		for (ix = 0; ix < nx; ix++)
			ampsX[ix] = ampl[ix][j];

		// note:  Previously I used median value for the good trace. But the results are over-done. It is likely because when I have a strong amplitude trace that I need, 
		//        the median value would remove it completely. But if we use average value, that strong amplitude would still have some influence on the resulting good trace,
		//		  which is probably what I need
		// tr.dat.data[j] = getMedianValue(ampsX, nx);
		tr.dat.data[j] = getAvgValue(ampsX, nx);
	}
	free1float(ampsX);


	complex *czGood = (complex *)ealloc1complex(njAppended / 2 + 1);
	pfarc(1, njAppended, &tr.dat.data[0], czGood);
	for (int j = 0; j < njAppended / 2 + 1; j++) {
		tr.dat.data[j] = (czGood[j].r * czGood[j].r + czGood[j].i*czGood[j].i) * (float)specThreshald2;
	}
	// now tr.dat.data contains the spectrum array for the good average trace

	complex *cz = (complex *)ealloc1complex(njAppended / 2 + 1);
	for (ix = 0; ix < nx; ix++) {
		pfarc(1, njAppended, &ampl[ix][0], cz);

		// now test if there are spikes to remove
		for (int j = 0; j < njAppended / 2 + 1; j++) {
			register double specThis = cz[j].r * cz[j].r + cz[j].i*cz[j].i;
			if (specThis > tr.dat.data[j]) {
				cz[j].r = czGood[j].r * (float)specThreshald;
				cz[j].i = czGood[j].i * (float)specThreshald;
				// note: previously I didn't use specThreshald here, but that changed the spectrum too much, so I scale back
			}
		}

		// now transform back to time domain
		pfacr(-1, njAppended, cz, &ampl[ix][0]);
		for (int j = 0; j < njAppended; j++) {
			ampl[ix][j] /= (float)njAppended;
		}
	}
	free1complex(cz);
	free1complex(czGood);

	// now put ampl[][] back
	ix = 0;
	for (int iTrc = iTrc1; iTrc < headRead->getnx(); iTrc++) {
		if (ix > nx - 1) break;
		memcpy(&headRead->trArr[iTrc].data[j1], &ampl[ix][0], nj*sizeof(float));
		ix++;
	}

	free2float(ampl);

	return true;
}



void CSeisWideDoc::OnProcessingSpectrum()
{
	CString tStr;
	CString outFile = BLANK, inFile = BLANK;
	inFile = draw.timeSecName;
	outFile = getFileNameAppend(inFile, _T("_FreqSpectrum"));

	if (!isFileExistNotDirectory(inFile) || outFile.IsEmpty()) return;

	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	CSegyMeta::segyHeadInit(inFile, &head);

	double tmin = cd.coord.Y1();
	double tmax = cd.coord.Y2();
	double xmin = cd.coord.X1() - draw.distShift;
	double xmax = cd.coord.X2() - draw.distShift;
	SegyWrapperEx sw(inFile, xmin, xmax, tmin, tmax, cd.coord.drawmode);
	sw.m_dxMin = sw.m_dyMin = 0.; // read all traces
	draw.red.clone(&sw.red2);
	if (!sw.openDistance(!cd.coord.isDistanceDisplay, head.numTraces, &head) || sw.headRead.getnx() < 2) {
		tStr.Format(_T("Input file cannot be opened properly."));
		pFrame->myCaption(tStr);
		return;
	}


	int njAppended = npfar(sw.headRead.getns());
	int numsampOut = njAppended / 2 + 1;
	HEAD_READ headRes;  // will hold freq domain data 
	SegyWrapper::headReadCopyReset(&sw.headRead, &headRes);


	SegyWrapper::headReadReallocateArray(&headRes, numsampOut, 0.f, 
		(float)(1. / (numsampOut*sw.headRead.getdt()*1000.)));

	float onjAppended = 1.f / (float)(njAppended);
	float *amps = (float*)ealloc1float(njAppended);
	complex *cz = (complex *)ealloc1complex(numsampOut);
	for (int ix = 0; ix < sw.headRead.getnx(); ix++) {
		memset(amps, (int) '\0', njAppended*sizeof(float));
		memcpy(amps, &sw.headRead.trArr[ix].data[0], sw.headRead.getns()*sizeof(float));
		pfarc(1, njAppended, amps, cz);

		for (int j = 0; j < numsampOut; j++) {
			headRes.trArr[ix].data[j] = (float)sqrt(cz[j].r*cz[j].r + cz[j].i*cz[j].i) * 
				onjAppended;
		}
		headRes.trArr[ix].setTraceDelayF(0.);
		if (cd.coord.drawmode == 6) {
			// because frequency domain only uses distance as the X-axis
			headRes.trArr[ix].setDistance((float)headRes.trArr[ix].tracl);
		}
		else if (!cd.coord.isDistanceDisplay) {
			// because frequency domain only uses distance as the X-axis
			register float x = headRes.trArr[ix].getOffset();
			headRes.trArr[ix].setDistance(x);
		}
	}
	free1complex(cz);
	free1float(amps);

	sw.headRead.setAscHead("XX8Spectrum");
	char *cs = sw.headRead.getAscHeadChar();

	bool isTrue = SegyWrapper::saveToSegyFile(&headRes, outFile, (unsigned char *)cs, FALSE);
	free1(cs);
	SegyWrapper::freeSegyArray(&headRes);

	if (isTrue &&
		AfxMessageBox(_T("based on your screen displayed data, a frequency spectrum has been generated named like _FreqSpectrum.sgy in the same folder. Do you want to show it?"), 
			MB_YESNO | MB_ICONINFORMATION | MB_ICONQUESTION) == IDYES) {

		pFrame->myCaption(BLANK);
		draw.depthSecName = outFile;
		cd.coord.drawmode = 1;

		// why we want to shift on x-axis? It is because a depth section in display is not shifted by draw.distShift,
		// Which is set because only a time section is shifted by it. It I do not revise here, the section cannot be seen 
		// if draw.distShift is bigger than the screen width
		cd.coord.xmin -= draw.distShift;
		cd.coord.xmax -= draw.distShift;

		// a frequency sample interval is mili-Hz, not micro-Hz. This is because if I use micro,
		// it is bigger than unsigned short number can represent
		cd.coord.setY1(0.);
		cd.coord.setY2(1. / sw.headRead.getdt() / 1000.);
		draw.strYLabelOverwrite = _T("Frequency (x1000)");

		// only distance mode 
		cd.coord.isDistanceDisplay = TRUE;
		OnToolbarRefreshAll();
	}
	else if (!isTrue)
		pFrame->myCaption(_T("Failed to generate a frequency spectrum from your displayed data."));
}


void CSeisWideDoc::OnModelingMag()
{
	static double he_suscept = 0.015;  // == he*suscept, 
	static double anginc = 90.;
	static double angstr = 0.;

	CdlgMagmod dlg;
	dlg.m_anginc = (float)anginc;
	dlg.m_angstr = (float)angstr;
	dlg.m_suscept = (float)he_suscept;
	if (dlg.DoModal() == IDOK) {
		anginc = dlg.m_anginc;
		angstr = dlg.m_angstr;
		he_suscept = dlg.m_suscept;
	}
	else {
		return;
	}

	int icont, j;
	CString tStr;
	if (!cd.coord.isModelingMode())  {
		AfxMessageBox(_T("Please show a velocity model before continue."));
		return;
	}
	if (draw.iLayerFocus < 0 || draw.iLayerFocus >= velMod.ncont) {
		AfxMessageBox(_T("Please selected a valid layer in the velocity model to calculate its magnetic contribution. Observed data may be specified in a symbol file."));
		return;
	}

	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	//int pathLen = velMod.velSecName.ReverseFind('\\');
	//if (pathLen>(-1)) SetCurrentDirectory(velMod.velSecName.Left(pathLen));
	//CVelMod vm;


	// now create memory blocks to store all the gravity blocks
	int nstn = 100;
	double *xs;
	if (digMarker.totCurve > 0) {
		nstn = digMarker.nPoint[0];
		xs = ealloc1double(nstn);
		for (int is = 0; is < nstn; is++) {
			xs[is] = digMarker.x[is][0];
		}
	}
	else {
		xs = ealloc1double(nstn);
		double dx = (cd.coord.xmax - cd.coord.xmin) / (double)nstn;
		xs[0] = cd.coord.xmin;
		for (int is = 1; is < nstn; is++) {
			xs[is] = xs[is - 1] + dx;
		}
	}

	double *zs = ealloc1double(nstn);
	double *mag_z = ealloc1double(nstn);
	memset(zs, (int)'\0', nstn*sizeof(double));
	memset(mag_z, (int)'\0', nstn*sizeof(double));

	icont = draw.iLayerFocus;
	int nvert = velMod.nzed[icont] + velMod.nzed[icont + 1];
	register double *xv = ealloc1double(nvert);
	register double *zv = ealloc1double(nvert);
	for (j = 0; j < velMod.nzed[icont]; j++) {
		xv[j] = velMod.xm[j][icont];
		zv[j] = velMod.zm[j][icont];
	}
	for (j = velMod.nzed[icont + 1] - 1; j >= 0; j--) {
		xv[nvert - 1 - j] = velMod.xm[j][icont + 1];
		zv[nvert - 1 - j] = velMod.zm[j][icont + 1];
	}
	m_poly(xs, zs, nstn, xv, zv, nvert, he_suscept, 90., 0., NULL, NULL, mag_z);
	free1double(xv);
	free1double(zv);

	// remove the DC shift from grav_Z[]
	double mag_dc = 0.;
	mag_dc = getAvgValue(mag_z, nstn);
	if (mag_dc != 0.) {
		for (int is = 0; is < nstn; is++)
			mag_z[is] -= mag_dc;
	}

	CDigitize pDg;
	dig.initDigitizeArray(nstn, 1);
	for (int is = 0; is < nstn; is++) {
		dig.x[is][0] = (float)xs[is];
		dig.t[is][0] = (float)mag_z[is];
	}
	dig.nPoint[0] = nstn;
	dig.totCurve = 1;
	dig.digName = GetFileNameAppendExt(velMod.velSecName, _T("_Magmod"), _T("txt"));
	dig.strComment.Format(_T("# Computed mag curve (DC shifted by %g nT; Mag suscept %g) \n# from velocity model %s"),
		mag_dc, he_suscept, velMod.velSecName);
	pFrame->myCaption(dig.strComment);
	dig.isSortedX = TRUE;
	pDg.myDigSaveAs2(&dig, false);

	free1double(xs);
	free1double(zs);
	free1double(mag_z);

	// now, placing the &dig to screen; this needs some transformation
	//float amin = pDg.getDigYMin(&dig);
	float amin = dig.getDigYMin();
	float amax = dig.getDigYMax();
	dig.transYMultFactor = (amax - amin == 0.f) ?
		1.f : 0.25f * (float)fabs(cd.coord.yHeight()) / (amax - amin);
	dig.transIsRevYAxis = !cd.coord.isFaceUp;
	if (dig.transIsRevYAxis) {
		dig.transYShift = (float)cd.coord.Y2() - (amax - amin) * dig.transYMultFactor;
	}
	else {
		dig.transYShift = (float)cd.coord.Y1() + (amax - amin) * dig.transYMultFactor;
	}


	UpdateAllViews(NULL);
	NotifyChanged();

}


void CSeisWideDoc::OnBitmap2Segy()
{
	// TODO: Add your command handler code here
	CString tStr;
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	//	tStr.Format(_T("To be implemented."));
	//	pFrame->myCaption(tStr);
	//	return;


	if (bmp24.bmpName.IsEmpty()) {
		tStr.Format(_T("Please select a bitmap and then do this again."), MB_ICONQUESTION);
		AfxMessageBox(tStr);
		OnFileImportbitmap();
		return;
	}

	int typeJP2 = CxImage::GetTypeIdFromName(_T("jp2"));
	CString t = GetFileExtension(bmp24.bmpName).MakeLower();
	int typeThis = CxImage::GetTypeIdFromName(t);
	CString fout = SetFileExtension(getFileNameAppend(bmp24.bmpName, _T("_conv")), _T("sgy"));

	if (typeThis == typeJP2) {
		if (jp2_segy::saveBitmapAsSegy(bmp24.bmpName, fout,
			(double)bmp24.xmin, (double)bmp24.xmax, (double)bmp24.ymin, (double)bmp24.ymax, cd.coord.isTraceMode())) {
			// AfxMessageBox(_T(" Quit digitizing and then you can switch to depth domain."), MB_OK | MB_ICONINFORMATION);
			if (AfxMessageBox(_T("The bitmap image is now converted to segy based on your current coordinate setting. Do you want to show the segy?"), MB_YESNO | MB_ICONINFORMATION) == IDYES) {
				bmp24.bmpName = BLANK;
				draw.isNoLableOutside = FALSE;
				myOpenNewFile(fout);
				UpdateAllViews(NULL);
				NotifyChanged();
				return;
			}
		}
	}
	else {
		// now save as a bitmap segy
		int isOffset;
		if (cd.coord.isTraceMode()) {
			isOffset = 2; // trace mode
			tStr.Format(_T("Coordinates for bitmap: (%d to %d), (%g to %g) sec. Convert to segy in trace mode only. Continue?"), 
				(int)myRound(bmp24.xmin), (int)myRound(bmp24.xmax), bmp24.ymin, bmp24.ymax);
		}
		else if (cd.coord.isDistanceDisplay) {
			isOffset = 1; // distance mode
			tStr.Format(_T("Coordinates for bitmap: (%g to %g) km, (%g to %g) sec. Convert to segy in distance mode. Continue?"),
				bmp24.xmin, bmp24.xmax, bmp24.ymin, bmp24.ymax);
		}
		else {
			isOffset = 0; // offset mode
			tStr.Format(_T("Coordinates for bitmap: (%g to %g) km, (%g to %g) sec. Convert to segy in offset mode. Continue?"),
				bmp24.xmin, bmp24.xmax, bmp24.ymin, bmp24.ymax);
		}
		if (AfxMessageBox(tStr, MB_YESNO | MB_ICONQUESTION) == IDYES) {
			if (SegyWrapper::saveTifAsSegy2(bmp24.ximage, fout, bmp24.xmin, bmp24.xmax, bmp24.ymin, bmp24.ymax, isOffset, cd.coord.isFaceUp)) {
				tStr.Format(_T("The bitmap image is now converted to segy based on your current coordinate setting. See\n %s "), fout);
				AfxMessageBox(tStr, MB_ICONQUESTION);
			} // if
		} // if
	}


}

#include "dlgOffset1Trc.h"
void CSeisWideDoc::OnOffsetChosentrace()
{
	static int aTrace = 0;
	CdlgOffset1Trc dlg;
	dlg.m_trace = aTrace;
	dlg.m_offset = 0.f;
	if (dlg.DoModal() != IDOK)
		return;
	aTrace = dlg.m_trace;

	if (aTrace == 0) return;

	CSegyMeta::segyHeadInit(draw.timeSecName, &head);
	bool isHeaderOnly = !head.isUnixFile && (head.formatFile == 1 || head.formatFile == 5);
	SegyWrapper sw(draw.timeSecName, isHeaderOnly, 0);
	if (sw.open(&head, 0)) {
		int ind = sw.getArrIndexAtTrace(aTrace);
		
//		CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
		if (ind >= 0) {
			sw.headRead.trArr[ind].setOffset(dlg.m_offset);
			if (sw.writeHeaderOnly() > 0) {
				AfxMessageBox(_T("Success in updating a trace header."), MB_ICONQUESTION);
			}
		}
		else
			AfxMessageBox(_T("Failed in updating a trace header."), MB_ICONQUESTION);
	}


}


void CSeisWideDoc::OnSonobuoyCopydata()
{
	CString tStr;
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	tStr.Format(_T("Copy data of the currently displayed segy file from a second file. Trace length and sample rate of the 2nd file cannot be different from the 1st. \nYES=use trace number, \nNO=use time infomation \nto assign offsets."));
	int ifeedback = AfxMessageBox(tStr, MB_YESNOCANCEL | MB_ICONINFORMATION | MB_ICONQUESTION);

	if (ifeedback == IDCANCEL) return;

	bool isTraceNumBased = (ifeedback == IDYES);


	if (!isFileExistNotDirectory(draw.timeSecName))  {
		tStr.Format(_T(" To assign offsets for sonobuoy data, please display a time section."));
		AfxMessageBox(tStr, MB_ICONQUESTION);
		return;
	}

	//open file dialog.
	CString file2;
	CFileDialog dlg2(FALSE, BLANK, _T("*.sgy"), OFN_EXPLORER,
		_T("Copy data from a second segy file (*.sgy)|*.sgy|"));
	dlg2.m_ofn.lpstrTitle = _T("Select the 2nd segy file");
	if (dlg2.DoModal() == IDOK)
		file2 = dlg2.GetPathName();
	else {
		return;
	}
	delete dlg2;

	if (file2 == draw.timeSecName) {
		tStr.Format(_T("Sorry. your first file is the same as the second file."));
		AfxMessageBox(tStr, MB_ICONQUESTION);
		return;
	}

	SegyWrapper sw(draw.timeSecName);
	sw.m_isHeadersOnly = false;
	if (CSegyMeta::segyHeadInit(draw.timeSecName, &head) != 1) return;
	if (!sw.open(&head, 0)) {
		tStr.Format(_T("Input file cannot be opened properly."));
		AfxMessageBox(tStr, MB_ICONQUESTION);
		return;
	}
	//if (sw.m_isUnixInFile) {
	//	tStr.Format(_T("Sorry, this routine only deals with PC format."));
	//	AfxMessageBox(tStr);
	//	return;
	//}

	HEAD head2;
	SegyWrapper sw2(file2);
	sw2.m_isHeadersOnly = false;
	if (CSegyMeta::segyHeadInit(file2, &head2) != 1) return;
	bool isTrue = sw2.open(&head2, 0);
	if (!isTrue || head2.numsampFiles != head.numsampFiles || head2.dtFile != head.dtFile) {
		CSegyMeta::segyHeadFree(&head2);  // head2 must free manually, but head should not free
		tStr.Format(_T("Input files must have the same numsamp and sample intervals."));
		AfxMessageBox(tStr, MB_ICONQUESTION);
		return;
	}

	// final catch for all-zero trace numbers
	if (isTraceNumBased &&
		sw.headRead.getnx() > 0 &&
		sw.headRead.trArr[0].tracl == 0 &&
		sw.headRead.trArr[1].tracl == 0) {
		tStr.Format(_T("Input files have all zero trace numbering. We will just use trace time info instead."));
		AfxMessageBox(tStr, MB_ICONQUESTION);
		isTraceNumBased = false;
	}

	int i2;
	int ii;
	int numTracesModified = 0;
	for (int i = 0; i < sw.headRead.getnx(); i++) {
		register int trc = sw.headRead.trArr[i].tracl;
		if (isTraceNumBased)
			ii = sw2.getArrIndexAtTrace(trc);
		else {
			// look for the trace index based on time
			ii = -1;
			for (i2 = 0; i2 < sw2.headRead.getnx(); i2++) {
				if (sw.headRead.trArr[i].year == sw2.headRead.trArr[i2].year &&
					sw.headRead.trArr[i].day == sw2.headRead.trArr[i2].day &&
					sw.headRead.trArr[i].hour == sw2.headRead.trArr[i2].hour &&
					sw.headRead.trArr[i].minute == sw2.headRead.trArr[i2].minute &&
					sw.headRead.trArr[i].sec == sw2.headRead.trArr[i2].sec
					) {
					// found it
					ii = i2;
					break;
				} // if
			} // for i2
		}
		if (ii >= 0) {
			memcpy(sw.headRead.trArr[i].data, sw2.headRead.trArr[ii].data, sw.headRead.getns() * sizeof(float));
			numTracesModified++;
		}
	}

	CSegyMeta::segyHeadFree(&head2);  // head2 must free manually, but head should not free

	tStr = getFileNameAppend(draw.timeSecName, _T("dataCopy"));

	CString tStr2;
	if (isTraceNumBased)
		tStr2.Format(_T("Successfully updated data for %d out of %d traces, based on trace numbers; saved to %s. Load it now?"), numTracesModified, sw.headRead.getnx(), tStr);
	else
		tStr2.Format(_T("Successfully updated data for %d out of %d traces, based on trace time; saved to %s. Load it now?"), numTracesModified, sw.headRead.getnx(), tStr);

	if (AfxMessageBox(tStr2, MB_YESNO | MB_ICONINFORMATION | MB_ICONQUESTION) == IDYES) {
		if (SegyWrapper::saveToSegyFile(&sw.headRead, tStr, head.ascHead, TRUE)) {
			draw.timeSecName = tStr;
			OnToolbarRefreshAll();
		}
		SegyWrapper::freeSegyArray(&sw.headRead);

	}

	//	pFrame->myCaption(tStr);

}


void CSeisWideDoc::OnSonobuoyOffsetjitteringremoval()
{
	CString tStr;
	
	if (cd.coord.isTraceMode() || cd.coord.isDistanceDisplay) {
		tStr.Format(_T("Offset tuneup must be performed in offset domain."));
		AfxMessageBox(tStr, MB_ICONQUESTION);
		return;
	}
	//tStr.Format(_T("For offset tuneup: first prepare an Offset-Time curve (e.g. direct water wave or seafloor reflection), save as a Marker file (free text format), and digitize a new Offset-Time curve. This function will adjust trace offsets so that the digitized path will exactly match the desired curve. Use linear (vs. spline) interpolation?"));
	//int iAnswer = AfxMessageBox(tStr, MB_YESNOCANCEL | MB_ICONINFORMATION | MB_ICONQUESTION);
	//if (iAnswer == IDCANCEL)
	//	return;
	if (!isFileExistNotDirectory(draw.timeSecName) ||
		(cd.coord.drawmode != 0 && cd.coord.drawmode != 6 && cd.coord.drawmode != 7) ||
		cd.coord.isDistanceDisplay)  {
		tStr.Format(_T(" To smooth offsets for sonobuoy data, display an offset section with km."));
		AfxMessageBox(tStr, MB_ICONQUESTION);
		return;
	}

	// by now, the section must have been initialized already, an assumption always true in SeisWide.
	if (head.numTraces < 2) {
		tStr.Format(_T(" Segy file contains <2 traces."));
		AfxMessageBox(tStr, MB_ICONQUESTION);
		return;
	}
	float offset1 = head.offsets[0];
	int ix, ix2;
	for (ix = 1; ix < head.numTraces; ix++) {
		if (SGN(offset1) + SGN(head.offsets[ix]) < 1.) {
			tStr.Format(_T(" Existing trace offsets have different signs. Try split the data based on positive and negative offsets by using -1 as input parameter."));
			AfxMessageBox(tStr, MB_ICONQUESTION);
			return;
		}
	}


	if (digMarker.digName.IsEmpty() ||
		digMarker.nPoint == NULL ||
		digMarker.nPoint[0] < 2 ||
		!dig.isDigitizing ||
		dig.nPoint == NULL ||
		dig.nPoint[0] < 2) {
		// the user is not digitizing. 
		tStr.Format(_T(" Offset smoothing needs to load an Offset-Time curve as a Marker file (free text format), while digitizing along the direct water wave. Note: only positive offsets are considered here!"));
		AfxMessageBox(tStr, MB_ICONQUESTION);
		return;
	}

	//bool isLinear = iAnswer == IDYES;
	bool isLinear = false;
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();

	tStr.Format(_T("Offset tuneup: %s"), draw.timeSecName);
	pFrame->myLogInfo(tStr);

	// first check if the digitized points have odds
	// this->OnDigitizingSavedig(); // save first
	// dig must now be sorted along X-axis
	CDigitize pDg;
	dig.isSortedX = TRUE;
	dig.isSortedY = FALSE;
	int isXInt = cd.coord.isTraceMode();
	pDg.myDigSaveAs2(&dig, isXInt);

	// before opening the segy file, we want to mark up some traces that have invalid offset info, and fix them up, otherwise
	// those traces will never have any valid offset info written by this routine! This has been found to be happening in some segys!
	SegyWrapper sw(draw.timeSecName, false);
	sw.m_isHeadersOnly = false;  // read the whole data, but later we may decide to update its headers only
	// without touching the data at all
	if (CSegyMeta::segyHeadInit(draw.timeSecName, &head) != 1) return;

	float digXmin = dig.getXmin(0);
	float digXmax = dig.getXmax(0);
	float secXmin = head.offsetMin();
	float secXmax = head.offsetMax();
	bool isExtendBeyond = false;
	if (secXmin - digXmin < -0.001 || secXmax - digXmax > 0.001) {
		tStr.Format(_T("Your digitized offsets are inside [%f, %f] km, not covering all [%f, %f] km. Do you want to tune up offsets for all the digitized range? If you choose Yes, Seiswide will interpolate for all traces."), 
			digXmin, digXmax, secXmin, secXmax);
		BOOL iAnswerYes = AfxMessageBox(tStr, MB_YESNOCANCEL | MB_ICONINFORMATION | MB_ICONQUESTION);
		if (iAnswerYes == IDCANCEL)
			return;
		isExtendBeyond = iAnswerYes == IDYES;
	}

	if (sw.open(&head, 0)) {
		if (sw.headRead.getnx() < 1) return;
	}

	//	float range;
	float offset;
	// it is not displaying by trace, so the SB must be at 0 km offset

	// fix some situ 
	int aInt = 0;
	int num;
	pDg.myDigSortX2(&dig);	// this must be done for each loop!  
	num = dig.nPoint[0];

	CDigitize::DIGITIZE dig2;
	if (!dig2.initDigitizeArray(dig.nPoint[0], 1)) return;
	dig2.isZeltFormat = FALSE;

	pFrame->statMain.myCursor(true);
	float tw; // water wave travel time
	int nx = sw.headRead.getnx();
	for (ix = 0; ix < nx; ix++) {
		offset = sw.headRead.trArr[ix].getOffset();
		tw = isLinear ? 
			CDigitize::getDigTfromXLinear(&dig, offset) : 
			CDigitize::getDigTfromXSpline(&dig, offset);  // on-screen digitized value at this location

		//convert time to range in km.
		offset = isLinear ?
			CDigitize::getDigXfromTLinear(&digMarker, tw) :
			CDigitize::getDigXfromTSpline(&digMarker, tw);

		// small correction when the offset is the same as previous trace; this would cause the 
		// program not able to correct properly.
		if (ix > 0 && offset == sw.headRead.trArr[ix - 1].getOffset()) {
			offset += 0.002f;  // this will help multiple times of assignment for very dense traces
			// and do not add a digitized point here!
		}
		else
			pDg.myDigAddPoint(&dig2, aInt, offset, tw);

		sw.headRead.trArr[ix].setOffset(offset);
	} // for ix
	if (sw.getCountNonMonoOffset(1) > 0) {
		sw.sortDistance(1);
	}

	// now tune up offset to correct for invalid offset values
	float *offsets = (float*)ealloc1(nx, sizeof(float));
	for (ix = 0; ix < nx; ix++) {
		offsets[ix] = sw.headRead.trArr[ix].getOffset();
	}
	for (ix = 1; ix < nx; ix++) {
		if (!isExtendBeyond && (offsets[ix]<digXmin || offsets[ix]>digXmax)) continue;

		if (fabs(offsets[ix] - offsets[ix - 1]) < 0.002) {
			for (ix2 = ix + 1; ix2 < nx; ix2++) {
				if (fabs(offsets[ix2] - offsets[ix]) > 0.002) {
					// select this one to use
					offsets[ix] = offsets[ix - 1] + (offsets[ix2] - offsets[ix - 1]) / (float)(ix2 - ix + 1);
					sw.headRead.trArr[ix].setOffset(offsets[ix]);
					break;
				}
			}
		}
	}
	free1float(offsets);

	sw.writeDataAll(sw.m_f);

	pDg.myDigSortX2(&dig2);	// this must be done for each loop!  prob: after this sort, na should be changed!

	if (!isEndWith(dig.digName, _T("_deJitter.txt")))
		dig2.digName = getFileNameAppend(dig.digName, _T("_deJitter"));
	else
		dig2.digName = dig.digName;
	dig.isSortedX = TRUE;
	dig.isSortedY = FALSE;
	pDg.myDigSaveAs2(&dig2, false);
	dig.digName = dig2.digName;  // this will make the display to show the newer version with _Poly.txt
	pDg.myDigitizingLoadTXTUnix2(&dig);


	tStr.Format(_T("Offset smoothing is done successfully."));
	tStr += _T(" Revised offsets vs direct arrival time is stored in: ") + dig2.digName;
	tStr += _T(" You may redo this process many times as you wish.");

	static bool isShowMsgBox = true;
	if (isShowMsgBox) {
		AfxMessageBox(tStr, MB_ICONQUESTION);
		isShowMsgBox = false;
	}
	else {
		offset = sw.headRead.trArr[0].getOffset();
		if (offset < 0.f)
			pFrame->myCaption(_T("First trace has <0 offsets. Try split the segy and redo the negative offsets."));
		else
			pFrame->myCaption(tStr);
	}

	dig2.freeDigAll();
	pFrame->statMain.myCursor(false);
	draw.isSameDataDisplay = FALSE;
	UpdateAllViews(NULL);
	NotifyChanged();

}


void CSeisWideDoc::OnModelingRaytrace()
{
	
	myModelingRaytrace(false);
}


void CSeisWideDoc::OnProcessingReverserange()
{

	int refShot, refShot2, shot, option;
	BOOL blOffset, blDistance;
	CdlgChangeRanges dlg;
	dlg.m_refName = draw.timeSecName;
	if (dlg.DoModal() == IDOK) {
		draw.timeSecName = dlg.m_refName.Trim();
		refShot = dlg.m_refShot;
		refShot2 = dlg.m_refShot2;
		blOffset = dlg.m_offset;
		blDistance = dlg.m_distance;
		option = dlg.m_option;
	}
	else return;
	delete dlg;

	if (!isFileExistNotDirectory(draw.timeSecName)) return;
	CFile file;
	if (!file.Open(draw.timeSecName, CFile::modeReadWrite | CFile::typeBinary)) return;
	ULONGLONG bytesRead = file.Seek(3200L, CFile::begin);
	// short i2buf[40000];
	bhed bh;
	bytesRead = file.Read(&bh, 400);
	if (IsUnix(bh.format)) {
		file.Close();
		AfxMessageBox(_T("Sorry, please convert to PC format first for this function."), MB_ICONQUESTION);
		return;
	}
	int len = bh.getTraceLenBytes();
	//int numsamp = bh.hns;
	//if (bh.format != 3)
	//	len = numsamp * 4 + 240;
	//else
	//	len = numsamp * 2 + 240;
	int tpp = (unsigned short)bh.hdt;

	segy tr;
	while (file.Read(&tr, 240) == 240) {
		shot = tr.tracl;

		if (option == 0) { //reverse sign according to trace number.
			if (shot >= refShot && shot <= refShot2) {
				if (blOffset) {
					tr.setOffset(-1.f*tr.getOffset());
				}
			}
		}
		else { // reverse sign according to azimuth.
			// NOTE: for 1 OBS 3E Erable, I have to use 18000 as the condition
			// if(!(i2buf[109]>=-9000 && i2buf[109]<=9000))
			if (blOffset) {
				tr.setOffset(-1.f*tr.getOffset());
			}
		}
		if (blDistance) {
			tr.setDistance(-tr.getDistance());
		}
		file.Seek(-240, CFile::current);
		file.Write(&tr, 240);
		file.Seek((long)(len - 240), CFile::current);
	} //end of while loop.
	file.Close();





	if (blOffset && !blDistance) {
		AfxMessageBox(_T("Reversing offset done without re-sorting (trace sequence is NOT changed)! "), MB_ICONQUESTION);
	}

}


void CSeisWideDoc::OnOptionsToggleclipchangewithgain()
{
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	pFrame->statMain.isClipChangeWithGain = !pFrame->statMain.isClipChangeWithGain;
}



void CSeisWideDoc::OnModeltoolsGeneratekml()
{
	//
	CString tStr = _T("This will dump navigations to file from many selected .vxml model files; Please make sure the models already contain info for drop, start and end points of the line. Yes=KML File; No=TXT file.");
	int msgOutFormat = AfxMessageBox(tStr, MB_YESNOCANCEL | MB_ICONINFORMATION);
	if (msgOutFormat == IDCANCEL)
		return;

	int nf = 0;
	CString inFileName, inFileNames[999];

	//Open file dialog.
	CFileDialog dlg(TRUE, _T("vxml"), _T("*.vxml"),
		OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT | OFN_ALLOWMULTISELECT | OFN_EXPLORER,
		_T("Input vxml files (with navigation info) (*.vxml)|*.vxml|"));
	TCHAR* buff = (TCHAR*)alloc1(65535, sizeof(TCHAR));
	buff[0] = '\0';
	dlg.m_ofn.lpstrTitle = _T("Select all vxml files for creating a kml file");
	dlg.m_ofn.lpstrFile = buff;
	dlg.m_ofn.nMaxFile = 65535;//sizeof(buff);

	 
	POSITION Position;

	if (dlg.DoModal() == IDOK) {
		Position = dlg.GetStartPosition();
		while (Position) {
			inFileName = dlg.GetNextPathName(Position);
			if (!inFileName.IsEmpty()) {
				inFileNames[nf] = inFileName;
				nf++;
			}
		}
		delete dlg;
	} //end dlg.DoModal function.
	else {
		free1(buff);
		delete dlg;
		return;
	}

	free1(buff);

	// If data numbers exceed max, just change this number
	int MAX_FILES = 999;
	if (nf > MAX_FILES) {
		AfxMessageBox(_T("Maximum number of files selected is exceeded."));
		return;
	}

	//now reorganize these files sequentially, alphabetically.
	int n;
	CString t, str;
	for (n = 0; n < nf - 1; n++) {
		for (int i = n + 1; i<nf; i++) {
			if (inFileNames[n]>inFileNames[i]) {
				t = inFileNames[i];
				inFileNames[i] = inFileNames[n];
				inFileNames[n] = t;
			}
		}
	}

	if (nf < 1) return;

	//###############loop thru the input files ###################
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	CString newName = inFileNames[0];
	if (nf > 1) {
		CString aPath = GetPathFromFileSlash(inFileNames[0]);
		newName = aPath + GetBaseFileName(inFileNames[0]) + _T("_") + GetBaseFileName(inFileNames[nf-1]);
	}

	if (msgOutFormat == IDYES) {
		newName = getFileNameTemp(newName, _T("kml"));
		CVelMod::saveModel2Kml(inFileNames, nf, newName);
		t.Format(_T("A total of %d files processed. Output stored in: \n%s\n. Open it in default program (Choose No to show in Notepad)?"), nf, newName);
		if (AfxMessageBox(t, MB_YESNO | MB_ICONINFORMATION) == IDYES)
			showFileInDefaultProg(newName);
		else
			showFileInNotePad(newName);
	}
	else {
		newName = getFileNameTemp(newName, _T("txt"));
		CVelMod::saveModelsNav2Txt(inFileNames, nf, newName);
		showFileInNotePad(newName);

		newName = getFileNameAppend(newName, _T("Wally"));
		newName = getFileNameTemp(newName, _T("txt"));
		CVelMod::saveModelsNav2TxtWally(inFileNames, nf, newName);
		showFileInNotePad(newName);
	}

}

#include "dlgValue.h"
void CSeisWideDoc::OnSonobuoyAutointerpolateinvalidoffsets()
{
	CString tstr;
	tstr.Format(_T("Please specify a maximum absolute offset value to be considered valid. Any values exceeding it will be auto interpolated."));
	AfxMessageBox(tstr, MB_ICONQUESTION);
	CdlgValue dlg;
	dlg.m_fvalue = (float)fabs(ERRORVAL);
	if (dlg.DoModal() != IDOK) {
		return;
	}
	SegyWrapper sw(draw.timeSecName, false);
	if (CSegyMeta::segyHeadInit(draw.timeSecName, &head) != 1) return;
	if (sw.open(&head, 0)) {
		int count = 0;
		for (int ix = 0; ix < sw.headRead.getnx(); ix++) {
			if (fabs(head.offsets[ix]) > fabs(dlg.m_fvalue)) {
				// when invalid offset found, we interpolate
				// first, find the valid offset to the left
				register int ixLeft = -1;
				for (int i = ix-1; i >= 0; i--) {
					if (fabs(head.offsets[i]) < fabs(dlg.m_fvalue)) {
						ixLeft = i;
						break;
					}
				}
				if (ixLeft < 0) continue; // 

				register int ixRight = -1;
				for (int i = ix + 1; i < sw.headRead.getnx(); i++) {
					if (fabs(head.offsets[i]) < fabs(dlg.m_fvalue)) {
						ixRight = i;
						break;
					}
				}
				if (ixRight < 0) continue; // 

				// now do the interpolate
				register float anOffset = 
					head.offsets[ixLeft] + 
					(head.offsets[ixRight] - head.offsets[ixLeft]) *
					(float)(ix - ixLeft) / (float)(ixRight - ixLeft);

				sw.headRead.trArr[ix].setOffset(anOffset);
				count++;
			}

			if (ix>0 && fabs(head.offsets[ix] - head.offsets[ix - 1]) < 0.001) {
				// cannot 
				head.offsets[ix] = head.offsets[ix - 1] + 0.0015f; // this makes it working
				sw.headRead.trArr[ix].setOffset(head.offsets[ix]);
				count++;
			}

		}

		int num = sw.writeDataAll(draw.timeSecName);
		tstr.Format(_T("Offsets of %d traces are updated out of a total of %d traces."), count, num);
		CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
		pFrame->myCaption(tstr);
	} // if sw.open
}

#include "dlgTwoValues.h"
void CSeisWideDoc::OnModeltoolsDumpvelocityrangetokml()
{
	CString tStr = _T("This will dump drop location to file from many selected .vxml model files based on pre-specified velocity ranges at the top boundary of a layer. Please make sure the models already contain info for drop points of the line. Continue?");
	int msgOutFormat = AfxMessageBox(tStr, MB_YESNO | MB_ICONINFORMATION | MB_ICONQUESTION);
	if (msgOutFormat != IDYES)
		return;

	CdlgTwoValues dlg2;
	static float val1 = 7.1f, val2 = 7.7f;
	dlg2.m_value1 = val1;
	dlg2.m_value2 = val2;
	if (dlg2.DoModal() == IDOK) {
		val1 = dlg2.m_value1;
		val2 = dlg2.m_value2;
	}
	else
		return;

	int nf = 0;
	CString inFileName, inFileNames[999];

	//Open file dialog.
	CFileDialog dlg(TRUE, _T("vxml"), _T("*.vxml"),
		OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT | OFN_ALLOWMULTISELECT | OFN_EXPLORER,
		_T("Input vxml files (with navigation info) (*.vxml)|*.vxml|"));
	TCHAR* buff = (TCHAR*)alloc1(65535, sizeof(TCHAR));
	buff[0] = '\0';
	dlg.m_ofn.lpstrTitle = _T("Select all vxml files for creating a kml file");
	dlg.m_ofn.lpstrFile = buff;
	dlg.m_ofn.nMaxFile = 65535;//sizeof(buff);


	POSITION Position;

	if (dlg.DoModal() == IDOK) {
		Position = dlg.GetStartPosition();
		while (Position) {
			inFileName = dlg.GetNextPathName(Position);
			if (!inFileName.IsEmpty()) {
				inFileNames[nf] = inFileName;
				nf++;
			}
		}
		delete dlg;
	} //end dlg.DoModal function.
	else {
		free1(buff);
		delete dlg;
		return;
	}

	free1(buff);

	// If data numbers exceed max, just change this number
	int MAX_FILES = 999;
	if (nf > MAX_FILES) {
		AfxMessageBox(_T("Maximum number of files selected is exceeded."));
		return;
	}

	//now reorganize these files sequentially, alphabetically.
	int n;
	CString t, str;
	for (n = 0; n < nf - 1; n++) {
		for (int i = n + 1; i<nf; i++) {
			if (inFileNames[n]>inFileNames[i]) {
				t = inFileNames[i];
				inFileNames[i] = inFileNames[n];
				inFileNames[n] = t;
			}
		}
	}

	if (nf < 1) return;

	//###############loop thru the input files ###################
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	CString newName = inFileNames[0];
	if (nf > 1) {
		CString aPath = GetPathFromFileSlash(inFileNames[0]);
		newName = aPath + GetBaseFileName(inFileNames[0]) + _T("_") + GetBaseFileName(inFileNames[nf - 1]);
	}
	
	CStringArray arrTxt;
	newName = getFileNameTemp(newName, _T("kml"));
	int count = CVelMod::saveModel2Kml(inFileNames, nf, newName, &arrTxt, val1, val2);
	showFileInNotePad(newName);
	showStringArrayToFile(&arrTxt);
	arrTxt.RemoveAll();
	tStr.Format(_T("Output %d points successfully."), count);
	AfxMessageBox(tStr, MB_ICONQUESTION);

	if (val2 > 7.8) {
		newName = getFileNameTemp(newName + _T("_Moho"), _T("kml"));
		count = CVelMod::saveModel2KmlMoho(inFileNames, nf, newName, &arrTxt, 7.8);
		showFileInNotePad(newName);
		showStringArrayToFile(&arrTxt);
		arrTxt.RemoveAll();
		tStr.Format(_T("For Moho depth: Output %d points successfully."), count);
		AfxMessageBox(tStr, MB_ICONQUESTION);
	}

}


void CSeisWideDoc::OnRaytraceDebug()
{
	// TODO: Add your command handler code here
	// draw.isRaytracePrompt = TRUE;
	myModelingRaytrace(true);
}


void CSeisWideDoc::OnModelingFlattenhorizon()
{
	float xShot = CCoords::isXShotDefined(tx.xShotRay)
		? tx.xShotRay
		: (float)cd.coord.xmin;

	
	if (draw.ncontFlatten <= 0) {
		draw.ncontFlatten = draw.iLayerFocus + 1;
		velMod.setHorizonModel2Flat(draw.ncontFlatten, xShot);
	}
	else {
		velMod.setHorizonFlat2Model(draw.ncontFlatten, xShot, cd.coord.isTimeDomain());
		draw.ncontFlatten = 0;
	}
	draw.isSameDataDisplay = FALSE;
	UpdateAllViews(NULL);
}


void CSeisWideDoc::OnProcessingAdddata()
{
	// Add amplitude from Primary and secondary segy files, output to a third file
	// with an option of static shift and amplitude scaling for the second file
	CString str;
	str.Format(_T("This will add data from many selected segy files having the same number of traces as the current segy. Sample rate and trace initial time can be different which are handled via interpolation."));
	if (AfxMessageBox(str, MB_OKCANCEL | MB_ICONQUESTION) != IDOK)
		return;

	CString inFile2 = BLANK;
	static CString outFile = BLANK;
	static BOOL isAmpAuto = FALSE;

	//CdlgAddData dlg;
	//dlg.m_timeSecName = draw.timeSecName;
	//dlg.m_timeSecName2 = _T("");
	//dlg.m_outputSecName = getFileNameAppend(draw.timeSecName, _T("_Add"));
	//dlg.m_isAutoScaling = isAmpAuto;
	//if (dlg.DoModal() == IDOK) {
	//	draw.timeSecName = dlg.m_timeSecName.Trim();
	//	inFile2 = dlg.m_timeSecName2;
	//	outFile = dlg.m_outputSecName.Trim();
	//	isAmpAuto = dlg.m_isAutoScaling;
	//}
	//else {
	//	return;
	//}

	//if (inFile2.IsEmpty()) {
	//	str.Format(_T("Second file name is empty."));
	//	AfxMessageBox(str, MB_ICONQUESTION);
	//	return;
	//}
	outFile = getFileNameAppend(draw.timeSecName, _T("_Add"));

	CSegyMeta::segyHeadInit(draw.timeSecName, &head);
	SegyWrapper sw(draw.timeSecName);
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	sw.m_isTimeAlign = true;
	bool isTrue = sw.openTrace(0, 99999, 0, &head, 1, 0.);
	int nxmax = sw.headRead.getnx();
	int ns = sw.headRead.getns();
	double dt = sw.headRead.getdt();
	sw.headRead.bh.format = 1; // only floating is adopted for output
	float *yVal = (float *)ealloc1float(ns);
	float *amp2New = (float *)ealloc1float(ns);
	HEAD_READ headRes;  // will hold the result, added for each freq band processing, 
	SegyWrapper::headReadCopy(&sw.headRead, &headRes, 0, false);

	myCursorsAll(true);
	int ix, j;

	CFileDialog dlg(TRUE, _T("sgy; SEG"), _T("*.sgy"),
		OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT | OFN_ALLOWMULTISELECT | OFN_EXPLORER,
		_T("Input Segy File (*.sgy)|*.sgy|"));

	TCHAR* buff = (TCHAR*)alloc1(65535, sizeof(TCHAR));
	buff[0] = '\0';
	dlg.m_ofn.lpstrTitle = _T("Select all files for adding to current segy.");
	dlg.m_ofn.lpstrFile = buff;
	dlg.m_ofn.nMaxFile = 65535;//sizeof(buff);


	POSITION Position;
	if (dlg.DoModal() == IDOK) {
		Position = dlg.GetStartPosition();
		while (Position) {
			inFile2 = dlg.GetNextPathName(Position);
			if (inFile2 == draw.timeSecName)
				continue;
			HEAD head2;
			CSegyMeta::segyHeadInit(inFile2, &head2);
			SegyWrapper sw2(inFile2);
			sw2.m_isTimeAlign = true;
			isTrue = sw2.openTrace(0, 99999, 0, &head2, 1, 0.);
			CSegyMeta::segyHeadFree(&head2);  // head2 must be free-ed manually, but head should not free
			if (nxmax != sw2.headRead.getnx()) {
				SegyWrapper::freeSegyArray(&sw2.headRead);
				str.Format(_T("%s : Num of traces different and will be ignored."), inFile2);
				AfxMessageBox(str, MB_ICONQUESTION);
				continue;
			}
			int ns2 = sw2.headRead.getns();
			double dt2 = sw2.headRead.getdt();
			for (ix = 0; ix < nxmax; ix++) {
				register segydynamic *ptr = &headRes.trArr[ix];
				register segydynamic *ptr2 = &sw2.headRead.trArr[ix];

				register double tmin2 = ptr2->getTraceDelay();
				yVal[0] = (float)ptr->getTraceDelay(); // desired trace delay
				for (j = 1; j < ns; j++) {
					yVal[j] = yVal[j - 1] + (float)dt;
				}
				ints8r(ns2, // ntin
					(float)dt2,   // dtin
					(float)tmin2,   // ftin
					&ptr2->data[0], // yin[t=ntin], with yin[0] = y(fxin)
					ptr2->data[0],  // yinl    value used to extrapolate yin values to left of yin[0]
					ptr2->data[ns2 - 1],  // yinr	 value used to extrapolate yin values to right of yin[ntin-1]
					ns,   // nxout
					&yVal[0],  // ntout
					&amp2New[0]);    // tout
				register double aMedian2 = getMedianAbsolute(&amp2New[0], ns);
				register double ratio = 1.;
				if (aMedian2 > MINAMP && isAmpAuto) {
					ratio = getMedianAbsolute(&ptr->data[0], ns) / aMedian2;
				}
				for (j = 0; j < ns; j++) {
					headRes.trArr[ix].data[j] = (float)((ptr->data[j] + amp2New[j] * ratio) * 0.5);
				} // for j
				str.Format(_T("T%d."), ix);
				pFrame->myCaption(str);
			} // for nx
			SegyWrapper::freeSegyArray(&sw2.headRead);
		} //end the while file POSITION loop.
	} //end dlg.DoModal function.







	free1float(amp2New);
	free1float(yVal);

	if (SegyWrapper::saveToSegyFile(&headRes, outFile, head.ascHead, FALSE)) {
		pFrame->myCaption(_T("success in adding segy data."));
		draw.timeSecName = outFile;
		OnToolbarRefreshAll();
	}
	SegyWrapper::freeSegyArray(&headRes);
	SegyWrapper::freeSegyArray(&sw.headRead);
	myCursorsAll(false);

}

void CSeisWideDoc::OnWideNormalizetraceinterval()
{
	CString str;
	if (cd.coord.isTraceMode()) {
		str.Format(_T("Sorry, this function cannot run in trace display mode."));
		AfxMessageBox(str, MB_ICONQUESTION);
		return;
	}

	static CString outFile = BLANK;
	static float multFactor = 1.f;
	static BOOL isAmpAuto = FALSE;

	CdlgNormTrcInt dlg;
	dlg.m_timeSecName = draw.timeSecName;
	dlg.m_outputSecName = getFileNameAppend(draw.timeSecName, _T("_NormTrcInt"));
	dlg.m_multFactor = multFactor;
	dlg.m_isAutoScaling = isAmpAuto;
	if (dlg.DoModal() == IDOK) {
		draw.timeSecName = dlg.m_timeSecName.Trim();
		outFile = dlg.m_outputSecName.Trim();
		multFactor = dlg.m_multFactor;
		isAmpAuto = dlg.m_isAutoScaling;
	}
	else {
		return;
	}

	if (outFile.IsEmpty() || outFile == draw.timeSecName) {
		outFile = getFileNameAppend(draw.timeSecName, _T("_NormTrcInt"));
	}

	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();

	CSegyMeta::segyHeadInit(draw.timeSecName, &head);
	SegyWrapper sw(draw.timeSecName);
	//	sw.m_isTimeAlign = true;
	bool isTrue = sw.openTrace(0, 99999, 0, &head, 1, 0.);
	bool isOffset = !cd.coord.isDistanceDisplay;
	sw.sortDistance(isOffset);

	int nxmax = sw.headRead.getnx();
	int ns = sw.headRead.getns();
	double deltaxAllowed = (isOffset ? head.offsetIntervalFile : head.distIntervalFile) * 0.5 * multFactor;
	str.Format(_T("input file has average offset interval of %g km. In output, minimum traces interval will be set to %g km (you may use multFactor to adjust this). Continue?"),
		head.offsetIntervalFile, deltaxAllowed);
	if (AfxMessageBox(str, MB_YESNO | MB_ICONQUESTION) != IDYES) {
		SegyWrapper::freeSegyArray(&sw.headRead);
		return;
	}


	// now do the addition
	HEAD_READ headOut;  // will hold the result, added for each freq band processing, 
	SegyWrapper::headReadCopy(&sw.headRead, &headOut, 0, false);

	HEAD_READ headSum;  // will hold the traces for summation for one output trace only. 
	SegyWrapper::headReadCopy(&sw.headRead, &headSum, 0, false);

	int nx, nx2, j, jj;
	myCursorsAll(true);
	int countOut = 0;
	for (nx = 0; nx < nxmax; nx++) {
		register segydynamic *ptr = &sw.headRead.trArr[nx];
		register float dist = isOffset ? ptr->getOffset() : ptr->getDistance();

		// determine if this trace nx is good for output: not too dense in output
		if (nx > 0) {
			register float dist3 = isOffset ? headOut.trArr[nx - 1].getOffset() : headOut.trArr[nx - 1].getDistance();
			if (fabs(dist3 - dist) < deltaxAllowed) {
				continue; // this is too dense so ignore
			}
		}

		// search for all traces to sum
		int countSum = 0;
		for (nx2 = 0; nx2 < nxmax; nx2++) {
			if (nx2 == nx) continue; // do not work on the same trace
			register segydynamic *ptr2 = &sw.headRead.trArr[nx2];
			register float dist2 = isOffset ? ptr2->getOffset() : ptr2->getDistance();
			if (fabs(dist2 - dist) < deltaxAllowed) {
				// now we found a trace to add to the current trace
				register double aMedian2 = getMedianAbsolute(ptr2->data, ns);
				register double ratio = 1.;
				if (aMedian2 > MINAMP && isAmpAuto) {
					ratio = getMedianAbsolute(ptr->data, ns) / aMedian2;
				}

				// we assume the same samprate for each file. If not the same rate, we cannot use a single jShift for each trace to be added
				register float tDelay = ptr->getTraceDelay();
				register float tDelay2 = ptr2->getTraceDelay();
				register int jShift = (int)myRound((tDelay - tDelay2) / (double)sw.headRead.getdt());
				for (j = 0; j < ns; j++) {
					jj = j + jShift;
					if (jj >= 0 && jj < ns) {
						headSum.trArr[countSum].data[j] = ptr2->data[jj] * (float)ratio;
					} // if jj
					else
						headSum.trArr[countSum].data[j] = 0.f;
				} // for j
				countSum++;
			} // if deltaxAllowed
		} // for nx2

		memcpy(headOut.trArr[countOut].data, sw.headRead.trArr[nx].data, ns * sizeof(float));
		if (countSum > 0) {
			// now ready to sum
			for (nx2 = 0; nx2 < countSum; nx2++) {
				for (j = 0; j < ns; j++) {
					headOut.trArr[countOut].data[j] += headSum.trArr[nx2].data[j];
				}
			}
			register float osum = 1.f / (float)(1 + countSum);
			for (j = 0; j < ns; j++) {
				headOut.trArr[countOut].data[j] *= osum;
			}
		}
		memcpy(&headOut.trArr[countOut].tracl, &sw.headRead.trArr[nx].tracl, 240);
		headOut.trArr[countOut].tracl = countOut + sw.headRead.trArr[0].tracl;
		countOut++;

		str.Format(_T("T%d."), nx);
		pFrame->myCaption(str);
	} // for nx

	// now free any trace data that are beyond countOut
	for (nx = countOut; nx < nxmax; nx++) {
		if (headOut.trArr[nx].data != NULL) {
			free1float(headOut.trArr[nx].data);
			headOut.trArr[nx].data = NULL;
		}
	}
	headOut.setnx(countOut);
	SegyWrapper::freeSegyArray(&sw.headRead);
	SegyWrapper::freeSegyArray(&headSum);

	// save 
	if (SegyWrapper::saveToSegyFile(&headOut, outFile, head.ascHead, FALSE)) {
		str.Format(_T("Output %d traces from %d traces by simple stacking traces of similar offsets."), countOut, nxmax);
		pFrame->myCaption(str);
		draw.timeSecName = outFile;
		OnToolbarRefreshAll();
	}

	// free
	SegyWrapper::freeSegyArray(&headOut);
}


void CSeisWideDoc::OnModelingDefinesourceposition()
{
//	float distTrc;
	int options;
	int isCalcFromUTM = 0;

	// para.isDistanceLeftOfShot controls how distance is calculated: if TRUE, Dist=xShot+offset. If FALSE, Dist=xShot-offset.
	int isSxsyOverwrite = (cd.coord.isMinusXShot) ? 1 : 0;

	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	static BOOL isNegativeFromLat = false;
	//CString xyFileName;
	//long FFID[20000];
	//float dist[20000];
	int i = 1;

	CdlgSourcePos dlg;
	dlg.m_timeSecName = draw.timeSecName;
	dlg.m_xShot = myFloat(tx.xShotRay, 5);
	dlg.m_isNegativeFromLat = isNegativeFromLat;
	//	dlg.m_recPlus = 0.25;
	dlg.m_sxsyOverwrite = 0;
	if (pFrame->psei->sxLong > ERRORVAL) {
		dlg.m_sx = pFrame->psei->sxLong;
		dlg.m_sy = pFrame->psei->syLat;
	}
	else {
		dlg.m_sx = 0.f;
		dlg.m_sy = 0.f;
	}
	if (dlg.DoModal() == IDOK) {
		draw.timeSecName = dlg.m_timeSecName.Trim();
		tx.xShotRay = dlg.m_xShot;
		options = dlg.m_options;

		// the first option
		isSxsyOverwrite = dlg.m_sxsyOverwrite;
		if (isSxsyOverwrite == 1)
			cd.coord.isMinusXShot = TRUE;
		else
			cd.coord.isMinusXShot = FALSE;

		pFrame->psei->sxLong = dlg.m_sx;
		pFrame->psei->syLat = dlg.m_sy;

		//xyFileName = dlg.m_xyFileName;
		// recPlus = dlg.m_recPlus;
		isNegativeFromLat = dlg.m_isNegativeFromLat;
		dlg.m_isCalcFromUTM;
	}
	else {
		return;
	}
	delete dlg;

	if (isSxsyOverwrite > 1 && pFrame->psei->sxLong == 0.f && pFrame->psei->syLat == 0.f) {
		AfxMessageBox(_T("Sorry, source long/lat cannot be all zero when calculating offset."), MB_ICONQUESTION);
		return;
	}

	if (CSegyMeta::segyHeadInit(draw.timeSecName, &head) != 1) return;
	SegyWrapper sw(draw.timeSecName, false);
	sw.m_isHeadersOnly = false;
	if (sw.open(&head, 0)) {
		// if (sw.headRead.nx() < 2) return;
	}


	//if (options == 2) {
	//	if (!isFileExistNotDirectory(xyFileName)) {
	//		//file.Close();
	//		AfxMessageBox(_T("please specify a FFID-Distance file name in ascii format"), MB_ICONQUESTION);
	//		return;
	//	}
	//	FILE *stream;
	//	if (_tfopen_s(&stream, xyFileName, _T("r")) != 0) {
	//		//file.Close();
	//		return;
	//	}
	//	_ftscanf_s(stream, _T("%ld %f"), &FFID[0], &dist[0]);
	//	while (_ftscanf_s(stream, _T("%ld %f"), &FFID[i], &dist[i]) > 0) {
	//		if (i == 20000) {
	//			AfxMessageBox(_T("No more than 20,000 lines are read in! Program continues though."), MB_ICONQUESTION);
	//			break;
	//		}
	//		i++;
	//	}
	//	fclose(stream);
	//	num = i;
	//	for (i = 0; i < num - 1; i++) {
	//		if (FFID[i + 1] < FFID[i]) {
	//			//file.Close();
	//			AfxMessageBox(_T("FFID table not in sequential order"), MB_ICONQUESTION);
	//			return;
	//		}
	//	} // for
	//} // if

	double aDistance = 0.0;
	double aOffset;
	int utmXOld = -1;
	int utmYOld = -1;

	if (options < 2) {
		sw.headRead.bh.obsPositionX = tx.xShotRay;
	}

	for (int ix = 0; ix < sw.headRead.getnx(); ix++) {
			segydynamic *ptr = &sw.headRead.trArr[ix];
			if (options == 0) {
				// single OBS/source for wide-angle data
				//now overwrite display to be offset+source position.
				if (isSxsyOverwrite > 1) {
					// now, we calculate offset between (sx,sy) and (gx,gy); assuming sxLong, syLat already in long/lat degrees:
					aOffset = calcDist(pFrame->psei->sxLong, pFrame->psei->syLat, ptr->gx*0.0001, ptr->gy*0.0001);
					if (isNegativeFromLat && pFrame->psei->syLat < ptr->gy*0.0001)
						aOffset *= -1;
					else if (!isNegativeFromLat && pFrame->psei->sxLong > ptr->gx*0.0001)
						aOffset *= -1;
					ptr->setOffset((float)aOffset);
				}
				else if (cd.coord.isMinusXShot) {
					ptr->setDistance(tx.xShotRay - ptr->getOffset());
				}
				else {
					ptr->setDistance(tx.xShotRay + ptr->getOffset());
				}
			}
			else if (options == 2) {
				ptr->setDistance((float)(ptr->cdp * 0.001));
			}

			// do nothting here for options = 1
	} // for ix
	sw.writeHeaderOnly();
//	sw.writeDataAll(draw.timeSecName);
	

	// old option code: disabled now
	//// near-offset MCS data, for simulating post-stack data for pre-stack algorithm
	//if (isCalcFromUTM == 0)
	//	ptr->sx = ptr->gx = ptr->cdp;
	//else {
	//	// now need to overwrite sx,gx,cdp according to UTM coordinates 
	//	if (utmXOld == -1) {
	//		utmXOld = ptr->sx;
	//		utmYOld = ptr->sy;
	//	}
	//	else {

	//		aDistance += sqrt((double)((ptr->sx - utmXOld)*(ptr->sx - utmXOld) + (ptr->sy - utmYOld)*(ptr->sy - utmYOld)));
	//		utmXOld = ptr->sx;
	//		utmYOld = ptr->sy;
	//	}
	//	ptr->sx = ptr->gx = (int)myRound(aDistance);
	//	ptr->setDistance((float)aDistance);
	//}

		// old option: disabled
		//	// modify source/receiver positions for pre-stack migration
		//	if (ptr->fldr<FFID[0])
		//		distTrc = dist[0];
		//	else if (ptr->fldr>FFID[num - 1])
		//		distTrc = dist[num - 1];
		//	else {
		//		for (i = 0; i < num - 1; i++) {
		//			if (ptr->fldr >= FFID[i] && ptr->fldr <= FFID[i + 1]) {
		//				if (abs(ptr->fldr - FFID[i]) < 1) {
		//					distTrc = dist[i];
		//					break;
		//				}
		//				distTrc = dist[i] + (dist[i + 1] - dist[i]) /
		//					(FFID[i + 1] - FFID[i])*(ptr->fldr - FFID[i]);
		//				break;
		//			}
		//		}
		//	}
		//	ptr->sx = (long)(distTrc*1000.);

		//	if (isSxsyOverwrite == 0)
		//		ptr->gx = ptr->sx + (int)(ptr->getOffset()*1000.); //receiver pos.
		//	else
		//		ptr->gx = ptr->sx - (int)(ptr->getOffset()*1000.); //receiver pos.
		//}


	draw.isRayShowing = TRUE;;
	tx.txTimeLoaded = 0;  // this line is to clear the memory cache for the traveltime curves. If not, it will still use the ones in memory, which will cause problerms.

	if (cd.coord.isDistanceDisplay) {
		draw.isSameDataDisplay = FALSE; //indicate display has been changed and will re-load all data in OnDraw().
	}
	// in offset display, no need to change anything in display

	SetModifiedFlag();
	UpdateAllViews(NULL);
	NotifyChanged();
}

#include "dlgSourcePosBulk.h"
void CSeisWideDoc::OnWideDefinesrc()
{
	int nf = 0;
	CString inFileName, inFileNames[999];

	//Open file dialog.
	CFileDialog dlg(TRUE, _T("sgy; SEG; segy"), _T("*.sgy; *.SEG; *.segy"),
		OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT | OFN_ALLOWMULTISELECT | OFN_EXPLORER,
		_T("Input Segy File (*.sgy;*.SEG; *.segy)|*.sgy; *.SEG; *.segy|"));

	TCHAR* buff = (TCHAR*)alloc1(65535, sizeof(TCHAR));
	buff[0] = '\0';
	dlg.m_ofn.lpstrTitle = _T("Select all files for batch processing");
	dlg.m_ofn.lpstrFile = buff;
	dlg.m_ofn.nMaxFile = 65535;//sizeof(buff);


	POSITION Position;

	if (dlg.DoModal() == IDOK) {
		Position = dlg.GetStartPosition();
		while (Position) {
			inFileName = dlg.GetNextPathName(Position);
			if (!inFileName.IsEmpty()) {
				inFileNames[nf] = inFileName;
				nf++;
			}
		}
		delete dlg;
	} //end dlg.DoModal function.
	else {
		free1(buff);
		delete dlg;
		return;
	}

	free1(buff);

	// If data numbers exceed max, just change this number
	int MAX_FILES = 999;
	if (nf > MAX_FILES) {
		AfxMessageBox(_T("Maximum number of files selected is exceeded."));
		return;
	}

	//now reorganize these files sequentially, alphabetically.
	int n;
	CString tStr;
	for (n = 0; n < nf - 1; n++) {
		for (int i = n + 1; i<nf; i++) {
			if (inFileNames[n]>inFileNames[i]) {
				tStr = inFileNames[i];
				inFileNames[i] = inFileNames[n];
				inFileNames[n] = tStr;
			}
		}
	}

	// these 2 variables will be provided via dialogbox
	BOOL isXsPlusOffset = true;
	float Xs = 0.f;

	CdlgSourcePosBulk dlg2;
	dlg2.m_xShot = Xs;
	dlg2.m_XsMinusOffset = !isXsPlusOffset;
	if (dlg2.DoModal() == IDOK) {
		Xs = dlg2.m_xShot;
		isXsPlusOffset = !dlg2.m_XsMinusOffset;
	}
	else return;

	// starting
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	int totFilesSuc = 0;
	int ix;

	for (n = 0; n < nf; n++) {
		if (!isFileExistNotDirectory(inFileNames[n])) continue;

		if (CSegyMeta::segyHeadInit(inFileNames[n], &head) != 1) continue;
		SegyWrapper sw(inFileNames[n], false);
		sw.m_isHeadersOnly = !head.isUnixFile;  // unix segy file cannot be overwritten
		if (sw.open(&head, 0)) {
			for (ix = 0; ix < sw.headRead.getnx(); ix++) {
				segydynamic *ptr = &sw.headRead.trArr[ix];
				if (!isXsPlusOffset) {
					ptr->setDistance(Xs - ptr->getOffset());
				}
				else {
					ptr->setDistance(Xs + ptr->getOffset());
				}
			}
		}
		if (head.isUnixFile)
			sw.writeDataAll(inFileNames[n]);
		else
			sw.writeHeaderOnly();
	} // for n

	tStr.Format(_T("A total of %d files successfully processed."), totFilesSuc);
	AfxMessageBox(tStr, MB_ICONQUESTION);

}

void CSeisWideDoc::OnWideOffsetsfromsrc()
{
	//const double ft2meter = 0.3048;
	int ix;
	CString tStr;
	CString inFileName = draw.timeSecName;
	if (!isFileExistNotDirectory(inFileName)) return;
	if (CSegyMeta::segyHeadInit(inFileName, &head) != 1) return;
	SegyWrapper sw(inFileName, false);
	if (!sw.open(&head, 0)) return;
	int nx = sw.headRead.getnx();
	if (nx < 1) return;
	segydynamic* ptr = &sw.headRead.trArr[0];
	double dx = ptr->sx - ptr->gx;
	double dy = ptr->sy - ptr->gy;
	double dist = sqrt(dx * dx + dy * dy) * 0.001;

	tStr.Format(_T("This will compute and overwrite offsets from trace headers sx, sy, gx, gy. Please make sure their values are already allocated in UTM coords. Existing offsets will be overwritten if clicking OK!\n FYI: for the first trace, dx=%d, dy=%d, computed offset=%f km."), dx, dy, (float)dist);
	if (AfxMessageBox(tStr, MB_OKCANCEL | MB_ICONQUESTION) != IDOK)
		return;

	sw.m_isHeadersOnly = !head.isUnixFile;  // unix segy file cannot be overwritten
	if (sw.open(&head, 0)) {
		for (ix = 0; ix < nx; ix++) {
			ptr = &sw.headRead.trArr[ix];
			dx = ptr->sx - ptr->gx;
			dy = ptr->sy - ptr->gy;
			dist = sqrt(dx * dx + dy * dy) * 0.001;
			ptr->setOffset((float)dist);

		//	test = ptr->getOffset();
		}
	}
		if (head.isUnixFile)
			sw.writeDataAll(inFileName);
		else
			sw.writeHeaderOnly();

	tStr.Format(_T("A total of %d files successfully processed."), nx);
	AfxMessageBox(tStr, MB_ICONQUESTION);

}


#include "dlgPoisson.h"
void CSeisWideDoc::OnToolsCalcPoisson()
{
	static CString strPoisson;
	dlgPoisson dlg;
	dlg.m_poisson = strPoisson;
	if (dlg.DoModal() == IDOK) {
		strPoisson = dlg.m_poisson;
	}
	else return;

	CString comments, a;
	CStringArray multiLinesArr, lineArr, outArr;

	if (strPoisson.GetLength() > 2) {
		SplitStringArr(strPoisson, _T("\n"), &multiLinesArr, false);

		for (int i = 0; i < multiLinesArr.GetSize(); i++) {
			a = multiLinesArr.ElementAt(i);
			a.Trim();
			if (a.GetLength() > 1) {
				// if here, the data is valid
				lineArr.RemoveAll();
				SplitStringArr(a, SPACE, &lineArr, false);
				register double aPoisson=0., aVpvs=0., t;
				for (int j = 0; j < lineArr.GetSize(); j++) {
					a = lineArr.ElementAt(j);
					t = StringToFloat(a);
					if (t > 1.) aVpvs = t;
					else aPoisson = t;
					if (j > 1) break;
				}
				if (aPoisson < 0.05 && aVpvs > 1.)
					aPoisson = CVelMod::calcPoisson(aVpvs);
				else if (aPoisson > 0.05 && aVpvs < 1.)
					aVpvs = CVelMod::calcVpovs(aPoisson);
				a.Format(_T("%8.3f  %8.3f"), (float)aPoisson, (float)aVpvs);
				outArr.Add(a);
			} // for i
		} // if

		strPoisson = BLANK;
		for (int i = 0; i < outArr.GetSize(); i++) {
			strPoisson += outArr.ElementAt(i) + CARRAGE;
		}
		// dlg.m_latLongMulti = aLatlong;
	}


	multiLinesArr.RemoveAll();
	lineArr.RemoveAll();
	outArr.RemoveAll();
	OnToolsCalcPoisson();
}


void CSeisWideDoc::OnModelingSethorizonlimitswithraypaths()
{
	CRayHelper cr;
	bool isTrue = false;
	if (cd.coord.isTimeDomain())
		isTrue = cr.setVelocityXmLimits(&velMod, &raypathsTwtt, true);
	else
		isTrue = cr.setVelocityXmLimits(&velMod, &raypaths, false);
	if (isTrue) {
		UpdateAllViews(NULL);
		NotifyChanged();
	}
}


void CSeisWideDoc::StartOpenGL2_OLD(CView* pView, CDC *pDC, int nx, int ny,
	float **ampArr, float x[], float y[],
	CColorHelper::AMPCOLORDYN *ampColorDyn2, CCoords::SEI_COORD *pcd)
{
	if (ny < 2 || nx < 2) return; // we cannot plot 3D with <2 samples or <2 traces
	int ix, iy;
	double xmin = pcd->X1();
	double ymin = pcd->Y1();
	//double dy = pcd->yHeight() / (double)(ny - 1);
	float dy = y[1] - y[0];  // this is constant for each segy

	//################################
	double dxPixel = pcd->dxPerPixel();  // km per pixel, skip if dx within 1 pixel
	float dyPixel = (float)pcd->dyPerPixel(); // seconds per pixel
  //################################
	int ny2 = (dy >= dyPixel) ? ny : (int)(pcd->yHeight() / dyPixel + 1.5);
	float dy2 = (dy >= dyPixel) ? dy : dyPixel;
	float *y2 = (float *)ealloc1float(ny2);
	y2[0] = (float)ymin;
	for (iy = 1; iy < ny2; iy++) {
		y2[iy] = y2[iy - 1] + dy2;
	}
	float **amp2 = (float **)ealloc2float(ny2, nx);

	if (dy >= dyPixel) {
		for (ix = 0; ix < nx; ix++) {
			memcpy(&amp2[ix][0], &ampArr[ix][0], ny2 * sizeof(float));
		}
	}
	else {
		for (ix = 0; ix < nx; ix++) {
			ints8r(ny, // ntin
				(float)dy,   // dtin
				(float)ymin,   // ftin
				&ampArr[ix][0], // yin[t=ntin], with yin[0] = y(fxin)
				0.f,  // yinl    value used to extrapolate yin values to left of yin[0]
				0.f,  // yinr	 value used to extrapolate yin values to right of yin[ntin-1]
				ny2,   // nxout
				&y2[0],  // ntout
				&amp2[ix][0]);    // tout
		}
	}

	double oHeight = 2. / pcd->yHeight();
	for (iy = 0; iy < ny2; iy++) {
		y2[iy] = (float)(-1.f + (y2[iy] - ymin) * oHeight); // note: y2[] is now normalized
	}

	//################################
	// now skip along X axis if traces are too dense
	int nyBytes2 = ny2 * sizeof(float);
	float *x2 = (float *)ealloc1float(nx);
	int ix2 = 0;
	x2[ix2] = x[0];
	memcpy(&amp2[ix2][0], &amp2[0][0], nyBytes2);
	ix2++;
	for (ix = 1; ix < nx; ix++) {
		if (fabs(x[ix] - x2[ix2 - 1]) < dxPixel) continue; // skip this trace ix
		memcpy(&amp2[ix2][0], &amp2[ix][0], nyBytes2);
		x2[ix2] = x[ix];
		ix2++; // this index is now accepted for plotting
	}
	int nx2 = ix2;
	//################################
	double oWidth = 2. / pcd->xWidth();
	for (ix = 0; ix < nx2; ix++)
		x2[ix] = (float)(-1.f + (x2[ix] - xmin) * oWidth); // note: x2[] is now normalized


	//################################
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	pFrame->statMain.myCursor(true);
	if (m_GLWin.CreateGLContextFBO(pcd->getPixelsAxes(),
		pcd->logicalAxes,
		pView, pDC, nx, pcd->isFaceUp, pcd->isSwapX == TRUE)) {
			m_GLWin.mySeis3DFBO_Init(amp2, ampColorDyn2, x2, y2, nx2, ny2);
			// m_OGL_Window_Right.myTest2FBO(amp2, ampColorDyn2, x, y, nx, ny, dxPixel * oWidth, dxPixel * oWidth);
			//m_OGL_Window_Right.depSeisFBO(amp2, ampColorDyn2, x2, y2, nx2, ny2, dxPixel * oWidth, dxPixel * oWidth);
	}

	free1float(x2);
	free1float(y2);
	free2float(amp2);
	pFrame->statMain.myCursor(false);
}



void CSeisWideDoc::StartOpenGL2(CView* pView, CDC *pDC, float **ampArr, 
	float x[], int nx, float y0, float dy, int ny,
	CColorHelper::AMPCOLORDYN *ampColorDyn2, CCoords::SEI_COORD *pcd)
{
	if (ny < 2 || nx < 2) return; // we cannot plot 3D with <2 samples or <2 traces
	int ix, iy;
	double xminData = getMinValue(x, nx, MAXAMP);
	double yminData = y0;
	double ymaxData = y0 + (ny - 1)*dy;
	//float dy = y[1] - y[0];  // this is constant for each segy

							 //################################
	double dxPixel = pcd->dxPerPixel();  // km per pixel, skip if dx within 1 pixel
	float dyPixel = (float)pcd->dyPerPixel(); // seconds per pixel
											  //################################
	int ny2 = (dy >= dyPixel) ? ny : (int)((ymaxData -yminData) / dyPixel + 1.5);
	float dy2 = (dy >= dyPixel) ? dy : dyPixel;
	float *y2 = (float *)ealloc1float(ny2);
	y2[0] = (float)yminData;
	for (iy = 1; iy < ny2; iy++) {
		y2[iy] = y2[iy - 1] + dy2;
	}
	float **amp2 = (float **)ealloc2float(ny2, nx);

	if (dy >= dyPixel) {
		for (ix = 0; ix < nx; ix++) {
			memcpy(&amp2[ix][0], &ampArr[ix][0], ny2 * sizeof(float));
		}
	}
	else {
		for (ix = 0; ix < nx; ix++) {
			register float vl = ampArr[ix][0];
			register float vr = ampArr[ix][ny - 1];
			ints8r(ny, // ntin
				(float)dy,   // dtin
				(float)yminData,   // ftin
				&ampArr[ix][0], // yin[t=ntin], with yin[0] = y(fxin)
				vl,  // yinl    value used to extrapolate yin values to left of yin[0]
				vr,  // yinr	 value used to extrapolate yin values to right of yin[ntin-1]
				ny2,   // nxout
				&y2[0],  // ntout
				&amp2[ix][0]);    // tout
		}
	}

	double oHeight = 2. / pcd->yHeight();
//	double oHeight = 2. / (ymax-ymin);  // since we have ny>0, ymax>ymin for sure
	for (iy = 0; iy < ny2; iy++) {
		y2[iy] = (float)(-1.f + (y2[iy] - pcd->Y1()) * oHeight); // note: y2[] is now normalized
	}

	//################################
	// now skip along X axis if traces are too dense
	int nyBytes2 = ny2 * sizeof(float);
	float *x2 = (float *)ealloc1float(nx);
	int ix2 = 0;
	x2[ix2] = x[0];
	memcpy(&amp2[ix2][0], &amp2[0][0], nyBytes2);
	ix2++;
	for (ix = 1; ix < nx; ix++) {
		if (fabs(x[ix] - x2[ix2 - 1]) < dxPixel) continue; // skip this trace ix
		memcpy(&amp2[ix2][0], &amp2[ix][0], nyBytes2);
		x2[ix2] = x[ix];
		ix2++; // this index is now accepted for plotting
	}
	int nx2 = ix2;
	//################################
	double oWidth = 2. / pcd->xWidth();
	for (ix = 0; ix < nx2; ix++)
		x2[ix] = (float)(-1.f + (x2[ix] - pcd->X1()) * oWidth); // note: x2[] is now normalized


														   //################################
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	pFrame->statMain.myCursor(true);
	if (m_GLWin.CreateGLContextFBO(pcd->getPixelsAxes(),
		pcd->logicalAxes,
		pView, pDC, nx, pcd->isFaceUp, pcd->isSwapX == TRUE)) {

		m_GLWin.mySeis3DFBO_Init(amp2, ampColorDyn2, x2, y2, nx2, ny2);



		// m_OGL_Window_Right.myTest2FBO(amp2, ampColorDyn2, x, y, nx, ny, dxPixel * oWidth, dxPixel * oWidth);
		//m_OGL_Window_Right.depSeisFBO(amp2, ampColorDyn2, x2, y2, nx2, ny2, dxPixel * oWidth, dxPixel * oWidth);
	}

	free1float(x2);
	free1float(y2);
	free2float(amp2);
	pFrame->statMain.myCursor(false);
}


void CSeisWideDoc::StartOpenGL3_2DOnly(CView* pView, CDC *pDC, int nx, int ny, CColorHelper::rgb **colorsArr, float x[], float y[], CCoords::SEI_COORD *pcd)
{
	int ix, iy;
	double xmin = pcd->X1();
	double ymin = pcd->Y1();

	//################################
	double dxPixel = pcd->dxPerPixel();  // km per pixel
	double dyPixel = pcd->dyPerPixel(); // seconds per pixel
	double dy = pcd->yHeight() / (double)(ny - 1);
	int numSamp2Skip = (int)(dyPixel / dy + 0.5); // if 0, no need to skip and we can use memcpy for the entire trace
												  //################################
												  // first, we produce a newer version of the ampArr** array to avoid too dense data
	CColorHelper::rgb **colors2 = (CColorHelper::rgb **)alloc2(ny, nx, sizeof(CColorHelper::rgb));
	int nyBytes = ny * sizeof(CColorHelper::rgb);
	int ny2;
	if (numSamp2Skip>0) {
		for (ix = 0; ix < nx; ix++) {
			ny2 = 0;
			for (iy = 0; iy < ny; iy += numSamp2Skip + 1) {
				colors2[ix][ny2] = colorsArr[ix][iy];
				ny2++;
			}
		}
	}
	else {
		memcpy(&colors2[0][0], &colorsArr[0][0], nyBytes*nx);
		ny2 = ny;
	}
	//################################
	// now skip along X axis if traces are too dense
	int nyBytes2 = ny2 * sizeof(CColorHelper::rgb);
	float *x2 = (float *)ealloc1float(nx);
	int ix2 = 0;
	x2[ix2] = x[0];
	// memcpy(&colors2[ix2][0], &colors2[0][0], nyBytes2); // no need to copy the same memory
	ix2++;
	for (ix = 1; ix < nx; ix++) {
		if (fabs(x[ix] - x2[ix2 - 1]) < dxPixel) continue; // skip this trace ix
		if (ix2 != ix)
			memcpy(&colors2[ix2][0], &colors2[ix][0], nyBytes2);
		x2[ix2] = x[ix]; // this is needed regardless of ix2==ix
		ix2++; // this index is now accepted for plotting
	}
	int nx2 = ix2;
	//################################
	double dy2 = (y[ny - 1] - y[0]) / (double)(ny2 - 1);
	float *y2 = (float *)ealloc1float(ny2);
	y2[0] = (float)ymin;
	for (iy = 1; iy < ny2; iy++) {
		y2[iy] = y2[iy - 1] + (float)dy2;
	}
	//################################
	// calculate the maximum trace spacing: if there is a big data gap, we will show the gap
	float dxMax = getAvgInterval(x2, nx2) * 5.f;

	//################################
	// Create OpenGL Control window
	if (m_GLWin.CreateGLContextFBO(pcd->getPixelsAxes(),
			pcd->logicalAxes,
			pView, pDC, nx, pcd->isFaceUp, pcd->isSwapX==TRUE)) {

		double oWidth = 2. / (x2[nx2 - 1] - x2[0]);
		for (ix = 0; ix < nx2; ix++)
			x2[ix] = (float)(-1.f + (x2[ix] - xmin) * oWidth);

		// now prepare y[] for opengl
		double oHeight = 2. / (y2[ny2 - 1] - y2[0]);
		for (iy = 0; iy < ny2; iy++) {
			y2[iy] = (float)(-1.f + (y2[iy] - ymin) * oHeight);
		}
		m_GLWin.depSeisFBO3(colors2, pDC, x2, y2, nx2, ny2, (float)(dxPixel * oWidth), (float)(dxMax*oWidth));
	}

	free1float(x2);
	free1float(y2);
	free2((void **)colors2);
}


void CSeisWideDoc::OnProcessingAddrangetosegy()
{
	// Associate km to trace
	double range, x0;
	static double dx = 0.0125;
	double lon0, lat0;
	double lon, lat;
	CString tStr;
	CString name;

	static int assignMethod = 0;
	static int traceRef1 = 0;
	static BOOL isSx = FALSE;

	CdlgAddRange dlg;
	dlg.m_refName = draw.timeSecName;
	dlg.m_refRange0 = 0.f;
	dlg.m_refDx = (float)dx;
	dlg.m_assignMethod = assignMethod;
	dlg.m_trace1 = traceRef1;
	dlg.m_isGs = isSx;
	if (dlg.DoModal() == IDOK) {
		name = dlg.m_refName;
		x0 = dlg.m_refRange0;
		dx = dlg.m_refDx;
		assignMethod = dlg.m_assignMethod;
		traceRef1 = dlg.m_trace1;
		isSx = dlg.m_isGs;
	}
	else {
		return;
	}
	delete dlg;

	if (!isFileExistNotDirectory(name)) return;
	CSegyMeta::segyHeadInit(name, &head);

	bool isPrestackShotGather = head.isPrestackShotGather();
	if (isPrestackShotGather) {
		tStr.Format(_T("Source positions of prestack segy can be assigned distance here, with a spacing of %g km, based on your input value. Continue?"), 2.*dx);
		if (AfxMessageBox(tStr, MB_OKCANCEL | MB_ICONQUESTION) != IDOK) {
			// start 
			return;
		}
	}

	draw.timeSecName = name;
	bool isHeaderOnly = false;
	SegyWrapper sw(draw.timeSecName, isHeaderOnly);
	if (!sw.openTrace(0, 99999, 0, &head, 1, 0.)) return;
	int numTraces = sw.headRead.getnx();
	if (numTraces < 2) return;

	static double arcFactor = 1.f / 360000.f;
	register double divFactor = 1.f;
	if (sw.headRead.trArr[0].counit == 0) divFactor = OMIL;
	else divFactor = arcFactor;
	static double oDivFactor = 1. / divFactor;

	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	pFrame->statMain.myCursor(true);
	range = 0.0;  // initialize it
	double rangeOld = 0.0f;

	int countUnAssigned = 0;

	int indFirstTrace = 0;
	if (traceRef1 > 0) {
		for (int ix = 0; ix < numTraces; ix++) {
			segydynamic *ptr = &sw.headRead.trArr[ix];
			if (ptr->tracl < traceRef1 - 1) continue;
			register int ii = ix - 1;
			if (ii < 0) ii = 0;
			lon0 = (isSx ? sw.headRead.trArr[ii].sx : sw.headRead.trArr[ii].gx) * divFactor;
			lat0 = (isSx ? sw.headRead.trArr[ii].sy : sw.headRead.trArr[ii].gy) * divFactor;
			x0 = ptr->getDistance();
			indFirstTrace = ix;
			break;
		}
	}
	else {
		// the first trace is used as reference
		// x0;  // already entered manually
		lon0 = (isSx ? sw.headRead.trArr[0].sx : sw.headRead.trArr[0].gx) * divFactor;
		lat0 = (isSx ? sw.headRead.trArr[0].sy : sw.headRead.trArr[0].gy) * divFactor;
	}


	int numTraceSeq = 0;
	int numShot = 0;
	for (int ix = 0; ix < numTraces; ix++) {
		segydynamic *ptr = &sw.headRead.trArr[ix];
		if (ptr->tracl < traceRef1) continue;
		//TRACE Number: sometimes tr.tracl=0 always, so we use numTraceSeq instead

		if (assignMethod == 0 && isPrestackShotGather) {
			//shot gather only
			range = x0 + (double)numShot*2.*dx;
			ptr->setDistance((float)range); // only set distance for the shot location, not at CMP!!!
		}
		else if (assignMethod == 0) {
			//Note dist can be either CDP or FFID.
			range = x0 + (double)numTraceSeq*dx;
			ptr->setDistance((float)range);
		}
		else if (assignMethod == 1) {
			range = x0 + (double)numTraceSeq * dx;
			ptr->setOffset((float)range);
		}
		else if (assignMethod == 2) {
			// assign curved distance based on lat/long of the previous trace
			lon = (isSx ? ptr->sx : ptr->gx) * divFactor;
			lat = (isSx ? ptr->sy : ptr->gy) * divFactor;
			if (ix > indFirstTrace) {
				lon0 = (isSx ? sw.headRead.trArr[ix - 1].sx : sw.headRead.trArr[ix - 1].gx) * divFactor;
				lat0 = (isSx ? sw.headRead.trArr[ix - 1].sy : sw.headRead.trArr[ix - 1].gy) * divFactor;
				x0 = sw.headRead.trArr[ix - 1].getDistance();
			}
			range = calcDist(lon0, lat0, lon, lat);
			ptr->setDistance((float)(x0 + range));
		} 
		else if (assignMethod == 3) {
			// assign straight distance based on lat/long of the first trace only
			lon = (isSx ? ptr->sx : ptr->gx) * divFactor;
			lat = (isSx ? ptr->sy : ptr->gy) * divFactor;
			range = calcDist(lon0, lat0, lon, lat);
			ptr->setDistance((float)(x0 + range));
		} 
		numTraceSeq++;

		if (ix > 0 && ptr->fldr != 0 && ptr->fldr != sw.headRead.trArr[ix - 1].fldr)
			numShot++;
	} // for ix
	sw.writeDataAll();
	pFrame->statMain.myCursor(false);

	//CString ts;
	tStr.Format(_T("%d traces Successful. %d traces failed in assigning. Last trace assigned at %g km"), numTraceSeq, countUnAssigned, x0+range);
	AfxMessageBox(tStr, MB_ICONQUESTION);
}

void CSeisWideDoc::OnReflectionAssociatekmtotracefromfile()
{
	// Associate km to trace
	double range;
	int numPoints = 0;
	bool isShotTable = false;
	int i;
	CString tStr;
	CString name, nameOffset;

	// static int distMethod = 0;
	static int assignMethod2 = 0;

	CdlgAddRangeFile dlg;
	dlg.m_refName = draw.timeSecName;
	dlg.m_assignMethod = assignMethod2;
	if (dlg.DoModal() == IDOK) {
		name = dlg.m_refName;
		assignMethod2 = dlg.m_assignMethod;
		nameOffset = dlg.m_nameOffset;
	}
	else {
		return;
	}
	delete dlg;
	if (nameOffset.Find(_T(".sht")) > 0) isShotTable = true;
	if (!isFileExistNotDirectory(nameOffset)) {
		AfxMessageBox(_T("Please specify a file name for assigning offset|distance info"), MB_ICONQUESTION);
		return;
	}

	if (!isFileExistNotDirectory(name)) return;
	CSegyMeta::segyHeadInit(name, &head);
	draw.timeSecName = name;
	bool isHeaderOnly = false;
	SegyWrapper sw(name, isHeaderOnly);
	if (!sw.openTrace(0, 99999, 0, &head, 1, 0.) || sw.headRead.getnx()<1) return;

	int *xx = NULL;
	float *yy = NULL;  // can be km if (assignMethod == 2 || assignMethod == 3),  or lon if (assignMethod == 5 || assignMethod == 6)

	CStringArray *kmTraces = getLinesFromFile(nameOffset);
	CStringArray *lineArr = new CStringArray();
	SplitStringArr(kmTraces->ElementAt(0), SPACE, lineArr, false);
	bool isSingleNumPerLine = lineArr->GetSize() < 2;
	lineArr->RemoveAll();
	delete lineArr;

	if (isShotTable) kmTraces->RemoveAt(0, 7);
	numPoints = (int)kmTraces->GetCount();
	if (numPoints < 2) {
		delete kmTraces;
		AfxMessageBox(_T("At least 2 points are needed for assigning offset|distance info"), MB_ICONQUESTION);
		return;
	}
	xx = (int *)ealloc1int(numPoints);
	yy = (float *)ealloc1float(numPoints);

	if (isShotTable) {
		// shot table format
		for (i = 0; i < numPoints; ++i) {
			//read in trace no., and offset/distance in m.
			if (_stscanf_s(kmTraces->ElementAt(i), _T("%d %*d %*d %*d %*f %*f %*f %f"), &xx[i], &yy[i]) == 0) continue;
		}
	}
	else if (isSingleNumPerLine) {
		//offset/distance in km.
		for (i = 0; i < numPoints; ++i) {
			if (_stscanf_s(kmTraces->ElementAt(i), _T("%f"), &yy[i]) == 0) continue;
		}
	}
	else {
		//offset/distance in km, 2 columns.
		for (i = 0; i < numPoints; ++i) {
		//	tStr = kmTraces->ElementAt(i);
			if (_stscanf_s(kmTraces->ElementAt(i), _T("%d %f"), &xx[i], &yy[i]) == 0) continue;
		//	if (_stscanf_s(tStr, _T("%f %f"), &xx[i], &yy[i]) == 0) continue;
		}
	}
	if (kmTraces != NULL) {
		kmTraces->RemoveAll();
		delete kmTraces;
	}

	if (numPoints != head.numTraces) {
		if (xx != NULL) free1int(xx);
		if (yy != NULL) free1float(yy);
		AfxMessageBox(_T("Sorry, number of traces do not match the ascii file, and cannot continue."), MB_ICONQUESTION);
		return;
	}

	tStr.Format(_T("%d numbers to be assigned to %d traces."), numPoints, head.numTraces);
	AfxMessageBox(tStr, MB_ICONQUESTION);





	//static double arcFactor = 1.f / 360000.f;
	//register double divFactor = 1.f;
	//if (sw.headRead.trArr[0].counit == 0) divFactor = OMIL;
	//else divFactor = arcFactor;
	//static double oDivFactor = 1. / divFactor;

	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();

	int numTraceSeq = 0;
	range = 0.0;  // initialize it
	double rangeOld = 0.0f;

	int countUnAssigned = 0;
	for (int ix = 0; ix < sw.headRead.getnx(); ix++) {
		segydynamic *ptr = &sw.headRead.trArr[ix];
		if (assignMethod2 == 0) {
			// assign offset info based on ascii file nameOffset.
			ptr->setOffset((float)yy[ix]);
		}
		else {
			ptr->setDistance((float)yy[ix]);
		}
		numTraceSeq++;
	} // for ix
	if (xx != NULL) free1int(xx);
	if (yy != NULL) free1float(yy);
	sw.writeDataAll();

	//CString ts;
	tStr.Format(_T("%d traces Successful. %d traces failed in assigning."), numTraceSeq, countUnAssigned);
	AfxMessageBox(tStr, MB_ICONQUESTION);
}


void CSeisWideDoc::OnDigitizeCurvestosegy()
{
	CString tStr;
	if (dig.isDigitizing || bmp24.bmpName.IsEmpty() || isFloatEqual(bmp24.xmin, bmp24.xmax)) {
		tStr.Format(_T("To digitize bitmap section into Segy, load it and define coordinates for its corners."));
		AfxMessageBox(tStr, MB_ICONQUESTION);
		return;
	}

	dig.isDigitizing = TRUE;
	dig.isTraceFormat = TRUE;
	dig.isSortedX = FALSE;
	dig.isSortedY = TRUE;

	dig.digName = GetFileNameAppendExt(bmp24.bmpName, _T("_Conv"), _T("txt"));
	if (isFileExistNotDirectory(dig.digName)) {
		// since the digi file exists, we want to load it
		CDigitize pDg;
		if (pDg.myDigitizingLoadTXTUnix2(&dig)) {
			if (dig.totCurve < 1) dig.totCurve = 1;
			dig.iCurveSel = dig.totCurve - 1;

			for (int ic = 0; ic < dig.totCurve; ic++) {
				dig.curveVal[ic] = (float)ic; //(float)StringToFloat(dig.labelArr->ElementAt(ic));
				if (dig.curveVal[ic] < ERRORVAL)
					dig.curveVal[ic] = ERRORVAL; // I usually deduct ERRORVAL by the ic to mark up in the text file
			}
		}
	}

	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	pFrame->statMain.add = TRUE;
	pFrame->statMain.pick =
		pFrame->statMain.move =
		pFrame->statMain.remove = FALSE;

}


void CSeisWideDoc::OnDigitizeEndcurvestosegy()
{
	CString tStr;
	if (!dig.isDigitizing || bmp24.bmpName.IsEmpty() || isFloatEqual(bmp24.xmin, bmp24.xmax)) {
		tStr.Format(_T("To digitize bitmap section into Segy, load it and define coordinates for its corners."));
		AfxMessageBox(tStr, MB_ICONQUESTION);
		return;
	}

	if (dig.totCurve < 1) {
		tStr.Format(_T("Resulting trace too few (<1)."));
		AfxMessageBox(tStr, MB_ICONQUESTION);
		return;
	}

	for (int ic = 0; ic < dig.totCurve; ic++) {
		if (isFloatEqual(dig.curveVal[ic], ERRORVAL)) {
			tStr.Format(_T("Trace zero line distances should be defined."));
			AfxMessageBox(tStr, MB_ICONQUESTION);
			return;
		}
	}

	// parameters:
	CString fname = GetFileNameAppendExt(bmp24.bmpName, _T("_Conv"), _T("sgy"));
	double tmin = cd.coord.Y1();
	double dt = 0.004;
	int numsample = (int)(ceil)(cd.coord.yHeight() / dt) + 1;
	if (numsample > 0xffff) {
		// since it is more than a segy can handle, we need to shorten it
		numsample = 0xffff;
		dt = cd.coord.yHeight() / (numsample - 1);
	}

	if (cd.coord.drawmode == 6)
		dig.xMode = CDigitize::trace;
	else if (cd.coord.isDistanceDisplay)
		dig.xMode = CDigitize::distance;
	else
		dig.xMode = CDigitize::offset;

	bool isSuc = SegyWrapper::saveDig2Trace(&dig, fname, numsample, tmin, dt);

	CDigitize pDg;
	pDg.myDigSaveAs2(&dig, false);

	dig.isDigitizing = FALSE;
	dig.isTraceFormat = FALSE;

	tStr.Format(_T("Successfully constructed segy: %s."), fname);
	AfxMessageBox(tStr, MB_ICONQUESTION);
}


void CSeisWideDoc::OnDigitizeDefineXval()
{
	CString tStr;
	if (!dig.isDigitizing || bmp24.bmpName.IsEmpty() || isFloatEqual(bmp24.xmin, bmp24.xmax)) {
		tStr.Format(_T("Function for digitizing and converting to segy traces only."));
		return;
	}

	//if (!cd.zoom.isZooming) {
	//	tStr.Format(_T("Please zoom in to define the X coordinate for the current trace."));
	//	AfxMessageBox(tStr, MB_ICONQUESTION);
	//	return;
	//}

	dig.isXValClicking = TRUE; // if TRUE, the next click will be for assigning curveVal[iCurveSel]

	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	pFrame->statMain.add = TRUE;

}




void CSeisWideDoc::OnBitmapsTimelineremoval()
{
	// this function is disabled already from the menu
	if (!isFileExistNotDirectory(draw.timeSecName)) return;

	CString tstr;
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	SegyWrapper sw(draw.timeSecName);
	if (CSegyMeta::segyHeadInit(draw.timeSecName, &head) == 1) {
		if (!sw.open(&head, 0)) {
			tstr.Format(_T("Valid input file cannot be opened"));
			AfxMessageBox(tstr, MB_ICONQUESTION);
			return;
		}
	}

	double tIntervalTM = 1.;
	double tIntervalRes = 0.01;
	if (tIntervalRes < head.dtFile*1.5) tIntervalRes = head.dtFile*1.5;
	tstr.Format(_T("Loaded segy with %d traces. Will try to remove timelines at interval of %g sec, with an resolution of %g sec. Continue?"), 
		sw.headRead.getnx(), tIntervalTM, tIntervalRes);
	if (AfxMessageBox((tstr), MB_YESNO | MB_ICONQUESTION) != IDYES) {
		return;
	}

	int nt = sw.headRead.getns();
	int nx = sw.headRead.getnx();
	int njAppended = npfar(nx);
	if (njAppended < 2) return;

	int ix, it; // loop indexes
	//double dt = sw.headRead.getdt();
	float *transpose = (float *)ealloc1float((size_t)(njAppended));
	memset((void *)&transpose[0], (int) '\0', njAppended * sizeof(float));

	// calculate filter parameters along the X-axis (note: not along the time axis!)
	double dxAvg = cd.coord.isDistanceDisplay ? head.distIntervalFile : head.offsetIntervalFile;
	if (cd.coord.isTraceMode()) dxAvg = .0125; // for trace mode, we just assume a unit for the X value
	double nyq = 0.5 / dxAvg;
	double f1 = 0.2; // low cut, just to cut the timelines out, which should be very loa frequency
	double f2 = nyq; // nyquest



	// loop thru
	complex *cz = (complex *)ealloc1complex(njAppended / 2 + 1);
	double t0 = sw.headRead.trArr[0].getTraceDelay();
	for (it = 0; it < nt; it++) {
		// should we use this one one?
		register double t = t0 + it * head.dtFile;
		register double aModVal = fmod(t, tIntervalTM);
		if (aModVal > tIntervalTM*0.5) aModVal -= tIntervalTM;
		if (fabs(aModVal) > tIntervalRes) {
			continue;
		}
		for (ix = 0; ix < nx; ix++) {
			transpose[ix] = sw.headRead.trArr[ix].data[it];
		}

		if ( fabs(t - 3.f) <= head.dtFile) {
			int rer = 1;
		}
		//register float a1 = getAvgValue(transpose, nx);
		//
		//// now do the filtering
		//pfarc(1, njAppended, &transpose[0], cz);
		//// now transform back to time domain
		//pfacr(-1, njAppended, cz, &transpose[0]);
		//register float a2 = getMedianValue(transpose, nx);
		//register float a3 = a2 / (float)njAppended;

		// now put the data back to where they were, with debias back on as well
		register float a1;
		for (ix = 0; ix < nx; ix++) {
			// sw.headRead.trArr[ix].data[it] = transpose[ix] / (float)njAppended;
			// here, if it is 255., it is empty, so we do not modify it
			//if (fabs(sw.headRead.trArr[ix].data[it]) < 200.)
			//	sw.headRead.trArr[ix].data[it] -= a1;

			if (fabs(sw.headRead.trArr[ix].data[it]) < 200.) {
				if (ix == 0)
					a1 = (transpose[0] + transpose[ix])*.5f;
				else if (ix == nx - 1)
					a1 = (transpose[nx - 2] + transpose[ix])*.5f;
				else
					a1 = (transpose[ix - 1] + transpose[ix] + transpose[ix + 1])*.33333f;

				sw.headRead.trArr[ix].data[it] -= a1;
			}
		}
	} // for it
	free1complex(cz);
	if (transpose != NULL) free1float(transpose);

	// output to file
	CString outFile = getFileNameAppend(draw.timeSecName, _T("TMRem"));
	if (SegyWrapper::saveToSegyFile(&(sw.headRead), outFile, head.ascHead, FALSE)) {
		draw.timeSecName = outFile;
		OnToolbarRefreshAll(); // need to do it at the last line
	}

}


void CSeisWideDoc::OnProcessingResetsamplerate()
{
	CString tstr;
	if (CSegyMeta::segyHeadInit(draw.timeSecName, &head) != 1) {
		tstr.Format(_T("Please show a section first."));
		AfxMessageBox(tstr, MB_ICONQUESTION);
		return;
	}

	tstr.Format(_T("Current sampling rate is %d micro sec. Please specify a new value to change to the new sampling rate. No other information will be changed here."), (int)(head.dtFile*MIL+0.5));
	AfxMessageBox(tstr, MB_ICONQUESTION);
	CdlgValue dlg;
	dlg.m_fvalue = (float)fabs(ERRORVAL);
	if (dlg.DoModal() != IDOK) {
		return;
	}
	if (dlg.m_fvalue > 65535 || dlg.m_fvalue < 1) {
		tstr.Format(_T("Sorry, the unit is in seconds. Your value is too high for a valid sampling rate."));
		AfxMessageBox(tstr, MB_ICONQUESTION);
		return;
	}
	CString fout = getFileNameAppend(draw.timeSecName, _T("NewRate"));

	SegyWrapper sw(draw.timeSecName, false);
	if (sw.open(&head, 0)) {
		sw.headRead.setdt(dlg.m_fvalue*OMIL);
		for (int ix = 0; ix < sw.headRead.getnx(); ix++) {
			sw.headRead.trArr[ix].dt = sw.headRead.bh.hdt;
		}
		int num = sw.writeDataAll(fout);
		tstr.Format(_T("New sampling rate of %d micro sec is updated."), sw.headRead.bh.hdt);
		AfxMessageBox(tstr, MB_ICONQUESTION);
		draw.timeSecName = fout;
		SetModifiedFlag();
		UpdateAllViews(NULL);
		NotifyChanged();

	}
}




void CSeisWideDoc::OnToolsInterpInvalidT0()
{
	CString tstr;
	tstr.Format(_T("Please specify a maximum absolute start time value in seconds to be considered valid. Any values exceeding it will be auto interpolated."));
	AfxMessageBox(tstr, MB_ICONQUESTION);
	CdlgValue dlg;
	dlg.m_fvalue = (float)fabs(200.);
	if (dlg.DoModal() != IDOK) {
		return;
	}
	SegyWrapper sw(draw.timeSecName, false);
	if (CSegyMeta::segyHeadInit(draw.timeSecName, &head) != 1) return;
	if (sw.open(&head, 0)) {
		int count = 0;
		for (int ix = 0; ix < sw.headRead.getnx(); ix++) {
			if (fabs(head.tminArr[ix]) > fabs(dlg.m_fvalue)) {
				// when invalid trace start time found, we interpolate
				// first, find the valid time to the left
				register int ixLeft = -1;
				for (int i = ix - 1; i >= 0; i--) {
					if (fabs(head.tminArr[i]) < fabs(dlg.m_fvalue)) {
						ixLeft = i;
						break;
					}
				}
				if (ixLeft < 0) continue; // 

				register int ixRight = -1;
				for (int i = ix + 1; i < sw.headRead.getnx(); i++) {
					if (fabs(head.tminArr[i]) < fabs(dlg.m_fvalue)) {
						ixRight = i;
						break;
					}
				}
				if (ixRight < 0) continue; // 

				// now do the interpolate
				register double aTime =
					head.tminArr[ixLeft] +
					(head.tminArr[ixRight] - head.tminArr[ixLeft]) *
					(float)(ix - ixLeft) / (float)(ixRight - ixLeft);
				sw.headRead.trArr[ix].setTraceDelayF(aTime);
				count++;
			}
		}

		int num = sw.writeDataAll(draw.timeSecName);
		tstr.Format(_T("Initial time of %d traces are updated out of a total of %d traces."), count, num);
		AfxMessageBox(tstr);
		//CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
		//pFrame->myCaption(tstr);
	} // if sw.open
}


void CSeisWideDoc::OnDigitizingSwitchdigitizingfile()
{
	OnDigitizingSavedig();
	CString tstr;
	draw.isNoPromptLabel = FALSE;
	if (dig.isDigitizing) {
		// switch to digitizing for marker
		dig.isDigitizing = FALSE;
		digMarker.isDigitizing = TRUE;
		tstr.Format(_T("Digitizing switched to the marker mode."));
		if (digMarker.totCurve == 0) {
			if (!digMarker.initDigitizeArray(100, 5)) return;
			OnDigitizingNewcurve();
		}
	}
	else if (digMarker.isDigitizing) {
			// switch to digitizing for marker
		digMarker.isDigitizing = FALSE;
		dig.isDigitizing = TRUE;
		tstr.Format(_T("Digitizing switched to line mode."));
		if (dig.totCurve == 0) {
			if (!dig.initDigitizeArray(100, 5)) return;
			OnDigitizingNewcurve();
		}
	}
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	pFrame->myCaption(tstr);
	UpdateAllViews(NULL);
}


//
//void CSeisWideDoc::myFileOpenproject(CString fSeiProject) {
//	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
//	CSeisWideApp* pSeiApp = (CSeisWideApp*)AfxGetApp();
//
//	CString fProjStr = getTextFromFileUnix(fSeiProject);
//	pFrame->parseProjectString(fProjStr);
//	for (int i = pSeiApp->statWin.winPosCount - 1; i >= 0; i--) {
//		register CString f = pSeiApp->statWin.winPosPathName[i];
//		myMakeSameDrive(f, fSeiProject);
//		if (!f.IsEmpty() && isFileExistNotDirectory(f)) {
//			pSeiApp->statWin.winPosCurrent = i; // tell ChildFrm.cpp the current index for PreCreateWindow()
//			pSeiApp->OpenDocumentFile(f);
//		}
//	}
////	pFrame->UpdateWindow();
//}

void CSeisWideDoc::OnFileOpenproject()
{
	CString fSeiProject;

	//new file dialog.
	CFileDialog dlg(TRUE, NULL, _T("*.seiProj"), OFN_EXPLORER, _T("Seiswide Project File name|*.seiProj"));
	//	dlg.m_ofn.lpstrTitle = _T("Each shot number in one line please";
	if (dlg.DoModal() == IDOK)
		fSeiProject = dlg.GetPathName();
	else
		return;

	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	pFrame->myFileOpenproject(fSeiProject);
}


void CSeisWideDoc::OnFileSaveproject()
{
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	CSeisWideApp* pSeiApp = (CSeisWideApp*)AfxGetApp();
	CString fSeiProject;

	//new file dialog.
	CFileDialog dlg(FALSE, _T("*.seiProj"), pSeiApp->statWin.winProjectName, OFN_EXPLORER | OFN_OVERWRITEPROMPT, _T("Seiswide Project File name|*.seiProj"));
	//	dlg.m_ofn.lpstrTitle = _T("Each shot number in one line please";
	if (dlg.DoModal() == IDOK)
		fSeiProject = dlg.GetPathName();
	else
		return;

	int count = 0;
	CString fProjStrContent = pFrame->getProjectString(count);
	int i = fProjStrContent.ReverseFind('.');
	if (i > -1) {
		fProjStrContent = fProjStrContent.Mid(0, i);
		i = fProjStrContent.ReverseFind(' ');
		fProjStrContent = fProjStrContent.Mid(0, i);
		fProjStrContent += _T(" ") + getFileNameOnly(fSeiProject);
	}



	if (count==0 || !saveStringToFile(fProjStrContent, fSeiProject))
		AfxMessageBox(_T("Sorry, failed to save the project file."));
	else {
		pSeiApp->statWin.winProjectName = fSeiProject;
		CString str;
		str.Format(_T("Project saved: %s"), fSeiProject);
		pFrame->myCaption(str);

		// update the project name in the title bar
		pFrame->SetTitle(getFileNameOnly(fSeiProject));
	}
}


void CSeisWideDoc::OnFileCloseproject()
{
	CDocTemplate* pDocTemplate = NULL;
	for (POSITION posTemplate = AfxGetApp()->GetFirstDocTemplatePosition(); posTemplate != NULL; )
	{
		pDocTemplate = AfxGetApp()->GetNextDocTemplate(posTemplate);

		POSITION posDoc;
		while (posDoc = pDocTemplate->GetFirstDocPosition())
		{
			CDocument* pDoc = pDocTemplate->GetNextDoc(posDoc);
			POSITION posView = pDoc->GetFirstViewPosition();
			CView* pView = pDoc->GetNextView(posView);
			pView->GetParentFrame()->DestroyWindow(); // a view may have several windows
		}
	}

	CSeisWideApp* pSeiApp = (CSeisWideApp*)AfxGetApp();
	pSeiApp->statWin.winProjectName = _T("Untitled.seiProj"); // this does not change the title unless refreshed
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	pFrame->SetTitle(_T("Untitled.seiProj"));
	// UpdateAllViews(NULL); // this caused exception when no MDI childs are found.
}


#include "dlgDepth2Time3.h"
void CSeisWideDoc::OnReflectionZt()
{
	// This routine converts segy data from depth to time.
	if (cd.coord.drawmode != 3) {
		AfxMessageBox(_T("This will convert segy from depth to time domains. Please show depth section and/or valid velocity models to continue."), MB_ICONQUESTION);
		return;
	}

	CString tStr;
	int j;
	draw.timeSecName = getFileNameAppend(draw.depthSecName, _T("_Time"));
	draw.timeSecName = SetFileExtension(draw.timeSecName, _T("sgy"));

	// these will be used using the same values on screen
	if (!isFileExistNotDirectory(velMod.velSecName) && draw.velSecNamesEx.IsEmpty()) {
		AfxMessageBox(_T("Input velocity model invalid."), MB_ICONQUESTION);
		return;
	}
	double dt = velColor.dz;

	CdlgDepth2Time3 dlg;
	dlg.m_dt = (float)dt;
	dlg.m_tmin = (float)cd.coord.m_tmin;
	dlg.m_tmax = (float)cd.coord.m_tmax;
	if (dlg.DoModal() == IDOK) {
		cd.coord.m_tmin = dlg.m_tmin;
		cd.coord.m_tmax = dlg.m_tmax;
		dt = dlg.m_dt;
	}
	else
		return;
		
	
	// make sure the user does not mess up
	if (dt < 0.000001) return;
	if (cd.coord.m_tmax - cd.coord.m_tmin < 0.00001) return;

	//setCurrentPathAs(getWorkingPathSlash());
	segy tr;
	bhed bh;
	CFile filezIn;
	if (!filezIn.Open(draw.depthSecName, CFile::modeRead | CFile::typeBinary)) {
		AfxMessageBox(_T("Input depth section cannot be read."), MB_ICONQUESTION);
		return;
	}
	CFile filet;
	if (!filet.Open(draw.timeSecName, CFile::modeCreate | CFile::modeReadWrite | CFile::typeBinary)) {
		filet.Close();
		AfxMessageBox(_T("Output time section cannot be created."), MB_ICONQUESTION);
		return;
	}

	// start reading segy
	filezIn.Seek(0, CFile::begin);
	UINT bytesRead = filezIn.Read(head.ascHead, 3200L);
	if (bytesRead < 3200)
		AfxMessageBox(_T("Ascii section header read wrong"), MB_ICONQUESTION);
	filezIn.Read(&bh, 400L);
	if (bytesRead < 400)
		AfxMessageBox(_T("Binary section header read wrong"), MB_ICONQUESTION);

	BOOL isUnixInFile = IsUnix(bh.format);
	if (isUnixInFile) SwapTapeHeader(&bh);
	int numsamp = bh.hns;
	int sampByte = (bh.format != 3) ? 4 : 2;
	short dformat_in = bh.format;
	int len = sampByte * numsamp + 240;
	if (bh.hdt == 0) bh.hdt = bh.dto;
	double oneodz = (double)MIL / (double)bh.hdt;
	double dz = 1. / oneodz;

	// calc the output limit in time [m_tmin, m_tmax], and then [ntmin, ntmax]
	filezIn.Read(&tr, 240);
	if (isUnixInFile) SwapTraceHeader(false, false, false, &tr);
	cd.coord.m_zmin = tr.getTraceDelay();
	cd.coord.m_zmax = cd.coord.m_zmin + (numsamp - 1) * dz;

	long ntmin = (long)floor(cd.coord.m_tmin / dt);
	long ntmax = (long)ceil(cd.coord.m_tmax / dt) + 1;
	// need to verify if ntmax is not greater than max(unsigned short) !!!

	//For progress control, need to know the last bytes no.
	LONGLONG curBytesRead, totBytesRead = filezIn.GetLength();
	filezIn.Seek(3600, CFile::begin);

	//Only after opening successfully, we begin progress control.
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	pFrame->BeginProgress();
	filet.Write(head.ascHead, 3200L);

	bh.hns = (WORD)(ntmax - ntmin + 1); // numsamp for output;
	bh.nso = bh.hns;
	bh.format = 1;
	bh.hdt = (unsigned short)(dt*MIL);	//Sampling rate;
	bh.dto = bh.hdt;
	filet.Write(&bh, 400L);

	//Prepare to formulate velocity traces.
	WORD totShot = 0;
	float *rData, *vTrc, *zTrc, *zTrc2;
	rData = (float*)ealloc1(numsamp, sizeof(float));
	vTrc = (float*)ealloc1(ntmax + 1, sizeof(float));
	zTrc = (float*)ealloc1(ntmax + 1, sizeof(float));
	zTrc2 = (float*)ealloc1(ntmax + 1, sizeof(float));
	if (ERROR == rData
		|| ERROR == vTrc
		|| ERROR == zTrc
		|| ERROR == zTrc2
		) {
		free1float(rData);
		free1float(vTrc);
		free1float(zTrc);
		free1float(zTrc2);
		return;
	}

	CVelMod vm;
	if (velMod.isVelModValid()) {
		vm.myModel_Depth2TWTT(&velMod, dz);
	}

	CVelMod::VELMODS velms;
	vm.loadInitVel(&velms, draw.velSecNamesEx, dt);

	CVelMod::VELMOD_X modX, modX2;
	double range;

	setCurrentPathAs(getWorkingPathSlash()); // note: draw.velSecNamesEx frequently uses relative folder names, so we need to set the working folder as current!!!
	while (filezIn.Read(&tr, len) == (UINT)len) {
		if (isUnixInFile) SwapTraceHeader(false, false, false, &tr);

		//Formulating velocity traces first.
		curBytesRead = filezIn.Seek(0, CFile::current);
		int iPos = (int)((double)curBytesRead / (double)totBytesRead*100.);
		if (iPos < 0)iPos = 0;
		if (iPos > 100)iPos = 100;
		if (pFrame) pFrame->SetProgress(iPos);

		if (tr.trid == 2) { //dead traces.
			continue;
		}

		range = tr.getDistance();  //range here is actually distance.
		if (range > cd.coord.xmax || range < cd.coord.xmin) continue;

		// compute vTrc[it], where it=[0, ntmax]
		modX.dist = range;
		if (!vm.initModX(&velMod, &velms, &modX, &modX2, range, false, true, dt)) continue;

		if (modX.ncont > 0 && modX2.ncont == 0) {
			// if here, only modX is needed for Z-T conversion
			//vm.getTzFromZMod(&modX, ntmax + 1, 0., velColor.dz, zTrc);
			vm.getZtFromTMod(&modX, ntmax + 1, dt, zTrc);
		}
		else if (isFloatEqual((float)modX.dist, (float)modX2.dist, 0.00001f)) {
			// the 2 modX are the same
			//vm.getTzFromZMod(&modX, nzmax + 1, 0., velColor.dz, tTrc);
			vm.getZtFromTMod(&modX, ntmax + 1, dt, zTrc); // zTrc[] starts from the surface.
		}
		else if (modX.ncont > 0 && modX2.ncont > 0) {
			// if here, both modX and modX2 are needed for Z-T conversion
			//vm.getTzFromZMod(&modX, nzmax + 1, 0., velColor.dz, tTrc);
			vm.getZtFromTMod(&modX, ntmax + 1, dt, zTrc);

			//vm.getTzFromZMod(&modX2, nzmax + 1, 0., velColor.dz, tTrc2);
			vm.getZtFromTMod(&modX2, ntmax + 1, dt, zTrc2);

			register float tFac = (float)((range - modX.dist) / (modX2.dist - modX.dist));
			for (j = 0; j < ntmax + 1; j++)
				zTrc[j] = interpolLinear(zTrc[j], zTrc2[j], tFac);
		}
		else if (modX.ncont == 0 && modX2.ncont > 0)
			// if here, only modX2 is needed for T-Z conversion
			//vm.getTzFromZMod(&modX2, nzmax + 1, 0., velColor.dz, tTrc);
			vm.getZtFromTMod(&modX2, ntmax + 1, dt, zTrc2);
		else {
			continue;
		}


		// reading data from input in depth domain
		if (dformat_in == 3)
			for (j = 0; j < numsamp; j++) rData[j] = (float)tr.dat.datashort[j];
		else if (dformat_in == 1) {
			// if (tr.idistopt==8 || pFrame->gIsIBMFloatSegy)
		//	ibm_to_float((int *)tr.dat.data, (int *)tr.dat.data, (int)numsamp);
			for (j = 0; j < numsamp; j++) {
				rData[j] = tr.dat.data[j];
			}
		} // if
		else if (dformat_in == 2)
			for (j = 0; j < numsamp; j++) rData[j] = (float)tr.dat.dataint[j];
		else if (dformat_in == 5) {
			for (j = 0; j < numsamp; j++) {
				rData[j] = tr.dat.data[j];
			}
		} // if
		else continue;

		//Construct trace in time domain. To save memory, overwrite vTrc[] array.
		float aDelay = tr.getTraceDelay();
		ints8r((int)numsamp, (float)dz,
			aDelay,
			rData, 0.f, 0.f, 
			(int)(ntmax -ntmin + 1), (float *)&zTrc[ntmin], (float *)&vTrc[ntmin]);

		//if (range > 75.) {
		//	int dsfds = 1;
		//	static bool isShow = false;
		//	if (!isShow) {
		//		isShow = true;
		//		showArrayInFile(rData, numsamp, _T("rData[]"), dz);
		//		showArrayInFile(zTrc, ntmax + 1, _T("zTrc[]"), dt);
		//		showArrayInFile(vTrc, ntmax + 1, _T("vTrc[]"), dt);
		//	}
		//}
		memcpy((void *)tr.dat.data, (void *)&vTrc[ntmin], (ntmax - ntmin + 1) * sizeof(float));
		tr.setTraceDelayF(cd.coord.m_tmin);
		tr.setDistance((float)range);
		tr.ns = (unsigned short)(ntmax - ntmin + 1);
		tr.dt = (unsigned short)(dt*MIL);

		if (bh.format == 1) {
			float_to_ibm((int *)tr.dat.data, (int *)tr.dat.data, (int)tr.ns);
		}

		filet.Write(&tr, (long)(240 + tr.ns * 4));
		totShot++;
	}

	if (totShot > 0) {
		CSegyMeta::setSegyTotalTrace(&filet, totShot);
	}

	filezIn.Close();
	filet.Close();

	if (pFrame) pFrame->EndProgress();

	//Free up space
	free1float(rData);
	free1float(vTrc);
	free1float(zTrc);
	free1float(zTrc2);

	//Auto change mode to display both.
	cd.coord.isDistanceDisplay = TRUE;  // set display using distance instead of offset, this avoids problems in  amplitude prepararing and calculation in display
	cd.coord.drawmodeOld = cd.coord.drawmode;
	cd.coord.drawmode = 9;	//Both velocity color and depth sections will be drawn.
	tx.rayCodeShow = -1; // this make sure all TX curves are shown, otherwise it is hard to show all when I am showing only one curve
	this->clearGDC(draw.gDCs.gDC); // after the new segy depth file generated, we need to clear gDC otherwise it's clustered with old data
	draw.isSameDataDisplay = FALSE; //indicate display has been changed and will re-load all data in OnDraw().

	SetModifiedFlag();
	UpdateAllViews(NULL);
	NotifyChanged();


}




void CSeisWideDoc::OnDigitizingSavehalfuncertainty()
{
	// TODO: Add your command handler code here
	if (AfxMessageBox(_T("This will half all uncertainty values for Zelt format, and save to file. The original file will be backed up. Continue?"), MB_YESNO | MB_ICONQUESTION | MB_ICONQUESTION) != IDYES) {
		return;
	}

	if (dig.totCurve > 0 && dig.isDigitizing && dig.isZeltFormat) {
		if (!CopyFile(dig.digName, dig.digName + _T(".bak"), FALSE)) {
			AfxMessageBox(_T("Sorry, copy failed."), MB_ICONQUESTION);
			return;
		}

		for (int i = 0; i < dig.totCurve; i++) {
			dig.curveVal[i] *= 0.5f;
		}

		OnDigitizingShowfile(); // this will save first, and then show
	}
}


BOOL CSeisWideDoc::DrawDenMod(CDC* pDC, DENMOD* pden, int iFocus)
{
	if (cd.coord.drawmode != 8) return FALSE;
	if (pden->ncont < 1) return FALSE;
	short icont;
	CPoint plt[299];
	CPoint p1;
	SEI_PAIR xz[299];
	CString aStr;
	COLORREF oldColorText;
	pDC->SetBkColor(WHITE);
	oldColorText = pDC->SetTextColor(BLUE);

	int nLimit = pden->MAX_POINTS * 2;
	double* xtmp = alloc1double(nLimit);
	double* ztmp = alloc1double(nLimit);
	for (icont = 0; icont < pden->ncont; icont++) {
		//if (icont < 49) continue;
		//if (icont > 50) break; // testing
		int n = pden->nzed[icont];
		for (int i = 0; i < n; i++) {
			xtmp[i] = pden->xm[icont][i];
			ztmp[i] = pden->zm[icont][i];
		}
		n = myClipPoints2(n, nLimit, xtmp, ztmp, cd.coord.X12Y12());
		if (n > 2) {
			for (int i = 0; i < n; i++) {
				plt[i] = cd.coord.mm_coord(xtmp[i], ztmp[i]);
			}
			pDC->Polyline(plt, n);
		}

		if (n > 2 && !draw.isNoLabelInSide) {
			// labels for density
			// 			if (!isFloatEqual(xpos, (double)ERRORVAL)) break;
			for (int i = 0; i < n; i++) {
				xz[i].set((double)xtmp[i], (double)ztmp[i]);
			}
			SEI_PAIR centr = compute2DPolygonCentroid(xz, n);
			p1 = cd.coord.mm_coord(centr.x, centr.y);
			aStr.Format(_T("%1.2f"), myFloat(pden->dm[icont], 2));
			CSize textSize = pDC->GetTextExtent(aStr);
			if (icont == iFocus) {
				oldColorText = pDC->SetTextColor(RED);
			}
			else {
				oldColorText = pDC->SetTextColor(BLUE);
			}
			pDC->TextOut(p1.x - textSize.cx / 2, p1.y - textSize.cy / 2, aStr);
		} // if

	}  //End of loop icont.

	free1double(xtmp);
	free1double(ztmp);
	return(TRUE);
}


