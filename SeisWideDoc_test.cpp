

// SeisWideDoc.cpp : implementation of the CSeisWideDoc class
//

#include "stdafx.h"
#include "SeisWide.h"
#include "cstringex.h"
#include "MainFrm.h"

#include "SeisWideDoc.h"
#include "CntrItem.h"
#include "SrvrItem.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#include "math.h"
#include "float.h"
#include "dlgVELOCITY1.h"
#include "dlgDEPTH1.h"
#include "dlgTIMESEC1.h"
#include "dlgTimeByTrc.h"
#include "dlgAddRange.h"
#include "dlgChangeRanges.h"
#include "BoundNodes.h"
#include "dlgLayerNodes.h"
#include "dlgNewVelFile.h"
#include "dlgdigitize.h"
#include "dlgDigResolution.h"
#include "dlgNewLayer.h"
#include "dlgReorganize.h"
#include "dlgCohMix.h"
#include "dlgFilter1.h"
#include "dlgFilterOffset.h"
#include "DlgNewModel.h"
#include "dlgRaytrace1.h"
#include "dlgLoadZelt.h"
#include "dlgLoadReid.h"
#include "dlgLatShift.h"
#include "dlgSegyInfo.h"
#include "dlgTim2Dpth.h"
#include "dlgWide2Depth.h"
#include "dlgSourcePos.h"
#include "dlgModelResize.h"
#include "dlgFillArea.h"
#include "dlgSegyColor.h"
#include "dlgSegyAppend.h"
#include "dlgVred.h"
#include "dlgSegyPreview.h"
#include "dlgMergeModels.h"
#include "dlgMigPS.h"
#include "dlgVZCurve.h"
#include "dlgTTCurve.h"
#include "dlgInOut.h"
#include "dlgChangeReducingBMP.h"

#include "preKDMig.c"
#include "preRayTraceLiu.c"

#include "sumig.h"

#include "dlgHydrateDisp.h"
#include "dlgSonobouy.h"
#include "dlgTablizeLayer.h"
#include "dlgLatLong.h"
#include "dlgConvertRawSgy.h"
#include "dlgLineDrawTim.h"
#include "dlgLineDrawDep.h"
#include "dlgVel2Den.h"
#include "dlgVel2Den1.h"
#include "dlgMigLineDraw.h"
#include "dlgDigitizeShift.h"
#include "dlgInitAmp.h"
#include "dlgImportbitmap.h"
#include "dlgTimDepthBMP.h"
#include "dlgDispBitmap.h"
#include "bmp24.h"
#include "util.h"
#include "string.h"
#include "dlgUnix2PC.h"
#include "dlgResample.h"
#include "dlgWienerFilter.h"
#include "dlgDigResize.h"
#include "dlgDigSelectCurrent.h"
#include "dlgModelShiftBoundary.h"
#include "dlgLabelSizes.h"
#include "dlgInputValie.h"
#include "dlgVelocityTwtt2.h"
#include "dlgWide2Velocity.h"
#include "dlgLabelOverwrite.h"
#include "CShellFileOp.h"
#include "dlgSineModulate.h"
#include "dlgDespiking.h"
#include "dlgDesimate.h"
#include "dlgAttenuationCorr.h"
#include "dlgAddData.h"
#include "SegyWrapper.h"
#include "SegyWrapperEx.h"
#include "segyMeta.h"

#include "dlgRmsVelocityAnalysis.h"
#include "dlgAgc.h"
#include "seiContour.h"
#include "dlgDigOption.h"
#include "dlgSonobuoyPoly.h"
#include "dlgSonobuoyAutoOffset.h"
#include "dlgTraceDub.h"
#include "dlgGainAdjust.h"
#include "dlgSegyColor2.h"
#include "dlgTraceBalanceXT.h"
#include "dlgDistanceAdjust.h"
#include "dlgRegionalModel.h"
//using namespace Utility;
#include "dlgVelocityPerturb.h"
#include "dlgPrint.h"

#include "IniWriter.h"
#include "IniReader.h"
//#include "StringExScanf.h"

// depreciated below
#include "dlgKdmig.h"

// std:: exception library is not compatible with VC++ debugging lib
// #include <stdexcept>

//#include "compare.h"
//using namespace metasharp;

//#define MIL 1000000.
//#define MINAMP 0.000000001
//#define velMod.depth velMod.depth
//#define VTOP velMod.vTop
//#define VBOT velMod.vBot

static BOOL digIsUpdatePartial = FALSE; // I move this static variable outside of function because I want to update it from another function.

/////////////////////////////////////////////////////////////////////////////
// CSeisWideDoc

IMPLEMENT_DYNCREATE(CSeisWideDoc, COleServerDoc)

	BEGIN_MESSAGE_MAP(CSeisWideDoc, COleServerDoc)
		//{{AFX_MSG_MAP(CSeisWideDoc)
		ON_COMMAND(ID_VIEW_BOTH, OnViewBoth)
		ON_COMMAND(ID_VIEW_CONTOURS, OnViewContours)
		ON_COMMAND(ID_VIEW_TIMESECTION, OnViewTimesection)
		ON_COMMAND(ID_VIEW_VELOCITYCOLORMAP, OnViewVelocitycolormap)
		ON_COMMAND(ID_VIEW_DEPTHSECTION, OnViewDepthsection)
		ON_COMMAND(ID_VIEW_ADDRANGETOSEGY, OnProcessingAddrangetosegy)
		ON_COMMAND(ID_EDIT_BOUNDARY, OnEditBoundary)
		ON_COMMAND(ID_EDIT_VELOCITY, OnEditVelocity)
		ON_COMMAND(ID_EDIT_NONODES, OnEditNonodes)
		ON_COMMAND(ID_TOOBAR_MOVE, OnToobarMove)
		ON_COMMAND(ID_TOOLBAR__REMOVE, OnToolbarRemove)
		ON_COMMAND(ID_TOOLBAR_PICK, OnToolbarPick)
		ON_COMMAND(ID_TOOLBAR_ADD, OnToolbarAdd)
		ON_COMMAND(ID_TOOLBAR_DELLINE, OnToolbarDelLine)
		//ON_COMMAND(ID_TOOLBAR_NEWLINE, OnToolbarNewLine)
		ON_COMMAND(ID_EDIT_COPY, OnEditCopy)
		ON_COMMAND(ID_TOOLBAR_SAVEV, OnToolbarSavev)
		ON_COMMAND(ID_TOOLBAR_SAVEASV, OnToolbarSaveasv)
		ON_COMMAND(ID_EDIT_DIGITIZE, OnDigitizingStart)
		ON_COMMAND(ID_EDIT_SAVEDIG, OnDigitizingSavedig)
		ON_COMMAND(ID_EDIT_NEWCURVE, OnDigitizingNewcurve)
		ON_COMMAND(ID_DIGITIZE_FINISHDIGITIZING, OnDigitizeFinishdigitizing)
		ON_COMMAND(ID_PROCESSING_TRACEREORDER, OnProcessingTracereorder)
		ON_COMMAND(ID_PROCESSING_COHMIX, OnProcessingCohmix)
		ON_COMMAND(ID_TOOLBAR_NEWMOD, OnToolbarNewmod)
		ON_COMMAND(ID_PROCESSING_REVERSERANGE, OnProcessingReverserange)
		ON_COMMAND(ID_PROCESSING_LOADZELTSMODEL, OnProcessingLoadzeltsmodel)
		ON_COMMAND(ID_PROCESSING_DATAREDUCTIONANDFILTER, OnProcessingDatareductionandfilter)
		ON_COMMAND(ID_PROCESSING_LATERALSHIFT, OnProcessingLateralshift)
		ON_COMMAND(ID_PROCESSING_RAYTRACE, OnModelingRaytrace)
		ON_COMMAND(ID_PROCESSING_RAYPATH, OnModelingRaypath)
		ON_COMMAND(ID_VIEW_SEGYINFO, OnViewSegyinfo)
		ON_COMMAND(ID_PROCESSING_DEFINESOURCEPOSITION, OnProcessingDefinesourceposition)
		ON_COMMAND(ID_EDIT_NOLABLES, OnEditNolables)
		ON_COMMAND(ID_EDIT_TUNEUP_NOBOUNDARY, OnEditTuneupNoboundary)
		ON_COMMAND(ID_EDIT_TUNEUP_NOCOLORMAP, OnEditTuneupNocolormap)
		ON_COMMAND(ID_EDIT_TUNEUP_OBSPOSITIONS, OnEditTuneupObspositions)
		ON_COMMAND(ID_TOOLBAR_DUPLICATE, OnToolbarDuplicate)
		ON_COMMAND(ID_PROCESSING_CHECKMODELINTEGRITY, OnProcessingCheckmodelintegrity)
		ON_COMMAND(ID_TOOLBAR_RESIZEMOD, OnToolbarResizemod)
		ON_COMMAND(ID_EDIT_DISPLAYTUNEUP_FILLAREAONCE, OnEditDisplaytuneupFillareaonce)
		ON_COMMAND(ID_DIGITIZE_UNDOPOINT, OnDigitizeUndopoint)
		ON_COMMAND(ID_PROCESSING_APPENDASEGYFILE, OnProcessingAppendasegyfile)
		ON_COMMAND(ID_PROCESSING_REDUCEMANUAL, OnProcessingReducemanual)
		ON_COMMAND(ID_VIEW_SEGYPREVIEW, OnViewSegypreview)
		ON_COMMAND(ID_MODELING_EXTRACTVZCURVE, OnModelingExtractvzcurve)
		ON_COMMAND(ID_PROCESSING_KDMIGPOST, OnProcessingKdmigpost)
		ON_COMMAND(ID_VIEW_TIMESECTRC, OnViewTimesectrc)
		ON_COMMAND(ID_PROCESSING_KDMIGSIMPLE, OnProcessingKdmigsimple)
		ON_COMMAND(ID_MENU_VIEW_HYDRO, OnViewHydro)
		ON_COMMAND(ID_PROCESSING_SB_KM, OnSonobuoyLinearKm)
		ON_COMMAND(ID_MODELING_EXTRACTLAYERINFOR, OnModelingExtractlayerinfor)
		ON_COMMAND(ID_TOOLBAR_REFRESH, OnToolbarRefresh)
		ON_COMMAND(ID_MODELING_LOADREIDSMODEL, OnModelingLoadreidsmodel)
		ON_COMMAND(ID_PROCESSING_LATLONGTODISTANCE, OnProcessingLatlongtodistance)
		ON_COMMAND(ID_EDIT_DISPLAYTUNEUP_BIGMODELNODES, OnEditDisplaytuneupBigmodelnodes)
		ON_COMMAND(ID_EDIT_DISPLAYTUNEUP_CHANGCOLORTTCURVES, OnEditDisplaytuneupChangcolorttcurves)
		ON_COMMAND(ID_PROCESSING_UNIX2PCBATCH, OnProcessingUnix2pcbatch)
		ON_COMMAND(ID_PROCESSING_PC2UNIXBATCH, OnProcessingPc2unixbatch)
		ON_COMMAND(ID_PROCESSING_RAWTOSEGY, OnProcessingRawtosegy)
		ON_COMMAND(ID_VIEW_TRACEANALYSIS, OnViewTraceanalysis)
		ON_COMMAND(ID_DIGITIZING_LOADEXISTING, OnDigitizingLoadexisting)
		ON_COMMAND(ID_EDIT_DISPLAYTUNEUP_EXTERNAL_DRAWINGS, OnEditDisplaytuneupExternalDrawings)
		ON_COMMAND(ID_PROCESSING_TIMEDEPTH_DRAWINGS, OnProcessingTimeDepthDrawings)
		ON_COMMAND(ID_PROCESSING_DUMPCDPDISTANCE, OnProcessingDumpdistance)
		ON_COMMAND(ID_MODELING_DENBLOCKS, OnModelingDenblocks)
		ON_COMMAND(ID_DIGITIZING_MIGRATELINEDRAWINGS, OnDigitizingMigratelinedrawings)
		ON_COMMAND(ID_DIGITIZING_CHANGECURVERES, OnDigitizingChangecurveres)
		ON_COMMAND(ID_DIGITIZING_LOADZELT_TX, OnDigitizingLoadzeltTx)
		ON_COMMAND(ID_DIGITIZING_WHEREANI, OnDigitizingWhereani)
		ON_COMMAND(ID_DIGITIZING_SHIFTDIGITING, OnDigitizingShiftdigiting)
		ON_COMMAND(ID_DIGITIZING_CHANGEERRORBAR_ASBAR, OnDigitizingChangeerrorbarAsBar)
		ON_COMMAND(ID_DIGITIZING_CHANGEERRORBAR_ASCIRCLE, OnDigitizingChangeerrorbarAscircle)
		ON_COMMAND(ID_DIGITIZING_CHANGEERRORBAR_ASSTAR, OnDigitizingChangeerrorbarAsstar)
		ON_COMMAND(ID_DIGITIZING_CHANGEERRORBAR_ASFILLCIRCLE, OnDigitizingChangeerrorbarAsfillcircle)
		ON_COMMAND(ID_EDIT_DISPLAYTUNEUP_REMOVEOUTSIDERAYPOINTS, OnEditDisplaytuneupRemoveoutsideraypoints)
		//	ON_COMMAND(ID_EDIT_DISPLAYTUNEUP_SKIPCOMPLAININGTRACETOODENSE, OnEditDisplaytuneupSkipcomplainingtracetoodense)
		ON_COMMAND(ID_TOOLBAR_FLIPMOD, OnToolbarFlipmod)
		ON_COMMAND(ID_MODELING_SUBSIDENCEBEFORESEDIMENTLOADING, OnModelingSubsidence)
		ON_COMMAND(ID_FILE_IMPORTBITMAP, OnFileImportbitmap)
		ON_COMMAND(ID_FILE_RESIZEBITMAP, OnFileResizebitmap)
		ON_COMMAND(ID_PROCESSING_TDCONVBMP, OnProcessingTdconvbmp)
		ON_COMMAND(ID_EDIT_PASTE, OnEditPaste)
		ON_COMMAND(ID_PROCESSING_DATARESAMPLE, OnProcessingDataresample)
		ON_COMMAND(ID_TOOLBAR_REFRESH_ALL, OnToolbarRefreshAll)
		ON_COMMAND(ID_EDIT_DISPLAYTUNEUP_REMOVETTOVERLAY, OnEditDisplaytuneupRemovettoverlay)
		ON_COMMAND(ID_PROCESSING_DEBIAS, OnProcessingDebias)
		ON_COMMAND(ID_PROCESSING_WIENER, OnProcessingWiener)
		ON_COMMAND(ID_DIGITIZING_RESIZE_SEGMENTS, OnDigitizingResizeSegments)
		ON_COMMAND(ID_MODEL_SHIFTXZ, OnModelShiftxz)
		ON_COMMAND(ID_DIGITIZING_SELECT_CURRENT, OnDigitizingSelectCurrent)
		ON_COMMAND(ID_DIGITIZING_CHANGEERRORBAR_REDEFINESOURCE, OnDigitizingChangeerrorbarRedefinesource)
		ON_COMMAND(ID_DIGITIZING_ZELTSFORMAT_TOGGLEZPLOT, OnDigitizingZeltsformatTogglezplot)
		ON_COMMAND(ID_EDIT_UNDO, OnEditUndo)
		ON_COMMAND(ID_PROCESSING_CHANGEREDUCEVELOCITYFORBMP, OnProcessingChangereducevelocityforbmp)
		ON_COMMAND(ID_MODELING_MOVEBOUNDARY, OnModelingMoveboundary)
		ON_COMMAND(ID_PROCESSING_CHOPDATA, OnProcessingChopdata)
		ON_COMMAND(ID_VIEW_STACKINGVELOCITYMAP, OnViewStackingvelocitymap)
		ON_COMMAND(ID_TOOLBAR_BIGGER, OnToolbarBiggerAmp)
		ON_COMMAND(ID_TOOLBAR_LESS, OnToolbarLessAmp)
		ON_COMMAND(ID_PROCESSING_APPENDMANYSEGYFILES, OnProcessingAppendmanysegyfiles)
		ON_COMMAND(ID_EDIT_DISPLAYTUNEUP_ADJUSTINGLABELSIZES, OnEditDisplaytuneupAdjustinglabelsizes)
		ON_COMMAND(ID_DIGITIZING_SPLIT, OnDigitizingSplit)
		ON_COMMAND(ID_DIGITIZING_REVISELINELABEL, OnDigitizingReviselinelabel)
		ON_COMMAND(ID_EDIT_DISPLAYTUNEUP_MODELPROPERTIES_LINEDRAWINGLABEL, OnEditDisplaytuneupModelpropertiesLinedrawinglabel)
		//}}AFX_MSG_MAP
		// Enable default OLE container implementation
		ON_UPDATE_COMMAND_UI(ID_EDIT_PASTE, COleServerDoc::OnUpdatePasteMenu)
		ON_UPDATE_COMMAND_UI(ID_EDIT_PASTE_LINK, COleServerDoc::OnUpdatePasteLinkMenu)
		ON_UPDATE_COMMAND_UI(ID_OLE_EDIT_CONVERT, COleServerDoc::OnUpdateObjectVerbMenu)
		ON_COMMAND(ID_OLE_EDIT_CONVERT, COleServerDoc::OnEditConvert)
		ON_UPDATE_COMMAND_UI(ID_OLE_EDIT_LINKS, COleServerDoc::OnUpdateEditLinksMenu)
		ON_COMMAND(ID_OLE_EDIT_LINKS, COleServerDoc::OnEditLinks)
		ON_UPDATE_COMMAND_UI(ID_OLE_VERB_FIRST, COleServerDoc::OnUpdateObjectVerbMenu)
		ON_COMMAND(ID_DIGITIZING_RAYCODES, &CSeisWideDoc::OnDigitizingRaycodes)
		ON_COMMAND(ID_DIGITIZING_SAVEDIGFFID, &CSeisWideDoc::OnDigitizingSavedigffid)
		ON_COMMAND(ID_TIME_FORWIDE, &CSeisWideDoc::OnTimeForwide)
		ON_COMMAND(ID_VIEW_VELOCITYCOLORTWTT, &CSeisWideDoc::OnViewVelocitycolortwtt)
		//ON_COMMAND(ID_TIME_FORWIDE_SEMB, &CSeisWideDoc::OnTimeForwideSemb)
		ON_COMMAND(ID_TIME_FORWIDE_NMOVELOCITY, &CSeisWideDoc::OnTimeForwideNmovelocity)
		ON_COMMAND(ID_VIEW_NMO_VELOCITY, &CSeisWideDoc::OnViewNmoVelocity)
		ON_COMMAND(ID_MODELING_MERGEMODEL, &CSeisWideDoc::OnModelingMergemodel)
		ON_COMMAND(ID_MODELING_GENERATESYNTHETICSEGYDATA, &CSeisWideDoc::OnModelingGeneratesyntheticsegydata)
		ON_COMMAND(ID_MODELING_DOSCONSOL, &CSeisWideDoc::OnModelingDosconsol)
		ON_COMMAND(ID_TIME_TIMESECTIONWITHPERTURBEDTRAVEL, &CSeisWideDoc::OnTimeTimesectionwithperturbedtravel)
		ON_COMMAND(ID_DISPLAYTUNE_OVERWRITEXLABEL, &CSeisWideDoc::OnDisplaytuneOverwritexlabel)
		ON_COMMAND(ID_PROCESSING_TIMEDEPTH_CONV, &CSeisWideDoc::OnProcessingTimedepthConv)
		ON_COMMAND(ID_MODELING_DISPLAYCIRCLE, &CSeisWideDoc::OnModelingDisplaycircle)
		ON_COMMAND(ID_MODELING_ADDSINESHAPE, &CSeisWideDoc::OnModelingAddsineshape)
		ON_COMMAND(ID_PROCESSING_DATADESPIKE, &CSeisWideDoc::OnProcessingDatadespike)
		ON_COMMAND(ID_ACCELERATOR_FONTSIZE, &CSeisWideDoc::OnAcceleratorFontsize)
		ON_COMMAND(ID_ACCELERATOR_FONTMINUS, &CSeisWideDoc::OnAcceleratorFontminus)
		ON_COMMAND(ID_MODELING_DUMPCMP_TWTT, &CSeisWideDoc::OnModelingDumpcmpTwtt)
		ON_COMMAND(ID_PROCESSING_DUMPSEGYLATLONG, &CSeisWideDoc::OnProcessingDumpsegylatlong)
		ON_COMMAND(ID_PROCESSING_DECIMATEDATALINES, &CSeisWideDoc::OnProcessingDecimatedatalines)
		ON_COMMAND(ID_DIGITIZING_ZELT_SWAPSOURCE, &CSeisWideDoc::OnDigitizingZeltSwapsource)
		ON_COMMAND(ID_SEGYCONVERSION_UNIXTOPCCONVERT, &CSeisWideDoc::OnSegyconversionUnixtopcconvert)
		ON_COMMAND(ID_MODELUP, &CSeisWideDoc::OnModelup)
		ON_COMMAND(ID_MODELDOWN, &CSeisWideDoc::OnModeldown)
		ON_COMMAND(ID_EDIT_REDO, &CSeisWideDoc::OnEditRedo)
		ON_COMMAND(ID_MODELING_TOGGLEPEGLET, &CSeisWideDoc::OnModelingTogglepeglet)
		ON_COMMAND(ID_EDIT_TEXT, &CSeisWideDoc::OnEditText)
		ON_COMMAND(ID_MODELING_TOGGLESWAVELABELS, &CSeisWideDoc::OnModelingToggleswavelabels)
		ON_COMMAND(ID_PROCESSING_DATASPLIT, &CSeisWideDoc::OnProcessingDatasplit)
		ON_COMMAND(ID_PROCESSING_ID_PROCESSING_TRACEDUB, &CSeisWideDoc::OnProcessingIdProcessingTracedub)
		ON_COMMAND(ID_TOOLS_MAPCONVERTTIME, &CSeisWideDoc::OnToolsMapconverttime)
		ON_COMMAND(ID_PROCESSING_SPHERICALCORRECTION, &CSeisWideDoc::OnProcessingSphericalcorrection)
		ON_COMMAND(ID_PROCESSING_CHOPDATA, &CSeisWideDoc::OnProcessingChopdata)
		ON_COMMAND(ID_PROCESSING_ADDDATA, &CSeisWideDoc::OnProcessingAdddata)
		ON_COMMAND(ID_TIME_RMSVELOCITYANALYSIS, &CSeisWideDoc::OnTimeRmsvelocityanalysis)
		ON_COMMAND(ID_Menu_TRACEBALANCING, &CSeisWideDoc::OnMenuProcessingTrcBalancing)
		ON_COMMAND(ID_MODELCONVERSION_RMS_INT_DEPTH, &CSeisWideDoc::OnModelconversionRmsToIntNotUsingModel)
		ON_COMMAND(ID_MODELCONVERSION_RMS_INT_MODELKM, &CSeisWideDoc::OnModelconversionRmsToIntUsingModel)
		ON_COMMAND(ID_MODELCONVERSION_RMS_INT_TWTT, &CSeisWideDoc::OnModelconversionRmsToIntTwtt)
		ON_COMMAND(ID_MODELCONVERSION_TORMSVELOCITY, &CSeisWideDoc::OnModelconversionIntToRmsvelocity)
		ON_COMMAND(ID_MODELCONVERSION_TORMSVELOCITY2, &CSeisWideDoc::OnModelconversionTormsvelocity2)
		ON_COMMAND(ID_SONOBUOY_AUTOCALCULATEOFFSETFROMLAT, &CSeisWideDoc::OnSonobuoyAutocalculateoffsetfromlat)
		ON_COMMAND(ID_SONOBUOY_POLY, &CSeisWideDoc::OnSonobuoyPoly)
		ON_COMMAND(ID_SEGYCONVERSION_IEEETOIBMFLOAT, &CSeisWideDoc::OnSegyconversionIeeetoibmfloat)
		ON_COMMAND(ID_PROCESSING_DATANORMALIZE, &CSeisWideDoc::OnProcessingDatanormalize)
		ON_COMMAND(ID_PROCESSING_FILTER_OFFSETVARYING, &CSeisWideDoc::OnProcessingFilterOffsetvarying)
		ON_COMMAND(ID_SONOBUOY_ASSIGNOFFSETFROMSEGY, &CSeisWideDoc::OnSonobuoyAssignoffsetfromsegy)
		ON_COMMAND(ID_FILE_SAVEASDEFAULTS, &CSeisWideDoc::OnFileSaveasdefaults)
		ON_COMMAND(ID_PROCESSING_GAINADJUST, &CSeisWideDoc::OnProcessingGainadjust)
		ON_COMMAND(ID_PROCESSING_TRACESUBTRACTALONGCURVE, &CSeisWideDoc::OnProcessingTracesubtractalongcurve)
		ON_COMMAND(ID_PROCESSING_SPLITODDEVENTRACES, &CSeisWideDoc::OnProcessingSplitoddeventraces)
		ON_COMMAND(ID_REFLECTION_FAULTENHANCING, &CSeisWideDoc::OnReflectionFaultenhancing)
		ON_COMMAND(ID_REFLECTION_COHERENCYPLOT, &CSeisWideDoc::OnReflectionCoherencyplot)
		ON_COMMAND(ID_TOOL_DUMPPOLYNOMIALPOINTS, &CSeisWideDoc::OnToolDumppolynomialpoints)
		ON_COMMAND(ID_WIDE_NMOSTRETCHING, &CSeisWideDoc::OnWideNmostretching)
		ON_COMMAND(ID_Menu_TRACEBALANCE_XT, &CSeisWideDoc::OnMenuTracebalanceXt)
		ON_COMMAND(ID_SONOBUOY_SHIFTTRACENUMBER, &CSeisWideDoc::OnSonobuoyShifttracenumber)
		ON_COMMAND(ID_TOOLS_PICKNEXT, &CSeisWideDoc::OnToolsPicknext)
		ON_COMMAND(ID_PROCESSING_DISTANCEADJUSTMENT, &CSeisWideDoc::OnProcessingDistanceadjustment)
		ON_COMMAND(ID_REFLECTION_FLATTENBOUNDARY, &CSeisWideDoc::OnReflectionFlattenboundary)
		ON_COMMAND(ID_MODELING_THEORETICALCURVES, &CSeisWideDoc::OnModelingTheoreticalcurves)
		ON_COMMAND(ID_MODEL_PERTURBVEL, &CSeisWideDoc::OnModelPerturbvel)
		ON_COMMAND(ID_MODEL_TOGGLERAYDETAILS, &CSeisWideDoc::OnModelToggleraydetails)
		ON_COMMAND(ID_VIEW_SIZINGOFGRAPH, &CSeisWideDoc::OnViewSizingofgraph)
	END_MESSAGE_MAP()

	/////////////////////////////////////////////////////////////////////////////
	// CSeisWideDoc construction/destruction

	CSeisWideDoc::CSeisWideDoc()
	{
		// Use OLE compound files
		EnableCompoundFile();

		//******* for all variables that are not saved in .SEI files, please initiate them in here!!! ******//
		sizeDoc = CSize(200, 200);
		draw.add = 0;
		draw.bigNodes = 1;  // 1=the smallest node display
		//	draw.extLineDrawing = draw.extLineDrawingTim = FALSE; //not saved in version 2.0.
		draw.clipBoardSizeX = 80; //in mm.
		draw.clipBoardSizeY = 40; // in mm.
		draw.distShift = 0.f;
		draw.colBar = FALSE;

		draw.gDC = new CDC();
		draw.gDC_isDrawable = FALSE;
		draw.gDC_vred = 0.f;  // this info is for rotation of gDC

		draw.isFillSmall =true; //not saved in version 2.0. Fill every fill-area separately.
		//as opposed to fill each trace once only.
		draw.isDigitizing = FALSE;

		draw.isNoLableOutside = FALSE;	
		draw.isAvgEnergy = FALSE;
		draw.isCopying = FALSE;
		draw.isDigitizing = FALSE; // this guarentees not in digitizing mode when opening up
		draw.isShowRaycode = FALSE;
		draw.isShiftPressed = FALSE;
		draw.isControlPressed = FALSE;
		draw.isAPressed = FALSE;
		draw.isNoNodes = FALSE;
		// draw.isNoSeismic = FALSE; // this guarentees seismic data are displayed when opening up
		draw.isPrinting = 0;
		draw.isNodeChanged = TRUE;
		draw.isSameDataDisplay = FALSE;
		draw.isNoLableOutside = FALSE;	//not saved in version 2.0.
		draw.isNoColorMap = FALSE; //not saved in version 2.0.
		draw.isNoBoundary = FALSE; //not saved in version 2.0.
		draw.isNoNodes = FALSE;
		draw.isNoOBSPos = FALSE; //not saved in version 2.0.
		draw.iLayerFocus = 3;
		draw.isNoOutSidePoints = FALSE;

		draw.iModelPeglet = -1;
		draw.isTopBound = true;
		draw.memMaxMB = 450;

		draw.mode = draw.modeOld = -1;

		//to avoid accidentaly delete, reset these:
		draw.modelUpInc = 0.01f; // def. 0.01km, not saved
		draw.modelVelInc = 0.01f; // def. 0.01km, not saved

		draw.move = 0;
		draw.nodes = 1;  //if 1 then boundary mode; if 2 then vel mode.
		draw.pick = 0;
		draw.pickOld = -1;  // for use with the right-mouse click
		draw.printX = 1.f;
		draw.printY = 1.f;

		draw.raymode = -1; // this will prompt selection of P or S wave velocities if no overwrite later
		draw.remove = 0;
		draw.restoreLevelCurrent = -1; // added June 14, 2010
		draw.remove = 0;

		velMod.velSecName = draw.velSecNamesEx = draw.timeSecName = draw.depthSecName = draw.vrmsTauName = _T("");
		draw.depthSecOld = velMod.floatNameOld = _T("");
		//		draw.traceStepPrompt = TRUE; //not saved always.
		draw.TTCurveColor = 4;
		draw.velErr =FALSE; //not used in ver 3.3.
		draw.strXLabelOverwrite = _T("");
		// if not blank, this value will be used instead of default. 
		// It is dynamically assigned in velocity analysys e.g.

		dig.twin_isEnergy = FALSE;
		dig.twin_lag = 0.04;
		dig.twin_lagWeight = 0.9f;
		dig.twin_min = 0.04;
		dig.twin_max = 0.1;
		dig.twin_numSubdivide = 5;
		pCd.coord.logicalAxes.SetRect(0, 0, 15000, 10000);

		//mm_xLen = 15000;
		//pCd.coord.logicalAxes.Height() = 10000;

		//*************************
		para.overWrite = FALSE;
		pCd.coord.vred = 0.f;
		para.clip = 5.f;
		para.gain = 0.8;
		para.baseGain = 5.;
		para.basePower = 1.;
		pCd.coord.tmax = 8.0;
		pCd.coord.tmin= 0.0;
		pCd.coord.tTick = 1.;
		para.wiggle = 4;  // make Color fill as the default fill.
		//para.colorFillIllumination = 4.0f;
		pCd.coord.xmax=100.0;
		pCd.coord.xmin=0.0;
		pCd.coord.xTick = 10.;
		para.trace1 = 0;
		para.trace2 = 99999;
		pCd.coord.isFaceUp = 0;
		pCd.coord.vred = 0.;
		para.isDistanceDisplay = FALSE;
		//	para.oriShot=0;
		para.fillOff = 0.01;
		para.gainDist = FALSE;

		para.traveltime = FALSE;
		//	para.segyOrder = FALSE;
		//	para.segyOrderReverse = FALSE;
		para.isNegativeFill = FALSE;
		para.overWrite = FALSE;

		// these are to move to more global variable area
		draw.restoreLevelMax = 10;   // added June 14, 2010

		para.sphericOrder = 0.f;
		para.attenuationCorr = 0.f;     // added Oct. 2008
		para.attenuationSeafloor = 4.5f; // added Oct. 2008

		//*************************
		vel.dz = 0.004;
		// vel.dt = 0.004f; // introduced for time-depth two-way conversions, to be used together with vel.dz
		pCd.coord.zmax = 15.0;
		pCd.coord.zmin = 0.0;
		vel.zTick = 1.;





		//vel.vmin = 1.6;
		//vel.vmid = 4.;
		//vel.vmid2 = 5.;
		//vel.vmid3 = 6.4;
		//vel.vmid4 = 7.2;
		//vel.vmax = 8.1;

		//vel.vminR = 0;
		//vel.vmidR = 135;
		//vel.vmidR2 = 210;
		//vel.vmidR3 = 255;
		//vel.vmidR4 = 255;
		//vel.vmaxR = 170;

		//vel.vminG = 140;
		//vel.vmidG = 255;
		//vel.vmidG2 = 255;
		//vel.vmidG3 = 135;
		//vel.vmidG4 = 151;
		//vel.vmaxG = 43;

		//vel.vminB =  255;
		//vel.vmidB =  0;
		//vel.vmidB2 = 0;
		//vel.vmidB3 = 0;
		//vel.vmidB4 = 0;
		//vel.vmaxB =  255;


		vel.vmin = 1.6;
		vel.vmid = 2.;
		vel.vmid2 = 3.;
		vel.vmid3 = 4.5;
		vel.vmid4 = 5.0;
		vel.vmid5 = 5.5;
		vel.vmid6 = 6.2;
		vel.vmid7 = 6.7;
		vel.vmid8 = 7.3;
		vel.vmax = 8.1;

		vel.vminR = 255;
		vel.vmidR = 234;
		vel.vmidR2 = 181;
		vel.vmidR3 = 192;
		vel.vmidR4 = 255;
		vel.vmidR5 = 255;
		vel.vmidR6 = 255;
		vel.vmidR7 = 255;
		vel.vmidR8 = 255;
		vel.vmaxR = 217;

		vel.vminG = 255;
		vel.vmidG = 255;
		vel.vmidG2 = 255;
		vel.vmidG3 = 245;
		vel.vmidG4 = 235;
		vel.vmidG5 = 220;
		vel.vmidG6 = 198;
		vel.vmidG7 = 171;
		vel.vmidG8 = 142;
		vel.vmaxG = 179;

		vel.vminB =  0;
		vel.vmidB =  0;
		vel.vmidB2 = 0;
		vel.vmidB3 = 103;
		vel.vmidB4 = 205;
		vel.vmidB5 = 178;
		vel.vmidB6 = 140;
		vel.vmidB7 = 132;
		vel.vmidB8 = 140;
		vel.vmaxB =  255;


		vel.cxExt = 8.;
		vel.cxPos = 2.;
		vel.cyExt = .5;
		vel.cyPos = 2.;
		vel.dv1 = .1;
		vel.dxVDesired = 0.0001;  // temporary variable should be in constroctur

		//*************************
		//These parameters are for KD Migration
		kd.ek=TRUE; kd.npv=FALSE;
		kd.amax=180.f; kd.amin=0.f; 
		kd.doff=99999.f; kd.angmax=60.f; 
		kd.dzv=(float)(pCd.coord.zmax-pCd.coord.zmin)*0.01f;
		kd.dxv =(float)(pCd.coord.xmax-pCd.coord.xmin)*0.01f; 
		kd.ds = kd.dxm=kd.dxo=0.025f;
		kd.fa=-60.f; kd.da=2.f; kd.na=61; 
		kd.fac=0.01f;
		kd.tmaxRay=12.f; kd.dt=0.008f; 
		kd.ns=1; kd.ls=1;
		kd.off0=0.f; kd.offmax=4.f;
		kd.v0=0.f; 
		kd.dvz = 0.f;
		kd.fmax=99999.f;
		kd.aperx=5.f;
		kd.memMax = 32.f;
		//*************************

		tx.xShot = 0.f;
		tx.iShot = -1;  // this indicates undefined
		for (int i=0; i<100; i++) {
			tx.shots[i][1] = -1.f;
			tx.ivray[i] = 0;
		}
		tx.rayCodes = new CStringArray();				

		//*************************
		dig.isZeltFormat2 = FALSE;
		dig.barForm = 0; //0=bar; 1=Circle (open); 2=Circle (filled); 3=Star.

		// initilize these pointers.
		dig.nPoint = NULL;
		dig.digResolution = NULL;
		dig.ivray = NULL;
		dig.x = NULL;
		dig.t = NULL;
		dig.labelArr =  NULL;
		dig.noPromptLabel = FALSE; 
		draw.isNoLabelInSide = FALSE; 

		dig.isSorted = TRUE;
		dig.isSortedY = FALSE;

		//*************************
		velMod.npArray = NULL;
		velMod.xArray = NULL;
		velMod.tArray = NULL;
		velMod.nzed = NULL;
		velMod.nvel = NULL;
		velMod.xm = NULL;
		velMod.zm = NULL;
		velMod.xvel = NULL;
		velMod.vf = NULL;
		velMod.grdDepth = NULL;
		velMod.vTop = NULL;
		velMod.grdTwtt = NULL;
		velMod.tm = NULL;
		velMod.anisotropy = NULL;


		char* rh[11] = {
			"00", "00", "33", "99", "CA", "FF", "FF", "FF", "FF", "FE", "FE"
		};
		char* gh[11] = {
			"66", "99", "99", "CC", "CB", "FF", "FE", "FF", "CA", "43", "00"
		};
		char* bh[11] = {
			"CC", "FF", "FF", "FF", "FF", "FF", "C9", "98", "65", "41", "00"
		};
		//for (int i=0; i<11; i++) {
		//	ampBiColor.rhi[i] = axtoi(rh[i]);
		//	ampBiColor.ghi[i] = axtoi(gh[i]);
		//	ampBiColor.bhi[i] = axtoi(bh[i]);
		//}

		ampColorDyn.colFileName = _T("");
		ampColorDyn.r = NULL;
		ampColorDyn.g = NULL;
		ampColorDyn.b = NULL;
		ampColorDyn.percentAmp = NULL;
		ampColorDyn.num = 0;
		//ampColorDyn.numContours = 50;


		//*************************

		//*************************
		bmp24.bmp24Name = _T("");
		bmp24.xmin = (float)pCd.coord.xmin;
		bmp24.xmax = (float)pCd.coord.xmax;
		bmp24.ymin = (float)pCd.coord.tmin;
		bmp24.ymax = (float)pCd.coord.tmax;
		bmp24.isDepth = FALSE;
		bmp24.isNeedInitialize = TRUE; //when update screen, initialize the bitmap file and DC etc.



		processing.filterxt.ta = 5.f;
		processing.filterxt.tb = 10.f;
		processing.filterxt.fLowa = 3.f;
		processing.filterxt.fHigha = 60.f;
		processing.filterxt.fLowb = 2.f;
		processing.filterxt.fHighb = 30.f;
		processing.filterxt.x1 = 0.f;

		processing.filterxt.tax2 = 5.f;
		processing.filterxt.tbx2 = 12.f;
		processing.filterxt.fLowax2 = 2.f;
		processing.filterxt.fHighax2 = 35.f;
		processing.filterxt.fLowbx2 = 1.f;
		processing.filterxt.fHighbx2 = 26.f;
		processing.filterxt.x2 = 20.f;

		processing.filterxt.tax3 = 5.f;
		processing.filterxt.tbx3 = 13.f;
		processing.filterxt.fLowax3 = 1.f;
		processing.filterxt.fHighax3 = 20.f;
		processing.filterxt.fLowbx3 = 0.5f;
		processing.filterxt.fHighbx3 = 20.f;
		processing.filterxt.x3 = 30.f;


		//processing.filterxt.ta = 4.f;
		//processing.filterxt.tb = 10.f;
		//processing.filterxt.fLowa = 3.f;
		//processing.filterxt.fHigha = 60.f;
		//processing.filterxt.fLowb = 3.f;
		//processing.filterxt.fHighb = 16.f;
		//processing.filterxt.x1 = 1.f;

		//processing.filterxt.tax2 = 5.f;
		//processing.filterxt.tbx2 = 11.f;
		//processing.filterxt.fLowax2 = 3.f;
		//processing.filterxt.fHighax2 = 50.f;
		//processing.filterxt.fLowbx2 = 3.f;
		//processing.filterxt.fHighbx2 = 15.f;
		//processing.filterxt.x2 = 2.f;

		//processing.filterxt.tax3 = 6.f;
		//processing.filterxt.tbx3 = 12.f;
		//processing.filterxt.fLowax3 = 3.f;
		//processing.filterxt.fHighax3 = 40.f;
		//processing.filterxt.fLowbx3 = 3.f;
		//processing.filterxt.fHighbx3 = 14.f;
		//processing.filterxt.x3 = 3.f;
		processing.filterxt.num_tfilter = 2;
	}

	CSeisWideDoc::~CSeisWideDoc()
	{
		// arrays for dig.x and dig.t ... are already assigned and should free.
		freeDigAll();
		CDigitize pDg;
		pDg.freeDigAll(&draw.digMarker);
		freeRaypathsAll();

		tx.rayCodes->RemoveAll();
		delete tx.rayCodes;
		tx.rayCodes = NULL;

		// oldPen->DeleteObject();
		// oldBrush->DeleteObject();
		bmp24.bmpDC.DeleteDC(); //if bmpDC is still there then delete it.
		//if I don't delete this DC here then it crashes in win95 system when exiting.

		draw.gDC->DeleteDC();
		delete draw.gDC;
		draw.gDC = NULL;

		freeModelArrayEx();
		velModFreeArrays();
		freeAmpColorArray();
		CSegyMeta::segyHeadFree(&head);
	}

	CSeisWideDoc * CSeisWideDoc::GetDoc()
	{ // added by Deping to allow getting doc pointer from anywhere.
		CMDIChildWnd * pChild = ((CMDIFrameWnd*)(AfxGetApp()->m_pMainWnd))->MDIGetActive();
		if ( !pChild ) return NULL;
		CDocument * pDoc = pChild->GetActiveDocument();
		if ( !pDoc ) return NULL;

		return (CSeisWideDoc *) pDoc;
	}


	BOOL CSeisWideDoc::OnNewDocument()
	{
		if (!COleServerDoc::OnNewDocument())
			return FALSE;



		velModSetArrays();

		// for initiliazing segy array caching
		//head.trDyn = NULL;
		//head.ntrCached = 0;

		// this->GetDoc();

		return TRUE;	
	}

	/////////////////////////////////////////////////////////////////////////////
	// CSeisWideDoc server implementation

	COleServerItem* CSeisWideDoc::OnGetEmbeddedItem()
	{
		// OnGetEmbeddedItem is called by the framework to get the COleServerItem
		//  that is associated with the document.  It is only called when necessary.

		CSeisWideSrvrItem* pItem = new CSeisWideSrvrItem(this);
		ASSERT_VALID(pItem);
		return pItem;
	}

	/////////////////////////////////////////////////////////////////////////////
	// CSeisWideDoc serialization

	void CSeisWideDoc::Serialize(CArchive& ar)
	{
		float xx1 = 0.f;  // disabled
		float xx2 = 0.f;  // disabled
		float yy1 = 0.f;  // disabled
		float yy2 = 0.f;  // disabled
		int iTopBound = 0;  // disabled
		CString aName = _T(""); // disabled
		BOOL labelAsTWTT = FALSE; // disabled
		BOOL isNoLableOutside = FALSE; // disabled
		BOOL traceStepPrompt = FALSE;  // disabeld
		int zeroAmpR = 0;// disabeld
		int zeroAmpG = 0;// disabeld
		int zeroAmpB = 0;// disabeld
		float colClipRatio = 0.f;// disabled
		float aFloat = 0.f; // diabled 


		TRY
		{
			if (ar.IsStoring())
			{
				ar << para.clip;
				ar << (int)pCd.coord.isFaceUp;  // must be casted to int otherwise the SEI file cannot be read
				ar << para.fillOff;
				ar << para.gain;
				ar << para.gainDist;
				ar << para.baseGain;
				ar << para.basePower;
				ar << para.isDistanceDisplay;
				ar << draw.distShift;
				ar << para.isDistanceLeftOfShot;
				ar << para.trace1;
				ar << para.trace2;
				ar << tx.xShot;
				ar << pCd.coord.tmax;
				ar << pCd.coord.tmin;
				ar << para.traveltime;
				ar << pCd.coord.tTick;
				ar << pCd.coord.vred;
				ar << para.wiggle;
				ar << pCd.coord.xmax;
				ar << pCd.coord.xmin;
				ar << pCd.coord.xTick;

				ar << vel.dz;
				ar << pCd.coord.zmax;
				ar << pCd.coord.zmin;
				ar << vel.zTick;
				ar << vel.dv;	//not used in version 2.0
				ar << vel.dxVDesired;
				ar << vel.vmin;
				ar << vel.vmid;
				ar << vel.vmax;

				ar << vel.vminR;
				ar << vel.vminG;
				ar << vel.vminB;
				ar << vel.vmidR;
				ar << vel.vmidG;
				ar << vel.vmidB;
				ar << vel.vmaxR;
				ar << vel.vmaxG;
				ar << vel.vmaxB;

				ar << draw.timeSecName;
				ar << draw.depthSecName;
				ar << velMod.velSecName;
				ar << draw.plotTitle;
				ar << draw.add;
				ar << draw.iLayerFocus;
				ar << iTopBound;
				ar << draw.mode;
				ar << draw.move;
				ar << draw.nodes;
				ar << draw.pick;
				ar << draw.printX;
				ar << draw.printY;
				ar << draw.rayName;
				ar << draw.remove;

				//These are additions in version 2.0
				ar << draw.colBar;
				ar << dig.isLabelShow;
				ar << vel.cxExt;
				ar << vel.cxPos;
				ar << vel.cyExt;
				ar << vel.cyPos;
				ar << vel.vmid2;
				ar << vel.vmid3;
				ar << vel.vmid4;
				ar << vel.vmidB2;
				ar << vel.vmidB3;
				ar << vel.vmidB4;
				ar << vel.vmidG2;
				ar << vel.vmidG3;
				ar << vel.vmidG4;
				ar << vel.vmidR2;
				ar << vel.vmidR3;
				ar << vel.vmidR4;
				ar << vel.dv1;
				ar << vel.dv1;
				ar << vel.dv1;
				ar << vel.dv1;
				ar << vel.dv1;

				ar << seisBiColor2.maxAmpR;
				ar << seisBiColor2.maxAmpG;
				ar << seisBiColor2.maxAmpB;
				ar << seisBiColor2.negAmpR;
				ar << seisBiColor2.negAmpG;
				ar << seisBiColor2.negAmpB;
				ar << zeroAmpR;
				ar << zeroAmpG;
				ar << zeroAmpB;
				ar << colClipRatio;

				//Version 3.2 should save the following:
				ar << draw.velSecNamesEx;
				ar << isNoLableOutside;  // disabled
				//These parameters are for KD Migration
				ar << kd.ek;
				ar << kd.npv;
				ar << kd.amax; 
				ar << kd.amin; 
				ar << kd.da; 
				ar << kd.doff; 
				ar << kd.angmax; 
				ar << kd.dzt;
				ar << kd.dzv;
				ar << kd.dxm; 
				ar << kd.dxv;
				ar << kd.dxt; 
				ar << kd.dxo;
				ar << kd.fa; 
				ar << kd.fac;
				ar << kd.na; 
				ar << kd.tmaxRay; 
				ar << kd.dt; 
				ar << kd.ns; 
				ar << kd.ls;
				ar << kd.off0; 
				ar << kd.offmax;
				ar << kd.v0; 
				ar << kd.dvz;
				ar << kd.ds;
				ar << kd.fmax;
				ar << kd.aperx;
				ar << kd.memMax;

				ar << para.obsDepth;
				ar << draw.isCopying; //this is for ActiveX for not auto adjusting shotstep.

				//The following is only for spacial mapping in OnModelingExtractlayerinfor() .
				ar << xx1;  // disabled
				ar << xx2;  // disabled
				ar << yy1;  // disabled
				ar << yy2;  // disabled

				ar << bmp24.bmp24Name;
				ar << bmp24.xmin;
				ar << bmp24.xmax;
				ar << bmp24.ymin;
				ar << bmp24.ymax;
				ar << bmp24.isDepth;

				// ver. 4.2
				ar << dig.barForm; //For wide-angle error bars: 0=bar; 1=Circle (open); 2=Circle (filled); 3=Star.
				ar << draw.bigNodes;
				//ar << draw.labelAsTWTT;
				ar << labelAsTWTT;  // this parameter is disabled
				ar << draw.isNoOutSidePoints;
				ar << traceStepPrompt;  // depreciated
				ar << velMod.floatName;

				// ver 4.6.5--sept. 2006
				ar << aName; // disabled
				ar << ampColorDyn.logScaleThreshold;
				ar << para.isNegativeFill;
				ar << draw.markerName; // this one was missed before

				// v4.6.7--nov 2006
				ar << draw.txRaytraceName;
				ar << dig.digName;

				// v5.6--Feb 11, 2009
				ar << aFloat;  // disabled

				// Apr 22, 2009
				ar << draw.strXLabelOverwrite;


				// June 24, 2010
				ar << draw.restoreLevelMax;   // added June 14, 2010
				ar << ampColorDyn.logScaleThreshold;   
				ar << para.obsDepth;	//this initilizes for hydro display.


				ar << para.gunDepth2;  // added Feb 2008, later disabled and brought back to live on Nov 2011
				ar << para.sphericOrder;
				ar << para.attenuationCorr;     // added Oct. 2008
				ar << para.attenuationSeafloor; // added Oct. 2008

				ar << draw.vrmsTauName; // added Jan. 2011
				ar << draw.isAvgEnergy;

				// additions Sept. 2011
				ar << vel.vmid5;
				ar << vel.vmid6;
				ar << vel.vmid7;
				ar << vel.vmid8;
				ar << vel.vmidR5;
				ar << vel.vmidG5;
				ar << vel.vmidB5;
				ar << vel.vmidR6;
				ar << vel.vmidG6;
				ar << vel.vmidB6;
				ar << vel.vmidR7;
				ar << vel.vmidG7;
				ar << vel.vmidB7;
				ar << vel.vmidR8;
				ar << vel.vmidG8;
				ar << vel.vmidB8;

				// additions Dec. 7, 2012
				ar << vel.colBarVmin;
				ar << vel.colBarVmax;

				// additions Dec. 16, 2012
				ar << draw.markerXMultFactor;
				ar << draw.markerXShift;
				ar << draw.markerYMultFactor;
				ar << draw.markerYShift;
				ar << draw.markerIsRevYAxis;
			}
			else
			{
				ULONGLONG lenCur;
				CFile* file = ar.GetFile();
				//	if (file!=NULL && !file->IsSerializable()) return; // this avoid crash problem

				ULONGLONG lenTot =  file->GetLength();
				file->Seek(0, CFile::begin);

				ar >> para.clip;
				ar >> iTopBound;
				pCd.coord.isFaceUp = iTopBound != 0;
				ar >> para.fillOff;
				ar >> para.gain;
				ar >> para.gainDist;
				ar >> para.baseGain;
				ar >> para.basePower;
				ar >> para.isDistanceDisplay;
				ar >> draw.distShift; 
				ar >> para.isDistanceLeftOfShot;  
				ar >> para.trace1;
				ar >> para.trace2;
				ar >> tx.xShot;
				ar >> pCd.coord.tmax;
				ar >> pCd.coord.tmin;
				ar >> para.traveltime;
				ar >> pCd.coord.tTick;
				ar >> pCd.coord.vred;
				ar >> para.wiggle;
				ar >> pCd.coord.xmax;
				ar >> pCd.coord.xmin;
				ar >> pCd.coord.xTick;

				ar >> vel.dz;
				ar >> pCd.coord.zmax;
				ar >> pCd.coord.zmin;
				ar >> vel.zTick;
				ar >> vel.dv;	//not used in version 2.0
				ar >> vel.dxVDesired; // vel.dxV = 0.0001;  // this should be reset everytime
				ar >> vel.vmin;
				ar >> vel.vmid;
				ar >> vel.vmax;

				ar >> vel.vminR;
				ar >> vel.vminG;
				ar >> vel.vminB;
				ar >> vel.vmidR;
				ar >> vel.vmidG;
				ar >> vel.vmidB;
				ar >> vel.vmaxR;
				ar >> vel.vmaxG;
				ar >> vel.vmaxB;

				//	lenCur = file->Seek(0, CFile::current);

				ar >> draw.timeSecName;
				ar >> draw.depthSecName;
				ar >> velMod.velSecName;
				ar >> draw.plotTitle;
				ar >> draw.add;
				ar >> draw.iLayerFocus;
				ar >> iTopBound;
				ar >> draw.mode;
				ar >> draw.move;
				ar >> draw.nodes;
				ar >> draw.pick;
				ar >> draw.printX;
				ar >> draw.printY;
				ar >> draw.rayName;
				ar >> draw.remove;

				//These are additions in version 2.0

				ar.Flush();
				lenCur = file->Seek(0, CFile::current);
				if(lenCur >= lenTot-4) 
				{
					extraSerialize();
					goto FileEndSudden;
				}
				ar >> draw.colBar;

				ar.Flush();
				lenCur = file->Seek(0, CFile::current);
				if(lenCur >= lenTot-4) 
				{
					extraSerialize();
					goto FileEndSudden;
				}
				ar >> dig.isLabelShow;

				ar >> vel.cxExt;
				ar >> vel.cxPos;
				ar >> vel.cyExt;
				ar >> vel.cyPos;
				ar >> vel.vmid2;
				ar >> vel.vmid3;
				ar >> vel.vmid4;
				ar >> vel.vmidB2;
				ar >> vel.vmidB3;
				ar >> vel.vmidB4;
				ar >> vel.vmidG2;
				ar >> vel.vmidG3;
				ar >> vel.vmidG4;
				ar >> vel.vmidR2;
				ar >> vel.vmidR3;
				ar >> vel.vmidR4;

				//These to upgrade to 2.1 version.
				ar >> vel.dv1;	
				ar >> vel.dv1;
				ar >> vel.dv1;
				ar >> vel.dv1;
				ar >> vel.dv1;

				ar >> seisBiColor2.maxAmpR;
				ar >> seisBiColor2.maxAmpG;
				ar >> seisBiColor2.maxAmpB;
				ar >> seisBiColor2.negAmpR;
				ar >> seisBiColor2.negAmpG;
				ar >> seisBiColor2.negAmpB;

				// 4 lines not used
				ar >> zeroAmpR;
				ar >> zeroAmpG;
				ar >> zeroAmpB;
				ar >> colClipRatio;

				//Version 3.2 should save the following:
				ar.Flush();
				lenCur = file->Seek(0, CFile::current);
				if(lenCur >= lenTot-4) goto FileEndSudden;
				ar >> draw.velSecNamesEx;

				ar.Flush();
				lenCur = file->Seek(0, CFile::current);
				if(lenCur >= lenTot-4) goto FileEndSudden;
				ar >> isNoLableOutside;  // disabled in saving

				//These parameters are for KD Migration
				ar.Flush();
				lenCur = file->Seek(0, CFile::current);
				if(lenCur >= lenTot-4) goto FileEndSudden;
				ar >> kd.ek;

				ar.Flush();
				lenCur = file->Seek(0, CFile::current);
				if(lenCur >= lenTot-4) goto FileEndSudden;
				ar >> kd.npv;

				ar >> kd.amax; 
				ar >> kd.amin; 
				ar >> kd.da; 
				ar >> kd.doff; 
				ar >> kd.angmax; 
				ar >> kd.dzt;
				ar >> kd.dzv;
				ar >> kd.dxm; 
				ar >> kd.dxv;
				ar >> kd.dxt; 
				ar >> kd.dxo;
				ar >> kd.fa; 
				ar >> kd.fac;
				ar >> kd.na; 
				ar >> kd.tmaxRay; 
				ar >> kd.dt; 
				ar >> kd.ns; 
				ar >> kd.ls;
				ar >> kd.off0; 
				ar >> kd.offmax;
				ar >> kd.v0; 
				ar >> kd.dvz;
				ar >> kd.ds;
				ar >> kd.fmax;
				ar >> kd.aperx;
				ar >> kd.memMax;

				ar.Flush();
				lenCur = file->Seek(0, CFile::current);
				if(lenCur >= lenTot-4) goto FileEndSudden;
				ar >> para.obsDepth;

				ar.Flush();
				lenCur = file->Seek(0, CFile::current);
				if(lenCur >= lenTot-4) goto FileEndSudden;
				ar >> draw.isCopying; //this is for ActiveX for not auto adjusting shotstep.

				//The following is only for spacial mapping in OnModelingExtractlayerinfor() .
				ar.Flush();
				lenCur = file->Seek(0, CFile::current);
				if(lenCur >= lenTot-4) 
				{
					xx1 = 0.f;
					xx2 = 0.f;
					yy1 = 0.f;
					yy2 = 0.f;
					goto FileEndSudden;
				}
				ar >> xx1;
				ar >> xx2;
				ar >> yy1;
				ar >> yy2;

				//the following is for bitmap operations.
				ar.Flush();
				lenCur = file->Seek(0, CFile::current);
				if(lenCur >= lenTot-4) goto FileEndSudden;
				ar >> bmp24.bmp24Name;
				ar >> bmp24.xmin;
				ar >> bmp24.xmax;
				ar >> bmp24.ymin;
				ar >> bmp24.ymax;
				ar >> bmp24.isDepth;

				//the following is new additions on Sept. 29.
				ar.Flush();
				lenCur = file->Seek(0, CFile::current);
				if(lenCur >= lenTot-4) goto FileEndSudden;
				ar >> dig.barForm; //For wide-angle error bars: 0=bar; 1=Circle (open); 2=Circle (filled); 3=Star.
				ar >> draw.bigNodes;
				ar >> labelAsTWTT; // this is disabled
				ar >> draw.isNoOutSidePoints;
				ar >> traceStepPrompt;  // disabled

				ar >> velMod.floatName;

				// additions on Sept, 2006
				ar.Flush();
				lenCur = file->Seek(0, CFile::current);
				if(lenCur >= lenTot-4) goto FileEndSudden;
				ar >> aName;  // disabled
				ar >> ampColorDyn.logScaleThreshold; 


				// additions on Oct, 2006
				ar.Flush();
				lenCur = file->Seek(0, CFile::current);
				if(lenCur >= lenTot-4) goto FileEndSudden;
				ar >> para.isNegativeFill;
				ar >> draw.markerName; // this one was missed before

				// v4.6.7--nov 2006
				ar.Flush();
				lenCur = file->Seek(0, CFile::current);
				if(lenCur >= lenTot-4) goto FileEndSudden;
				ar >> draw.txRaytraceName;

				ar.Flush();
				lenCur = file->Seek(0, CFile::current);
				if(lenCur >= lenTot-4) goto FileEndSudden;
				ar >> dig.digName;

				ar.Flush();
				lenCur = file->Seek(0, CFile::current);
				if(lenCur >= lenTot-4) goto FileEndSudden;
				ar >> aFloat;  // disabled

				// added apr 22, 2009
				ar.Flush();
				lenCur = file->Seek(0, CFile::current);
				if(lenCur >= lenTot-4) goto FileEndSudden;

				TRY {
					// this can cause problem after we switch from ascii to Unicode
					ar >> draw.strXLabelOverwrite;
				} // TRY 
				CATCH_ALL(e)
				{
					goto FileEndSudden;
				}
				END_CATCH_ALL

					// added June 24, 2010
					ar.Flush();
				lenCur = file->Seek(0, CFile::current);
				if(lenCur >= lenTot-4) goto FileEndSudden;
				ar >> draw.restoreLevelMax;   // added June 14, 2010
				ar >> ampColorDyn.logScaleThreshold;     // added June 14, 2010
				ar >> para.obsDepth;	//this initilizes for hydro display.
				ar >> para.gunDepth2; // para.gunDepth;  // added Feb 2008
				ar >> para.sphericOrder;
				ar >> para.attenuationCorr;     // added Oct. 2008
				ar >> para.attenuationSeafloor; // added Oct. 2008

				// added Jan , 2011
				ar.Flush();
				lenCur = file->Seek(0, CFile::current);
				if(lenCur >= lenTot-4) goto FileEndSudden;
				ar >> draw.vrmsTauName;

				// added Jan 30, 2011
				ar.Flush();
				lenCur = file->Seek(0, CFile::current);
				if(lenCur >= lenTot-4) goto FileEndSudden;
				ar >> draw.isAvgEnergy;

				// added Sept 26, 2011
				ar.Flush();
				lenCur = file->Seek(0, CFile::current);
				if(lenCur >= lenTot-4) goto FileEndSudden;
				ar >> vel.vmid5;
				ar >> vel.vmid6;
				ar >> vel.vmid7;
				ar >> vel.vmid8;
				ar >> vel.vmidR5;
				ar >> vel.vmidG5;
				ar >> vel.vmidB5;
				ar >> vel.vmidR6;
				ar >> vel.vmidG6;
				ar >> vel.vmidB6;
				ar >> vel.vmidR7;
				ar >> vel.vmidG7;
				ar >> vel.vmidB7;
				ar >> vel.vmidR8;
				ar >> vel.vmidG8;
				ar >> vel.vmidB8;

				// additions Dec. 7, 2012
				ar.Flush();
				lenCur = file->Seek(0, CFile::current);
				if(lenCur >= lenTot-4) {
					vel.colBarVmin = 1.5f;
					vel.colBarVmax = 8.f;
				}
				else {
					ar >> vel.colBarVmin;
					ar >> vel.colBarVmax;
				}


				// additions Dec. 16, 2012
				ar.Flush();
				lenCur = file->Seek(0, CFile::current);
				if(lenCur >= lenTot-4) {
					// no need to set since they are initial values
				}
				else {
					ar >> draw.markerXMultFactor;
					ar >> draw.markerXShift;
					ar >> draw.markerYMultFactor;
					ar >> draw.markerYShift;
					ar >> draw.markerIsRevYAxis;
				}


				goto FileEndNormal;

FileEndSudden:
				ampColorDyn.logScaleThreshold = 70;

				bmp24.bmp24Name = _T("");
				bmp24.xmin = (float)pCd.coord.xmin;
				bmp24.xmax = (float)pCd.coord.xmax;
				bmp24.ymin = (float)pCd.coord.tmin;
				bmp24.ymax = (float)pCd.coord.tmax;
				bmp24.isDepth = FALSE;

				dig.digName = _T("");
				dig.isZeltFormat2 = FALSE;
				dig.barForm=0; //For wide-angle error bars: 0=bar; 1=Circle (open); 2=Circle (filled); 3=Star.

				draw.bigNodes=1;
				draw.distShift = 0.f;
				draw.isNoOutSidePoints=FALSE;
				//	draw.traceStepPrompt=TRUE;
				draw.markerName=_T(""); // this one was missed before
				draw.txRaytraceName = _T("");
				draw.strXLabelOverwrite = _T("");
				draw.markerName = _T("");

				para.isNegativeFill = FALSE;
				pCd.coord.tmin = 0.;
				pCd.coord.tmax = 8.;
				pCd.coord.tTick = 1.;
				pCd.coord.xmin = 0.;
				pCd.coord.xmax = pCd.coord.xmin + 10.;
				pCd.coord.xTick = 1.;

				// if SEI file not complete, we need to use default colors always.
				pCd.coord.zmin = 0.;
				pCd.coord.zmax = 10.;
				vel.dz = 0.004;
				vel.zTick = 1.;

				vel.cxPos = 0.;
				vel.cyPos = 0.;
				vel.cxExt = 8.;
				vel.cyExt = 1.;
				vel.dv = .1;
				vel.dxVDesired = .1;




				vel.vmin = 1.6;
				vel.vmid = 2.;
				vel.vmid2 = 3.;
				vel.vmid3 = 4.5;
				vel.vmid4 = 5.0;
				vel.vmid5 = 5.5;
				vel.vmid6 = 6.2;
				vel.vmid7 = 6.7;
				vel.vmid8 = 7.3;
				vel.vmax = 8.1;

				vel.vminR = 255;
				vel.vmidR = 234;
				vel.vmidR2 = 181;
				vel.vmidR3 = 192;
				vel.vmidR4 = 255;
				vel.vmidR5 = 255;
				vel.vmidR6 = 255;
				vel.vmidR7 = 255;
				vel.vmidR8 = 255;
				vel.vmaxR = 217;

				vel.vminG = 255;
				vel.vmidG = 255;
				vel.vmidG2 = 255;
				vel.vmidG3 = 245;
				vel.vmidG4 = 235;
				vel.vmidG5 = 220;
				vel.vmidG6 = 198;
				vel.vmidG7 = 171;
				vel.vmidG8 = 142;
				vel.vmaxG = 179;

				vel.vminB =  0;
				vel.vmidB =  0;
				vel.vmidB2 = 0;
				vel.vmidB3 = 103;
				vel.vmidB4 = 205;
				vel.vmidB5 = 178;
				vel.vmidB6 = 140;
				vel.vmidB7 = 132;
				vel.vmidB8 = 140;
				vel.vmaxB =  255;

				// additions Dec. 7, 2012
				vel.colBarVmin = 1.5f;
				vel.colBarVmax = 8.f;

				velMod.floatName=_T("");

FileEndNormal:
				if (ampColorDyn.logScaleThreshold<5 || ampColorDyn.logScaleThreshold>100)
					ampColorDyn.logScaleThreshold = 70;  // old file may have invalid logScaleThreshold values

				// all other initializations are moved to OnOpenDocument()
				;

			} // else
		} // TRY 
		CATCH_ALL(e)
		{
			AfxMessageBox(_T("Failed loading."));
			return;
		}
		END_CATCH_ALL
			// Calling the base class COleServerDoc enables serialization
			//  of the container document's COleClientItem objects.
			// COleServerDoc::Serialize(ar);
	}

	/////////////////////////////////////////////////////////////////////////////
	// CSeisWideDoc diagnostics

#ifdef _DEBUG
	void CSeisWideDoc::AssertValid() const
	{
		COleServerDoc::AssertValid();
	}

	void CSeisWideDoc::Dump(CDumpContext& dc) const
	{
		COleServerDoc::Dump(dc);
	}
#endif //_DEBUG

	/////////////////////////////////////////////////////////////////////////////
	// CSeisWideDoc commands
	void CSeisWideDoc::OnViewBoth() 
	{
		if (draw.isDigitizing && (draw.mode<1 || (draw.mode>4 && draw.mode<10)) ) 
		{
			AfxMessageBox(_T(" Quit digitizing and then you can switch to depth domain."), MB_OK |MB_ICONINFORMATION);
			return;
		}

		draw.modeOld = draw.mode;
		draw.mode = 3; 
		draw.isNodeChanged = FALSE;
		if(!myParas())
		{
			draw.isNodeChanged = TRUE;	
			draw.mode = draw.modeOld;
			return;
		}

		//if (draw.modeOld == 9) {
		//	// the user likely changed the model in tm[] and we now need to re-calc the zm[] array
		//	myModel_TWTT_Depth(&velMod, (float)vel.dz);
		//}

		if( isTimeDomainUtil(draw.modeOld) ) draw.depthSecOld = _T("");
		//this enforces re-initilize amplitude parameters 
		// for depth sections.

		draw.mode = 3;	//Both velocity color and depth sections will be drawn.
		draw.isSameDataDisplay = FALSE; //indicate display has been changed and will re-load all data in OnDraw().
		SetModifiedFlag();
		UpdateAllViews(NULL);
		NotifyChanged();

	}

	void CSeisWideDoc::OnViewContours() 
	{
		if (draw.isDigitizing && (draw.mode<1 || (draw.mode>4 && draw.mode<10)) ) 
		{
			AfxMessageBox(_T(" Quit digitizing and then you can switch to depth domain."), MB_OK |MB_ICONINFORMATION);
			return;
		}
		draw.modeOld = draw.mode;
		draw.mode = 4;	//Velocity contours will be drawn.
		draw.isNodeChanged = FALSE;	
		if(!myParas()) 
		{
			draw.isNodeChanged = TRUE;	
			draw.mode = draw.modeOld;
			return;
		}
		//if (draw.modeOld == 9) {
		//	// the user likely changed the model in tm[] and we now need to re-calc the zm[] array
		//	myModel_TWTT_Depth(&velMod, (float)vel.dz);
		//}

		if( isTimeDomainUtil(draw.modeOld) ) draw.depthSecOld = _T("");
		draw.isNodeChanged = TRUE;	//when draw.isDigitizing=TRUE, this ensures
		//that a new time section plot instruction
		//gets passed thru the OnDraw(). A mouse click
		//will set this to FALSE again in digitize mode.
		draw.isSameDataDisplay = FALSE; //indicate display has been changed and will re-load all data in OnDraw().

		SetModifiedFlag();
		UpdateAllViews(NULL);
		NotifyChanged();
	}

	void CSeisWideDoc::OnViewStackingvelocitymap() 
	{
		// is this accessble???
		if (draw.isDigitizing && (draw.mode<1 || (draw.mode>4 && draw.mode<10)) ) 
		{
			AfxMessageBox(_T(" Quit digitizing and then you can switch to depth domain."), MB_OK |MB_ICONINFORMATION);
			return;
		}
		draw.modeOld = draw.mode;
		draw.mode = 8;	//stacking Velocity contours will be drawn.
		if(!myParas()) 
		{
			draw.mode = draw.modeOld;
			return;
		}
		if( isTimeDomainUtil(draw.modeOld) ) draw.depthSecOld = _T("");

		draw.isSameDataDisplay = FALSE; //indicate display has been changed and will re-load all data in OnDraw().

		SetModifiedFlag();
		UpdateAllViews(NULL);
		NotifyChanged();
	}

	void CSeisWideDoc::OnViewTimesection() 
	{
		if (draw.isDigitizing && !isTimeDomainUtil(draw.modeOld) ) 
		{
			AfxMessageBox(_T(" Quit digitizing and then you can switch to time domain."), MB_OK |MB_ICONINFORMATION);
			return;
		}

		if(draw.modeOld == 6)
		{	//this is set because it is bothersome if one goes 
			//from trace display to km display and the xmin and xmax are all shot numbers.
			//pCd.coord.xmin = 0.f;
			//pCd.coord.xmax = 10.f;
			//para.xTick = 1.f;
			para.isDistanceDisplay = FALSE; // display in offset
			head.modifiedtime = zeroTime; //recalculate amplitude parameters
		}

		draw.modeOld = draw.mode;
		draw.mode = 0;	//Time section will be drawn.

		if(!myParas()) 
		{
			draw.mode = draw.modeOld;
			return;
		}

		draw.isSameDataDisplay = FALSE; //indicate display has been changed and will re-load all data.

		SetModifiedFlag();
		UpdateAllViews(NULL);
		NotifyChanged();
	}

	void CSeisWideDoc::OnViewTimesectrc() 
	{
		if (draw.isDigitizing && (draw.mode>0 && draw.mode<5) ) 
		{
			AfxMessageBox(_T("  Quit digitizing and then you can switch to time domain."), MB_OK |MB_ICONINFORMATION);
			return;
		}


		CdlgTimeByTrc dlg;
		dlg.m_timeSecName = draw.timeSecName;

		dlg.m_clip = para.clip;
		dlg.m_faceDown = pCd.coord.isFaceUp;
		dlg.m_gain = para.gain;
		if(fabs(para.fillOff) > 10.) para.fillOff = 0.1;
		dlg.m_fillOff = para.fillOff;
		dlg.m_shot1 = para.trace1;
		dlg.m_shot2 = para.trace2;
		dlg.m_timeSecTitle = draw.plotTitle;
		dlg.m_wiggle = para.wiggle;

		dlg.m_tmax = (float)pCd.coord.tmax;
		dlg.m_tmin = (float)pCd.coord.tmin;
		dlg.m_tTick = (float)pCd.coord.tTick;
		//	dlg.m_colPalette = GetPathFromFile(draw.timeSecName) + _T("colPalette.txt");

		dlg.seisBiColor.maxAmpR = seisBiColor2.maxAmpR;
		dlg.seisBiColor.maxAmpG = seisBiColor2.maxAmpG;
		dlg.seisBiColor.maxAmpB = seisBiColor2.maxAmpB;
		dlg.seisBiColor.negAmpR = seisBiColor2.negAmpR;
		dlg.seisBiColor.negAmpG = seisBiColor2.negAmpG;
		dlg.seisBiColor.negAmpB = seisBiColor2.negAmpB;
		dlg.m_isAvgAmp = draw.isAvgEnergy;
		dlg.m_vred = (float)pCd.coord.vred;
		dlg.m_logScaleThreshold = ampColorDyn.logScaleThreshold;
		if (dlg.DoModal() == IDOK) {
			draw.plotTitle = dlg.m_timeSecTitle;
			para.clip = dlg.m_clip;
			pCd.coord.isFaceUp = dlg.m_faceDown != 0;
			para.gain = dlg.m_gain;
			para.fillOff = dlg.m_fillOff;
			para.trace1 = dlg.m_shot1;
			para.trace2 = dlg.m_shot2;
			para.wiggle = dlg.m_wiggle;

			draw.timeSecName = dlg.m_timeSecName.Trim();
			pCd.coord.tmax = dlg.m_tmax;
			pCd.coord.tmin = dlg.m_tmin;
			pCd.coord.tTick = dlg.m_tTick;

			para.tstart = dlg.m_tstart;
			para.overWrite = dlg.m_overWrite;
			ampColorDyn.colFileName = GetPathFromFileSlash(draw.timeSecName) + _T("colPalette.txt");

			ampColorDyn.logScaleThreshold = dlg.m_logScaleThreshold;
			if (ampColorDyn.logScaleThreshold<0) ampColorDyn.logScaleThreshold = 0;
			else if (ampColorDyn.logScaleThreshold > 100) ampColorDyn.logScaleThreshold = 100;

			seisBiColor2.maxAmpR = dlg.seisBiColor.maxAmpR;
			seisBiColor2.maxAmpG = dlg.seisBiColor.maxAmpG;
			seisBiColor2.maxAmpB = dlg.seisBiColor.maxAmpB;
			seisBiColor2.negAmpR = dlg.seisBiColor.negAmpR;
			seisBiColor2.negAmpG = dlg.seisBiColor.negAmpG;
			seisBiColor2.negAmpB = dlg.seisBiColor.negAmpB;
			draw.isAvgEnergy = dlg.m_isAvgAmp;
			pCd.coord.vred = dlg.m_vred;
		} else {
			draw.mode = draw.modeOld;  // the action was canceled by the user
			return;
		}

		draw.modeOld = draw.mode;
		draw.mode = 6;	
		//if (draw.modeOld == 9) {
		//	// the user likely changed the model in tm[] and we now need to re-calc the zm[] array
		//	myModel_TWTT_Depth(&velMod, (float)vel.dz);
		//}
		if(para.trace2<para.trace1) 
		{
			myCaption(_T("trace2 is smaller than trace1, please check!"));
			int ibak = para.trace1;
			para.trace1 = para.trace2;
			para.trace2 = ibak;
		}

		//pCd.coord.xmin = getMinRounded(para.trace1, para.trace2, 10);  
		//pCd.coord.xmax = (float)para.trace2;
		if (para.trace2 == para.trace1) para.trace2 = para.trace1 + 100;
		pCd.coord.xmin = para.trace1;
		pCd.coord.xmax = para.trace2;
		pCd.coord.xTick = getTickRounded(pCd.coord.xmin, pCd.coord.xmax, 2, 50, 1.0);
		if(pCd.coord.xTick<1) pCd.coord.xTick = 1;
		if(pCd.coord.tmax<=pCd.coord.tmin) pCd.coord.tmax = pCd.coord.tmin + 8.;
		pCd.coord.tTick = getTickRounded(pCd.coord.tmin, pCd.coord.tmax, 2, 8, 1.0);

		para.isDistanceDisplay = FALSE; // this is important  

		if(draw.modeOld != 6) {
			pCd.coord.vred = 0.;
			head.modifiedtime = zeroTime;
		}
		draw.isSameDataDisplay = FALSE; //internal control and not saved.
		SetModifiedFlag();
		UpdateAllViews(NULL);
		NotifyChanged();

	}

	void CSeisWideDoc::OnViewHydro() 
	{
		if (draw.isDigitizing && (draw.mode>0 && draw.mode<5) ) 
		{
			AfxMessageBox(_T(" You are still digitizing in depth "), MB_OK |MB_ICONINFORMATION);
			return;
		}

		draw.modeOld = draw.mode;
		draw.mode = 7;	//Hydro Time section will be drawn.

		CdlgHydrateDisp dlg;
		dlg.m_clip = para.clip;
		dlg.m_faceDown = pCd.coord.isFaceUp;
		dlg.m_gain = para.gain;
		if(fabs(para.fillOff) > 10.) para.fillOff = 0.001;
		dlg.m_fillOff = para.fillOff;
		dlg.m_obsDepth = para.obsDepth;
		// dlg.m_gunDepth = para.gunDepth;

		if (para.waterVelocityAboveObs<-10. || para.waterVelocityAboveObs>15.) para.waterVelocityAboveObs = 0.f;
		// para.waterDepth = para.obsDepth;
		dlg.m_waterDepth = para.waterVelocityAboveObs;
		dlg.m_timeSecName = draw.timeSecName;
		dlg.m_velName = velMod.velSecName;
		dlg.m_timeSecTitle = draw.plotTitle;
		dlg.m_tmax = (float)pCd.coord.tmax;
		dlg.m_tmin = (float)pCd.coord.tmin;
		dlg.m_tTick = (float)pCd.coord.tTick;
		dlg.m_vRed = (float)pCd.coord.vred;
		dlg.m_wiggle = para.wiggle;
		dlg.m_xmax = pCd.coord.xmax;
		dlg.m_xmin = pCd.coord.xmin;
		dlg.m_xTick = pCd.coord.xTick;
		dlg.m_viewAsOffset = para.isDistanceDisplay;
		dlg.m_travelTime = para.traveltime;

		dlg.m_gainDist = para.gainDist;
		dlg.m_baseGain = (float)para.baseGain;
		dlg.m_basePower = (float)para.basePower;

		dlg.m_sphericOrder = para.sphericOrder;
		dlg.m_attenuationCorr = para.attenuationCorr;
		dlg.m_attenuationSeafloor =	para.attenuationSeafloor;
		dlg.m_isAvgAmp = draw.isAvgEnergy;
		dlg.m_isNegativeFill = para.isNegativeFill;


		dlg.seisBiColor.maxAmpR = seisBiColor2.maxAmpR;
		dlg.seisBiColor.maxAmpG = seisBiColor2.maxAmpG;
		dlg.seisBiColor.maxAmpB = seisBiColor2.maxAmpB;
		dlg.seisBiColor.negAmpR = seisBiColor2.negAmpR;
		dlg.seisBiColor.negAmpG = seisBiColor2.negAmpG;
		dlg.seisBiColor.negAmpB = seisBiColor2.negAmpB;
		dlg.m_digFileName = dig.digName;
		dlg.m_markerName = draw.markerName; 

		dlg.m_logScaleThreshold = ampColorDyn.logScaleThreshold;
		dlg.m_velWater = para.waterVelocityAboveObs;
		dlg.m_gundepth = para.gunDepth2;

		if (dlg.DoModal() == IDOK)
		{
			para.clip = dlg.m_clip;
			pCd.coord.isFaceUp = dlg.m_faceDown != 0;
			para.fillOff = dlg.m_fillOff;
			para.gain = dlg.m_gain;
			para.obsDepth = dlg.m_obsDepth;
			// para.gunDepth = dlg.m_gunDepth;
			para.waterVelocityAboveObs = dlg.m_waterDepth;
			draw.timeSecName = dlg.m_timeSecName.Trim();
			velMod.velSecName = dlg.m_velName.Trim();
			draw.plotTitle = dlg.m_timeSecTitle;
			pCd.coord.tmax = dlg.m_tmax;
			pCd.coord.tmin = dlg.m_tmin;
			pCd.coord.tTick = dlg.m_tTick;
			pCd.coord.vred = dlg.m_vRed;
			para.wiggle = dlg.m_wiggle;
			pCd.coord.xmax = (float)dlg.m_xmax;
			pCd.coord.xmin = (float)dlg.m_xmin;
			pCd.coord.xTick = (float)dlg.m_xTick;
			para.traveltime = dlg.m_travelTime;
			if(dlg.m_viewAsOffset != para.isDistanceDisplay) 
			{
				para.isDistanceDisplay = dlg.m_viewAsOffset;
				// head.timeSecModTime = NULL; //if here then "display as offset" is changed so recalculate gain.
			}
			para.gainDist = dlg.m_gainDist;
			para.baseGain = dlg.m_baseGain;
			para.basePower = dlg.m_basePower;

			para.sphericOrder = dlg.m_sphericOrder;
			para.attenuationCorr = dlg.m_attenuationCorr;
			para.attenuationSeafloor = dlg.m_attenuationSeafloor;
			draw.isAvgEnergy = dlg.m_isAvgAmp;
			para.isNegativeFill = dlg.m_isNegativeFill;


			seisBiColor2.maxAmpR = dlg.seisBiColor.maxAmpR;
			seisBiColor2.maxAmpG = dlg.seisBiColor.maxAmpG;
			seisBiColor2.maxAmpB = dlg.seisBiColor.maxAmpB;
			seisBiColor2.negAmpR = dlg.seisBiColor.negAmpR;
			seisBiColor2.negAmpG = dlg.seisBiColor.negAmpG;
			seisBiColor2.negAmpB = dlg.seisBiColor.negAmpB;
			dig.digName = dlg.m_digFileName;
			draw.markerName = dlg.m_markerName; 
			ampColorDyn.logScaleThreshold = dlg.m_logScaleThreshold;
			para.waterVelocityAboveObs = dlg.m_velWater;
			para.gunDepth2 = dlg.m_gundepth;
		}
		else
		{
			draw.mode = draw.modeOld;  // the action was canceled by the user
			return;
		}

		if(draw.modeOld != 0 && draw.modeOld!=7)
			head.modifiedtime = zeroTime; //recalculate amplitude parameters
		//because current paras are for depth sections.
		draw.isSameDataDisplay = FALSE; //internal control and not saved.

		SetModifiedFlag();
		UpdateAllViews(NULL);
		NotifyChanged();

	}

	void CSeisWideDoc::OnViewVelocitycolormap() 
	{
		if (draw.isDigitizing && (draw.mode<1 || (draw.mode>4 && draw.mode<10)) ) 
		{
			AfxMessageBox(_T(" Quit digitizing and then you can switch to depth domain."), MB_OK |MB_ICONINFORMATION);
			return;
		}
		draw.modeOld = draw.mode;
		draw.mode = 2;	//Velocity color map will be drawn.
		if(!myParas())
		{
			draw.mode = draw.modeOld;
			return;
		}
		//if (draw.modeOld == 9) {
		//	// the user likely changed the model in tm[] and we now need to re-calc the zm[] array
		//	myModel_TWTT_Depth(&velMod, (float)vel.dz);
		//}

		draw.isSameDataDisplay = FALSE; //indicate display has been changed and will re-load all data in OnDraw().
		SetModifiedFlag();
		UpdateAllViews(NULL);
		NotifyChanged();
	}







	void CSeisWideDoc::OnProcessingTimedepthConv()
	{
		// This routine converts segy data from time to depth.
		CString tStr;
		int j;

		CVelMod vm;

		//int icont;
		CdlgTim2Dpth dlg;
		dlg.m_xmax = (float)pCd.coord.xmax;
		dlg.m_xmin = (float)pCd.coord.xmin;
		dlg.m_depthSecName = draw.depthSecName;
		dlg.m_dz = (float)vel.dz;
		dlg.m_zmax = (float)pCd.coord.zmax;
		dlg.m_zmin = (float)pCd.coord.zmin;
		dlg.m_timeSecName = draw.timeSecName;

		dlg.m_depthSecName = getFileNameAppend(
			draw.timeSecName, 
			_T("_depth_")+ GetBaseFileName(velMod.velSecName)
			) ;

		if(fabs(para.sphericOrder) > 100.f) para.sphericOrder = 0.f;
		dlg.m_sphericOrder = para.sphericOrder; //not saved in documents
		dlg.m_velSecName = velMod.velSecName;
		dlg.m_distShift = draw.distShift;

		if (dlg.DoModal() == IDOK) {
			pCd.coord.xmax = dlg.m_xmax;
			pCd.coord.xmin = dlg.m_xmin;
			draw.depthSecName = dlg.m_depthSecName;
			vel.dz = dlg.m_dz;
			pCd.coord.zmax = dlg.m_zmax;
			pCd.coord.zmin = dlg.m_zmin;
			draw.timeSecName = dlg.m_timeSecName.Trim();
			para.sphericOrder = dlg.m_sphericOrder;	//not saved in documents
			velMod.velSecName = dlg.m_velSecName.Trim();
			draw.distShift = dlg.m_distShift;
		} else {
			return;
		}

		draw.depthSecName = mySetFileExtension(draw.depthSecName, _T("sgy"));

		if (!isFileExistNotDirectory(velMod.velSecName)) {
			AfxMessageBox(_T("Input velocity model invalid."));
			return;
		}

		segy tr;
		bhed bh;

		CFile file;
		if (!file.Open(draw.timeSecName, CFile::modeRead | CFile::typeBinary)) {
			AfxMessageBox(_T("Input time section cannot be read."));
			return;
		}
		CFile filez;
		if (!filez.Open(draw.depthSecName, CFile::modeCreate|CFile::modeWrite|CFile::typeBinary)) {
			file.Close();
			AfxMessageBox(_T("Output depth section cannot be created."));
			return;
		}



		file.Seek(0, CFile::begin);
		UINT bytesRead = file.Read(head.ascHead, 3200L);
		if(bytesRead < 3200) 
			AfxMessageBox(_T("Ascii section header read wrong"));
		file.Read(&bh, 400L);
		if(bytesRead < 400) 
			AfxMessageBox(_T("Binary section header read wrong"));
		//The following numbers have to be recalculated everytime,
		//because plotting the depth section will change these numbers.
		BOOL isUnixInFile = IsUnix(bh.format);
		if (isUnixInFile) SwapTapeHeader(&bh);
		int numsamp = bh.hns;
		int sampByte = (bh.format != 3) ?  4  :  2;
		short dformat_in = bh.format;
		int len = sampByte*numsamp + 240;
		int tpp = bh.hdt;

		long nzmin = (long)myRound (pCd.coord.zmin / vel.dz);
		long nzmax = (long)myRound (pCd.coord.zmax / vel.dz);

		//For progress control, need to know the last bytes no.
		LONGLONG curBytesRead, totBytesRead = file.GetLength();
		file.Seek(3600, CFile::begin);


		//Only after opening successfully, we begin progress control.
		CMainFrame* pFrame = 
			(CMainFrame*)AfxGetMainWnd();
		ASSERT(pFrame);
		ASSERT_KINDOF(CMainFrame, pFrame);
		if (pFrame) pFrame->BeginProgress();

		filez.Write(head.ascHead, 3200L);
		bh.hns = (WORD)(nzmax-nzmin+1); // numsamp;
		bh.nso = bh.hns;
		bh.format = pFrame->gIsIBMFloatSegy2  ?  1  :  5;



		bh.hdt = (unsigned short)(vel.dz*MIL);	//Sampling rate;
		bh.dto = bh.hdt;
		filez.Write(&bh, 400L);

		//Prepare to formulate velocity traces.
		long shot;
		WORD totShot=0;
		double oneodt = (double)MIL/(double)tpp;
		float *rData, *vTrc, *tTrc;
		rData = (float*)ealloc1(numsamp,sizeof(float));
		if (ERROR == rData) return;
		vTrc = (float*)ealloc1(nzmax+1,sizeof(float));
		if (ERROR == vTrc) return;
		tTrc = (float*)ealloc1(nzmax+1,sizeof(float));
		if (ERROR == tTrc) return;

		if (isTimeDomain())
			vm.myModel_TWTT2Depth(&velMod, vel.dz);
		else
			vm.myModel_Depth2TWTT(&velMod, vel.dz);

		CVelMod::VELMOD_X modX;
		double range;

		while (file.Read(&tr, len) == (UINT)len)
		{
			if (isUnixInFile) SwapTraceHeader(&tr);

			//Formulating velocity traces first.
			curBytesRead = file.Seek(0, CFile::current);
			int iPos = (int)((double)curBytesRead/(double)totBytesRead*100.);
			if(iPos<0)iPos=0;
			if(iPos>100)iPos=100;
			if (pFrame) pFrame->SetProgress(iPos);

			if(tr.trid==2) //dead traces.
			{
				// file.Seek(len, CFile::current);
				continue ;
			}

			shot = tr.tracl;

			range = getDistance(&tr) + draw.distShift;  //range here is actually distance.
			if(range > pCd.coord.xmax || range<pCd.coord.xmin ||
				range>velMod.xmax || range<velMod.xmin) continue;

			// compute vTrc[iz], where iz=[0, nzmax]
			modX.dist = range;
			vm.initModX(&velMod, &modX, false, true, false, vel.dz); 
			// assume depth model is defined, since we already did a conversion beforehand

			vm.getTzFromZMod(&modX, nzmax + 1, 0., vel.dz, tTrc);  
			// since depth is defined, we can get tTrc[]


			//Construct trace in depth domain. To save space, overwrite vTrc[] array.
			if(dformat_in==3)
				for (j=0; j<numsamp; j++) rData[j] = (float)tr.dat.datashort[j];
			else if (dformat_in==1) {
				// if (tr.idistopt==8 || pFrame->gIsIBMFloatSegy)
				ibm_to_float((int *) tr.dat.data, (int *) tr.dat.data, (int)numsamp);
				for (j=0; j<numsamp; j++) {
					rData[j] = tr.dat.data[j];
				}
			} // if
			else if (dformat_in==2) 
				for (j=0; j<numsamp; j++) rData[j] = (float)tr.dat.dataint[j];
			else if (dformat_in==5) {
				for (j=0; j<numsamp; j++) {
					rData[j] = tr.dat.data[j];
				}
			} // if
			else continue;

			if(para.sphericOrder > 0.f)
			{
				double a = getTraceDelay(&tr);  // a is now the initial time in sec for this trace
				double b;
				for (j=0; j<numsamp; j++) {
					b = a + j* (double)tpp / (double)MIL;      // b is now the actual time in sec for the inidex j
					if (b > 1.0)
						rData[j] *= (float)pow(b,(double)para.sphericOrder);
				}
			}

			ints8r((int)numsamp, (float)(1./oneodt), 
				getTraceDelay(&tr), 
				rData, 0.f, 0.f, (int)(nzmax-nzmin+1), (float *)&tTrc[nzmin], (float *)&vTrc[nzmin]);


			memcpy( (void *)tr.dat.data, (void *)&vTrc[nzmin], (nzmax-nzmin+1)*sizeof(float));
			setTraceDelayF(&tr, pCd.coord.zmin);
			setDistance(&tr, range);
			tr.ns = (unsigned short)(nzmax-nzmin+1);
			tr.dt = (unsigned short)(vel.dz*MIL);


			if ( bh.format==1 ) {
				//tr.idistopt = 8;
				float_to_ibm((int *) tr.dat.data, (int *) tr.dat.data, (int)tr.ns);
			}

			filez.Write(&tr, (long)(240+tr.ns*4));

			totShot++;

			//_stprintf(s, "Shot,range=%d,%d,v[0],v[max],tmax: %d %d %d",shot,ssmic.iv,(long)(vTrc[0]*1000),(long)(vTrc[nzmax-nzmin]*1000),(long)(tTrc[nzmax-nzmin]*1000));
			//AfxMessageBox(s);
		}

		filez.Seek(3212L, CFile::begin);
		filez.Write(&totShot, 2);
		file.Close();
		filez.Close();

		if (pFrame) pFrame->EndProgress();

		//Free up space
		free1float(rData);
		free1float(vTrc);
		free1float(tTrc);

		//Auto change mode to display both.
		para.isDistanceDisplay = TRUE;  // set display using distance instead of offset, this avoids problems in  amplitude prepararing and calculation in display
		draw.modeOld = draw.mode;
		draw.mode = 3;	//Both velocity color and depth sections will be drawn.
		draw.depthSecOld = _T("");	//recalculate gain.
		this->clearGDC(); // after the new segy depth file generated, we need to clear gDC otherwise it's clustered with old data
		draw.isSameDataDisplay = FALSE; //indicate display has been changed and will re-load all data in OnDraw().

		SetModifiedFlag();
		UpdateAllViews(NULL);
		NotifyChanged();


	}

	void CSeisWideDoc::OnProcessingTdconvbmp() 
	{
		// This routine converts bitmapped segy data from time to depth.
		//the bitmap must be properly displayed on screen before continue.
		//	int icont, j;
		int row,row1,nrow,nrow1, col,col1,ncol,ncol1;
		BYTE  r, g, b;
		FILE* fou;
		TCHAR * name;
		unsigned char* bmpline;
		float tempf;
		//	TCHAR s[80];
		CString newName;
		CString tStr;

		if(!CheckTime(100)) {
			return;
		}

		if (!isFileExistNotDirectory(bmp24.bmp24Name))
			return;
		if (bmp24.isDepth) {
			AfxMessageBox(_T("Please import a bitmap file that is in two-way travel-time."));
			return;
		}

		if (pCd.coord.isFaceUp==1) {
			tempf = bmp24.ymin;
			bmp24.ymin = bmp24.ymax;
			bmp24.ymax = tempf;
		}

		CSize siz = bmp24.bmpDC.GetWindowExt();
		ncol = siz.cx;
		nrow = siz.cy;

		CdlgTimDepthBMP dlg;
		dlg.m_bmpIN = bmp24.bmp24Name;
		dlg.m_bmpOUT = bmp24.bmp24Name + _T("Out.bmp");
		dlg.m_col = ncol;
		dlg.m_row = 2*nrow;
		dlg.m_velSecName = velMod.velSecName;
		dlg.m_xmax = (float)pCd.coord.xmax;
		dlg.m_xmin = (float)pCd.coord.xmin;
		dlg.m_zmax = (float)pCd.coord.zmax;
		dlg.m_zmin = (float)pCd.coord.zmin;
		dlg.m_bitSize = (bmp24.biForm == 1)?0:1;
		if(dlg.DoModal() == IDOK)
		{
			bmp24.bmp24Name = dlg.m_bmpIN;
			newName = dlg.m_bmpOUT;
			ncol1 = dlg.m_col;
			nrow1 = dlg.m_row;
			velMod.velSecName = dlg.m_velSecName.Trim();
			pCd.coord.xmax = dlg.m_xmax ;
			pCd.coord.xmin = dlg.m_xmin;
			pCd.coord.zmax = dlg.m_zmax;
			pCd.coord.zmin = dlg.m_zmin ;
			bmp24.biForm = (dlg.m_bitSize==0)? 1:24 ;
		}
		delete dlg;

		//now in output, pCd.coord.zmin to pCd.coord.zmax would cover nrow1 pixels.
		//so 1 pixel is (pCd.coord.zmax-pCd.coord.zmin)/(nrow1-1) km.
		double dx = (pCd.coord.xmax-pCd.coord.xmin)/(ncol1-1.0);
		double dz = (pCd.coord.zmax-pCd.coord.zmin)/(nrow1-1.0);
		long nzmin = (int)myRound (pCd.coord.zmin / dz);
		long nzmax = (int)myRound (pCd.coord.zmax / dz);
		COLORREF *colArray; //32-bit color values.

		//Prepare to formulate velocity traces.
		long iz;
		float *vTrc, *tTrc;
		vTrc = (float*)ealloc1(nzmax+1,sizeof(float));
		if (ERROR == vTrc) return;
		tTrc = (float*)ealloc1(nzmax+1,sizeof(float));
		if (ERROR == tTrc) return;
		colArray = (COLORREF *)malloc(nrow1*ncol1*sizeof(COLORREF));
		if (colArray == NULL)
		{
			AfxMessageBox(_T("Can not allocate memory for bitmap"));
			return;
		}


		//Begin progress control.
		CMainFrame* pFrame = 
			(CMainFrame*)AfxGetMainWnd();
		ASSERT(pFrame);
		ASSERT_KINDOF(CMainFrame, pFrame);
		if (pFrame) pFrame->BeginProgress();

		CVelMod vm;
		vm.myModel_TWTT2Depth(&velMod, vel.dz);

		double a, z, range;
		CVelMod::VELMOD_X modX;

		range = pCd.coord.xmin-dx;
		for (col1=0; col1<ncol1; col1++)
		{
			range += dx;  //range here is actually distance in km.

			if(range<velMod.xm[0][0] || range>velMod.xm[velMod.nzed[0]-1][0] ) 
			{
				for (iz=nzmin; iz<=nzmax; iz++)
				{
					row1 = iz - nzmin;
					colArray[row1*ncol1+col1] = RGB(255,255,255);
				}
				continue;
			}

			modX.dist = range;
			vm.initModX(&velMod, &modX, false, true, false, vel.dz);
			//	vm.getZModFromZ(&velMod, &modX);
			vm.getTzFromZMod(&modX, nzmax + 1, 0., vel.dz, tTrc);

			//Construct trace in depth domain. To save space, reuse vTrc[] array.
			col = (int)myRound((range-bmp24.xmin)/(bmp24.xmax - bmp24.xmin)*(ncol-1)); //corresponding col in original bitmap.
			a = 1./(bmp24.ymax-bmp24.ymin)*(nrow-1);
			for (iz=nzmin; iz<=nzmax; iz++)
			{
				row1 = iz - nzmin;
				z = pCd.coord.zmin + (iz-nzmin)*dz;
				row = (int)myRound((tTrc[iz]-bmp24.ymin)*a); //corresponding row in original bitmap.
				if (row<0 || row>nrow-1 || col<0 || col>ncol-1)
					colArray[row1*ncol1+col1] = RGB(255,255,255);
				else
					colArray[row1*ncol1+col1] = bmp24.bmpDC.GetPixel(col,row);
			}

			int iPos = (int)((float)col1/(float)ncol1*100.0);
			if(iPos<0)iPos=0;
			if(iPos>100)iPos=100;
			if (pFrame) pFrame->SetProgress(iPos);

		}

		//Free up space
		free1float(vTrc);
		free1float(tTrc);

		//start writing to file.
		newName = mySetFileExtension(newName, _T("bmp"));

		//generate a new file for holding output bitmap.
		name = newName.GetBuffer(newName.GetLength());
		if (0==(fou = BMP24CreateWriteStream(name, ncol1, nrow1, bmp24.biForm)) ) 
		{
			AfxMessageBox(_T("Unable to generate a new file for output\n"));
			free (colArray);
			return;
		}
		newName.ReleaseBuffer();
		if (0==(bmpline=BMP24CreateLineBuffer(ncol1, bmp24.biForm)) )
		{
			AfxMessageBox(_T("Unable to allocate memory for holding bitmap data"));
			free (colArray);
			return;
		}

		for (row1=0; row1<nrow1; row1++) {
			int iPos = (int)((float)row1/(float)nrow1*100.0);
			if(iPos<0)iPos=0;
			if(iPos>100)iPos=100;
			if (pFrame) pFrame->SetProgress(iPos);

			for(col1=0; col1<ncol1; col1++) {
				if(colArray[row1*ncol1+col1] < 0)
					r=g=b=255;
				else
				{
					r   = (int)GetRValue(colArray[row1*ncol1+col1]);
					g   = (int)GetGValue(colArray[row1*ncol1+col1]);
					b   = (int)GetBValue(colArray[row1*ncol1+col1]);
				}
				BMP24SetRow(bmpline, col1, r, g, b, bmp24.biForm);
			}
			BMP24WriteRow(bmpline, ncol1, fou, bmp24.biForm);
			//	_ftprintf_s(stdout, _T("%s: %d rows total. %3d rows remaining        \r", fnou, nrow, nrow-1-row);
			// fflush(stdout);
		}

		//close bitmap file.
		fclose(fou);
		if (pFrame) pFrame->EndProgress();
		free(bmpline);
		free (colArray);
		bmp24.bmp24Name  = newName;
		bmp24.isNeedInitialize = TRUE;
		bmp24.isDepth = TRUE;
		bmp24.xmax = (float)pCd.coord.xmax;
		bmp24.xmin = (float)pCd.coord.xmin;
		bmp24.ymax = (float)pCd.coord.zmax;
		bmp24.ymin = (float)pCd.coord.zmin;

		//Auto change mode to display both.
		draw.modeOld = draw.mode;
		draw.mode = 3;	//Both velocity contours and depth sections will be drawn.
		draw.isNoColorMap = TRUE; //don't let color map overlay bitmap.
		draw.isSameDataDisplay = FALSE; //indicate display has been changed and will re-load all data in OnDraw().

		SetModifiedFlag();
		UpdateAllViews(NULL);
		NotifyChanged();

	}

	void CSeisWideDoc::OnViewDepthsection() 
	{
		draw.modeOld = draw.mode;
		if (draw.isDigitizing && (draw.mode<1 || draw.mode>4) ) 
		{
			AfxMessageBox(_T(" You are still digitizing a time section "), MB_OK |MB_ICONINFORMATION);
			return;
		}


		if(!myParas())
		{
			return;
		}
		//if (draw.modeOld == 9) {
		//	// the user likely changed the model in tm[] and we now need to re-calc the zm[] array
		//	myModel_TWTT_Depth(&velMod, (float)vel.dz);
		//}

		draw.mode = 1;	//Depth section will be drawn.
		draw.isSameDataDisplay = FALSE; //indicate display has been changed and will re-load all data in OnDraw().

		SetModifiedFlag();
		UpdateAllViews(NULL);
		NotifyChanged();
	}

	void CSeisWideDoc::OnProcessingAddrangetosegy() 
	{
		// Associate km to trace
		static double aFactor = 1. / 360000.;
		long trcRef,trcRef0 = -99999;
		double range,x0,dx;

		const int NUMPOINTS = 99999;
		int *xx = NULL;
		float *yy = NULL;
		int numPoints;
		bool isShotTable = false;

		CString name, nameOffset;
		segy tr;
		bhed bh;

		static int distMethod = 2;
		static int assignMethod = 0;
		static int refTrace = 0;
		CdlgAddRange dlg;
		dlg.m_refName = draw.timeSecName;
		dlg.m_refCDPTrue = distMethod;
		dlg.m_assignMethod = assignMethod;
		dlg.m_refTrace = refTrace;
		if (dlg.DoModal() == IDOK)
		{
			name = dlg.m_refName;
			x0 = dlg.m_refRange;
			dx = dlg.m_refDx;
			//		deadkm = dlg.m_deadkm;
			distMethod = dlg.m_refCDPTrue;	//0 means use CDP, 1 means use FFID, 2=seq. trace no..
			assignMethod = dlg.m_assignMethod;
			nameOffset = dlg.m_nameOffset;
			refTrace = dlg.m_refTrace;
		}
		else 
		{
			return;
		}
		delete dlg;
		if (nameOffset.Find(_T(".sht")) > 0) isShotTable = true;

		if (!isFileExistNotDirectory(name)) return;

		if(assignMethod==2 || assignMethod==3)
		{
			if (!isFileExistNotDirectory(nameOffset)) 
			{
				AfxMessageBox(_T("Please specify a file name for assigning offset|distance info"));
				return;
			}


			CStringArray *kmTraces = getLinesFromFile(nameOffset);
			if (isShotTable) kmTraces->RemoveAt(0, 7);
			numPoints = (int)kmTraces->GetCount();
			if (numPoints < 2) {
				AfxMessageBox(_T("At least 2 points are needed for assigning offset|distance info"));
				return;
			}

			xx = (int *)malloc(numPoints *sizeof(int));
			yy = (float *)malloc(numPoints * sizeof(float));

			if (isShotTable) {
				// shot table format
				for (int i=0;i<numPoints;++i)
				{
					//read in trace no., and offset/distance in m.
					if ( _stscanf_s(kmTraces->ElementAt(i), _T("%d %*d %*d %*d %*f %*f %*f %f"),&xx[i],&yy[i]) == 0) continue;
				}
			}
			else {
				for (int i=0;i<numPoints;++i)
				{
					//read in trace no., and offset/distance in m.
					if ( _stscanf_s(kmTraces->ElementAt(i), _T("%d%f"),&xx[i],&yy[i]) == 0) continue;
				}
			} // else if isShotTable
			if (kmTraces!=NULL) {
				kmTraces->RemoveAll();
				delete kmTraces;
			} 
		}
		draw.timeSecName = name;

		double longOld, latOld;
		double longNew, latNew;
		if(assignMethod==6) {
			CSegyMeta::segyHeadInit(draw.timeSecName, &head, 0);
			SegyWrapper sw(draw.timeSecName, true);
			int ix = 0;
			int nxDesired = (refTrace==0)  ?  1  :  0;
			//if (refTrace==0) {
			//	// to save CPU time, we just need the first trace
			//	sw.nxDesired = 1;
			//}

			if (sw.openTrace(0, 99999, 1, nxDesired, &head)) {
				// read all the trace headers
				if (refTrace>0)
					ix = sw.getClosestTrcIndexAtTraceNum((float)refTrace);
				// if refTrace==0, do not assign ix here!
			}

			if (ix >= 0) {
				longOld = sw.trArr[ix].gx * aFactor; 
				latOld = sw.trArr[ix].gy * aFactor; 
			}
		} // if


		CFile file;
		if (!file.Open(name, CFile::modeReadWrite | CFile::typeBinary)) {
			AfxMessageBox(_T("Input time section cannot be read."));
			return;
		}
		LONGLONG bytesRead = file.Seek(3200L, CFile::begin);
		if(bytesRead < 3200) 
		{
			file.Close();
			AfxMessageBox(_T("Ascii section header read wrong"));
			return;
		}
		bytesRead = file.Read(&bh, 400);
		if(bytesRead < 400) 
		{
			file.Close();
			AfxMessageBox(_T("Binary section header read wrong"));
			return;
		}
		if (IsUnix(bh.format)) {
			file.Close();
			AfxMessageBox(_T("Please convert the segy file to PC format first."));
			return;
		}
		int numsamp = bh.hns;
		int format = bh.format;
		int len;
		if(format!=3)  
			len = numsamp*4 + 240;
		else
			len = numsamp*2 + 240;
		int tpp = bh.hdt;
		//	_stprintf(s, _T("i2buf[8-12]: %d %d %d %d",(long)i2buf[8],i2buf[9],i2buf[10],i2buf[12]);
		//	AfxMessageBox(s);

		//For progress control, need to know the last bytes no.
		LONGLONG curBytesRead, totBytesRead = file.GetLength();
		file.Seek(3600, CFile::begin);

		//Begin progress control.
		CMainFrame* pFrame = 
			(CMainFrame*)AfxGetMainWnd();
		ASSERT(pFrame);
		ASSERT_KINDOF(CMainFrame, pFrame);
		if (pFrame) pFrame->BeginProgress();

		int numTraceSeq = 0;
		range = 0.0;  // initialize it
		double rangeOld = 0.0f;
		while (file.Read(&tr, 240) == 240)
		{
			curBytesRead = file.Seek(0, CFile::current);
			int iPos = (int)((double)curBytesRead/(double)totBytesRead*100.);
			if(iPos<0)iPos=0;
			if(iPos>100)iPos=100;
			if (pFrame) pFrame->SetProgress(iPos);

			if(distMethod==0)
				trcRef = tr.cdp;	 //really CDP
			else if(distMethod==1)
				trcRef = tr.fldr;	//FFID
			else
				trcRef = numTraceSeq;	
			//TRACE Number: sometimes tr.tracl=0 always, so we use numTraceSeq instead

			if (trcRef0 == -99999) trcRef0 = trcRef;

			if(assignMethod==0)
			{
				//Note dist can be either CDP or FFID.
				range = x0 + (double)(trcRef-trcRef0)*dx;
				// if (tr.cdpbak == 0) tr.cdpbak = tr.cdp;  // do backup original cdp first!
				setDistance(&tr, (float)range );
			}
			else if(assignMethod==1)
			{
				tr.sx = tr.gx + (int)getOffset(&tr)*1000;
				setDistance(&tr, getOffset(&tr));
				range = getOffset(&tr);
			}
			else if(assignMethod==2)
			{
				setOffset(&tr, getDistance(&tr));
			}
			else if(assignMethod==3)
			{
				// assign offset info based on ascii file nameOffset.

				// now find the 2 shots beside thsi dist0 from xx[] and yy[]
				int iSel = -1;
				for (int i=0; i<numPoints; i++) {
					if (xx[i] >= trcRef) {
						// we found it
						iSel = i;
						break;
					}
				}

				if (iSel < 0) {
					// this means it is not found. We use the last point
					iSel = numPoints - 1;
				}
				if (iSel == 0) iSel = 1; 

				if (iSel >= 0) {
					int tmp = xx[iSel] - xx[iSel-1];
					// note that yy[] is in meters
					if (tmp == 0) 
						setOffset(&tr, yy[iSel-1]*0.001f);
					else
						setOffset(&tr, yy[iSel-1] + (yy[iSel] - yy[iSel-1]) * (trcRef - xx[iSel-1]) / (float)tmp * 0.001f);
				}
				range = tr.offset;
			}
			else if(assignMethod==4)
			{
				// assign dist distance info based on ascii file nameOffset.
				// now find the 2 shots beside thsi dist0 from xx[] and yy[]
				int iSel = -1;
				for (int i=0; i<numPoints; i++) {
					if (xx[i] >= trcRef) {
						// we found it
						iSel = i;
						break;
					}
				}

				if (iSel < 0) {
					// this means it is not found. We use the last point
					iSel = numPoints - 1;
				}
				if (iSel == 0) iSel = 1; 

				if (iSel >= 0) {
					int tmp = xx[iSel] - xx[iSel-1];
					// note that yy[] is in meters
					if (tmp == 0) 
						range = yy[iSel-1];
					else
						range = yy[iSel-1] + (yy[iSel] - yy[iSel-1]) * (trcRef - xx[iSel-1]) / (float)tmp;
				}

				setDistance(&tr, (float)range );
			}
			else if(assignMethod==5)
			{
				// assign curved distance 
				longNew = tr.gx * aFactor; 
				latNew = tr.gy * aFactor; 
				if (numTraceSeq > 0) {
					range = rangeOld + calcDist(longOld, latOld, longNew, latNew);
				}
				else {
					// if here, it is the first trace, which has 0 distance
				}
				setDistance(&tr, range);

				longOld = longNew;
				latOld = latNew;
				rangeOld = range;
			}
			else if(assignMethod==6)
			{
				// assign straight distance based on lat/long of the first trace only
				longNew = tr.gx * aFactor; 
				latNew = tr.gy * aFactor; 
				range = calcDist(longOld, latOld, longNew, latNew);
				if (tr.tracl < refTrace) range = -range;
				setDistance(&tr, range);
			}

			file.Seek(-240, CFile::current);
			file.Write(&tr, 240);
			file.Seek(len-240, CFile::current);
			numTraceSeq ++;

		}
		file.Close();
		if ( xx != NULL) free(xx);
		if ( yy != NULL) free(yy);

		if (pFrame) pFrame->EndProgress();
		CString ts;
		ts.Format(_T("Last trc %d at %fkm"),numTraceSeq, myFloat(range));
		myCaption(ts);

		//	draw.timeSecOld = _T("");
		//	para.isDistanceDisplay = 1;   // should now display in distance
		// para.isDistanceDisplay = 1;	//suggest to display as distance instead of offset.
		//	para.segyOrder = TRUE;	//suggest that the segy file is order properly.
	}

	BOOL CSeisWideDoc::myChangeDrive(CString *driveNew)
	{
		// depreciated
		// note: driveNew is usually a static variable. Once changed in one DOC
		// it'll be assigned for all opened windows.

		// but so far only called by myParas(). Cannot be called by serialize() due to 
		// static issues unresulved yet.

		TCHAR c = (*driveNew).GetAt(0);
		if (  c < 0x7c ||  c > 0x82)   return false;

		TRY
		{
			if (!draw.timeSecName.IsEmpty()) {
				if (draw.timeSecName.GetAt(1)==':') {
					draw.timeSecName.SetAt(0, c);
				}
			}
			if (!draw.depthSecName.IsEmpty()) {
				if (draw.depthSecName.GetAt(1)==':') {
					draw.depthSecName.SetAt(0, c);
				}
			}
			if (!velMod.velSecName.IsEmpty()) {
				if (velMod.velSecName.GetAt(1)==':') {
					velMod.velSecName.SetAt(0, c);
				}
			}
			if (!draw.rayName.IsEmpty()) {
				if (draw.rayName.GetAt(1)==':') {
					draw.rayName.SetAt(0, c);
				}
			}
			if (!dig.digName.IsEmpty()) {
				if (dig.digName.GetAt(1)==':') {
					dig.digName.SetAt(0, c);
				}
			}
			if (!bmp24.bmp24Name.IsEmpty()) {
				if (bmp24.bmp24Name.GetAt(1)==':') {
					bmp24.bmp24Name.SetAt(0, c);
				}
			}
			return TRUE;
		}
		CATCH_ALL(e)
		{
			*driveNew = _T("");
			return FALSE;
		}
		END_CATCH_ALL
	}

	BOOL CSeisWideDoc::myParas()
	{
		if (draw.isPrinting > 0 && isModelDisplayed()) return TRUE;
		if (isFileExistNotDirectory(bmp24.bmp24Name) && (isTimeDomain() == !bmp24.isDepth))  {
			CdlgDispBitmap dlg;
			dlg.m_title = draw.plotTitle;
			dlg.m_xMax = (float)pCd.coord.xmax;
			dlg.m_xMin = (float)pCd.coord.xmin;
			dlg.m_xTick = (float)pCd.coord.xTick;
			dlg.m_faceDown = pCd.coord.isFaceUp;
			dlg.m_offset = para.isDistanceDisplay;
			if (isTimeDomain()) {
				dlg.m_yMax = (float)pCd.coord.tmax;
				dlg.m_yMin = (float)pCd.coord.tmin;
				dlg.m_yTick = (float)pCd.coord.tTick;
			} else {
				dlg.m_yMax = (float)pCd.coord.zmax;
				dlg.m_yMin = (float)pCd.coord.zmin;
				dlg.m_yTick = (float)vel.zTick;
			}
			dlg.m_vred = (float)pCd.coord.vred;
			dlg.m_velFileName = velMod.velSecName;
			dlg.m_srcPos = (float)tx.xShot;
			if (dlg.DoModal() == IDOK) {
				draw.plotTitle = dlg.m_title;
				pCd.coord.xmax = dlg.m_xMax;
				pCd.coord.xmin = dlg.m_xMin;
				pCd.coord.xTick = dlg.m_xTick;
				pCd.coord.isFaceUp = dlg.m_faceDown != 0;
				para.isDistanceDisplay = dlg.m_offset;
				if (isTimeDomain()) {
					pCd.coord.tmax = dlg.m_yMax;
					pCd.coord.tmin = dlg.m_yMin;
					pCd.coord.tTick = dlg.m_yTick;
				} else {
					pCd.coord.zmax = dlg.m_yMax;
					pCd.coord.zmin = dlg.m_yMin;
					vel.zTick = dlg.m_yTick;
				}
				pCd.coord.vred = dlg.m_vred;
				velMod.velSecName = dlg.m_velFileName.Trim();
				tx.xShot = dlg.m_srcPos;
				return TRUE;
			}
			else return FALSE;
		}

		CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
		CPropertySheet sheet(_T("Combined Parameter List") );

		CdlgTIMESEC1 dlg;	//This is now actually general plotting parameters, not really for time section.
		dlg.m_clip = myFloat3(para.clip);
		dlg.m_faceDown = pCd.coord.isFaceUp;
		dlg.m_gain = (float)para.gain;  // do not use myFloat3() here
		if(fabs(para.fillOff) > 10.) para.fillOff = 0.001;
		dlg.m_fillOff = (float)para.fillOff;
		dlg.m_timeSecTitle = draw.plotTitle;
		dlg.m_wiggle = para.wiggle;
		dlg.m_timeSecName = draw.timeSecName;
		dlg.m_offset = para.isDistanceDisplay;
		dlg.m_xmax = myFloat3(pCd.coord.xmax);
		dlg.m_xmin = myFloat3(pCd.coord.xmin);
		dlg.m_xTick = myFloat3(pCd.coord.xTick);
		dlg.m_isNegativeFill = para.isNegativeFill;
		dlg.m_isAvgAmp = draw.isAvgEnergy;
		dlg.m_maxLevels = draw.numContours;
		dlg.m_logScaleThreshold = ampColorDyn.logScaleThreshold;

		dlg.seisBiColor.maxAmpR = seisBiColor2.maxAmpR;
		dlg.seisBiColor.maxAmpG = seisBiColor2.maxAmpG;
		dlg.seisBiColor.maxAmpB = seisBiColor2.maxAmpB;
		dlg.seisBiColor.negAmpR = seisBiColor2.negAmpR;
		dlg.seisBiColor.negAmpG = seisBiColor2.negAmpG;
		dlg.seisBiColor.negAmpB = seisBiColor2.negAmpB;

		CdlgDEPTH1 dlg1;
		dlg1.mode = draw.mode;
		dlg1.m_depthSecName = draw.depthSecName;
		dlg1.m_dz = vel.dz;
		dlg1.m_zmax = myFloat3(pCd.coord.zmax);
		dlg1.m_zmin = myFloat3(pCd.coord.zmin);
		dlg1.m_zTick = myFloat3(vel.zTick);
		//	dlg1.m_timeSecName = draw.timeSecName;
		dlg1.m_tmax = myFloat3(pCd.coord.tmax);
		dlg1.m_tmin = myFloat3(pCd.coord.tmin);
		dlg1.m_tTick = myFloat3(pCd.coord.tTick);
		dlg1.m_vred = myFloat3(pCd.coord.vred);
		dlg1.m_travelTime = para.traveltime;
		dlg1.m_gainDist = para.gainDist;
		dlg1.m_baseGain = myFloat3(para.baseGain);
		dlg1.m_basePower = myFloat3(para.basePower);
		dlg1.m_rayTracing = draw.rayName;
		dlg1.m_digName = dig.digName;
		dlg1.m_isShowLabel4LineDrawing = dig.isLabelShow;
		dlg1.m_distShift = draw.distShift;


		CdlgVELOCITY1 dlg2;
		dlg2.m_velSecName = velMod.velSecName;
		dlg2.m_floatName = velMod.floatName;
		dlg1.m_markerName = draw.markerName; // addition on Nov. 14, 2003
		dlg1.m_xMultFactor = draw.markerXMultFactor;
		dlg1.m_xShift = draw.markerXShift;
		dlg1.m_yMultFactor = draw.markerYMultFactor;
		dlg1.m_markerRevYAxis = draw.markerIsRevYAxis;
		dlg1.m_yShift = draw.markerYShift;

		dlg2.m_vrmsTauName = draw.vrmsTauName;
		dlg2.m_dxV = vel.dxVDesired;
		dlg2.m_vmin = vel.vmin;
		dlg2.m_vmid = vel.vmid;
		dlg2.m_vmax = vel.vmax;
		dlg2.m_vminR = vel.vminR;
		dlg2.m_vminG = vel.vminG;
		dlg2.m_vminB = vel.vminB;
		dlg2.m_vmidR = vel.vmidR;
		dlg2.m_vmidG = vel.vmidG;
		dlg2.m_vmidB = vel.vmidB;
		dlg2.m_vmaxR = vel.vmaxR;
		dlg2.m_vmaxG = vel.vmaxG;
		dlg2.m_vmaxB = vel.vmaxB;

		//These are additions of version 2.0
		dlg2.m_colBar = draw.colBar;
		dlg2.m_colBarVmin = vel.colBarVmin;
		dlg2.m_colBarVmax = vel.colBarVmax;
		dlg2.m_cxExt= (float)vel.cxExt;
		dlg2.m_cxPos=	(float)vel.cxPos;
		dlg2.m_cyExt=	(float)vel.cyExt;
		dlg2.m_cyPos=	(float)vel.cyPos;
		dlg2.m_vmid2=	vel.vmid2;
		dlg2.m_vmid3=	vel.vmid3;
		dlg2.m_vmid4=	vel.vmid4;
		dlg2.m_vmid5=	vel.vmid5;
		dlg2.m_vmid6=	vel.vmid6;
		dlg2.m_vmid7=	vel.vmid7;
		dlg2.m_vmid8=	vel.vmid8;

		dlg2.m_vmidB2=	vel.vmidB2;
		dlg2.m_vmidB3=	vel.vmidB3;
		dlg2.m_vmidB4=	vel.vmidB4;
		dlg2.m_vmidB5=	vel.vmidB5;
		dlg2.m_vmidB6=	vel.vmidB6;
		dlg2.m_vmidB7=	vel.vmidB7;
		dlg2.m_vmidB8=	vel.vmidB8;

		dlg2.m_vmidG2=	vel.vmidG2;
		dlg2.m_vmidG3=	vel.vmidG3;
		dlg2.m_vmidG4=	vel.vmidG4;
		dlg2.m_vmidG5=	vel.vmidG5;
		dlg2.m_vmidG6=	vel.vmidG6;
		dlg2.m_vmidG7=	vel.vmidG7;
		dlg2.m_vmidG8=	vel.vmidG8;

		dlg2.m_vmidR2=	vel.vmidR2;
		dlg2.m_vmidR3=	vel.vmidR3;
		dlg2.m_vmidR4=	vel.vmidR4;
		dlg2.m_vmidR5=	vel.vmidR5;
		dlg2.m_vmidR6=	vel.vmidR6;
		dlg2.m_vmidR7=	vel.vmidR7;
		dlg2.m_vmidR8=	vel.vmidR8;

		dlg2.m_dv1= (float)vel.dv1;
		dlg2.m_xWell = (float)tx.xShot;
		dlg2.m_velModExtras = draw.velSecNamesEx;

		dlg.mode = dlg1.mode = draw.mode; //this tells the dialog box initialization to disable some particular items.

		//More additions:
		dlg.m_psp.dwFlags &= ~(PSP_HASHELP);
		dlg1.m_psp.dwFlags &= ~(PSP_HASHELP);
		dlg2.m_psp.dwFlags &= ~(PSP_HASHELP);
		sheet.AddPage(&dlg);
		sheet.AddPage(&dlg1);
		sheet.AddPage(&dlg2);
		if( draw.mode >= 2 && draw.mode <= 4 ) {
			sheet.SetActivePage(&dlg2);
		}
		else
			if(draw.mode == 1 || draw.mode == 10) {
				sheet.SetActivePage(&dlg1);
			}



			if (sheet.DoModal() == IDOK)
			{
				draw.plotTitle = dlg.m_timeSecTitle;
				draw.timeSecName = dlg.m_timeSecName.Trim();
				para.clip = dlg.m_clip;
				pCd.coord.isFaceUp = dlg.m_faceDown != 0;
				para.gain = dlg.m_gain;
				para.fillOff = dlg.m_fillOff;
				para.wiggle = dlg.m_wiggle;
				// ampColorDyn.colFileName = dlg.m_colPalette;
				pCd.coord.xmax = (float)dlg.m_xmax;
				pCd.coord.xmin = (float)dlg.m_xmin;
				pCd.coord.xTick = (float)dlg.m_xTick;
				// para.colorFillIllumination = dlg.m_illumination;
				para.isNegativeFill = dlg.m_isNegativeFill;
				draw.isAvgEnergy = dlg.m_isAvgAmp;


				seisBiColor2.maxAmpR = dlg.seisBiColor.maxAmpR;
				seisBiColor2.maxAmpG = dlg.seisBiColor.maxAmpG;
				seisBiColor2.maxAmpB = dlg.seisBiColor.maxAmpB;
				seisBiColor2.negAmpR = dlg.seisBiColor.negAmpR;
				seisBiColor2.negAmpG = dlg.seisBiColor.negAmpG;
				seisBiColor2.negAmpB = dlg.seisBiColor.negAmpB;
				draw.numContours = dlg.m_maxLevels;
				ampColorDyn.logScaleThreshold = dlg.m_logScaleThreshold;
				if (ampColorDyn.logScaleThreshold<0) ampColorDyn.logScaleThreshold = 0;
				else if (ampColorDyn.logScaleThreshold > 100) ampColorDyn.logScaleThreshold = 100;


				draw.depthSecName = dlg1.m_depthSecName;
				// vel.dz = dlg1.m_dz;	dz not to be changed from here.
				pCd.coord.zmax = dlg1.m_zmax;
				pCd.coord.zmin = dlg1.m_zmin;
				vel.zTick = dlg1.m_zTick;
				pCd.coord.tmax = dlg1.m_tmax;
				pCd.coord.tmin = dlg1.m_tmin;
				pCd.coord.tTick = dlg1.m_tTick;
				pCd.coord.vred = dlg1.m_vred;

				if(draw.isDigitizing && dlg.m_offset != para.isDistanceDisplay)
				{
					AfxMessageBox(_T("You can not switch between offset and distance display while digitizing"));
					return FALSE;
				}
				if(dlg.m_offset != para.isDistanceDisplay) 
				{
					para.isDistanceDisplay = dlg.m_offset;
					// draw.timeSecOld = _T(""); //if here then "display as offset" is changed so recalculate gain.
				}
				//	para.oriShot = dlg1.m_oriYes;
				para.traveltime = dlg1.m_travelTime;
				para.gainDist = dlg1.m_gainDist;
				para.baseGain = dlg1.m_baseGain;
				para.basePower = dlg1.m_basePower;
				dig.digName = dlg1.m_digName;
				if (!dig.digName.IsEmpty()) {
					velMod.floatNameOld = _T("");
				}
				dig.isLabelShow = dlg1.m_isShowLabel4LineDrawing;
				draw.distShift = dlg1.m_distShift;

				velMod.velSecName = dlg2.m_velSecName.Trim();
				velMod.floatName = dlg2.m_floatName;
				draw.markerName = dlg1.m_markerName; // addition on Nov. 14, 2003
				draw.markerXMultFactor = dlg1.m_xMultFactor;
				draw.markerXShift = dlg1.m_xShift;
				draw.markerYMultFactor = dlg1.m_yMultFactor;
				draw.markerIsRevYAxis = dlg1.m_markerRevYAxis;
				draw.markerYShift = dlg1.m_yShift;


				vel.dxVDesired = dlg2.m_dxV;
				vel.vmin = dlg2.m_vmin;
				vel.vmid = dlg2.m_vmid;
				vel.vmax = dlg2.m_vmax;
				vel.vminR = dlg2.m_vminR;
				vel.vminG = dlg2.m_vminG;
				vel.vminB = dlg2.m_vminB;
				vel.vmidR = dlg2.m_vmidR;
				vel.vmidG = dlg2.m_vmidG;
				vel.vmidB = dlg2.m_vmidB;
				vel.vmaxR = dlg2.m_vmaxR;
				vel.vmaxG = dlg2.m_vmaxG;
				vel.vmaxB = dlg2.m_vmaxB;

				//These are additions of version 2.0
				draw.colBar = dlg2.m_colBar;
				vel.colBarVmin = dlg2.m_colBarVmin;
				vel.colBarVmax = dlg2.m_colBarVmax;
				vel.cxExt = dlg2.m_cxExt;
				vel.cxPos = dlg2.m_cxPos;
				vel.cyExt = dlg2.m_cyExt;
				vel.cyPos = dlg2.m_cyPos;
				vel.vmid2 = dlg2.m_vmid2;
				vel.vmid3 = dlg2.m_vmid3;
				vel.vmid4 = dlg2.m_vmid4;

				vel.vmid5 = dlg2.m_vmid5;
				vel.vmid6 = dlg2.m_vmid6;
				vel.vmid7 = dlg2.m_vmid7;
				vel.vmid8 = dlg2.m_vmid8;

				vel.vmidB2 = dlg2.m_vmidB2;
				vel.vmidB3 = dlg2.m_vmidB3;
				vel.vmidB4 = dlg2.m_vmidB4;
				vel.vmidB5 = dlg2.m_vmidB5;
				vel.vmidB6 = dlg2.m_vmidB6;
				vel.vmidB7 = dlg2.m_vmidB7;
				vel.vmidB8 = dlg2.m_vmidB8;

				vel.vmidG2 = dlg2.m_vmidG2;
				vel.vmidG3 = dlg2.m_vmidG3;
				vel.vmidG4 = dlg2.m_vmidG4;
				vel.vmidG5 = dlg2.m_vmidG5;
				vel.vmidG6 = dlg2.m_vmidG6;
				vel.vmidG7 = dlg2.m_vmidG7;
				vel.vmidG8 = dlg2.m_vmidG8;

				vel.vmidR2 = dlg2.m_vmidR2;
				vel.vmidR3 = dlg2.m_vmidR3;
				vel.vmidR4 = dlg2.m_vmidR4;
				vel.vmidR5 = dlg2.m_vmidR5;
				vel.vmidR6 = dlg2.m_vmidR6;
				vel.vmidR7 = dlg2.m_vmidR7;
				vel.vmidR8 = dlg2.m_vmidR8;

				vel.dv1 = dlg2.m_dv1;
				tx.xShot = dlg2.m_xWell;
				draw.velSecNamesEx = dlg2.m_velModExtras;

				//More additions:
				draw.rayName = dlg1.m_rayTracing;  // added Feb 12, 2008
				draw.vrmsTauName = dlg2.m_vrmsTauName;
			}
			else return(FALSE);

			//	if (pFrame && !pFrame->gDriveNew.IsEmpty()) myChangeDrive(&pFrame->gDriveNew);

			//Some checks to ensure correct parameters
			if(para.trace2<para.trace1) 
			{
				AfxMessageBox(_T("trace2 is smaller than trace1, please check!"));
				return FALSE;
			}
			if(pCd.coord.xTick<=0)  pCd.coord.xTick = 1.;
			if(vel.zTick<=0)  vel.zTick = 1.;
			if(pCd.coord.tTick<=0)  pCd.coord.tTick = 1.;

			if(pCd.coord.xmax<pCd.coord.xmin) 
			{
				AfxMessageBox(_T("xmax is smaller than xmin, please check!"));
				return FALSE;
			}
			if(pCd.coord.zmax<pCd.coord.zmin) 
			{
				AfxMessageBox(_T("zmax is smaller than zmin, please check!"));
				return FALSE;
			}
			if(pCd.coord.tmax<pCd.coord.tmin) 
			{
				AfxMessageBox(_T("tmax is smaller than tmin, please check!"));
				return FALSE;
			}

			if (pFrame) pFrame->SetMessageText(draw.timeSecName);


			//pFrame->SetAppName(this->GetPathName() + _T(" - " + draw.timeSecName);
			//pFrame->OnUpdateFrameTitle(TRUE);

			return(TRUE);
	}
	//BOOL CSeisWideDoc::myParasColor()
	//{
	//	// this function is not used any more!!!
	//		CdlgSegyColor dlg3;
	//
	//		dlg3.m_maxAmpR = seisBiColor.maxAmpR;
	//		dlg3.m_maxAmpG = seisBiColor.maxAmpG;
	//		dlg3.m_maxAmpB = seisBiColor.maxAmpB;
	//		dlg3.m_negAmpR = seisBiColor.negAmpR;
	//		dlg3.m_negAmpG = seisBiColor.negAmpG;
	//		dlg3.m_negAmpB = seisBiColor.negAmpB;
	//
	//		if(dlg3.DoModal() == IDOK)
	//		{
	//			seisBiColor.maxAmpR = dlg3.m_maxAmpR;
	//			seisBiColor.maxAmpG = dlg3.m_maxAmpG;
	//			seisBiColor.maxAmpB = dlg3.m_maxAmpB;
	//			seisBiColor.negAmpR = dlg3.m_negAmpR;
	//			seisBiColor.negAmpG = dlg3.m_negAmpG;
	//			seisBiColor.negAmpB = dlg3.m_negAmpB;
	//		}
	//		else return FALSE;
	//
	//		return TRUE;
	//}

	void CSeisWideDoc::OnEditBoundary() 
	{
		draw.nodes = 1;	

		draw.pick = 1;
		draw.pickOld = -1;  // indicate no previous state for right click 
		draw.remove = 0;	
		draw.move =0;
		draw.add = 0;
		//	draw.iLayerFocus = -1;
		//draw.isSameDataDisplay = FALSE; //indicate display has been changed and will re-load all data in OnDraw().
		SetModifiedFlag();
		UpdateAllViews(NULL);
		NotifyChanged();
	}

	void CSeisWideDoc::OnEditVelocity() 
	{
		draw.nodes = 2;	

		draw.pick = 1;
		draw.pickOld = -1;  // for use with the right-mouse click
		draw.remove = 0;	
		draw.move =0;
		draw.add = 0;
		//	draw.iLayerFocus = -1;
		//draw.isSameDataDisplay = FALSE; //indicate display has been changed and will re-load all data in OnDraw().
		SetModifiedFlag();
		UpdateAllViews(NULL);
		NotifyChanged();
	}

	void CSeisWideDoc::OnEditText()
	{
		draw.nodes = 3;	
		bool isEmpty = draw.markerName.IsEmpty();
		if (!isEmpty) {
			CFile file;
			if (file.Open(draw.markerName, CFile::modeRead | CFile::typeBinary)) {
				int i = (int)file.GetLength();;
				if (i == 0) isEmpty = true;
				file.Close();
			}
			else {
				isEmpty = true;
			}
		}


		if (isEmpty) {
			// since the marker is empty, we create a new one
			if (isTimeDomain()) {
				draw.markerName = draw.timeSecName + _T("Marker.txt");
			}
			else {
				draw.markerName = velMod.velSecName + _T("Marker.txt");
			}
			if (isFileExistNotDirectory(draw.markerName))
				showFileInNotePad(draw.markerName);
			else
				showStringInFile("#Use this file to edit Marker/text. Free formatted such as\r\n# 5.  8.  255   0   0    14   45.0       PmP\r\n# X   Y   red green blue size angle(deg) text\r\n# Note: actual text angle will auto adjust based on Y/X ratio changes on screen/printer\r\n# Click Refresh Drawing (in SeisWide) after changes in this Notepad.", draw.markerName);
		}
		else
			showFileInNotePad(draw.markerName);


		draw.pick = 1;
		draw.pickOld = -1;  // for use with the right-mouse click
		draw.remove = 0;	
		draw.move =0;
		draw.add = 0;
		draw.iTextFocus = -1;
		//draw.isSameNodeDisplay = TRUE;
		////draw.isSameDataDisplay = FALSE; //indicate display has been changed and will re-load all data in OnDraw().
		//SetModifiedFlag();
		UpdateAllViews(NULL);
		//NotifyChanged();
	}


	void CSeisWideDoc::OnEditNonodes() 
	{
		if(!draw.isNoNodes)draw.isNoNodes=TRUE;
		else draw.isNoNodes=FALSE;
		draw.isNodeChanged = TRUE;
		// draw.isSameDataDisplay = FALSE; //indicate display has been changed and will re-load all data in OnDraw().
		SetModifiedFlag();
		UpdateAllViews(NULL);
		NotifyChanged();
	}

	void CSeisWideDoc::OnToobarMove() 
	{
		draw.pickOld=ptdraw(draw.pick, draw.remove, draw.move, draw.add);
		draw.move =1;

		draw.remove = 0;
		draw.pick = 0;
		draw.add = 0;
		draw.isNodeChanged = TRUE;

		//	draw.isSameDataDisplay = FALSE; //indicate display has been changed and will re-load all data in OnDraw().
		//	SetModifiedFlag();
		//	UpdateAllViews(NULL);
		//	NotifyChanged();

	}

	void CSeisWideDoc::OnToolbarRemove() 
	{
		//if (draw.isDigitizing && dig.nPoint!=NULL) {
		//	if(dig.iCurveSel>=0 && dig.nPoint[dig.iCurveSel]>0) {
		//		dig.nPoint[dig.iCurveSel] --;
		//		myCaption(_T(" Last point has been removed"));
		//		myDigSaveAs(&dig, dig.digName, dig.isSorted, dig.isSortedY); 
		//		OnToolbarRefresh();
		//	}
		//	return;
		//}



		draw.pickOld=ptdraw(draw.pick, draw.remove, draw.move, draw.add);
		draw.remove = 1;	

		draw.move =0;
		draw.pick = 0;
		draw.add = 0;
		draw.isSameDataDisplay = FALSE; //indicate display has been changed and will re-load all data in OnDraw().
		SetModifiedFlag();
		draw.isNodeChanged = TRUE;
		draw.isSameDataDisplay = TRUE; //indicate display has been changed and will re-load all data in OnDraw().

		//	UpdateAllViews(NULL);
		//	NotifyChanged();
	}

	void CSeisWideDoc::OnToolbarPick() 
	{
		draw.pickOld=ptdraw(draw.pick, draw.remove, draw.move, draw.add);
		draw.pick = 1;	

		draw.move =0;
		draw.remove = 0;
		draw.add = 0;

		draw.isNodeChanged = TRUE;
		draw.isSameDataDisplay = TRUE; 
		CString tStr = _T("Dragging mouse click to show slope or apparent velocity.");
		this->myCaption(tStr);

		SetModifiedFlag();
	}

	void CSeisWideDoc::OnToolsPicknext()
	{
		draw.isNodeChanged = FALSE;
		draw.isSameDataDisplay = TRUE; 
		draw.iLayerFocus++;

		SetModifiedFlag();
		UpdateAllViews(NULL);
		NotifyChanged();
	}


	void CSeisWideDoc::OnToolbarAdd() 
	{
		draw.pickOld=ptdraw(draw.pick, draw.remove, draw.move, draw.add);
		draw.add = 1;

		draw.move =0;
		draw.remove = 0;
		draw.pick = 0;
		draw.isNodeChanged = TRUE;
		draw.isSameDataDisplay = TRUE; 
		SetModifiedFlag();
		//	this->myModelSaveAs();
		//	UpdateAllViews(NULL);
		//	NotifyChanged();
	}

	void CSeisWideDoc::OnToolbarDelLine() 
	{
		if (draw.isDigitizing && dig.nPoint!=NULL) {
			if(AfxMessageBox(_T(" This will delete the selected curve; Continue? "), MB_YESNO |MB_ICONINFORMATION) == IDYES) {
				CDigitize pDg;
				if (pDg.digDeleteCurve(&dig, dig.iCurveSel))
					OnToolbarRefresh();

				//if (dig.iCurveSel==dig.totCurve-1) {
				//	// only the last curve will be deleted
				//}
				//else {
				//	for (int i=dig.iCurveSel; i<dig.totCurve-1; i++) {
				//		dig.nPoint[i] = dig.nPoint[i+1];
				//		for (int j=0; j<dig.nPoint[i]; j++) {
				//			dig.x[j][i] = dig.x[j][i+1];
				//			dig.t[j][i] = dig.t[j][i+1];
				//		} // for j
				//	}
				//}
				//dig.totCurve--;
				//pDg.myDigSaveAs(&dig, dig.isSorted, dig.isSortedY, tx.xShot); 
			}

			return;
		} // if


		if (!isModelDisplayed()) return;


		//Delete a boundary/layer.
		if( draw.iLayerFocus<0) {
			AfxMessageBox(_T("Please select a layer first"), MB_OK |MB_ICONINFORMATION);
			return ;
		}

		CVelMod vm;
		int j,icont;
		draw.add = 0;
		draw.move =0;
		draw.remove = 0;
		draw.pick = 0;
		//	draw.isSameDataDisplay = FALSE; //indicate display has been changed and will re-load all data in OnDraw().
		//	SetModifiedFlag();

		// the selected boundary for delete is: iLayerFocus.
		velMod.ncont--;
		for (icont= draw.iLayerFocus; icont<velMod.ncont; icont++)
		{
			velMod.nzed[icont]=velMod.nzed[icont+1];
			for (j=0; j<velMod.nzed[icont+1]; j++)
			{
				velMod.xm[j][icont]=velMod.xm[j][icont+1]; 
				if (draw.mode!=9)
					velMod.zm[j][icont]=velMod.zm[j][icont+1]; 
				else
					velMod.tm[j][icont]=velMod.tm[j][icont+1]; 
			}
		}
		for (icont= draw.iLayerFocus; icont<velMod.ncont-1; icont++)
		{
			velMod.nvel[icont][0]=velMod.nvel[icont+1][0];
			velMod.nvel[icont][1]=velMod.nvel[icont+1][1];
			for (j=0; j<velMod.nvel[icont][0]; j++)
			{
				velMod.xvel[j][icont][0]=velMod.xvel[j][icont+1][0];
				velMod.vf[j][icont][0]=velMod.vf[j][icont+1][0];
			}
			for (j=0; j<velMod.nvel[icont][1]; j++)
			{
				velMod.xvel[j][icont][1]=velMod.xvel[j][icont+1][1];
				velMod.vf[j][icont][1]=velMod.vf[j][icont+1][1];
			}
		}
		draw.iLayerFocus = -1;
		//End of delete a boundary/layer.

		// OnToolbarSavev();
		if (draw.mode==9) 
			vm.myModel_TWTT2Depth(&velMod, vel.dz);

		UpdateAllViews(NULL);
		//	NotifyChanged();
		return ;

	}

	void CSeisWideDoc::OnToolbarDuplicate() 
	{
		if (!isModelDisplayed()) return;

		draw.add = 0;
		draw.move =0;
		draw.remove = 0;
		draw.pick = 1;

		if( draw.iLayerFocus<0) {
			AfxMessageBox(_T("Please select a boundary first"), MB_OK |MB_ICONINFORMATION);
			return ;
		}
		if(AfxMessageBox(_T("Boundary duplication is convenient for adding a local layer. Continue?"), MB_OKCANCEL|MB_ICONINFORMATION) == IDCANCEL) return;

		// the selected boundary for delete is: iLayerFocus.

		CVelMod vm;
		draw.iLayerFocus = vm.myModelBoundaryDup(&velMod, draw.iLayerFocus, vel.dz);
		//End duplicating a boundary.

		// note: since have duplicated a boundary in the depth domain. We need to 
		// convert to time domain right now

		draw.isNodeChanged = TRUE;
		UpdateAllViews(NULL);
		NotifyChanged();
	}

	void CSeisWideDoc::OnEditDisplaytuneupRemoveoutsideraypoints() 
	{
		draw.isNoOutSidePoints = !draw.isNoOutSidePoints;
		draw.isSameDataDisplay = FALSE; //indicate display has been changed and will re-load all data in OnDraw().
		UpdateAllViews(NULL);
		NotifyChanged();
	}
	//
	//BOOL CSeisWideDoc::getSegyMeta(CString t, HEAD *pHead)
	//{
	//	if (!isFileExistNotDirectory(t)) return TRUE;
	//	if (segyHeadInit(t, pHead, 0) != 1) return FALSE;
	//	SegyWrapper sw(t);
	//
	//	// note: we cannot sort head.offsets[] or head.dist[], 
	//	//  so we have to create offset[] and dist[] for sorting
	//	float offset[100], dist[100], dx[100];
	//	if (!sw.open(pHead, 100)) {
	//		pHead->aveAmp = 1.f;
	//		pHead->maxAmp = 1.f;
	//		pHead->offsetInterval = .1;
	//		pHead->distInterval = 1.;
	//		return FALSE;
	//	}
	//
	//	// NOTE: when the result is 18 million, if I do not have (double) cast, it returns 0. Why?
	//	pHead->maxAmp = (double)sw.getMaxAmp();
	//	if (pHead->maxAmp < MINAMP) pHead->maxAmp = 1.;
	//
	//	pHead->aveAmp = (double)sw.getAvgAmp();
	//	if (pHead->aveAmp < MINAMP) pHead->aveAmp = 0.5;
	//
	//	int numsamp = sw.bh.hns;
	//
	//	int i;
	//	int nxmax = min(100, sw.nxmax);
	//	for (i=0; i<nxmax; i++) {
	//		dist[i] = getDistance(&sw.trArr[i]);
	//		offset[i] = getOffset(&sw.trArr[i]);
	//	} // for i
	//
	//	if(nxmax>1) {
	//		sort(&offset[0], nxmax);
	//		sort(&dist[0], nxmax);
	//		//if (!isTimeDomain()) 
	//		//	para.isDistanceDisplay = TRUE; // we cannot display using offset[]
	//
	//		for (i=1; i<nxmax; i++) {
	//			dx[i-1] = (float)fabs(offset[i]-offset[i-1]);
	//		}
	//		// note: dx[] only has totTrc-1 values
	//		pHead->offsetInterval = getMedianAbsolute(&dx[0], nxmax - 1);	//This is the average trace interval in km.
	//		if (pHead->offsetInterval < MINAMP) pHead->offsetInterval = .1;
	//
	//		for (i=1; i<sw.nxmax; i++) {
	//			dx[i-1] = (float)fabs(dist[i]-dist[i-1]);
	//		}
	//		pHead->distInterval = getMedianAbsolute(&dx[0], nxmax - 1);	//This is the average trace interval in km.
	//		if (pHead->distInterval < MINAMP) pHead->distInterval = 1.;
	//	} else  {
	//		pHead->offsetInterval = .1;
	//		pHead->distInterval = 1.;
	//	}
	//
	////So, the average ampl should be "stretched" to cover the distance "temp*gain",
	////But since this routine cannot use para.gain or para.clip (since this routine only
	////executes once and yet para changed many times), the draw.trcIntOavgAmp and
	////para.clip will have to be multiplied in separate drawing routines.
	////	head.timeSecModTime = getFileModifiedTime(draw.timeSecName);
	//
	//	return TRUE;
	//}







	//
	//BOOL CSeisWideDoc::MyInitAmpTrc2(CString t)
	//{
	////This routine initializes segy data for displaying by trace.
	//	if (!isFileExistNotDirectory(t)) return TRUE;
	////		CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	//	SegyWrapper sw(t);
	//	if (segyHeadInit(t, &head, 0) == 1) {
	//		head.offsetInterval = .1;
	//		head.distInterval = 1.;
	//		// strange: if I use 80 or 100 as desired numtraces, it will have 10 memory exceptions
	//		// however, if I use 50, it has no exception. Why???
	//		if (sw.open(&head, 50)) {  
	//			int numsamp = sw.bh.hns;
	//			head.aveAmp = (double)sw.getAvgAmp();
	//			head.maxAmp = (double)sw.getMaxAmp();
	//			return TRUE;
	//		} // if sw
	//		else {
	//			head.aveAmp = 0.f;
	//			head.maxAmp = 0.f;
	//			return FALSE;
	//		}
	//	}
	//	return FALSE;
	//}




	void CSeisWideDoc::OnEditCopy() 
	{
		BOOL tempNoLable=draw.isNoLableOutside;
		//	BOOL tempNoSeismic;

		if(draw.mode >= 0 ) {
			CdlgFillArea dlg;
			// when opening an older .sei file, this may not be valid, so we give a fix here... sept, 2009
			if (draw.clipBoardSizeX < 10) draw.clipBoardSizeX = 880; 
			if (draw.clipBoardSizeY < 10) draw.clipBoardSizeY = 50;
			dlg.m_XLen = draw.clipBoardSizeX;
			dlg.m_YLen = draw.clipBoardSizeY;

			if (!bmp24.bmp24Name.IsEmpty() && (isTimeDomain() == !bmp24.isDepth) ) 
				dlg.m_mode = 1; //indicate drawing in bitmap.
			else if (draw.mode == 2 || draw.mode==4)
				dlg.m_mode = 1; //indicate drawing of model with no seismics.
			dlg.m_noLables = draw.isNoLableOutside;
			if(dlg.DoModal() == IDOK) {
				tempNoLable = dlg.m_noLables;
				draw.clipBoardSizeX = dlg.m_XLen;
				draw.clipBoardSizeY = dlg.m_YLen;
			}
			delete dlg;
		}

		// backup the global values first before overwritten
		BOOL t1 = draw.isNoLableOutside;

		// the reason for using tempNoXXXX is to avoid changing the global values 
		// when people click Cancel buttons in the above.
		draw.isNoLableOutside = tempNoLable;
		draw.isCopying = TRUE;
		// draw.isSameDataDisplay = FALSE;

		// real place to do copying to clipboard
		CSeisWideSrvrItem* pItem = GetEmbeddedItem();
		pItem->CopyToClipboard(TRUE);

		// after copying, the bitmap is gone, so need to initialize
		bmp24.isNeedInitialize = true;

		// recover the old values
		// draw.isSameDataDisplay = FALSE;
		draw.isNoLableOutside = t1;
		draw.isCopying = FALSE;
	}

	void CSeisWideDoc::OnEditPaste() 
	{ // this routine not used for now.


		//POSITION pos = GetFirstDocTemplatePosition();
		//CDocTemplate *pTemplate = GetNextDocTemplate(pos);            
		//CDocument *pDoc = pTemplate->OpenDocumentFile(NULL);
		//pDoc->SetTitle ("My own title");

		return;

		CWnd *pWnd;
		pWnd = pWnd->GetActiveWindow( );
		if (pWnd->OpenClipboard())
		{
			HGLOBAL hMem = GetClipboardData( CF_METAFILEPICT );
			if (!hMem != NULL)
			{
				char *lpMeta = (char *) GlobalLock (hMem);
				if(lpMeta != NULL)
				{ //work with the METAFILEPICT structure...
				}
			}
		}
		else
			AfxMessageBox(_T("Couldn't get metafile from clipboard"));
		CloseClipboard();
	}


	//
	//CPoint CSeisWideDoc::mm_coord(double x, double y, int xLen, int yLen)
	//{
	//// A routine to convert my world coordinates (in km, sec) into logical coordinates of windows. 
	//// for facedown plot only: xmin->0, xmax->xLen;  ymin->0, ymax->yLen.
	//	CPoint p;
	//	double a;
	//	a = (x-pCd.coord.xmin)*pCd.coord.mm_xscale;
	//	p.x = (int)myRound(pCd.coord.logicalAxes.left + a);
	//
	//	
	//	if (isTimeDomain()) {
	//		//if true then in time domain.
	//		if(pCd.coord.isFaceUp == 0)
	//			a = (y-pCd.coord.tmin)*pCd.coord.mm_yscale;
	//		else
	//			a = (pCd.coord.tmax-y)*pCd.coord.mm_yscale;
	//	}
	//	else {
	//		a = (y-pCd.coord.zmin)*pCd.coord.mm_yscale;
	//	}
	//
	//	p.y = (int)myRound(a+pCd.coord.logicalAxes.top);
	//
	//	return p;
	//
	//}

	/////////////////////////////////////////////////////////////////////////////

	COLORREF CSeisWideDoc::getVelocityColor(float v, VEL vel)
	{
		// convert velocity to colors based on the mapping in vel struct
		int vR,vG,vB;
		if(v<vel.vmin) 
		{
			//vR = vel.vminR;
			//vG = vel.vminG;
			//vB = vel.vminB;
			vR = 255;
			vG = 255;
			vB = 255;
		}
		else if(v<=vel.vmid) 
		{
			vR=(int)(vel.vminR+(vel.vmidR-vel.vminR)/
				(vel.vmid-vel.vmin)*(v-vel.vmin));
			vG=(int)(vel.vminG+(vel.vmidG-vel.vminG)/
				(vel.vmid-vel.vmin)*(v-vel.vmin));
			vB=(int)(vel.vminB+(vel.vmidB-vel.vminB)/
				(vel.vmid-vel.vmin)*(v-vel.vmin));
		}
		else if (v<=vel.vmid2) 
		{
			vR=(int)(vel.vmidR+(vel.vmidR2-vel.vmidR)/
				(vel.vmid2-vel.vmid)*(v-vel.vmid));
			vG=(int)(vel.vmidG+(vel.vmidG2-vel.vmidG)/
				(vel.vmid2-vel.vmid)*(v-vel.vmid));
			vB=(int)(vel.vmidB+(vel.vmidB2-vel.vmidB)/
				(vel.vmid2-vel.vmid)*(v-vel.vmid));
		}
		else if (v<=vel.vmid3)
		{
			vR=(int)(vel.vmidR2+(vel.vmidR3-vel.vmidR2)/
				(vel.vmid3-vel.vmid2)*(v-vel.vmid2));
			vG=(int)(vel.vmidG2+(vel.vmidG3-vel.vmidG2)/
				(vel.vmid3-vel.vmid2)*(v-vel.vmid2));
			vB=(int)(vel.vmidB2+(vel.vmidB3-vel.vmidB2)/
				(vel.vmid3-vel.vmid2)*(v-vel.vmid2));
		}
		else if (v<=vel.vmid4) 
		{
			vR=(int)(vel.vmidR3+(vel.vmidR4-vel.vmidR3)/
				(vel.vmid4-vel.vmid3)*(v-vel.vmid3));
			vG=(int)(vel.vmidG3+(vel.vmidG4-vel.vmidG3)/
				(vel.vmid4-vel.vmid3)*(v-vel.vmid3));
			vB=(int)(vel.vmidB3+(vel.vmidB4-vel.vmidB3)/
				(vel.vmid4-vel.vmid3)*(v-vel.vmid3));
		}

		else if (v<=vel.vmid5) 
		{
			vR=(int)(vel.vmidR4+(vel.vmidR5-vel.vmidR4)/
				(vel.vmid5-vel.vmid4)*(v-vel.vmid4));
			vG=(int)(vel.vmidG4+(vel.vmidG5-vel.vmidG4)/
				(vel.vmid5-vel.vmid4)*(v-vel.vmid4));
			vB=(int)(vel.vmidB4+(vel.vmidB5-vel.vmidB4)/
				(vel.vmid5-vel.vmid4)*(v-vel.vmid4));
		}


		else if (v<=vel.vmid6) 
		{
			vR=(int)(vel.vmidR5+(vel.vmidR6-vel.vmidR5)/
				(vel.vmid6-vel.vmid5)*(v-vel.vmid5));
			vG=(int)(vel.vmidG5+(vel.vmidG6-vel.vmidG5)/
				(vel.vmid6-vel.vmid5)*(v-vel.vmid5));
			vB=(int)(vel.vmidB5+(vel.vmidB6-vel.vmidB5)/
				(vel.vmid6-vel.vmid5)*(v-vel.vmid5));
		}



		else if (v<=vel.vmid7) 
		{
			vR=(int)(vel.vmidR6+(vel.vmidR7-vel.vmidR6)/
				(vel.vmid7-vel.vmid6)*(v-vel.vmid6));
			vG=(int)(vel.vmidG6+(vel.vmidG7-vel.vmidG6)/
				(vel.vmid7-vel.vmid6)*(v-vel.vmid6));
			vB=(int)(vel.vmidB6+(vel.vmidB7-vel.vmidB6)/
				(vel.vmid7-vel.vmid6)*(v-vel.vmid6));
		}

		else if (v<=vel.vmid8) 
		{
			vR=(int)(vel.vmidR7+(vel.vmidR8-vel.vmidR7)/
				(vel.vmid8-vel.vmid7)*(v-vel.vmid7));
			vG=(int)(vel.vmidG7+(vel.vmidG8-vel.vmidG7)/
				(vel.vmid8-vel.vmid7)*(v-vel.vmid7));
			vB=(int)(vel.vmidB7+(vel.vmidB8-vel.vmidB7)/
				(vel.vmid8-vel.vmid7)*(v-vel.vmid7));
		}



		else if (v<=vel.vmax)
		{
			vR=(int)(vel.vmidR8+(vel.vmaxR-vel.vmidR8)/
				(vel.vmax-vel.vmid8)*(v-vel.vmid8));
			vG=(int)(vel.vmidG8+(vel.vmaxG-vel.vmidG8)/
				(vel.vmax-vel.vmid8)*(v-vel.vmid8));
			vB=(int)(vel.vmidB8+(vel.vmaxB-vel.vmidB8)/
				(vel.vmax-vel.vmid8)*(v-vel.vmid8));
		}
		else
		{
			//vR = vel.vmaxR;
			//vG = vel.vmaxG;
			//vB = vel.vmaxB;
			vR = 255;
			vG = 255;
			vB = 255;
		}

		if(vR<0)vR=0;	
		if(vG<0)vG=0;	
		if(vB<0)vB=0;	
		if(vR>255) vR=255;
		if(vG>255) vG=255;
		if(vB>255) vB=255;

		return RGB(vR, vG, vB);

	}


	BOOL CSeisWideDoc::DrawVel(CDC* pDC, BOOL isBoundOnly) {
		if (draw.mode==4) return DrawCont(pDC);

		// note: draw.distShift is not used in the horizontal shifting of displayed velocity model!
		//       This is because, by definition, draw.distShift is used in shifting segy data only, not a model.
		//       A model can be shifted by another string parameter draw.velSecNamesEx in the time domain.
		return this->DrawVelocityDepth(pDC, &velMod, isBoundOnly, draw.isNoNodes, 0.);
	}


	// the problem is: if I only display a small portion of a big model, I can view more details of the model. How we do this?
	BOOL CSeisWideDoc::DrawVelocityDepth(CDC* pDC, CVelMod::VELMOD *velm, BOOL isBoundOnly, BOOL isNoNodes, double xShift, CPen* greenPen)
	{
		// if this model is not visible after initialization, we should not draw it
		CVelMod vm;
		if (velm == NULL && velm->ncont<1) 
			vm.velModSetArrays(velm);
		if(!isFileExistNotDirectory(velm->velSecName) || !this->isModelVisible(velm, xShift)) return FALSE;

		bool isModelEditable = 	velm->velSecName == velMod.velSecName;

		bool isMainModelShowing = 
			GetBaseFileName(velMod.velSecName) == GetBaseFileName(velm->velSecName);

		//Generate velocity contours
		short i,j,icont;
		short ix, iv, nv;
		double range;
		double a,b,x1,v,dv, temp;
		CPoint p,p1,plt[MOD_POINTS_MAX*2],pltOld[MOD_POINTS_MAX];

		if (!vm.loadInitVel(velm, velm->velSecName, vel.dz))
			return FALSE;

		vm.myVelModInterpolDisplay(velm, pCd.coord.xmin, pCd.coord.xmax, xShift, vel.dxVDesired); //calculate velocity interpolation.
		double grdXmax = velMod.grdXmin + (velMod.grdNx-1)*velMod.grdDx;

		//Start plotting velocity color map.
		CPen whitePen(PS_NULL, 0, RGB(255,255,255));
		CPen whiteLinePen(PS_SOLID, 0, RGB(255,255,255));
		CPen blackPen(PS_SOLID, 0, RGB(0,0,0));
		CPen redPen(PS_SOLID, (int)(pCd.coord.logicalAxes.Height()/400), RGB(255,0,0));
		//CPen greenPen(PS_SOLID, (int)(pCd.coord.logicalAxes.Height()/400), RGB(0,255,0));
		CPen thickPen(PS_SOLID, (int)(min(pCd.coord.logicalAxes.Width(),pCd.coord.logicalAxes.Height())/400), RGB(0,0,0));
		CPen thinPen(PS_SOLID, 0, RGB(0,100,0));
		CBrush blackBrush(RGB(0,0,0));
		CBrush redBrush(RGB(255,0,0));
		CBrush greenBrush(RGB(0,255,0));
		CBrush blueBrush(RGB(0,0,255));


		//For each velocity contour, look for the right depth for each range.
		//_stprintf(s, _T("at v,vtop,vbot=%d %d %d %d %d",(long)v,(long)vTop[0][ix],(long)vBot[0][ix],(long)vTop[1][ix],(long)vBot[1][ix]);
		//AfxMessageBox(s);
		//Cycle thru each layer and plot vel within each layer.
		double vminLayer=99999., vmaxLayer=0.;
		if (!isBoundOnly) {
			for (icont=0; icont<velm->ncont-1; icont++) {
				//Find the min and max vel for this layer.
				vminLayer=99999.;
				for (ix = 0; ix<velm->grdNx; ix++)
					if(vminLayer>velm->vTop[icont][ix]) vminLayer = velm->vTop[icont][ix];
				for (ix = 0; ix<velm->grdNx; ix++)
					if(vminLayer>velm->vBot[icont][ix]) vminLayer = velm->vBot[icont][ix];
				vmaxLayer=0.;
				for (ix = 0; ix<velm->grdNx; ix++)
					if(vmaxLayer<velm->vTop[icont][ix]) vmaxLayer = velm->vTop[icont][ix];
				for (ix = 0; ix<velm->grdNx; ix++)
					if(vmaxLayer<velm->vBot[icont][ix]) vmaxLayer = velm->vBot[icont][ix];


				dv = vel.dv1;

				//vminLayer should be rounded to a multiple of dv.
				vminLayer = (int)(vminLayer/dv) * dv;

				// we only plot a max of  500 points in resolution. Others will interpolate
				nv = (int)((vmaxLayer-vminLayer)/dv + .5);
				if (nv<2) nv=2;
				if(nv>=500) {
					dv = (vmaxLayer-vminLayer)/499;
					nv = 500;
				}	//Make sure plt[] array do not exceed 500.

				//Loop through colors for this layer.
				for (iv=0; iv<500; iv++) {
					v = vminLayer + iv*dv;
					if(v>vmaxLayer) break;

					COLORREF colThis = getVelocityColor((float)v, vel);

					//Search by interpolation for the curve for v in layer icont.
					for (ix = 0; ix<velm->grdNx; ix++) {
						if (ix == (velm->grdNx - 1)) range = grdXmax;
						else range = velm->grdXmin + velm->grdDx *(double)ix;
						temp=velm->vBot[icont][ix]-velm->vTop[icont][ix];
						if (velm->grdDepth[icont + 1][ix]<velm->grdDepth[icont][ix]) {
							a = velm->grdDepth[icont + 1][ix];
							b = velm->grdDepth[icont + 1][ix];
						} else if(fabs(temp)<0.001) {
							//const vel, odd fix.
							if (nv == 2 && iv == 0) { a = velm->grdDepth[icont][ix]; b = velm->grdDepth[icont + 1][ix]; }
							else if (nv == 2 && iv == 1) a = b = velm->grdDepth[icont + 1][ix];
							else if (fabs(v - velm->vTop[icont][ix]) <= dv) a = velm->grdDepth[icont][ix];
							else if (iv <= nv - 1) a = velm->grdDepth[icont][ix];
							else a = velm->grdDepth[icont + 1][ix];
						} else {
							a = velm->grdDepth[icont][ix] + (velm->grdDepth[icont + 1][ix] - velm->grdDepth[icont][ix])
								*(v-velm->vTop[icont][ix])/temp;
							b = velm->grdDepth[icont][ix] + (velm->grdDepth[icont + 1][ix] - velm->grdDepth[icont][ix])
								*(v+dv-velm->vTop[icont][ix])/temp;
						}
						if (a<velm->grdDepth[icont][ix]) a = velm->grdDepth[icont][ix];
						if (a>velm->grdDepth[icont + 1][ix]) a = velm->grdDepth[icont + 1][ix];
						if(a<pCd.coord.zmin) a=pCd.coord.zmin;
						if(a>pCd.coord.zmax) a=pCd.coord.zmax;
						if (b<velm->grdDepth[icont][ix]) b = velm->grdDepth[icont][ix];
						if (b>velm->grdDepth[icont + 1][ix]) b = velm->grdDepth[icont + 1][ix];
						if(b<pCd.coord.zmin) b=pCd.coord.zmin;
						if(b>pCd.coord.zmax) b=pCd.coord.zmax;

						plt[ix] = pCd.mm_coordz(range + xShift, a);
						plt[2 * velm->grdNx - ix - 1] = pCd.mm_coordz(range + xShift, b);
					}

					if(!draw.isNoColorMap)  {
						CBrush brush;
						CPen* oldPen = pDC->SelectObject(&whitePen);
						if(draw.nodes == 2 && icont == draw.iLayerFocus)
							brush.CreateHatchBrush(HS_DIAGCROSS, colThis);
						else
							brush.CreateSolidBrush(colThis);
						CBrush* oldBrush = pDC->SelectObject(&brush);
						pDC->Polygon(plt, 2 * velm->grdNx);
						pDC->SelectObject(oldBrush);
						pDC->SelectObject(oldPen);
						brush.DeleteObject();
					} else if(draw.nodes == 2 && icont == draw.iLayerFocus) {
						CPen* oldPen = pDC->SelectObject(&whitePen);
						CBrush brush;
						brush.CreateHatchBrush(HS_DIAGCROSS, colThis);
						CBrush* oldBrush = pDC->SelectObject(&brush);
						pDC->Polygon(plt, 2 * velm->grdNx);
						pDC->SelectObject(oldBrush);
						pDC->SelectObject(oldPen);
						brush.DeleteObject();
					}
				} //End of loop iv.
			}  //End of loop icont.
		} // 	if (!isBoundOnly)

		CString tstr;

		//Draw color bar.
		this->DrawColorbar(pDC);

		if(draw.isNoBoundary) return TRUE;

		int dPlt = (int)(MIN(pCd.coord.logicalAxes.Width(), pCd.coord.logicalAxes.Height())/350.) * draw.bigNodes;

		CPen whiteNodePen(PS_JOIN_BEVEL, (draw.isNoColorMap) ? 3 : 30, RGB(255,255,255));
		CPen whiteNodeFocusPen(PS_SOLID, (draw.isNoColorMap) ? 5 : 80, RGB(255,255,255));

		double xx[MOD_POINTS_MAX],zz[MOD_POINTS_MAX];
		int itop, ibot, ileft, iright;
		CPen* oldPen;
		CBrush* oldBrush;
		for (icont=0; icont<velm->ncont; icont++) {
			i =0;
			for (j=0; j<velm->nzed[icont]; j++) {
				xx[i] = velm->xm[j][icont] + xShift;
				zz[i] = velm->zm[j][icont];
				i++;
			}
			i = myClipPoints2(i, MOD_POINTS_MAX, xx, zz, pCd.coord.axisX1 + xShift, pCd.coord.axisX2 + xShift, pCd.coord.zmin, pCd.coord.zmax);
			for (j=0; j<i; j++)
				plt[j] = pCd.mm_coordz(xx[j],zz[j]);

			if(draw.nodes ==1 && icont==draw.iLayerFocus) {
				if (isModelEditable)
					oldPen = pDC->SelectObject(&redPen);
				else
					oldPen = pDC->SelectObject(&thickPen);
			} else if(draw.nodes==2 && !(icont==draw.iLayerFocus||icont==draw.iLayerFocus+1)) {
				if (greenPen!=NULL)
					oldPen = pDC->SelectObject(greenPen);
				else 
					oldPen = pDC->SelectObject(&thinPen);
			} else {
				if (greenPen!=NULL)
					oldPen = pDC->SelectObject(greenPen);
				else 
					oldPen = pDC->SelectObject(&thickPen);
			}
			pDC->Polyline(plt,i);
			pDC->SelectObject(oldPen);

			if(draw.nodes==1 && !draw.isNoNodes) {
				// drawing nodes need to get rid of the clipped points on two sides, so re-calculate
				i = 0;
				for (j=0; j<velm->nzed[icont]; j++) {
					a = velm->xm[j][icont] + xShift;
					b = velm->zm[j][icont];
					if (isVisibleOrNot(a, b)) {
						plt[i] = pCd.mm_coordz(a,b);
						i++;
					}
				}

				if(icont==draw.iLayerFocus) {
					oldPen = pDC->SelectObject(&whiteNodeFocusPen);
					oldBrush = pDC->SelectObject(&redBrush);
				} else {
					oldPen = pDC->SelectObject(&whiteNodePen);
					oldBrush = pDC->SelectObject(&greenBrush);
				}
				if (!isNoNodes) {
					//int ixBorder1 = pCd.mm_coord((float)velm->xmin + xShift);
					//int ixBorder2 = pCd.mm_coord((float)velm->xmax + xShift);
					for (j=0; j<i; j++) {
						//if (draw.isCopying || draw.isPrinting) 
						//	if (plt[j].x == ixBorder1 || plt[j].x == ixBorder2) 
						//		continue;

						itop = plt[j].y - dPlt; 
						ibot = plt[j].y + dPlt; 
						ileft = plt[j].x - dPlt; 
						iright = plt[j].x + dPlt; 
						pDC->Ellipse(ileft, itop, iright, ibot);
					} // for j
				}
				pDC->SelectObject(oldPen);
				pDC->SelectObject(oldBrush);
			} //if(draw.nodes==
		} // for i

		//When an invalid iLayerFocus is selected, and when boundary or layer
		//mode is first started, do not draw layer nodes, only boundary nodes.
		//	if(draw.iLayerFocus<0 || draw.iLayerFocus >velm->nlayer)
		//		return(TRUE);

		if(!isBoundOnly && draw.nodes == 2 && draw.iLayerFocus>=0 && draw.iLayerFocus<velm->ncont-1) 
			//Draw nodes specifying velocities within layer draw.iLayerFocus.
		{
			//Calculate the depths for all nodes (not given by velocity input file).
			icont = draw.iLayerFocus;
			BOOL DrawTopLine = TRUE;
			BOOL DrawBotLine = TRUE;
			i = 0;

			for (j=0; j<velm->nvel[icont][0]; j++) {
				x1 = velm->xvel[j][icont][0];
				xx[i] = x1 + xShift;
				for (ix=0; ix<(velm->nzed[icont]-1); ix++) {
					if(x1>=velm->xm[ix][icont] && x1<=velm->xm[ix+1][icont]) {
						zz[i] = velm->zm[ix][icont] + (velm->zm[ix+1][icont] -
							velm->zm[ix][icont])*(x1 - velm->xm[ix][icont])/
							(velm->xm[ix+1][icont] - velm->xm[ix][icont]);
						break;
					}
				}
				if(isVisibleOrNot(xx[i], zz[i])) i++;
				else if(xx[i]>=pCd.coord.axisX1 && xx[i]<=pCd.coord.axisX2 && 
					(zz[i]<pCd.coord.axisY1||zz[i]>pCd.coord.axisY2))
					DrawTopLine = FALSE;
			}

			int nTop = i;
			for (j=0; j<nTop; j++)
				plt[j] = pCd.mm_coordz(xx[j], zz[j]);

			i=0;
			for (j=0; j<velm->nvel[icont][1]; j++) {
				x1 = velm->xvel[j][icont][1];
				xx[i] = x1 + xShift;
				for (ix=0; ix<velm->nzed[icont+1]-1; ix++) {
					if(x1>=velm->xm[ix][icont+1] && x1<=velm->xm[ix+1][icont+1]) {
						zz[i] = velm->zm[ix][icont+1] + (velm->zm[ix+1][icont+1] -
							velm->zm[ix][icont+1])*(x1 - velm->xm[ix][icont+1])/
							(velm->xm[ix+1][icont+1] - velm->xm[ix][icont+1]);
						break;
					}
				}
				if(isVisibleOrNot(xx[i] + xShift, zz[i])) i++;
				else if(xx[i]>=pCd.coord.axisX1 && xx[i]<=pCd.coord.axisX2 && 
					(zz[i]<pCd.coord.axisY1||zz[i]>pCd.coord.axisY2))
					DrawBotLine = FALSE;
			}
			for (j=0; j<i; j++)
				pltOld[j] = pCd.mm_coordz(xx[j],zz[j]);

			if(!draw.isNoNodes) {

				if(draw.isTopBound) {
					oldPen = pDC->SelectObject(&whiteLinePen);
					oldBrush = pDC->SelectObject(&redBrush);
					for (j=0; j<nTop; j++) 
						pDC->Ellipse(plt[j].x-dPlt,plt[j].y-dPlt,plt[j].x+dPlt,plt[j].y+dPlt);
					pDC->SelectObject(oldBrush);
					pDC->SelectObject(oldPen);
					oldPen = pDC->SelectObject(&whitePen);
					oldBrush = pDC->SelectObject(&blueBrush);
					for (j=0; j<i; j++) 
						pDC->Ellipse(pltOld[j].x-dPlt,pltOld[j].y-dPlt,pltOld[j].x+dPlt,pltOld[j].y+dPlt);
					pDC->SelectObject(oldBrush);
					pDC->SelectObject(oldPen);
				} else {
					oldPen = pDC->SelectObject(&whitePen);
					oldBrush = pDC->SelectObject(&blueBrush);
					for (j=0; j<nTop; j++) 
						pDC->Ellipse(plt[j].x-dPlt,plt[j].y-dPlt,plt[j].x+dPlt,plt[j].y+dPlt);
					pDC->SelectObject(oldPen);
					pDC->SelectObject(oldBrush);
					oldPen = pDC->SelectObject(&whiteLinePen);
					oldBrush = pDC->SelectObject(&redBrush);
					for (j=0; j<i; j++) 
						pDC->Ellipse(pltOld[j].x-dPlt,pltOld[j].y-dPlt,pltOld[j].x+dPlt,pltOld[j].y+dPlt);
					pDC->SelectObject(oldPen);
					pDC->SelectObject(oldBrush);
				}
			} // if !draw.isNoNodes
		} // if draw.nodes == 2

		whitePen.DeleteObject();
		whiteLinePen.DeleteObject();
		blackPen.DeleteObject();
		redPen.DeleteObject();
		thickPen.DeleteObject();
		thinPen.DeleteObject();
		blackBrush.DeleteObject();

		redBrush.DeleteObject();
		greenBrush.DeleteObject();
		blueBrush.DeleteObject();

		//CString tStr;
		//if (pCd.coord.xmin < velm->xmin || pCd.coord.xmax > velm->xmax) {
		//	tStr.Format(_T("Model limits: %f , %f km."), velm->xmin, velm->xmax);
		//	myCaption(tStr);
		//}



		return(TRUE);
	}


	// this clipping will consider reducing velocity; it will first apply reducing velocity, and decide if it is outside of the bounds. 
	// In the end,it will put the reducing velocity back as before to the DIGITIZE struct
	void CSeisWideDoc::myClipReducePoints4(CDigitize::DIGITIZE *digIn, CDigitize::DIGITIZE *digOut, double xmin, double xmax, double tmin, double tmax)
	{
		CDigitize pd;
		pd.initDigitizeArray(digOut, digIn->DIG_POINT_MAX, digIn->totCurve);
		double* xtemp = (double *)malloc((size_t)digIn->DIG_POINT_MAX*2*sizeof(double));
		double* ztemp = (double *)malloc((size_t)digIn->DIG_POINT_MAX*2*sizeof(double));
		
		for (int ii=0; ii<digIn->totCurve; ii++) {
			int n = digIn->nPoint[ii];
			int i;
			for (i=0; i<n; i++) {
				xtemp[i] = digIn->x[i][ii]; // ii: curve index;  i: point index per curve
				ztemp[i] = digIn->t[i][ii];
				ztemp[i] -= getReduceTime(getOffsetFromXVal(xtemp[i]), (float)pCd.coord.vred);
				if (myFloat2(pCd.coord.vred) == 0.0f) {
					xtemp[i] *= draw.markerXMultFactor;
					xtemp[i] += draw.markerXShift;
					if (draw.markerIsRevYAxis) ztemp[i] = -ztemp[i];
					ztemp[i] *= draw.markerYMultFactor;
					ztemp[i] += draw.markerYShift;
				}
			}
			n = myClipPoints2(n, n*2, xtemp, ztemp, xmin, xmax, tmin, tmax);
			for (i=0; i<n; i++) {
				digOut->x[i][ii] = (float)xtemp[i];
				digOut->t[i][ii] = (float)ztemp[i];
				digOut->t[i][ii] += (float)getReduceTime(getOffsetFromXVal(xtemp[i]), pCd.coord.vred);
			}
			digOut->nPoint[ii] = n;
		} // for ii
		free(xtemp); xtemp = NULL;
		digOut->totCurve = digIn->totCurve;

		free(ztemp); ztemp = NULL;
	} // end myClipReducePoints4()

	//void CSeisWideDoc::myClipReducePoints4(CDigitize::DIGITIZE *dig2, CCoords::SEI_COORD *coord2) 
	//{
	//	return myClipReducePoints4(dig2, coord2->axisX1, coord2->axisX2, coord2->axisY1, coord2->axisY2);
	//}


	BOOL CSeisWideDoc::loadRayPathFromDepth2TWTT(CString fDepth, CString fTwtt, RAYPATHS *raypaths3, int npoint, int ncurve)
	{
		if (!raypaths3 || !isFileExistNotDirectory(fDepth)) return FALSE;

		// we need to re-create twtt version only in 2 cases: 1. fDepth is newer, 2. RAYPATHS struct in twtt domain is invalid
		if ( isFileNewer(fTwtt, fDepth) && loadRayPathFromFile(fTwtt, raypaths3, npoint, ncurve) )
			return TRUE;

		CVelMod vm;

		// now the twtt version should be reloaded, because it is newer or it is not loaded yet.
		if (!isFileNewer(fTwtt, fDepth)) {
			if (!loadRayPathFromFile(fDepth, &this->raypaths, npoint, ncurve)) {
				// cannot load even the original RAYPATHS in depth, give up
				return FALSE;
			}

			// we need to re-create file:  rPath.out.twtt   
			CFile file2;
			if (!file2.Open(fTwtt, CFile::modeCreate|CFile::modeWrite | CFile::typeBinary)) {
				file2.Close();
				return FALSE;
			}

			// double depth[MOD_LAYER_MAX],vTop[MOD_LAYER_MAX],vBot[MOD_LAYER_MAX];
			CVelMod::VELMOD_X modX;

			double dxv = vel.dxVDesired;
			int nxv = 200;  		//myRound((pCd.coord.xmax - pCd.coord.xmin) / dxv);

			double dtz = vel.dz;  // this is important 
			float dzThreshold = (velMod.isRayDetails) ? (float)(9.*dtz) : (float)(0.2*dtz);

			dxv = (velMod.xmax - velMod.xmin) / (float)(nxv-1);
			int nzv = (int)myRound(velMod.zmax / dtz) + 1;
			double **trv = (double **)alloc2double(nzv, nxv);  // vtr[ix][iz] is for caching the Z-T conversion table for quicker action, iz=[0, dtz ...]
			for (int ix=0; ix<nxv; ix++) {
				modX.dist = velMod.xmin + ix*dxv;
				vm.initModX(&velMod, &modX, false, true, false, vel.dz);
				// vm.getZModFromZ(&velMod, &modX);
				vm.getTzFromZModGrad(&modX, nzv, dtz, &trv[ix][0]);
			}

			for (int count=0; count<this->raypaths.totCurve; count++) {
				int npts = this->raypaths.npts[count];
				int irrcol = this->raypaths.irrcol[count];
				file2.Write(&npts, sizeof(int));
				file2.Write(&irrcol, sizeof(int));

				// now convert zr[] to twtt domain
				float *tr = (float *)ealloc1float(npts);
				for (int j=0; j<npts; j++) {
					register float az = raypaths.zr[count][j];
					register bool isLowPoint =
						j>0 && j<npts-1 &&
						( fabs(az-raypaths.zr[count][j-1]) < dzThreshold || 
						fabs(az-raypaths.zr[count][j+1]) < dzThreshold ||
						(az>raypaths.zr[count][j-1] && az > raypaths.zr[count][j+1]) );

					if (!isLowPoint) {
						register double aix = this->raypaths.xr[count][j] / dxv;
						register double aiz = az / dtz;  // tr[] is in time (sec)
						register int ix = (int)aix;
						if (ix<0) ix = 0;
						if (ix>nxv-1) ix = nxv-1;
						register int iz = (int)aiz + 1;
						if (iz > 1) {
							register double a = trv[ix][iz-2] + (trv[ix][iz-1] - trv[ix][iz-2]) * (aiz - iz);
							if (ix<nxv-1) {
								register double b = trv[ix+1][iz-2] + (trv[ix+1][iz-1] - trv[ix+1][iz-2]) * (aiz - iz);
								a = a + (b-a)*(aix-ix);
							}
							tr[j] = (float)a;  // tr[] is now TWTT
						}
						else
							tr[j] = 0.f;
					} else {
						// if here, it is the lowest point and we need to re-calculate the TWTT for this point
						modX.dist = raypaths.xr[count][j];
						vm.initModX(&velMod, &modX, false, true, false, vel.dz);
						tr[j] = (float)vm.getTimeAtZ(&modX, raypaths.zr[count][j], dtz);
					}
				} // for j
				file2.Write(this->raypaths.xr[count], npts*sizeof(float));
				file2.Write(tr, npts*sizeof(float));
				free1float(tr);
			} // for count
			free2double(trv);
			file2.Close();
		} // if


		// raypaths2 struct may be incomplete in some parameters. So let us reload it from file to avoid coding complexities.
		return loadRayPathFromFile(fTwtt, raypaths3, npoint, ncurve);
	}


	// this is for 
	BOOL CSeisWideDoc::loadRayPathFromDepth2TWTT_detail(CString fDepth, CString fTwtt, RAYPATHS *raypaths3, int npoint, int ncurve)
	{
		if (!raypaths3 || !isFileExistNotDirectory(fDepth)) return FALSE;

		// we need to re-create twtt version only in 2 cases: 1. fDepth is newer, 2. RAYPATHS struct in twtt domain is invalid
		if ( isFileNewer(fTwtt, fDepth) && loadRayPathFromFile(fTwtt, raypaths3, npoint, ncurve) )
			return TRUE;

		CVelMod vm;
		// now the twtt version should be reloaded, because it is newer or it is not loaded yet.
		if (!isFileNewer(fTwtt, fDepth)) {
			if (!loadRayPathFromFile(fDepth, &this->raypaths, npoint, ncurve)) {
				// cannot load even the original RAYPATHS in depth, give up
				return FALSE;
			}

			// we need to re-create file:  rPath.out.twtt   
			CFile file2;
			if (!file2.Open(fTwtt, CFile::modeCreate|CFile::modeWrite | CFile::typeBinary)) {
				file2.Close();
				return FALSE;
			}

			CVelMod::VELMOD_X modX;
			double dxv = vel.dxVDesired;
			int nxv = 50;  		//myRound((pCd.coord.xmax - pCd.coord.xmin) / dxv);
			dxv = (velMod.xmax - velMod.xmin) / (float)(nxv-1);
			int nzv = (int)myRound(velMod.zmax / vel.dz) + 1;
			double **trv = (double **)alloc2double(nzv, nxv);  // vtr[ix][iz] is for caching the Z-T conversion table for quicker action, iz=[0, vel.dz ...]
			for (int ix=0; ix<nxv; ix++) {
				modX.dist = (velMod.xmin + ix*dxv);
				vm.initModX(&velMod, &modX, false, true, true, vel.dz);
				// vm.getZModFromZ(&velMod, &modX);
				vm.getTzFromZModGrad(&modX, nzv, vel.dz, &trv[ix][0]);
			}

			for (int count=0; count<this->raypaths.totCurve; count++) {
				int npts = this->raypaths.npts[count];
				int irrcol = this->raypaths.irrcol[count];
				file2.Write(&npts, sizeof(int));
				file2.Write(&irrcol, sizeof(int));

				// now convert zr[] to twtt domain
				float *zr = (float *)ealloc1float(npts);
				for (int j=0; j<npts; j++) {
					register float aix = (float)(this->raypaths.xr[count][j] / dxv);
					register int ix = (int)aix;
					if (ix<0) ix = 0;
					if (ix>nxv-1) ix = nxv-1;
					register float aiz = this->raypaths.zr[count][j] / (float)vel.dz;  // zr[] is in depth (km)
					register int iz = (int)aiz + 1;
					if (iz > 1) {
						register double a = trv[ix][iz-2] + (trv[ix][iz-1] - trv[ix][iz-2]) * (aiz - iz);
						if (ix<nxv-1) {
							register double b = trv[ix+1][iz-2] + (trv[ix+1][iz-1] - trv[ix+1][iz-2]) * (aiz - iz);
							a = a + (b-a)*(aix-ix);
						}
						zr[j] = (float)a;  // zr[] is now TWTT
					}
					else
						zr[j] = 0.f;
				} // for j
				file2.Write(this->raypaths.xr[count], npts*sizeof(float));
				file2.Write(zr, npts*sizeof(float));
				free1float(zr);
			} // for count
			free2double(trv);
			file2.Close();
		} // if


		// raypaths2 struct may be incomplete in some parameters. So let us reload it from file to avoid coding complexities.
		return loadRayPathFromFile(fTwtt, raypaths3, npoint, ncurve);
	}

	BOOL CSeisWideDoc::loadRayPathFromFile(CString f, RAYPATHS *raypaths2, int npoint, int ncurve)
	{
		if (raypaths2->rayFileModifiedTime == getFileModifiedTime(f) && raypaths2->totCurve>0) return TRUE; // checked cached
		if (!initRaypathsArray(raypaths2, npoint, ncurve)) return FALSE;

		CFile file;

		if (!file.Open(f, CFile::modeRead | CFile::typeBinary)) {
			return FALSE;
		}
		int count=0;
		while(file.Read(&raypaths2->npts[count], sizeof(int)) == sizeof(int)) {
			if (count > ncurve) {
				file.Close();
				return loadRayPathFromFile(f, raypaths2, npoint, count+10);
			}
			if (raypaths2->npts[count] > npoint) {
				file.Close();
				return loadRayPathFromFile(f, raypaths2, raypaths2->npts[count]+100, ncurve);
			}
			file.Read(&raypaths2->irrcol[count], sizeof(int));
			register UINT nBytes = raypaths2->npts[count]*sizeof(float);
			if(file.Read(raypaths2->xr[count], nBytes) != nBytes)  {
				file.Close();
				return FALSE;
			}
			if(file.Read(raypaths2->zr[count], nBytes) != nBytes)  {
				file.Close();
				return FALSE;
			}

			//============================================================
			// now we want to correct for the depth using tx.gunDepth
			if (para.gunDepth2 != 0.) {
				for (register int j=0; j<raypaths2->npts[count]; j++) {
					raypaths2->zr[count][j] += para.gunDepth2;
				}
			}

			count++;
		} // while
		file.Close();
		raypaths2->totCurve = count;
		raypaths2->rayFileModifiedTime = getFileModifiedTime(f);
		raypaths2->rayFileName = f;



		return TRUE;
	}

	void CSeisWideDoc::DrawRayPath(CDC * pDC)
	{
		// only depth domain here
		int i,j,k;
		CPoint *plt;
		CPen aPen;
		if(!para.traveltime) return;
		if (isTimeDomain()) return;
		CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();

		setXShotAll();

		//make rPath.out file in the same directory as velMod.velSecName.
		SetCurrentDirectory(GetPathFromFileSlash(velMod.velSecName));

		if (!loadRayPathFromFile(_T("rPath.out"), &this->raypaths, 1500, 500)) return;

		int irrcolOld = -1;
		COLORREF colorThis = RGB(rand()*205 ,rand()*205 ,rand()*205 );

		CStringArray 	*xrr = new CStringArray();				
		CStringArray 	*zrr = new CStringArray();				
		CStringArray 	*icolrr = new CStringArray();				
		CString cstr;

		for (int count=0; count<this->raypaths.totCurve; count++) {
			int npts = raypaths.npts[count];
			int irrcol = raypaths.irrcol[count];
			if (irrcolOld != irrcol && irrcol > 0) {
				// a new ray group encountered. Need to change color
				// NOTE: the first  irrcol   is   1
				colorThis = this->getRaycodeColor(tx.ivray[irrcol-1]);
				irrcolOld = irrcol;
			}


			//============================================================
			// now we want to calculate the reflection point 
			float zLow = 0.f;
			float xLow = ERRORVAL;
			for (j=0; j<npts; j++) {
				if (zLow < raypaths.zr[count][j]) {
					xLow = raypaths.xr[count][j];
					zLow = raypaths.zr[count][j];
				}
			}
			int icontBot;
			if( isVisibleOrNot((double)xLow, (double)zLow)){
				//############################################################################
				// save 2 numbers for later handling diving rays
				icontBot = 0;
				// First interpolate the velocity model to see if (xLow,zLow) is on the boundary
				BOOL isFound = FALSE;
				for (int icont=0; icont<velMod.ncont; icont++) {
					if (icont >= MOD_LAYER_MAX) break;
					if (isFound) break;
					for (j=1; j<velMod.nzed[icont]; j++) {
						// if the icontBot is obtained, do not update it any more
						if (isFound || icontBot > 0) break;
						if (j >= MOD_POINTS_MAX) break;
						if(xLow>=velMod.xm[j-1][icont] && xLow<=velMod.xm[j][icont]) {
							// now we found that xLow is inside [x1,x2].
							// we try to see if zLow is to be linearly interpolated
							float x1 = velMod.xm[j-1][icont];
							float x2 = velMod.xm[j][icont];
							float z1 = velMod.zm[j-1][icont];
							float z2 = velMod.zm[j][icont];
							float dx = x2-x1;
							if (fabs(dx) >= 0.00001f) {
								float z = z1 + (xLow-x1)*(z2-z1)/dx;
								if (fabs(z-zLow) < 0.00001f) {
									cstr.Format(_T("%f"), xLow);
									xrr->Add(cstr);
									cstr.Format(_T("%f"), zLow);
									zrr->Add(cstr);
									cstr.Format(_T("%d"), irrcol);
									icolrr->Add(cstr);
									isFound = TRUE;
									break;
								}
								if ( z >= zLow) {
									icontBot = icont;
									break;
								}
							}
						} // if xLow
					} // for j
				} // for icont

				if (!isFound && icontBot > 0) {
					// now the (xLow,zLow) is NOT on a boundary, and it is a real diving ray. We need to search 
					// for an adjacent point on the boundary
					// if no ray point is not on this boundary, the reflecting point does not exist
					BOOL isFoundDiving = FALSE;
					for (j=1; j<velMod.nzed[icontBot]; j++) {
						if (isFoundDiving) break;
						float x1 = velMod.xm[j-1][icontBot];
						float x2 = velMod.xm[j][icontBot];
						float z1 = velMod.zm[j-1][icontBot];
						float z2 = velMod.zm[j][icontBot];
						for (k=0; k<npts; k++) {
							if(raypaths.xr[count][k]>= x1 && raypaths.xr[count][k]<=x2) {
								// now xr[k] is inside [x1,x2]
								if (fabs(x2-x1) >= 0.00001f) {
									float z = z1 + (raypaths.xr[count][k]-x1)*(z2-z1)/(x2-x1);
									if (fabs(z-raypaths.zr[count][k]) < 0.00001f) {
										if(isVisibleOrNot((double)raypaths.xr[count][k], (double)raypaths.zr[count][k])){
											cstr.Format(_T("%f"), raypaths.xr[count][k]);
											xrr->Add(cstr);
											cstr.Format(_T("%f"), raypaths.zr[count][k]);
											zrr->Add(cstr);
											cstr.Format(_T("%d"), irrcol);
											icolrr->Add(cstr);
											isFoundDiving = TRUE;
											break;
										} // if isvalid
									} // if fabs(z-zr[k])
								} // if fabs(x1-x1)
							} // if xr[k]
						} // for k
					} // for j
				} // if !isFound
				//############################################################################
			} // if isVisibleOrNot
			//============================================================

			// now decide if we should plot this ray path
			// int tx.rayCodeShow;  // -1=Show All, otherwise 0-20(show only if a ray code equals tx.rayCodeShow). For ray codes>20, will deduct  (int)(irrCol/20) * 20
			BOOL isPlotThisRay = FALSE;
			if (tx.rayCodeShow>=0) {
				register int rayCodeCurr = (irrcol>20)  ?  (int)(irrcol/20) * 20  :  irrcol;
				if (rayCodeCurr == tx.rayCodeShow) 
					isPlotThisRay = TRUE;
			} else {
				if (tx.iShot<0 || tx.iShot>= 100) {
					// this case will plot all rays
					isPlotThisRay = TRUE;
				}
				else {
					// now we only plot for a certain shot or OBS
					float xs = tx.shots[tx.iShot][0];
					float zs = tx.shots[tx.iShot][1];
					float dist0 = (xs-raypaths.xr[count][0])*(xs-raypaths.xr[count][0]) + (zs-raypaths.zr[count][0])*(zs-raypaths.zr[count][0]);
					if (dist0 < 0.00001f) isPlotThisRay = TRUE;
				}
			}

			// now do clipping
			if (isPlotThisRay) {
				double* xtemp = (double *)malloc((size_t)npts*2*sizeof(double));
				double* ztemp = (double *)malloc((size_t)npts*2*sizeof(double));
				for (i=0; i<npts; i++) {
					xtemp[i] = raypaths.xr[count][i];
					ztemp[i] = raypaths.zr[count][i];
				}
				npts = myClipPoints2(npts, npts*2, xtemp, ztemp, pCd.coord.xmin, pCd.coord.xmax, pCd.coord.zmin, pCd.coord.zmax);
				if(npts>0) {
					plt = (CPoint *)malloc(npts*sizeof(CPoint));
					for (j=0; j<npts; j++) {
						plt[j] = pCd.mm_coordz(xtemp[j],ztemp[j]);
					}
					aPen.CreatePen(PS_SOLID, (int)myRound(25* pFrame->thicknessLines), colorThis);
					CPen* oldPen = pDC->SelectObject(&aPen);
					pDC->Polyline(plt,npts);
					pDC->SelectObject(oldPen);
					aPen.DeleteObject();
					free(plt);
				}
				free(xtemp);
				free(ztemp);
			} // if isPlotThisRay
		} // while

		// now plot the low points
		if (!draw.isNoLabelInSide || !draw.isNoLableOutside) {
			short pdx = (short)(pCd.coord.logicalAxes.Width() / 400);
			short dx = (short)((pdx-pCd.coord.logicalAxes.left)/pCd.coord.mm_xscale + pCd.coord.xmin);
			aPen.CreatePen(PS_SOLID, pCd.coord.logicalAxes.Height()/150, RGB(0, 255, 255));
			CPen* oldPen = pDC->SelectObject(&aPen);
			POINT pts[2];
			for (j=0; j<xrr->GetSize(); j++) {
				float xLow = (float)_tstof(xrr->ElementAt(j));
				float zLow = (float)_tstof(zrr->ElementAt(j));
				if (isVisibleOrNot((double)(xLow-dx), (double)zLow) && isVisibleOrNot((double)(xLow+dx), (double)zLow)) {
					pts[0] = pts[1] = pCd.mm_coordz(xLow,zLow);
					pts[0].x -= pdx;
					pts[1].x += pdx;
					pDC->Polyline(pts,2);
				}
			}
			pDC->SelectObject(oldPen);
			aPen.DeleteObject();
		}


		// clean up
		xrr->RemoveAll();
		delete xrr;
		xrr = NULL;
		zrr->RemoveAll();
		delete zrr;
		zrr = NULL;
		icolrr->RemoveAll();
		delete icolrr;
		icolrr = NULL;

	}




	BOOL CSeisWideDoc::DrawColorbar(CDC* pDC) {
		if(!draw.colBar) return FALSE;

		CString tstr;
		CPoint p,p1;
		CPen greenPen(PS_SOLID, (int)(pCd.coord.logicalAxes.Height()/400), RGB(0,255,0));
		CPen whitePen(PS_NULL, 0, RGB(255,255,255));
		CPen thinPen(PS_SOLID, 0, RGB(0,100,0));


		//Draw a frame for the color bar.
		p = pCd.mm_coordz(vel.cxPos, vel.cyPos);
		p1 = pCd.mm_coordz(vel.cxPos+vel.cxExt, vel.cyPos+vel.cyExt);
		CRect rect2(p.x, p.y, p1.x, p1.y);
		CPen* oldPen = pDC->SelectObject(&greenPen);
		CBrush brush(RGB(255,255,255));
		CBrush* oldBrush = pDC->SelectObject(&brush);
		pDC->Rectangle(rect2);
		pDC->SelectObject(oldBrush);
		pDC->SelectObject(oldPen);
		brush.DeleteObject();


		if (vel.colBarVmax < vel.colBarVmin + 1.f) 
			vel.colBarVmax = vel.colBarVmin + 1.f;

		vel.colBarVmin = getMinRounded(vel.colBarVmin, vel.colBarVmax, 8);
		vel.colBarVmax = getMaxRounded(vel.colBarVmin, vel.colBarVmax, 8);


		int nvBar = 50;
		double dvBar = (vel.colBarVmax-vel.colBarVmin)/(double)(nvBar-1);
		for (int iv=0; iv<nvBar; iv++)
		{
			double v = vel.colBarVmin + iv*dvBar;
			COLORREF colThis = getVelocityColor((float)v, vel);
			double x1 = vel.cxPos + vel.cxExt*(v-vel.colBarVmin)/(vel.colBarVmax-vel.colBarVmin);
			p = pCd.mm_coordz(x1, vel.cyPos);
			double x2 = x1 + vel.cxExt/(double)(nvBar-1)*2;
			if(x2>vel.cxPos + vel.cxExt) x2 = vel.cxPos + vel.cxExt;
			p1 = pCd.mm_coordz(x2, vel.cyPos+vel.cyExt);
			CRect rect2(p.x, p.y, p1.x, p1.y);
			CPen* oldPen = pDC->SelectObject(&whitePen);
			CBrush brush(colThis);
			oldBrush = pDC->SelectObject(&brush);
			pDC->Rectangle(rect2);
			pDC->SelectObject(oldBrush);
			pDC->SelectObject(oldPen);
			brush.DeleteObject();
		}	//End of loop iv.

		CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
		LOGFONT logFontNum;
		pDC->GetCurrentFont()->GetLogFont(&logFontNum);
		float xyRatio = (float)logFontNum.lfWidth / (float)logFontNum.lfHeight;
		int numWidth = (LONG)myRound(pFrame->fLabelDistance3 * 150.);
		int numHeight = (LONG)(numWidth / xyRatio);

		COLORREF oldColor = pDC->SetTextColor(RGB(0xB0, 0, 0));
		logFontNum.lfHeight = numHeight;
		logFontNum.lfWidth = numWidth;
		logFontNum.lfEscapement = 0;
		logFontNum.lfOrientation = 0;
		logFontNum.lfWeight = FW_NORMAL;
		logFontNum.lfItalic = 0;
		logFontNum.lfUnderline = 0;
		logFontNum.lfStrikeOut = 0;
		logFontNum.lfCharSet = ANSI_CHARSET;
		logFontNum.lfOutPrecision = OUT_DEFAULT_PRECIS;
		logFontNum.lfClipPrecision = CLIP_DEFAULT_PRECIS;
		logFontNum.lfQuality = DEFAULT_QUALITY;
		logFontNum.lfPitchAndFamily = VARIABLE_PITCH | FF_SWISS;
		_tcscpy_s(logFontNum.lfFaceName, _T("Sans Serif"));
		CFont* fontN = new CFont();
		fontN->CreateFontIndirect(&logFontNum);
		CFont* oldFont = pDC->SelectObject(fontN);

		CPoint plt[2];
		for (int iv=0; iv<10; iv++)
		{
			double v=1+iv;
			if(v<vel.colBarVmin || v>vel.colBarVmax) continue;
			double x1 = vel.cxPos + vel.cxExt*(v-vel.colBarVmin)/(vel.colBarVmax-vel.colBarVmin);
			p = pCd.mm_coordz(x1, vel.cyPos);
			p1 = pCd.mm_coordz(x1, vel.cyPos+vel.cyExt);
			plt[0] = p;
			plt[1] = p1;
			CPen* oldPen = pDC->SelectObject(&thinPen);
			pDC->Polyline(plt, 2);
			pDC->SelectObject(oldPen);
			tstr.Format( _T("%d"), (int)v);
			pDC->TextOut(p1.x-tstr.GetLength()*numWidth/2, p1.y, tstr);
		}
		pDC->SelectObject(oldFont);
		fontN->DeleteObject();
		delete fontN;
		fontN = NULL;

		whitePen.DeleteObject();
		greenPen.DeleteObject();
		thinPen.DeleteObject();
		return TRUE;
	}



	BOOL CSeisWideDoc::DrawCont(CDC* pDC)
	{
		int i,j,icont;

		//Generate velocity contours
		int ix, iv, nv;
		double range;
		double a,b,x1, v,dv, temp;
		CPoint p,p1,plt[MOD_POINTS_MAX*2],pltOld[MOD_POINTS_MAX];
		CString tstr;

		BOOL xminmaxChanged = FALSE;

		myVelModWholeInterpol(); //calculate velocity interpolation.
		//	nx = velMod.grdNx;
		double grdXmax = velMod.grdXmin + (velMod.grdNx-1)*velMod.grdDx;

		//float xminDisp = (float)velMod.xmin;
		//if (xminDisp < pCd.coord.xmin) xminDisp = (float)pCd.coord.xmin;
		//else if (xminDisp > pCd.coord.xmax) return FALSE;  // no need to display anything

		//float xmaxDisp = (float)velMod.xmax;
		//if (xmaxDisp < pCd.coord.xmin) return FALSE;  // no need to display anything
		//else if (xmaxDisp > pCd.coord.xmax) xmaxDisp = (float)pCd.coord.xmax;

		//Start plotting velocity color map.
		CPen whitePen(PS_NULL, 0, RGB(255,255,255));
		CPen whiteLinePen(PS_SOLID, 0, RGB(255,255,255));
		CPen blackPen(PS_SOLID, 0, RGB(0,0,0));
		CPen redPen(PS_SOLID, (int)(pCd.coord.logicalAxes.Height()/400), RGB(255,0,0));
		CPen thickPen(PS_SOLID, (int)(min(pCd.coord.logicalAxes.Width(),pCd.coord.logicalAxes.Height())/600), RGB(0,0,0));
		CPen thinPen(PS_SOLID, 0, RGB(0,100,0));
		CBrush blackBrush(RGB(0,0,0));
		CBrush redBrush(RGB(255,0,0));
		CBrush greenBrush(RGB(0,255,0));
		CBrush blueBrush(RGB(0,0,255));

		//For each velocity contour, look for the right depth for each range.
		//Cycle thru each layer and plot vel within each layer.
		double vminLayer=99999., vmaxLayer=0.;
		for (icont=0; icont<velMod.ncont-1; icont++) {
			//Find the min and max vel for this layer.
			for (ix=0; ix< velMod.grdNx; ix++) {
				if(fabs(velMod.vBot[icont][ix]-velMod.vTop[icont][ix])<0.001) velMod.vBot[icont][ix] = velMod.vTop[icont][ix]+0.001;
			}
			vminLayer=999999.;
			for (ix=0;ix<velMod.grdNx;ix++) 
				if(vminLayer>velMod.vTop[icont][ix]) vminLayer = velMod.vTop[icont][ix];
			for (ix=0;ix<velMod.grdNx;ix++) 
				if(vminLayer>velMod.vBot[icont][ix]) vminLayer = velMod.vBot[icont][ix];
			vmaxLayer=0.;
			for (ix=0;ix<velMod.grdNx;ix++) 
				if(vmaxLayer<velMod.vTop[icont][ix]) vmaxLayer = velMod.vTop[icont][ix];
			for (ix=0;ix<velMod.grdNx;ix++) 
				if(vmaxLayer<velMod.vBot[icont][ix]) vmaxLayer = velMod.vBot[icont][ix];


			dv = vel.dv1;

			//vminLayer should be rounded to a multiple of dv.
			vminLayer = (int)(vminLayer/dv) * dv;

			// we only draw a max of 500 horizontal points.
			nv = (int)((vmaxLayer-vminLayer)/dv + .5);
			if(nv<2)  nv=2;
			if(nv>=500) {
				dv = (vmaxLayer-vminLayer)/499;
				nv = 500;
			}	//Make sure plt[] array do not exceed 500.

			//Loop through colors for this layer.
			for (iv=0; iv<500; iv++)
			{
				v = vminLayer + iv*dv;
				if(v>vmaxLayer) break;

				COLORREF colThis = getVelocityColor((float)v, vel);

				//Search by interpolation for the curve for v in layer icont.
				for (ix=0; ix<velMod.grdNx; ix++) {
					if(ix==(velMod.grdNx-1)) range=grdXmax;
					else range = velMod.grdXmin + velMod.grdDx * (double)ix;
					temp=velMod.vBot[icont][ix]-velMod.vTop[icont][ix];
					if (velMod.grdDepth[icont + 1][ix]<velMod.grdDepth[icont][ix]) {
						a = velMod.grdDepth[icont + 1][ix];
						b = velMod.grdDepth[icont + 1][ix];
					}
					else if(fabs(temp)<0.001) {
						//const vel, odd fix.
						if (nv == 2 && iv == 0) { a = velMod.grdDepth[icont][ix]; b = velMod.grdDepth[icont + 1][ix]; }
						else if (nv == 2 && iv == 1) a = b = velMod.grdDepth[icont + 1][ix];
						else if (fabs(v - velMod.vTop[icont][ix]) <= dv) a = velMod.grdDepth[icont][ix];
						else if (iv <= nv - 1) a = velMod.grdDepth[icont][ix];
						else a = velMod.grdDepth[icont + 1][ix];
					}
					else {
						a = velMod.grdDepth[icont][ix] + (velMod.grdDepth[icont + 1][ix] - velMod.grdDepth[icont][ix])
							*(v-velMod.vTop[icont][ix])/temp;
						b = velMod.grdDepth[icont][ix] + (velMod.grdDepth[icont + 1][ix] - velMod.grdDepth[icont][ix])
							*(v+dv-velMod.vTop[icont][ix])/temp;
					}
					if (a<velMod.grdDepth[icont][ix]) a = velMod.grdDepth[icont][ix];
					if (a>velMod.grdDepth[icont + 1][ix]) a = velMod.grdDepth[icont + 1][ix];
					if(a<pCd.coord.zmin) a=pCd.coord.zmin;
					if(a>pCd.coord.zmax) a=pCd.coord.zmax;
					if (b<velMod.grdDepth[icont][ix]) b = velMod.grdDepth[icont][ix];
					if (b>velMod.grdDepth[icont + 1][ix]) b = velMod.grdDepth[icont + 1][ix];
					if(b<pCd.coord.zmin) b=pCd.coord.zmin;
					if(b>pCd.coord.zmax) b=pCd.coord.zmax;
					plt[ix] = pCd.mm_coordz(range, a);
					plt[2*velMod.grdNx-ix-1] = pCd.mm_coordz(range, b);
				}
				if(!bmp24.bmp24Name.IsEmpty() && bmp24.isDepth)
					pDC->Polyline(plt, 2*velMod.grdNx);
				else {


					CPen* oldPen;
					CBrush* oldBrush;
					if(!draw.isNoColorMap) {
						oldPen = pDC->SelectObject(&blackPen);
						CBrush brush;
						brush.CreateSolidBrush(colThis);
						oldBrush = pDC->SelectObject(&brush);
						pDC->Polygon(plt, 2*velMod.grdNx);
						pDC->SelectObject(oldBrush);
						pDC->SelectObject(oldPen);
						brush.DeleteObject();
					}
					else if(draw.nodes == 2 && icont == draw.iLayerFocus) {
						oldPen = pDC->SelectObject(&blackPen);
						CBrush brush;
						brush.CreateHatchBrush(HS_DIAGCROSS, RGB(255,255,255));
						oldBrush = pDC->SelectObject(&brush);
						pDC->Polygon(plt, 2*velMod.grdNx);
						pDC->SelectObject(oldBrush);
						pDC->SelectObject(oldPen);
						brush.DeleteObject();
					}
					else {
						// if here, no color map, but we need to draw contours only
						oldPen = pDC->SelectObject(&blackPen);
						pDC->Polygon(plt, 2*velMod.grdNx);
						pDC->SelectObject(oldPen);
					}
				}
			} //End of loop iv.
		}  //End of loop icont.

		//Draw color bar.
		DrawColorbar(pDC);


		if(xminmaxChanged)
		{
			AfxMessageBox(_T(" xmin or xmax cannot be beyond model limits; For proper display, re-calculate the drawing or resize the model"));
			draw.isSameDataDisplay = FALSE;
		}
		if(draw.isNoBoundary) return TRUE;

		int dPlt = (int)(MIN(pCd.coord.logicalAxes.Width(), pCd.coord.logicalAxes.Height())/300.) * draw.bigNodes;

		double xx[MOD_POINTS_MAX],zz[MOD_POINTS_MAX];
		CPen* oldPen;
		CBrush* oldBrush;
		for (icont=0; icont<velMod.ncont; icont++)
		{
			i =0;
			for (j=0; j<velMod.nzed[icont]; j++) {
				xx[i] = velMod.xm[j][icont];
				zz[i] = velMod.zm[j][icont];
				i++;
			}
			i = myClipPoints2(i, MOD_POINTS_MAX, xx, zz, pCd.coord.xmin, pCd.coord.xmax, pCd.coord.zmin, pCd.coord.zmax);
			for (j=0; j<i; j++)
				plt[j] = pCd.mm_coordz(xx[j],zz[j]);

			if(draw.nodes ==1 && icont==draw.iLayerFocus)
				oldPen = pDC->SelectObject(&redPen);
			else  if(draw.nodes==2 && !(icont==draw.iLayerFocus||icont==draw.iLayerFocus+1))
				oldPen = pDC->SelectObject(&thinPen);
			else
				oldPen = pDC->SelectObject(&thickPen);
			pDC->Polyline(plt,i);
			pDC->SelectObject(oldPen);

			if(draw.nodes==1 && !draw.isNoNodes)
			{
				if(icont==draw.iLayerFocus)
				{
					oldPen = pDC->SelectObject(&whiteLinePen);
					oldBrush = pDC->SelectObject(&redBrush);
				}
				else
				{
					oldPen = pDC->SelectObject(&whitePen);
					oldBrush = pDC->SelectObject(&greenBrush);
				}
				for (j=0; j<i; j++) pDC->Ellipse
					(plt[j].x-dPlt,plt[j].y-dPlt,plt[j].x+dPlt,plt[j].y+dPlt);
				pDC->SelectObject(oldPen);
				pDC->SelectObject(oldBrush);
			}
		}

		if(draw.nodes == 2 && draw.iLayerFocus>=0 && draw.iLayerFocus<velMod.ncont-1)  //Draw nodes specifying velocities within layer draw.iLayerFocus.
		{
			//Calculate the depths for all nodes (not given by velocity input file).
			if (draw.iLayerFocus < 0) draw.iLayerFocus = 0;
			icont = draw.iLayerFocus;
			BOOL DrawTopLine = TRUE;
			BOOL DrawBotLine = TRUE;
			i = 0;

			for (j=0; j<velMod.nvel[icont][0]; j++)
			{
				for (ix=0; ix<(velMod.nzed[icont]-1); ix++)
				{
					x1 = velMod.xvel[j][icont][0];
					xx[i] = x1;
					if(x1>=velMod.xm[ix][icont] && x1<=velMod.xm[ix+1][icont])
					{
						zz[i] = velMod.zm[ix][icont] + (velMod.zm[ix+1][icont] -
							velMod.zm[ix][icont])*(x1 - velMod.xm[ix][icont])/
							(velMod.xm[ix+1][icont] - velMod.xm[ix][icont]);
						break;
					}
				}
				if(isVisibleOrNot(xx[i], zz[i])) i++;
				else if(xx[i]>=pCd.coord.axisX1 && xx[i]<=pCd.coord.axisX2 && 
					(zz[i]<pCd.coord.axisY1||zz[i]>pCd.coord.axisY2))
					DrawTopLine = FALSE;
			}

			int nTop = i;
			for (j=0; j<nTop; j++)
				plt[j] = pCd.mm_coordz(xx[j],zz[j]);

			i=0;
			for (j=0; j<velMod.nvel[icont][1]; j++)
			{
				for (ix=0; ix<velMod.nzed[icont+1]-1; ix++)
				{
					x1 = velMod.xvel[j][icont][1];
					xx[i] = x1;
					if(x1>=velMod.xm[ix][icont+1] && x1<=velMod.xm[ix+1][icont+1])
					{
						zz[i] = velMod.zm[ix][icont+1] + (velMod.zm[ix+1][icont+1] -
							velMod.zm[ix][icont+1])*(x1 - velMod.xm[ix][icont+1])/
							(velMod.xm[ix+1][icont+1] - velMod.xm[ix][icont+1]);
						break;
					}
				}
				if(isVisibleOrNot(xx[i], zz[i])) i++;
				else if(xx[i]>=pCd.coord.axisX1 && xx[i]<=pCd.coord.axisX2 && 
					(zz[i]<pCd.coord.axisY1||zz[i]>pCd.coord.axisY2))
					DrawBotLine = FALSE;
			}
			for (j=0; j<i; j++)
				pltOld[j] = pCd.mm_coordz(xx[j],zz[j]);

			if(draw.isTopBound)
			{
				oldPen = pDC->SelectObject(&redPen);
				//	if(DrawTopLine) pDC->Polyline(plt,nTop);
				pDC->SelectObject(oldPen);
				oldPen = pDC->SelectObject(&thickPen);
				//	if(DrawBotLine) pDC->Polyline(pltOld,i);
				pDC->SelectObject(oldPen);
			}
			else
			{
				oldPen = pDC->SelectObject(&redPen);
				//	if(DrawBotLine) pDC->Polyline(pltOld,i);
				pDC->SelectObject(oldPen);
				oldPen = pDC->SelectObject(&thickPen);
				//	if(DrawTopLine) pDC->Polyline(plt,nTop);
				pDC->SelectObject(oldPen);
			}
			if( !draw.isNoNodes)
			{
				if(draw.isTopBound)
				{
					oldPen = pDC->SelectObject(&whiteLinePen);
					oldBrush = pDC->SelectObject(&redBrush);
					for (j=0; j<nTop; j++) 
						pDC->Ellipse(plt[j].x-dPlt,plt[j].y-dPlt,plt[j].x+dPlt,plt[j].y+dPlt);
					pDC->SelectObject(oldBrush);
					pDC->SelectObject(oldPen);
					oldPen = pDC->SelectObject(&whitePen);
					oldBrush = pDC->SelectObject(&blueBrush);
					for (j=0; j<i; j++) 
						pDC->Ellipse(pltOld[j].x-dPlt,pltOld[j].y-dPlt,pltOld[j].x+dPlt,pltOld[j].y+dPlt);
					pDC->SelectObject(oldBrush);
					pDC->SelectObject(oldPen);
				}
				else
				{
					oldPen = pDC->SelectObject(&whitePen);
					oldBrush = pDC->SelectObject(&blueBrush);
					for (j=0; j<nTop; j++) 
						pDC->Ellipse(plt[j].x-dPlt,plt[j].y-dPlt,plt[j].x+dPlt,plt[j].y+dPlt);
					pDC->SelectObject(oldPen);
					pDC->SelectObject(oldBrush);
					oldPen = pDC->SelectObject(&whiteLinePen);
					oldBrush = pDC->SelectObject(&redBrush);
					for (j=0; j<i; j++) 
						pDC->Ellipse(pltOld[j].x-dPlt,pltOld[j].y-dPlt,pltOld[j].x+dPlt,pltOld[j].y+dPlt);
					pDC->SelectObject(oldPen);
					pDC->SelectObject(oldBrush);
				}
			} //end of  !draw.isNoNodes
		}

		whitePen.DeleteObject();
		whiteLinePen.DeleteObject();
		blackPen.DeleteObject();
		redPen.DeleteObject();
		thickPen.DeleteObject();
		thinPen.DeleteObject();
		blackBrush.DeleteObject();

		redBrush.DeleteObject();
		greenBrush.DeleteObject();
		blueBrush.DeleteObject();

		return(TRUE);
	}


	BOOL CSeisWideDoc::MyDlgBound(double xOld,double yOld, double xNew,double yNew)
	{
		CBoundNodes dlg;
		dlg.m_layerFocus = draw.iLayerFocus;
		dlg.m_xNew = xNew;
		dlg.m_yNew = yNew;
		dlg.m_xOld = xOld;
		dlg.m_yOld = yOld;
		if (dlg.DoModal() == IDOK)
		{
			draw.iLayerFocus = dlg.m_layerFocus;
			xNew = dlg.m_xNew;
			yNew = dlg.m_yNew;
			xOld = dlg.m_xOld;
			yOld = dlg.m_yOld;
			return (TRUE);
		}
		else return (FALSE);
	}

	BOOL CSeisWideDoc::showDigLineDraw(CDC *pDC)
	{
		//this routine draws all digitized lines or any external line drawings, in time or depth.
		//called only in OnDraw().
		if(draw.isNoBoundary) return FALSE;
		getLineColorArray();

		if (draw.isDigitizing) {
			if (isTimeDomain()) {
				myShowDigitizeTimeDomain(pDC); 
				// it shows all digitize points, plus travel-time curves, data.
			}
			else
				myLineDrawing(pDC); // draws digitized points as lines in depth domain
		}
		else {
			myLineDrawing(pDC);
			if (!isTimeDomain()) {
				// depth domain
				myShowFloatReflectors(pDC); // draws floating reflectors.
			}
		}


		return TRUE;
	}

	BOOL CSeisWideDoc::myLoadFloatReflectors()
	{
		//	if (velMod.floatName.IsEmpty()) return FALSE;
		if (!isFileExistNotDirectory(velMod.floatName)) return FALSE;

		// if here, the float file must be loaded.
		BOOL firstTim=TRUE, textErr=FALSE ;
		TCHAR line[MAXLINE];
		FILE *ifh1;  /* Input file handle */
		int i,j,k,k0, ncurve,npoint;
		float x1,t1;


		if(_tfopen_s(&ifh1, velMod.floatName, _T("r") ) != 0) 
		{
			fclose(ifh1);
			AfxMessageBox(_T("File ")+velMod.floatName+_T(" cannot be opened"));
			velMod.floatName = _T("");
			return FALSE;
		}
		i = ncurve = npoint = 0;
		k0=-9999;

		//first decide how big the arrays should be.
		while (_fgetts(line,MAXLINE,ifh1)!=NULL)
		{
			if (_tcslen(line) < 2) continue;
			if (line[0] == _T('#')) continue; // we do not need comment lines
			if (_stscanf_s(line,_T("%f%f%d"),&x1, &t1, &k)==0)
			{
				textErr=TRUE; 
				continue;
			}
			if(firstTim)
			{
				firstTim = FALSE;
				i ++;
				k0 = k;
			}
			else if(k!=k0 && k0!=-99999)
			{ //now a new curve is encountered and has already been read in.
				if(npoint<i) npoint = i;
				ncurve++;
				i = 1; //must be 1 instead of 0 since already read in.
				k0 = k;
			}
			else 
			{
				i ++;
				k0 = k;
			}
		}
		if(npoint<i) npoint = i;
		ncurve++;

		rewind(ifh1);
		CString tStr;
		if(textErr) tStr  = _T("Input file read with error.");
		if(ncurve>100 || npoint>100) {
			tStr.Format(_T("%s %5d curves & each curve has a max of %5d points. You may use the Select, Move, Delete, Add, and Zoom buttons for digitizing."), tStr, ncurve, npoint);
			myCaption(tStr);
		}

		freeModelArrayEx();  // before allocating arrays for digiting, we need to free them anyway
		velMod.npArray = (int *)ealloc1int(ncurve+1);
		velMod.xArray = (float **)ealloc2float(ncurve,npoint+1);
		velMod.tArray = (float **)ealloc2float(ncurve,npoint+1);

		firstTim = TRUE;
		i=0; j=0; k0=-99999;
		while (_fgetts(line,MAXLINE,ifh1)!=NULL)
		{
			if (_tcslen(line) < 2) continue;
			if (line[0] == _T('#')) continue;
			if( _stscanf_s(line, _T("%f%f%d"),&velMod.xArray[j][i], &velMod.tArray[j][i], &k)==0 ) continue;
			if (k == 0) continue;
			if(firstTim)
			{
				firstTim = FALSE;
				j ++;
				k0 = k;
			}
			else if(k!=k0)
			{ //now a new curve is encountered and has already been read in.
				velMod.npArray[i] = j;
				i ++;
				velMod.xArray[0][i] = velMod.xArray[j][i-1];
				velMod.tArray[0][i] = velMod.tArray[j][i-1];

				k0 = k;
				j = 1;
			}
			else j ++;
		}
		//now write the last set.
		velMod.npArray[i] = j;
		velMod.totCurve = i+1;
		fclose(ifh1);
		velMod.floatNameOld = velMod.floatName; // indicates the data file is loaded already.

		//	extern CFile cfile;
		BOOL initFileStatus = CFile::GetStatus( velMod.floatName, velMod.floatReflStatus ); // static function
		if(!initFileStatus)	return FALSE;

		return TRUE; // succesful.
	}

	void CSeisWideDoc::myShowFloatReflectors(CDC *pDC)
	{
		// draws floating reflectors. Called only from showDigLineDraw() which is called from OnDraw().
		int i,ii,j;
		float xpos,ypos, xpos2, ypos2, xpos3, ypos3;
		CPoint *plt, plt1[4];

		CPen* oldPen;

		if (velMod.floatName.IsEmpty() && !velMod.floatNameOld.IsEmpty())
		{ // free arrays since they may have been used before.
			freeModelArrayEx();
			velMod.floatNameOld = _T("");
			return;
		}
		if (velMod.floatName != velMod.floatNameOld)
		{
			if (! myLoadFloatReflectors() ) return;
		} // end of loading float reflectors.
		else
		{
			//check to see if some other processes have changed the file since this document last initilized it.
			CFileStatus status;
			if(!CFile::GetStatus( velMod.floatName, status )) return;
			CTimeSpan timeSpan1=status.m_mtime-velMod.floatReflStatus.m_mtime;
			LONGLONG nSec1 = timeSpan1.GetTotalSeconds();
			if(nSec1 > 0)
			{
				//	if( AfxMessageBox(_T("File "+velMod.floatName+" on disk is newer than onscreen. Do you want to reload this file to update the display (may need to refresh screen)?", MB_YESNO |MB_ICONINFORMATION) == IDYES)
				//	{
				if (! myLoadFloatReflectors() ) return;

				//	}
			}
		}

		// now start draw the floating reflectors.
		// CPen bluePen(PS_SOLID, (int)(min(pCd.coord.logicalAxes.Width(), pCd.coord.logicalAxes.Height())/600), RGB(0,0,255));
		CPen bluePen(PS_SOLID, 3, RGB(0,255,255));
		CPen thinBluePen(PS_SOLID, 1, RGB(0,0,255));
		//	CPen blackPen(PS_SOLID, (int)(max(pCd.coord.logicalAxes.Width(), pCd.coord.logicalAxes.Height())/600), RGB(0,255,0));

		int dPlt = (int)(MIN(pCd.coord.logicalAxes.Width(), pCd.coord.logicalAxes.Height())/150.) * draw.bigNodes;


		for (i=0; i<velMod.totCurve; i++) {
			ii=0;
			plt = (CPoint *)malloc(velMod.npArray[i]*sizeof(CPoint));
			if(plt==NULL)  {
				freeModelArrayEx();
				AfxMessageBox(_T("Memory un-available 9"));
				return;
			}
			for (j=0; j<velMod.npArray[i]; j++) {
				xpos3 = xpos2 = xpos = velMod.xArray[j][i];
				ypos3 = ypos2 = ypos = velMod.tArray[j][i];
				if (j+1 < velMod.npArray[i]) {
					xpos2 = velMod.xArray[j+1][i];
					ypos2 = velMod.tArray[j+1][i];
				}
				if (j-1 >= 0) {
					xpos3 = velMod.xArray[j-1][i];
					ypos3 = velMod.tArray[j-1][i];
				}
				if(!isVisibleOrNot(xpos,ypos) && !isVisibleOrNot(xpos2,ypos2) && !isVisibleOrNot(xpos3,ypos3) ) continue;

				plt[ii] = pCd.mm_coordz(xpos,ypos);

				ii++;
			}
			if(ii>1)  {
				oldPen = pDC->SelectObject(&bluePen);
				pDC->Polyline(plt, ii);
				pDC->SelectObject(oldPen);
			}
			free (plt);
		}

		bluePen.DeleteObject();
		thinBluePen.DeleteObject();
	}

	int CSeisWideDoc::isPointsLeftofShot(TRAVELTIME *tx2)
	{
		//returns; -1=left; 0=plus; 1=right; Can be directly moved to other files
		// note: 1. an offset can be calculated by: xoffset=xshot-x; xshot+x; x-xshot for -1, 0, 1 cases
		//       2. this value cannot be assigned globally since the file is calculated by fortran 
		//          and loaded passively in C++ , and fortran program does not supply this value
		if (tx2->tot[0]<1 && tx2->tot[1]<1) return 0;

		bool isLeftSideOnly = true;
		bool isRightSideOnly = true;
		// double xshot = tx2->xShot;
		for (int j=0; j<2; j++)
			for (register int k=0; k<tx2->tot[j]; k++) {
				register int n = tx.num[k][j];
				for (register int i=0; i<n; i++) {
					register float xpos = tx2->x[i][k][j];
					if (xpos < tx2->xShot)
						isRightSideOnly = false;
					else if (xpos > tx2->xShot)
						isLeftSideOnly = false;  
					// note: xpos==xshot can be true, so we want to ignore this here
				}
			}


			int out = 0;
			if (!isRightSideOnly && isLeftSideOnly) 
				out = -1;
			else if (!isLeftSideOnly && isRightSideOnly) 
				out = 1;

			return out;
	}


	BOOL CSeisWideDoc::myShowTravelTime(CDC *pDC, CPen *bPen)
	{
		// aPen is the default color to use. But if we want other colors, it can be calculated inside
		// if return FALSE, loading the travel-time curves has failed.
		if ((draw.mode!=0    // time section in km
			&& draw.mode!=7  // NMO or gas hydrate display
			) || !para.traveltime || !isTimeDomain()) return FALSE;

		long i, j, k;
		CPoint *plt;
		CString txPath;
		double xpos, ypos;
		CPen* oldPen;

		bool isDistanceLeftOfShot = false;

		CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();

		//make tx.out file in the same directory as velMod.velSecName, and load "tx.out" into tx.***.
		// Even if the tx.out is already loaded, here I load it again.

		// note: we must calc the xShot each time we display the TT curves; it happens that even when xShot has a valid value, it represents a source for a different segy file
		tx.xShot = (float)getXPosAll();

		// get the TT curves for the correct xShot
		txPath = getWorkingPathSlash();
		if (!isDirectoryExist(txPath)) {
			// cannot determine the current dir, so we just use the current one and do not change it
			txPath = _T("tx.out");
		}
		else
			txPath += _T("tx.out");
		CTime aTime = getFileModifiedTime(txPath);
		if ( (tx.tot[0]>0 || tx.tot[1]>0)   && tx.txTimeLoaded == aTime) {
			// same data already inside tx struct. No need to load again
		}
		else {
			// need to load the data
			if (!myLoadTravelTime(txPath)) return FALSE;

			tx.txTimeLoaded = aTime;  // this enables caching
		}



		int ii=0;

		int pointsSide = this->isPointsLeftofShot(&tx);
		bool isCurvesPlotted = false;
		bool isCircleDetected = false;
		for (j=0; j<2; j++)
			for (k=0; k<tx.tot[j]; k++)
			{
				register int n = tx.num[k][j];
				if (n<2) continue;
				register double *xx = (double *)malloc(n*2*sizeof(double));
				register double *tt = (double *)malloc(n*2*sizeof(double));
				if(xx==NULL || tt==NULL) {
					AfxMessageBox(_T("Memory un-available 4"));
					return FALSE;
				}
				for (i=0; i<n; i++) {
					xpos = tx.x[i][k][j];
					ypos = tx.t[i][k][j] - this->getReduceTime(fabs(xpos - tx.xShot), pCd.coord.vred);	//Apply reduction velocity. Note tx.out outputs distance as X
					if(!para.isDistanceDisplay) {
						// this means displaying in offset
						// a dilemma: if shooting is to the left of SB/OBS, offsets are supposed to be negative, and it's fine. But what if the user is trying to display the data positively...
						// note: an offset can be calculated by: 
						// xoffset=       xshot-x; xshot+x; x-xshot 
						// for pointsSide=     -1,       0,   1 cases
						if (pointsSide<0)
							xpos = tx.xShot - xpos;
						else if (pointsSide>0)
							xpos = xpos - tx.xShot;
						else
							xpos = xpos - tx.xShot;
					}

					xx[i] = xpos;
					tt[i] = ypos;
				} // for i
				ii=myClipPoints2(n, 2*n, xx, tt, pCd.coord.xmin, pCd.coord.xmax, pCd.coord.tmin, pCd.coord.tmax);
				if(ii>0) {
					CPen redPen;

					if (bPen!=NULL) {
						oldPen = pDC->SelectObject(bPen);
					} else if (draw.TTCurveColor < 4) {
						redPen.CreatePen(PS_SOLID, (int)myRound(25 * pFrame->thicknessLines), getRayColor(draw.TTCurveColor));
						oldPen = pDC->SelectObject(&redPen);
					} else {
						register int rayCodeThis = tx.rayCodePerCurve[k][j];
						register int colourCodeThis = (rayCodeThis<tx.ncolour) ? tx.colour[rayCodeThis] : rayCodeThis;
						COLORREF colorThis = this->getRaycodeColor(colourCodeThis);
						redPen.CreatePen(PS_SOLID, min(60, (int)myRound(40.0* pFrame->thicknessLines)),  colorThis);
						oldPen = pDC->SelectObject(&redPen);
					} // if ii

					plt = (CPoint *)malloc(ii*sizeof(CPoint));
					for (i=0; i<ii; i++)
						plt[i] = pCd.mm_coordt(xx[i],tt[i]);
					if (k != tx.circleCurve)
						pDC->Polyline(plt, ii);
					else {
						for (i=0; i<ii; i++) {
							pDC->Ellipse(plt[i].x-200, plt[i].y-200, plt[i].x+200, plt[i].y+200);
						}
						isCircleDetected = true;
					}
					free(plt);

					redPen.DeleteObject();

					pDC->SelectObject(oldPen);
					isCurvesPlotted = true;
				}
				free(xx);
				free(tt);
			} // k and j

			if (tx.circleCurve>=0 && !isCircleDetected) {
				// if here, the circle display is intended but no circles are detected. So we should set to no display
				tx.circleCurve = -1;
			}

			CString str;
			//str.Format(_T("TT :%d"), tx.tot[0]);
			//myCaption(str);

			if (!isCurvesPlotted) {
				str.Format(_T("TT read in for source at %f km, but not plotted. Shooting direction compatible?"), tx.xShot);
				myCaption(str);
			}


			return TRUE;

	}


	BOOL CSeisWideDoc::myShowDigitizeTimeDomain(CDC* pDC)
	{
		if (dig.nPoint==NULL) return FALSE;  // this avoids program crash
		if(!draw.isDigitizing) return FALSE; 

		// No need to reload the digitize points everytime I refresh screen!
		//CDigitize pDg;
		//if (dig.isZeltFormat2)
		//	pDg.myDigitizingLoadzeltTx(&dig, tx.xShot); // first load dig points if any
		//else
		//	pDg.myDigitizingLoadTXTUnix(&dig);


		// it shows all digitize points, for wide angle format.
		//called once by showDigLineDraw(pDC).
		//only uses globals: dig.XXX struct, para.isDistanceDisplay, para.rvVred, tx.xShotInSegy, isValidOrNot(),
		// and in constructing pen styles, uses pCd.coord.logicalAxes.Width(), pCd.coord.logicalAxes.Height().
		CPoint *plt, plt2[2];
		double xpos,ypos;
		int i,j;

		CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();

		// how thick should the error bars be? I choose they are roughly half the trace intervals (i.e. draw.trcInt), no!
		// int penThickness = min(60, (int)myRound(draw.trcInt * pCd.coord.mm_xscale * pFrame->thicknessLines));
		int penThickness = (int)myRound(25 * pFrame->thicknessLines);
		if (penThickness > 200) penThickness = 200;

		// CPen yellowPen(PS_SOLID, (int)(max(pCd.coord.logicalAxes.Width(), pCd.coord.logicalAxes.Height())/600), RGB(255,255,0));
		CPen yellowPen(PS_SOLID, penThickness, RGB(255,0,0));
		CPen thickPen(PS_SOLID, penThickness, RGB(255,100,0));
		CPen thinPen(PS_SOLID, 0, RGB(255,255,0));
		// CPen greenPen(PS_SOLID, (int)(pCd.coord.logicalAxes.Width()*0.0025), RGB(0,255,0)); 
		CPen greenPen(PS_SOLID, penThickness, RGB(255,0,0)); 
		int dPltPlain = (int)(pCd.coord.logicalAxes.Width()/400.* pFrame->thicknessLines);
		//	if (dPltPlain > 50) dPltPlain = 50;
		CPen* oldPen;
		CBrush* oldBrush;
		//draw.bigNodes
		// int tttt = pCd.mm_coord(0.04) - pCd.mm_coord(0.);

		//to avoid program crash, must save a few numbers.
		// dig.nPoint[dig.iCurve] = dig.iPoint+1;
		BOOL inTimeDomain = (isTimeDomain());
		if (dig.isZeltFormat2 && !inTimeDomain) return FALSE;
		// depth domain does not allow non-plain digitize formats.

		// dig.iCurve -- currently active curve number, starting from 0
		// dig.totCurve -- total curve count.
		// ############# consider remove this part and use the function myLineDrawing(CDC * pDC) ########
		for (i=0; i<dig.totCurve; i++) {
		//	if(dig.nPoint[i]<=0 || dig.nPoint[i]>99999) continue;

			int ind = i;
			while (ind >= lineColors.NUM_LINECOLORS)  
				ind -= lineColors.NUM_LINECOLORS;
			COLORREF col = RGB(lineColors.r[ind],
				lineColors.g[ind],
				lineColors.b[ind]);

			CPen randomPen(PS_SOLID, penThickness, col);
			if (i==dig.iCurveSel && dig.iCurveSel>=0)
				oldPen = pDC->SelectObject(&greenPen);
			else 
				oldPen = pDC->SelectObject(&randomPen);

			int ii=0;
			if(!dig.isZeltFormat2) { //plain digitize format.
				plt = (CPoint *)malloc(dig.nPoint[i]*sizeof(CPoint));
				if(plt==NULL) {
					AfxMessageBox(_T("Memory un-available 2"));
					return FALSE; //problem, and return.
				}
				for (j=0; j<dig.nPoint[i]; j++) {
					xpos = dig.x[j][i];
					ypos = dig.t[j][i];
					if (inTimeDomain && draw.mode != 10) {
						//float offset = (para.isDistanceDisplay==0) ?  (float)xpos  :  (float)(xpos - tx.xShotInSegy);
						//ypos -= this->getReduceTime(offset);	   //Apply reduction velocity.
						ypos -= getReduceTime(getOffsetFromXVal(xpos), pCd.coord.vred);

					}
					if (isVisibleOrNot(xpos, ypos)) {
						plt[ii] = pCd.mm_coordt(xpos,ypos);
						ii++;
					}
				}
				if(ii>0) {
					// now for the selected curve, I need to show points in addition to curve!
					if (i==dig.iCurveSel) {
						for (int j=0; j<ii; j++) {
							pDC->Ellipse((int)(plt[j].x-dPltPlain), (int)(plt[j].y-dPltPlain), 
								(int)(plt[j].x+dPltPlain), (int)(plt[j].y+dPltPlain));
						}
					}


					//CPen dynPen(PS_SOLID, penThickness, col);
					//oldPen = pDC->SelectObject(&dynPen);
					pDC->Polyline(plt, ii);
				}
				free (plt); 
			} else { 
				//digitize format with error bars.
				register double dPlt;
				CPoint plt2[2];
				// if the bar is too small, we need to boost it to display properly
				if (dig.digResolution[i] < 2.*vel.dz) 
					dig.digResolution[i] = (float)(2.*vel.dz);
				if (dig.barForm == 0) { //show as error bar.
					for (j=0; j<dig.nPoint[i]; j++) {
						xpos = dig.x[j][i];
						ypos = dig.t[j][i];
						//	ypos -= this->getReduceTime((float)(xpos - tx.xShotInSegy));	   //Apply reduction velocity.
						ypos -= getReduceTime(getOffsetFromXVal(xpos), pCd.coord.vred);

						if(isVisibleOrNot(xpos,ypos)) {
							plt2[0] = pCd.mm_coordt(xpos,ypos-0.5*dig.digResolution[i]);
							double a = ypos+0.5*dig.digResolution[i];
							if (a > pCd.coord.axisY2) a = pCd.coord.axisY2; // this helps to make the rectangle perfect for resizing in corelDraw
							plt2[1] = pCd.mm_coordt(xpos, a);
							pDC->Polyline(plt2, 2);
						}
					}
				}
				else if(dig.barForm == 1 || dig.barForm == 2) { //show as circle (1=open; 2=filled).
					CBrush redBrush(RGB(255, 0, 0));
					if (dig.barForm == 2)
						oldBrush = pDC->SelectObject(&redBrush);
					else
						pDC->SelectStockObject(NULL_BRUSH);
					for (j=0; j<dig.nPoint[i]; j++) {
						xpos = dig.x[j][i];
						ypos = dig.t[j][i];
						// ypos -= this->getReduceTime((float)(xpos - tx.xShotInSegy));	   //Apply reduction velocity.
						ypos -= getReduceTime(getOffsetFromXVal(xpos), pCd.coord.vred);

						if(isVisibleOrNot(xpos,ypos)) {
							dPlt = 0.5*dig.digResolution[i];
							plt2[0] = pCd.mm_coordt(xpos,ypos);
							double a = ypos+dPlt;
							if (a > pCd.coord.axisY2) a = pCd.coord.axisY2; // this helps to make the rectangle perfect for resizing in corelDraw
							plt2[1] = pCd.mm_coordt(xpos,a);
							int iPlt = abs(plt2[1].y - plt2[0].y);
							pDC->Ellipse(plt2[0].x-iPlt/2, plt2[0].y-iPlt, plt2[0].x+iPlt/2, plt2[0].y+iPlt);
						}
					}
					if (dig.barForm == 2)
						pDC->SelectObject(oldBrush);
				}
				else if (dig.barForm == 3) { //show as crosses.
					for (j=0; j<dig.nPoint[i]; j++) {
						xpos = dig.x[j][i];
						ypos = dig.t[j][i];
						//	ypos -= this->getReduceTime((float)(xpos - tx.xShotInSegy));	   //Apply reduction velocity.
						ypos -= getReduceTime(getOffsetFromXVal(xpos), pCd.coord.vred);

						if(isVisibleOrNot(xpos,ypos)) {
							dPlt = 0.5*dig.digResolution[i];
							plt2[0] = pCd.mm_coordt(xpos,ypos-dPlt);
							plt2[1] = pCd.mm_coordt(xpos,ypos+dPlt);
							pDC->Polyline(plt2, 2);
							int iPlt = abs(plt2[1].y - plt2[0].y)/4;
							plt2[1] = plt2[0] = pCd.mm_coordt(xpos,ypos);
							plt2[0].x -= iPlt;
							plt2[1].x += iPlt;
							pDC->Polyline(plt2, 2);
						}
					}
					pDC->SelectObject(oldPen);
				} // if (dig.barForm
			} // if(dig.fileFormat 

			pDC->SelectObject(oldPen);
		} // for (i=0; i<=dig.iCurve

		//	myLineDrawingLabel(pDC);	

		// finally, plot the raycodes
		// draw.isShowRaycode = TRUE;
		if (inTimeDomain && draw.isShowRaycode) {
			int numHeight = max(pCd.coord.logicalAxes.Width(), pCd.coord.logicalAxes.Height())/90;
			int numWidth = max(pCd.coord.logicalAxes.Width(), pCd.coord.logicalAxes.Height())/280;
			LOGFONT logFontNum;
			logFontNum.lfHeight = numHeight;
			logFontNum.lfWidth = numWidth;
			logFontNum.lfEscapement = 450;
			logFontNum.lfOrientation = 450;
			// logFontNum.lfWeight = FW_NORMAL;
			logFontNum.lfWeight = FW_BOLD;
			logFontNum.lfItalic = 0;
			logFontNum.lfUnderline = 0;
			logFontNum.lfStrikeOut = 0;
			logFontNum.lfCharSet = ANSI_CHARSET;
			logFontNum.lfOutPrecision = OUT_DEFAULT_PRECIS;
			logFontNum.lfClipPrecision = CLIP_DEFAULT_PRECIS;
			logFontNum.lfQuality = DEFAULT_QUALITY;
			logFontNum.lfPitchAndFamily = FF_SWISS;
			_tcscpy_s(logFontNum.lfFaceName, _T("Arial"));
			CFont* fontN = new CFont();
			fontN->CreateFontIndirect(&logFontNum);
			CFont* oldFont = pDC->SelectObject(fontN);
			COLORREF oldColor = pDC->SetTextColor(RGB(20, 20, 20));


			for (i=0; i<dig.totCurve; i++) {
				// added Jan 2007 to plot labels for this curve
				// first, we get the center x
				double xMin = 9999999.; 
				double xMax = -9999999.; 
				for (j=0; j<dig.nPoint[i]; j++) {
					xpos = dig.x[j][i];
					if (xMin>xpos) xMin = xpos;
					if (xMax<xpos) xMax = xpos;
				}
				xpos = (float)(xMin + (xMax-xMin)*0.5);

				// now get the center ypos value
				for (j=0; j<dig.nPoint[i]-1; j++) {
					if (xpos>=dig.x[j][i] && xpos<=dig.x[j+1][i]) {
						double dx = dig.x[j+1][i] - dig.x[j][i];
						if (dx < 0.00001) {
							ypos = dig.t[j][i];
						}
						else {
							ypos = dig.t[j][i] + 
								(float)((dig.t[j+1][i]-dig.t[j][i])/dx*(xpos-dig.x[j][i]));
						}
						break;
					}
				}

				//	ypos -= getReduceTime((draw.mode==6 || para.isDistanceDisplay==0)  ?  (float)xpos  :   (float)(xpos-tx.xShotInSegy) );
				ypos -= getReduceTime(getOffsetFromXVal(xpos), pCd.coord.vred);


				if(isVisibleOrNot(xpos,ypos)) {
					// now plot the labels for this curve i
					CPoint p = pCd.mm_coordt(xpos,ypos);
					// strncpy(&s[0], &dig.label[i*8], 7);
					CString a;
					a.Format(_T("%d"), dig.ivray[i]);
					for (int k=0; k<tx.rayCodes->GetCount(); k++) {
						CString strRayCode = tx.rayCodes->GetAt(k);
						strRayCode.Trim();
						if (strRayCode.Find(a) == 0) {
							a = strRayCode;
							break;
						}
					}
					pDC->TextOut((int)(p.x-numWidth), (int)(p.y-numHeight*0.5),a);
					// why (p.x-numWidth) ?  Because the texts tilts by 45degrees to the upperright
				}
			} // for i

			fontN->DeleteObject();
			pDC->SelectObject(oldFont);
			pDC->SetTextColor(oldColor);
		}

		return TRUE;
	}






	BOOL CSeisWideDoc::DrawTimeArr(CDC* pDC) {
		double ymin = this->isTimeDomain()  ?  pCd.coord.tmin  :  pCd.coord.zmin;
		double ymax = this->isTimeDomain()  ?  pCd.coord.tmax  :  pCd.coord.zmax;
		return DrawSectionArr(pDC, draw.timeSecName, ymin, ymax);
	}


	BOOL CSeisWideDoc::DrawSectionArr(CDC* pDC, CString fSection, double ymin, double ymax)
	{
		CString tStr;
		if (draw.isSameDataDisplay && !pDC->IsPrinting()) return TRUE;  // printers can have very different resolutions, so we will calculate again

		if(!isFileExistNotDirectory(fSection) ) {
			// if here,  the time section does not exist, and no need to continue this routine
			return(TRUE);
		}
		//	if (draw.isNoSeismic) return TRUE;
		CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();

		//	if (!isFileExistNotDirectory(ampColorDyn.colFileName))
		ampColorDyn.colFileName = GetPathFromFileSlash(fSection) + _T("colPalette.txt");
		// must calc color pallette file name every time!

		int i,j;
		//CPoint p,p1;
		double xpos, ypos;
		if (head.aveAmp <  MINAMP) {
			tStr.Format(_T("Detected average amplitude is too small: %f"), head.aveAmp);
			myCaption(tStr);
			head.aveAmp = 1.;
		}


		// NOTE: para.gain, gain_real, para.clip, clip_real, para.fillOff, fillOff are for area fill only
		double trcInterval = (para.isDistanceDisplay)  ?  head.distInterval  :  head.offsetInterval;
		if (head.aveAmp < MINAMP)
			areaFill.gain_real = 1.0;
		else {
			double aMean = draw.isAvgEnergy ?  head.aveAmp*head.aveAmp  :   head.aveAmp;
			areaFill.gain_real = para.gain / aMean * trcInterval; // when a sample multiplied by gain_real, it'll span a suitable trace span.
		}
		areaFill.clip_real = para.clip * trcInterval;
		areaFill.fillOff = para.fillOff * trcInterval;
		if ( trcInterval < pCd.coord.xValuePerPixel) {
			// but if a single trace is spanned to <1 pixel, it'll display blanks at all. So...
			double gainHike = pCd.coord.xValuePerPixel / trcInterval * 1.2;
			areaFill.gain_real *= gainHike;
			areaFill.clip_real *= gainHike;
			areaFill.fillOff *= gainHike;
		}

		//Note draw.trcInt is the average trace interval in km.
		double res=(double)pDC->GetDeviceCaps(HORZRES) / (double)pDC->GetWindowExt().cx;
		//p = pCd.mm_coord((double)pCd.coord.xmin,0.);
		//p1 = pCd.mm_coord((double)(pCd.coord.xmin+draw.trcInterval),0.);
		//a = (p1.x-p.x)*res;  //a is double prec.
		double temp = areaFill.clip_real;
		double gainExtraAtTrace; // for each trace, the gain can change with offset

		if(temp < 0.0) temp = fabs(temp);

		bool isRealWaveForm = para.wiggle ==0 || para.wiggle ==2 || para.wiggle == 5;
		bool isXArrContainRange = para.wiggle < 4;


		SegyWrapperEx sw(fSection, pCd.coord.xmin, pCd.coord.xmax, ymin, ymax, draw.mode, pCd.coord.vred);

		// NOTE: drawing of depth domain segy also comes thru this routine. So please do not shift the data by draw.distShift for depth sections
		bool isTime = isTimeDomain() == TRUE;
		if (isTime && para.isDistanceDisplay)
			sw.m_distShift = draw.distShift;

		if (draw.mode == 7) {
			// hydro display needs extra parameters here
			sw.m_waterDepth = para.waterVelocityAboveObs;
			sw.m_obsDepth = para.obsDepth;
		}

		tStr.Format(_T("Loading..."));
		myCaption(tStr);
		CSegyMeta::segyHeadInit(fSection, &head, 0);
		sw.m_dxMin = pCd.coord.xValuePerPixel;
		sw.m_zGun = para.gunDepth2;  // only used for NMO mode
		sw.m_vWater = para.waterVelocityAboveObs;
		sw.m_waterDepth = para.waterVelocityAboveObs;
		sw.m_obsDepth = para.obsDepth;

		//	double trcInterval = (para.isDistanceDisplay)  ?  head.distInterval  ;  head.offsetInterval;
		if (sw.openDistance(!para.isDistanceDisplay, trcInterval, head.numTraces, &head) && sw.nxmax > 1) {
			if (dig.twin_isEnergy) {
				float amp;  // we only want float here since the array is float only, not double
				float aMedian;
				int i, j;
				for (i=0; i<sw.nxmax; i++)
					aMedian = (float)getMedianAbsolute(&sw.trArr[i].data[0], sw.bh.hns);
				if (aMedian > MINAMP) aMedian = 1.f / aMedian;
				for (j=0; j<sw.bh.hns; j++) {
					amp = sw.trArr[i].data[j]*aMedian;
					// why do we divide it by mean value? This is because if we do not, the values may be 
					// extremely large to go beyond floating max.
					if (amp != 0.f) {
						amp *= amp;
						sw.trArr[i].data[j] = (sw.trArr[i].data[j] < 0.f)  ?  -amp  :  amp;
					}
				}
			}

			int numsamp = sw.bh.hns;
			tStr.Format(_T("Loaded %d traces at sample length %d into memory...Plot preparing..."), sw.nxmax, numsamp);
			myCaption(tStr);

			COLORREF colPos = RGB(0,0,0);
			COLORREF colNeg = RGB(255,255,255);
			CPen redPen(PS_SOLID, 0, RGB(255,0,0));
			CPen bluePen(PS_SOLID, 0, RGB(0,0,255));
			CPen whitePen(PS_NULL, 0, colNeg);
			CPen blackPen(PS_SOLID, 0, colPos);
			CPen wigPen(PS_SOLID, 0, RGB(seisBiColor2.maxAmpR,seisBiColor2.maxAmpG,seisBiColor2.maxAmpB));
			CBrush brush(colPos);
			CPen* oldPen;
			CBrush* oldBrush;
			sw.sortDistance(!para.isDistanceDisplay);
			// after the sorting, the first trace should have the m_xmin


			double odt = (double)MIL / (double) sw.bh.hdt;
			double dt = 1. / odt;
			int sampByte = (sw.bh.format != 3) ?  4  :  2;

			float **xArray = (float **)ealloc2float(numsamp, sw.nxmax);
			float *yArr = (float *)ealloc1float(numsamp);
			float *rangeArray = (float *)ealloc1float(sw.nxmax);
			CPoint *plt = (CPoint *)alloc1(numsamp, sizeof(CPoint));
			if (xArray==NULL || yArr==NULL || rangeArray==NULL || plt==NULL) {
				// memory prob; got to exit decently
				if (xArray!=NULL) free2float (xArray);
				if (yArr!=NULL) free1float (yArr);
				if (rangeArray!=NULL) free1float (rangeArray);
				if (plt!=NULL) free (plt);
				sw.freeSegyDataArrayOnly(sw.nxmax);
				return FALSE;
			}

			// if ymin or ymax are wider than the data itself, we need to narrow the gap 
			//  otherwise the plot has problem
			if (ymin < sw.m_tmin) ymin = sw.m_tmin;
			if (ymax > sw.m_tmax) ymax = sw.m_tmax;

			for (j=0; j<numsamp; j++) {
				yArr[j] = (float)(ymin + j * dt);
			}
			for (i=0; i<sw.nxmax; i++) {
				float trOffset = getOffset(&sw.trArr[i]);
				rangeArray[i] = (para.isDistanceDisplay) ?  
					getDistance(&sw.trArr[i])  :  trOffset;
				// float reducedTime2 = getReduceTime((float)trOffset);
				float tShift = getTraceDelay(&sw.trArr[i]) - (float)getReduceTime((float)trOffset, pCd.coord.vred);
				//gainExtraAtTrace = 1.;
				gainExtraAtTrace = (para.isNegativeFill)  ?  -1.0  :  1.0;  
				if(isTimeDomain() && para.gainDist && fabs(trOffset)>(double)para.baseGain) {
					gainExtraAtTrace *=  pow(fabs(trOffset)/(double)para.baseGain, (double)para.basePower);
				} // if

				// NOTE: ymin and ymax are the desired plot/axis limits
				//    but the segy data may have different time limits  sw.m_tmin

				for (j=0; j<numsamp; j++) {
					ypos = (double)j*dt + tShift;
					// ypos -= reducedTime; //Apply reduction velocity. already reduced in sw.
					if(ypos < ymin ) ypos=ymin;
					if(ypos > ymax ) ypos=ymax;

					xpos = sw.trArr[i].data[j];
					if (draw.isAvgEnergy) {
						xpos *= sgn(xpos)*xpos;
					}
					xpos *= gainExtraAtTrace;
					if(isXArrContainRange) {
						xpos *= areaFill.gain_real;
						if(xpos> temp) xpos = temp; // clipping
						else if(xpos< (-temp)) xpos = - temp;
						xpos += rangeArray[i]; // add range
						if(xpos<pCd.coord.xmin ) xpos=pCd.coord.xmin;
						if(xpos>pCd.coord.xmax ) xpos=pCd.coord.xmax;
					}
					xArray[i][j] = (float)xpos;
					// yArray[i][j] = (float)ypos;
				} // for j
			} // for i
			sw.freeSegyDataArrayOnly(sw.nxmax);

			tStr.Format(_T("Finished loading %d traces with sample length %d into memory."), sw.nxmax, numsamp);
			myCaption(tStr);


			// now do the plotting
			//tStr.Format(_T("Plotting..."));
			//myCaption(tStr);

			register CPoint pPrev, pCurr;
			pPrev.y = pCurr.y = 0;
			pPrev.x = pCd.mm_coordx(rangeArray[0]);
			pDC->LPtoDP(&pPrev);
			switch ( para.wiggle)
			{
			case 0:
				break;
			case 1:
				if(draw.isFillSmall && !para.isNegativeFill) {
					this->airColorSmallArr(pDC, sw.nxmax, numsamp, xArray, rangeArray, ymin, dt, colPos, colNeg, areaFill.fillOff);
				}
				else if(draw.isFillSmall && para.isNegativeFill) {
					this->airColorSmallArr(pDC, sw.nxmax, numsamp, xArray,  rangeArray, ymin, dt, colNeg, colPos, areaFill.fillOff);
				}
				else if(!draw.isFillSmall && !para.isNegativeFill) {
					this->airColorBigArr(pDC, sw.nxmax, numsamp, xArray,  rangeArray, ymin, dt, colPos, colNeg, areaFill.fillOff);
				}
				else {
					this->airColorBigArr(pDC, sw.nxmax, numsamp, xArray, rangeArray, ymin, dt, colNeg, colPos, areaFill.fillOff);
				}
				break;
			case 2:
				if(draw.isFillSmall && !para.isNegativeFill) {
					this->airColorSmallArr(pDC, sw.nxmax, numsamp, xArray, rangeArray, ymin, dt, colPos, colNeg, areaFill.fillOff);
				}
				else if(draw.isFillSmall && para.isNegativeFill) {
					this->airColorSmallArr(pDC, sw.nxmax, numsamp, xArray, rangeArray, ymin, dt, colNeg, colPos, areaFill.fillOff);
				}
				else if(!draw.isFillSmall && !para.isNegativeFill) {
					this->airColorBigArr(pDC, sw.nxmax, numsamp, xArray, rangeArray, ymin, dt, colPos, colNeg, areaFill.fillOff);
				}
				else {
					this->airColorBigArr(pDC, sw.nxmax, numsamp, xArray, rangeArray, ymin, dt, colNeg, colPos, areaFill.fillOff);
				}
				break;
			case 3:
				if(draw.isFillSmall) {
					this->airColorSmallArr(pDC, sw.nxmax, numsamp, xArray, rangeArray, ymin, dt, areaFill.fillOff);
				}
				else {
					this->airColorBigArr(pDC, sw.nxmax, numsamp, xArray, rangeArray, ymin, dt, areaFill.fillOff);
					//for (i=0; i<sw.nxmax; i++)
					//	airCol(pDC, numsamp, &xArray[i][0], &yArray[i][0], rangeArray[i], fillOff);
				}
				break;
			case 4:
				this->floodFillArr5Multi(pDC, sw.nxmax, numsamp, xArray, rangeArray, sw.m_xmin, sw.m_xmax, sw.m_tmin, sw.m_tmax, draw.memMaxMB);
				break;
			case 5:
				this->floodFillArr5Multi(pDC, sw.nxmax, numsamp, xArray, rangeArray, sw.m_xmin, sw.m_xmax, sw.m_tmin, sw.m_tmax, draw.memMaxMB);
				break;


			default:
				CBrush brush;
				CPen aPen;
				float *xx = (float *)alloc1float(sw.nxmax);
				float *yy = (float *)alloc1float(numsamp);
				float *zz = (float *)alloc1float(sw.nxmax*numsamp);
				float tShift0 = getTraceDelay(&sw.trArr[0]);  // need to check if other traces have different delay
				for (j=0; j<numsamp; j++) {
					//yy[j] = (float)mm_coord(0., (double)j*dt + tShift0).y;
					yy[j] = (float)yArr[j];
				}
				int ix;
				for (ix=0; ix<sw.nxmax; ix++) {
					xx[ix] = (float)rangeArray[ix];
				}
				CString tstr;
				for (j=0; j<numsamp; j++) {
					for (ix=0; ix<sw.nxmax; ix++) {
						zz[j*sw.nxmax+ix] = sw.trArr[ix].data[j];
					} // for ix
				} // for j
				float c, da; // for contouring
				//da = (float)((head.maxAmp-head.aveAmp)/(float)ampColorDyn.numContours);
				da = (float)(head.maxAmp*2.0/(float)draw.numContours);
				//da2 = (float)(head.aveAmp + (head.maxAmp-head.aveAmp) * 0.07f);
				//da3 = (float)(head.aveAmp + (head.maxAmp-head.aveAmp) * 0.01f);

				double amax = draw.isAvgEnergy ?  head.maxAmp*head.maxAmp  :  head.maxAmp;
				//double amin = draw.mode>9  ?  0.0  :  -head.maxAmp;
				double amin = 0.0;

				COLORREF *colArr = (COLORREF *)malloc(draw.numContours * sizeof(COLORREF));
				float *percentAmpExpanded = (float *)malloc(draw.numContours * sizeof(float));
				if (!getExpandedColorTableDepreciated(colArr, percentAmpExpanded, draw.numContours)) {
					draw.numContours = ampColorDyn.num; // if cannot be expanded, just use the original number of colors
				} // if

				for (c = (float)amin; c<=(float)amax; c+=da ) {
					// COLORREF cref = getAmpRgbPixel(c);
					//COLORREF cref = getAmpRgbPixel(c, -(float)head.maxAmp, (float)head.maxAmp);
					register COLORREF ac = getColorRef4Amp(c, draw.numContours, percentAmpExpanded, colArr);
					brush.CreateSolidBrush(ac);
					aPen.CreatePen(PS_SOLID, 1, ac);
					oldBrush = pDC->SelectObject(&brush);
					oldPen = pDC->SelectObject(&aPen);
					psContour(pDC, c, sw.nxmax, &xx[0], numsamp, &yy[0], &zz[0], para.wiggle == 7);
					pDC->SelectObject(oldBrush);
					pDC->SelectObject(oldPen);
					aPen.DeleteObject();
					brush.DeleteObject(); 
				} // for
				free(colArr);
				free(percentAmpExpanded);
				//psContour(pDC, (float)head.aveAmp, numTraceRead, &xx[0], numsamp, &yy[0], &zz[0]);
				free1float(xx);
				free1float(yy);
				free1float(zz);
				break;


			} // switch


			if (isRealWaveForm) {
				if (!isXArrContainRange) {
					for (i=0; i<sw.nxmax; i++) {
						//register double delta;
						//delta = (isXArrContainRange)  ?  rangeArray[i] * (1.f - gain_real)  :  rangeArray[i];
						for (j=0; j<numsamp; j++)
							xArray[i][j] = (float)(xArray[i][j]*areaFill.gain_real + rangeArray[i]);
						// xArray[i][j] = (float)(xArray[i][j]*gainArray[i] + delta);
					}
				}
				this->wiggleArr(pDC, sw.nxmax, numsamp, xArray, rangeArray, yArr);
			}


			try {
				if (xArray != NULL) {
					free2float (xArray);
					xArray = NULL;
				}  
			}
			catch(...){
			}
			free1float (yArr);
			free1float (rangeArray);
			//free1double (gainArray);
			free(plt); 

		} // if sw
		else {
			// no data loaded
			myCaption(_T("No traces found."));
		}

		tStr.Format(_T("Done."));
		myCaption(tStr);
		return TRUE;
	}




	BOOL CSeisWideDoc::DrawSectionTrcArr(CDC* pDC, CString fSection, int trace1, int trace2)
	{

		//	return TRUE; // test

		CString tStr;
		if (draw.isSameDataDisplay && !pDC->IsPrinting()) return TRUE;
		//	if (draw.isNoSeismic) return TRUE;
		if(!isFileExistNotDirectory(fSection) ) {
			// if here,  the time section does not exist, and no need to continue this routine
			return(TRUE);
		}
		int i,j;
		CPoint p,p1;
		double a, xpos, ypos;
		double ymin = pCd.coord.tmin;  // ymin/ymax are the data limits, not the X-Y axis limits
		double ymax = pCd.coord.tmax;

		// need to decide trace step for reading
		if(head.aveAmp < MINAMP*0.00001) {
			tStr.Format(_T("Could not estimate gain based on the first 100 traces."));
			myCaption(tStr);
		}

		// fixup odds
		if (para.wiggle < 0) para.wiggle = 4;

		if (!isFileExistNotDirectory(ampColorDyn.colFileName))
			ampColorDyn.colFileName = GetPathFromFileSlash(fSection) + _T("colPalette.txt");
		// colFileName is enough: the actual plotting function will use it to load the color table for display.

		// NOTE: para.gain, gain_real, para.clip, clip_real, para.fillOff, fillOff are for area fill only
		//if (head.maxAmp < head.aveAmp * 2.) head.maxAmp = head.aveAmp * 2.0;
		int minTraceStep = 1 + (int)(0.3*pCd.coord.xValuePerPixel);
		double aMean = draw.isAvgEnergy ?   head.aveAmp*head.aveAmp  :   head.aveAmp;
		areaFill.gain_real = para.gain / aMean * minTraceStep; // when a sample multiplied by gain_real, it'll span a suitable trace span.
		areaFill.clip_real = para.clip * minTraceStep;
		areaFill.fillOff = para.fillOff * minTraceStep;
		//if ( draw.trcInt < pCd.coord.xValuePerPixel) {
		//		// but if a single trace is spanned to <1 pixel, it'll display blanks at all. So...
		//		double gainHike = pCd.coord.xValuePerPixel / draw.trcInt * 1.2;
		//		areaFill.gain_real *= gainHike;
		//		areaFill.clip_real *= gainHike;
		//		areaFill.fillOff *= gainHike;
		//}

		//Note draw.trcInt is the average trace interval in km.
		double res=(double)pDC->GetDeviceCaps(HORZRES) / (double)pDC->GetWindowExt().cx;
		p = pCd.mm_coordt((double)pCd.coord.xmin,0.);
		p1 = pCd.mm_coordt((double)(pCd.coord.xmin+1.0),0.);
		a = (p1.x-p.x)*res;  //a is double prec.
		double temp = areaFill.clip_real;
		double gainExtraAtTrace;
		if(temp < 0.0) temp = fabs(temp);
		bool isRealWaveForm = para.wiggle ==0 || para.wiggle ==2 || para.wiggle == 5;

		COLORREF colPos = RGB(0,0,0);
		COLORREF colNeg = RGB(255,255,255);
		CPen redPen(PS_SOLID, 0, RGB(255,0,0));
		CPen bluePen(PS_SOLID, 0, RGB(0,0,255));
		CPen whitePen(PS_NULL, 0, colNeg);
		CPen blackPen(PS_SOLID, 0, colPos);
		CPen wigPen(PS_SOLID, 0, RGB(seisBiColor2.maxAmpR,seisBiColor2.maxAmpG,seisBiColor2.maxAmpB));
		CBrush brush(colPos);
		CPen* oldPen;
		CBrush* oldBrush;
		gainExtraAtTrace = (para.isNegativeFill)  ?  -1.0  :  1.0;


		SegyWrapper sw(fSection);
		sw.m_tmin = (float)pCd.coord.tmin;
		sw.m_tmax = (float)pCd.coord.tmax;
		CSegyMeta::segyHeadInit(fSection, &head, 0);
		//getTraceMetaMore(fSection, &head);
		//sw.m_tminFile = head.tminFile;
		//sw.m_tmaxFile = head.tmaxFile;

		tStr.Format(_T("Loading..."));
		myCaption(tStr);
		//sw.nxDesired = 1;  // testing
		CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
		//	sw.m_isIBMFloatSegy = pFrame->gIsIBMFloatSegy == TRUE;

		if (sw.openTrace(trace1, trace2, minTraceStep, 0, &head)) {
			int numsamp = sw.bh.hns;
			tStr.Format(_T("Loaded %d traces at sample length %d into memory...Plot preparing..."), sw.nxmax, numsamp);
			myCaption(tStr);
			double odt = (double)MIL / (double) sw.bh.hdt;
			double dt = 1. / odt;
			int sampByte = (sw.bh.format != 3) ?  4  :  2;

			// note: data min and max time might have changed after reading the data
			// so we need to re-calc the ymin and ymax:
			// if ymin or ymax are wider than the data itself, we need to narrow the gap 
			//  otherwise the plot has problem
			if (ymin < sw.m_tmin) ymin = sw.m_tmin;
			if (ymax > sw.m_tmax) ymax = sw.m_tmax;



			float **xArray = (float **)ealloc2float(numsamp, sw.nxmax);
			float *yArr = (float *)ealloc1float(numsamp);
			float *rangeArray = (float *)ealloc1float(sw.nxmax);
			CPoint *plt = (CPoint *)alloc1(numsamp, sizeof(CPoint));
			if (xArray==NULL || yArr==NULL || rangeArray==NULL || plt==NULL) {
				// memory prob; got to exit decently
				if (xArray!=NULL) free2float (xArray);
				if (yArr!=NULL) free1float (yArr);
				if (rangeArray!=NULL) free1float (rangeArray);
				if (plt!=NULL) free (plt);
				sw.freeSegyDataArrayOnly(sw.nxmax);
				return FALSE;
			}

			for (j=0; j<numsamp; j++) {
				yArr[j] = (float)(ymin + j * dt);
			}
			for (i=0; i<sw.nxmax; i++) {
				float trOffset = getOffset(&sw.trArr[i]);
				rangeArray[i] = (float)sw.trArr[i].tracl;
				float tShift = getTraceDelay(&sw.trArr[i]);

				for (j=0; j<numsamp; j++) {
					ypos = (double)j*dt + tShift;
					// ypos -= reducedTime; //Apply reduction velocity. already reduced in sw.
					if(ypos < ymin ) ypos=ymin;
					if(ypos > ymax ) ypos=ymax;
					xpos = sw.trArr[i].data[j];
					if (draw.isAvgEnergy) {
						xpos *= sgn(xpos)*xpos;
					}
					xpos *= gainExtraAtTrace;
					if(para.wiggle < 4 ) {
						xpos *= areaFill.gain_real;
						if(xpos> temp) xpos = temp; // clipping
						else if(xpos< (-temp)) xpos = - temp;
						xpos += rangeArray[i]; // add range
						if(xpos<pCd.coord.xmin ) xpos=pCd.coord.xmin;
						if(xpos>pCd.coord.xmax ) xpos=pCd.coord.xmax;
					}
					xArray[i][j] = (float)xpos;
				} // for j
			} // for i
			sw.freeSegyDataArrayOnly(sw.nxmax);

			tStr.Format(_T("Plotting..."));
			myCaption(tStr);


			// now do the plotting
			int stepCount;
			switch ( para.wiggle)
			{
			case 0:
				stepCount = 0;
				for (i=0; i<sw.nxmax; i++) {
					for (j=0; j<numsamp; j++)
						plt[j] = pCd.mm_coordt(xArray[i][j],yArr[j]);
					oldPen = pDC->SelectObject(&blackPen);
					pDC->Polyline(plt, numsamp);
					pDC->SelectObject(oldPen);
				} // for i
				break;
			case 1:
				if(draw.isFillSmall && !para.isNegativeFill) {
					this->airColorSmallArr(pDC, sw.nxmax, numsamp, xArray, rangeArray, (float)ymin, (float)dt, colPos, colNeg, areaFill.fillOff);
				}
				else if(draw.isFillSmall && para.isNegativeFill) {
					this->airColorSmallArr(pDC, sw.nxmax, numsamp, xArray, rangeArray, (float)ymin, (float)dt, colNeg, colPos, areaFill.fillOff);
				}
				else if(!draw.isFillSmall && !para.isNegativeFill) {
					this->airColorBigArr(pDC, sw.nxmax, numsamp, xArray, rangeArray, (float)ymin, (float)dt, colPos, colNeg, areaFill.fillOff);
				}
				else {
					this->airColorBigArr(pDC, sw.nxmax, numsamp, xArray, rangeArray, (float)ymin, (float)dt, colNeg, colPos, areaFill.fillOff);
				}
				break;
			case 2:
				stepCount = 0;
				for (i=0; i<sw.nxmax; i++) {
					for (j=0; j<numsamp; j++)
						plt[j] = pCd.mm_coordt((double)xArray[i][j],yArr[j]);
					oldPen = pDC->SelectObject(&blackPen);
					pDC->Polyline(plt, numsamp);
					pDC->SelectObject(oldPen);
				} // for i
				if(draw.isFillSmall && !para.isNegativeFill) {
					this->airColorSmallArr(pDC, sw.nxmax, numsamp, xArray, rangeArray, (float)ymin, (float)dt, colPos, colNeg, areaFill.fillOff);
				}
				else if(draw.isFillSmall && para.isNegativeFill) {
					this->airColorSmallArr(pDC, sw.nxmax, numsamp, xArray, rangeArray, (float)ymin, (float)dt, colNeg, colPos, areaFill.fillOff);
				}
				else if(!draw.isFillSmall && !para.isNegativeFill) {
					this->airColorBigArr(pDC, sw.nxmax, numsamp, xArray, rangeArray, (float)ymin, (float)dt, colPos, colNeg, areaFill.fillOff);
				}
				else {
					this->airColorBigArr(pDC, sw.nxmax, numsamp, xArray, rangeArray, (float)ymin, (float)dt, colNeg, colPos, areaFill.fillOff);
				}
				break;
			case 3:
				if(draw.isFillSmall) {
					this->airColorSmallArr(pDC, sw.nxmax, numsamp, xArray, rangeArray, (float)ymin, (float)dt, areaFill.fillOff);
				}
				else {
					this->airColorBigArr(pDC, sw.nxmax, numsamp, xArray, rangeArray, (float)ymin, (float)dt, areaFill.fillOff);
				}
				break;
			case 4:
				this->floodFillArr5Multi(pDC, sw.nxmax, numsamp, xArray, rangeArray, (double)trace1, (double)trace2, sw.m_tmin, sw.m_tmax, draw.memMaxMB);
				break;
			case 5:
				this->floodFillArr5Multi(pDC, sw.nxmax, numsamp, xArray, rangeArray, (double)trace1, (double)trace2, sw.m_tmin, sw.m_tmax, draw.memMaxMB);
				stepCount = 0;
				for (i=0; i<sw.nxmax; i++) {
					for (j=0; j<numsamp; j++) {
						xpos = xArray[i][j]*areaFill.gain_real;
						if(xpos> temp) xpos = temp; // clipping
						else if(xpos< (-temp)) xpos = - temp;
						xpos += rangeArray[i]; // add range
						plt[j] = pCd.mm_coordt(xpos, (double)yArr[j]);
					}
					oldPen = pDC->SelectObject(&blackPen);
					pDC->Polyline(plt, numsamp);
					pDC->SelectObject(oldPen);
				} // for i
				break;


			default:
				CBrush brush;
				CPen aPen;
				float *xx = (float *)alloc1float(sw.nxmax);
				float *yy = (float *)alloc1float(numsamp);
				float *zz = (float *)alloc1float(sw.nxmax*numsamp);
				float tShift0 = getTraceDelay(&sw.trArr[0]);  // need to check if other traces have different delay
				for (j=0; j<numsamp; j++) {
					//yy[j] = (float)mm_coord(0., (double)j*dt + tShift0).y;
					yy[j] = (float)yArr[j];
				}
				int ix;
				for (ix=0; ix<sw.nxmax; ix++) {
					xx[ix] = (float)rangeArray[i];
				}

				for (j=0; j<numsamp; j++) {
					for (ix=0; ix<sw.nxmax; ix++) {
						zz[j*sw.nxmax+ix] = sw.trArr[ix].data[j];
					} // for ix
				} // for j
				float c, da; // for contouring
				//da = (float)((head.maxAmp-head.aveAmp)/(float)ampColorDyn.numContours);
				da = (float)(head.maxAmp*2.0/(float)draw.numContours);
				//da2 = (float)(head.aveAmp + (head.maxAmp-head.aveAmp) * 0.07f);
				//da3 = (float)(head.aveAmp + (head.maxAmp-head.aveAmp) * 0.01f);

				double amax = draw.isAvgEnergy ?  head.maxAmp*head.maxAmp  :  head.maxAmp;
				//double amin = draw.mode>9  ?  0.0  :  -head.maxAmp;
				double amin = 0.0;

				COLORREF *colArr = (COLORREF *)malloc(draw.numContours * sizeof(COLORREF));
				float *percentAmpExpanded = (float *)malloc(draw.numContours * sizeof(float));
				if (!getExpandedColorTableDepreciated(colArr, percentAmpExpanded, draw.numContours)) {
					draw.numContours = ampColorDyn.num; // if cannot be expanded, just use the original number of colors
				} // if

				for (c = (float)amin; c<=(float)amax; c+=da ) {
					register COLORREF ac = getColorRef4Amp(c, draw.numContours, percentAmpExpanded, colArr);
					// register int ic = getColorIndex4Amp(&c, percentAmpExpanded);
					brush.CreateSolidBrush(ac);
					aPen.CreatePen(PS_SOLID, 1, ac);
					oldBrush = pDC->SelectObject(&brush);
					oldPen = pDC->SelectObject(&aPen);
					psContour(pDC, c, sw.nxmax, &xx[0], numsamp, &yy[0], &zz[0], para.wiggle == 7);
					pDC->SelectObject(oldBrush);
					pDC->SelectObject(oldPen);
					aPen.DeleteObject();
					brush.DeleteObject(); 
				} // for
				free(colArr);
				free(percentAmpExpanded);
				//psContour(pDC, (float)head.aveAmp, numTraceRead, &xx[0], numsamp, &yy[0], &zz[0]);
				free1float(xx);
				free1float(yy);
				free1float(zz);
				break;


			} // switch

			if (xArray != NULL) free2float (xArray);
			free1float (yArr);
			free1float (rangeArray);
			free(plt); 
		}
		// if sw
		tStr.Format(_T("Done."));
		myCaption(tStr);

		return TRUE;
	}




	// for all drawing routines, Draw trace meta info such as trace numbers, FFIDs et al.
	// x is the trace distance in km
	BOOL CSeisWideDoc::drawTrcInfo(CDC* pDC, float xkm, segy *tr, int *sPos, int *sLen, BOOL isDetail) 
	{
		if (draw.isNoLableOutside) return FALSE;
		if (tr == NULL) return TRUE;

		//int numHeight = max(pCd.coord.logicalAxes.Width(), pCd.coord.logicalAxes.Height())/100;
		//int numWidth = max(pCd.coord.logicalAxes.Width(), pCd.coord.logicalAxes.Height())/180;
		int numHeight = 300;
		int numWidth = 150;
		LOGFONT logFontNum;
		logFontNum.lfHeight = numHeight;
		logFontNum.lfWidth = numWidth;
		logFontNum.lfEscapement = 0;
		logFontNum.lfOrientation = 0;
		logFontNum.lfWeight = FW_REGULAR;
		logFontNum.lfItalic = 0;
		logFontNum.lfUnderline = 0;
		logFontNum.lfStrikeOut = 0;
		logFontNum.lfCharSet = ANSI_CHARSET;
		logFontNum.lfOutPrecision = OUT_DEFAULT_PRECIS;
		logFontNum.lfClipPrecision = CLIP_DEFAULT_PRECIS;
		logFontNum.lfQuality = DEFAULT_QUALITY;
		logFontNum.lfPitchAndFamily = VARIABLE_PITCH | FF_SWISS;
		_tcscpy_s(logFontNum.lfFaceName, _T("Sans Serif"));
		CFont fontN;
		fontN.CreateFontIndirect(&logFontNum);
		CFont* oldFont;
		COLORREF oldColor;


		//if (isDetail) {
		//	oldFont = pDC->SelectObject(&fontN);
		//	oldColor = pDC->SetTextColor(RGB(0, 0, 255));
		//	if(draw.headInfo=="Trace No.") pDC->TextOut(0,0,"Trc");
		//	if(draw.headInfo=="FFID") pDC->TextOut(0,0,"FFID");
		//	if(draw.headInfo=="CDP") pDC->TextOut(0,0,"CDP");
		//	if(draw.headInfo=="All")
		//	{
		//		pDC->TextOut(0,0,"Trc");
		//		pDC->TextOut(0,numHeight,"FFID");
		//		pDC->TextOut(0,numHeight*2,"SP");
		//		pDC->TextOut(0,numHeight*3,"CDP");
		//		pDC->TextOut(0,numHeight*4,"Dist");
		//		pDC->TextOut(0,numHeight*5,"sx");
		//		pDC->TextOut(0,numHeight*6,"gx");
		//		pDC->TextOut(0,numHeight*7,"Offset");
		//	}

		//	pDC->SelectObject(oldFont);
		//	pDC->SetTextColor(oldColor);
		//}



		bool isTime = isTimeDomain() == TRUE;
		int x = pCd.mm_coordx((double)xkm);   // x is now the client coordinate

		oldFont = pDC->SelectObject(&fontN);
		oldColor = pDC->SetTextColor(RGB(0, 0, 255));
		//if(draw.headInfo=="Trace No.")
		//{
		//	_stprintf(s, "%d", tr->tracl);
		//	lenThis = numWidth*_tcslen(s);
		//	if(tr->tracl % 10 == 0  &&   abs(x - *sPos) > lenThis*1.3)
		//	{
		//		pDC->TextOutA(x-lenThis/2, 0,s);
		//		*sPos = x;
		//	}
		//}
		//else if(draw.headInfo=="FFID")
		//{
		//	_stprintf(s, "%d", tr->fldr);
		//	lenThis = numWidth*_tcslen(s);
		//	if(tr->tracl % 10 == 0  &&   abs(x - *sPos) > lenThis*1.3)
		//	{
		//		pDC->TextOutA(x-lenThis/2, 0,s);
		//		*sPos = x;
		//	}
		//}
		//else if(draw.headInfo=="CDP")
		//{
		//	_stprintf(s, "%d", tr->cdp);
		//	lenThis = numWidth*_tcslen(s);
		//	if(tr->tracl % 10 == 0  &&   abs(x - *sPos) > lenThis*1.3)
		//	{
		//		pDC->TextOutA(x-lenThis/2, 0,s);
		//		*sPos = x;
		//	}
		//}
		//else if(draw.headInfo=="All")
		//{
		//	_stprintf(s, "%d", tr->tracl);
		//	lenThis = numWidth*_tcslen(s);
		//	int sPosNew = -1;
		//	
		//	if(tr->tracl % 10 == 0  &&   abs(x - *sPos) > lenThis*1.3)
		//	{
		//		pDC->TextOutA(x-lenThis/2, 0,s);
		//		sPosNew = max(sPosNew, x+lenThis/2);

		//		_stprintf(s, "%d", tr->fldr);  
		//		lenThis = numWidth*_tcslen(s);
		//		pDC->TextOutA(x-lenThis/2, numHeight,s);

		//		_stprintf(s, "%d", tr->ep);
		//		lenThis = numWidth*_tcslen(s);
		//		pDC->TextOutA(x-lenThis/2, numHeight*2,s);

		//		_stprintf(s, "%d", tr->cdp); 
		//		lenThis = numWidth*_tcslen(s);
		//		pDC->TextOutA(x-lenThis/2, numHeight*3,s);

		//		
		//		_stprintfA(s, "%d", (int)myRound( getDistance(tr)*1000.f ) );
		//		lenThis = numWidth*_tcslen(s);
		//		pDC->TextOutA(x-lenThis/2, numHeight*4,s);

		//		_stprintf(s, "%d", tr->sx);
		//		lenThis = numWidth*_tcslen(s);
		//		pDC->TextOutA(x-lenThis/2, numHeight*5,s);

		//		_stprintf(s, "%d", tr->gx);
		//		lenThis = numWidth*_tcslen(s);
		//		pDC->TextOutA(x-lenThis/2, numHeight*6,s);

		//		_stprintf(s, "%d", tr->offset);
		//		lenThis = numWidth*_tcslen(s);
		//		pDC->TextOutA(x-lenThis/2, numHeight*7,s);

		//		if (sPosNew > 0) *sPos = sPosNew;
		//	} // if abs(x
		//}
		pDC->SelectObject(oldFont);
		pDC->SetTextColor(oldColor);

		fontN.DeleteObject();
		// oldFont->DeleteObject();  do not delete oldFont since it is the default one on screen

		return FALSE;
	}





	// check if a client point is a valid for onscreen display. Not consider any reduction velocity
	BOOL CSeisWideDoc::isVisibleOrNot(double x, double y)
	{
		if(x< pCd.coord.xmin-0.00001 || x> pCd.coord.xmax+0.00001 ||
			y< pCd.coord.axisY1-0.00001 || y> pCd.coord.axisY2+ 0.00001) return(FALSE);

		return(TRUE);
	}

	// NOTE: this function will Not load the velMod if it is already loaded!!! 
	//BOOL CSeisWideDoc::MyInitVelGen()
	//{
	//
	//	//if(velMod.velSecOld==velMod.velSecName) 
	//	//	return TRUE;
	//	if (!isEndWith(velMod.velSecName, _T(".bin"))) return FALSE;
	//	if (velMod.ncont>0 && velMod.velSecTimeLoaded == getFileModifiedTime(velMod.velSecName)) 
	//		return TRUE;
	//
	//	CVelMod vm;
	//	vm.velModSetArrays(&velMod);
	//	// return TRUE;
	//	if (!vm.MyInitVel(&velMod, velMod.velSecName, vel.dz)) {
	//		// if failed, we free 
	//		myCaption(_T("Failed to load the velocity file"));
	//		return FALSE;
	//	}
	//
	//
	//	return TRUE;
	//}



	//void CSeisWideDoc::myVelModInterpolDisplay() {
	//	CVelMod vm;
	//	vm.myVelModInterpolDisplay(&velMod, pCd.coord.xmin, pCd.coord.xmax, draw.distShift, vel.dxV);
	//}


	void CSeisWideDoc::myVelModWholeInterpol()
	{
		//this routine calculates the interpolated value for X, Z, V for a given model that is already loaded by MyInitVel.
		//myVelModInterpol is called by DrawVel(), DrawCont() et al.
		//However, myWholeVelModInterpol is only called by OnDigitizingMigratelinedrawings() to interpolate the whole model that 
		//        may be bigger than what is currently displayed on screen.

		//this rouine set values for 
		// depth[MOD_LAYER_MAX][500],vTop[MOD_LAYER_MAX][500],vBot[MOD_LAYER_MAX][500] and nx; //for vel interpolation.
		// in velMod struct.
		CVelMod vm;
		vm.myVelModInterpolDisplay(&velMod, velMod.xmin, velMod.xmax, draw.distShift, vel.dxVDesired);
		return;
	}


	//yminExact, ymaxExact are the exact values of min and max box to plot, although they may not be the "nice" numbers to show. 
	//   Note:  1. ymin and ymax already considered the time or depth domain issues correctly.
	//          2. I have not pre-calculated the xminNice, xmaxNice values; this is because we may have issues of trace or distance/offset which may need separate handling. 
	//             If you really want to do this, you need to test before commiting.
	//          3. This routine is only called by ticks()  and is therefore put to the protected section in header file
	void CSeisWideDoc::DrawAxesTicksValues(CDC* pDC, double yminExact, double ymaxExact, double yminNice, double yTickNice, int fontWidth, int fontHeight)
	{
		CPoint p,tick[2];
		CString tStr;
		int ideltx = -130; 
		int idelty = 120;

		// xmin can be 1, which should be rounded to 0, and incremented by a regular tick value
		// xmax cannot be rounded, otherwise 899 becomes 1000, which is not good
		double xminNice = getMinRounded(pCd.coord.xmin, pCd.coord.xmax, 10);  
		double xmaxNice = (float)niceNum(pCd.coord.xmax, false); 
		double xTickNice = getTickRounded(pCd.coord.xmin, pCd.coord.xmax, 2, 50, pCd.coord.xTick);
		if (xTickNice < (xmaxNice-xminNice)*0.05 ) xTickNice = (xmaxNice-xminNice)*0.05;
		else if (xTickNice > (xmaxNice-xminNice)*0.5 ) xTickNice = (xmaxNice-xminNice)*0.5;
		xTickNice = getTickRounded(pCd.coord.xmin, pCd.coord.xmax, 2, 50, xTickNice);

		if (xminNice > pCd.coord.xmin) {
			do {
				xminNice -= xTickNice;
			} while (xminNice > pCd.coord.xmin);
		}

		bool isTime = isTimeDomain() == TRUE;
		double x = xminNice;
		do {
			if (x>= pCd.coord.xmin && x<=pCd.coord.xmax) {
				if(pCd.coord.isFaceUp==1) {
					tick[0] = pCd.mm_coord(x, yminExact, isTime);	//delty is negative.
				} else {
					tick[0] = pCd.mm_coord(x, ymaxExact, isTime);
				}
				tick[1].x = tick[0].x;
				tick[1].y = tick[0].y + (long)(1.5*idelty);

				if(xTickNice < 0.01) tStr.Format(_T("%1.2f"), x);
				else if(xTickNice < 1.) tStr.Format(_T("%1.1f"), x);
				else tStr.Format(_T("%d"), (int)x);
				int countS =tStr.GetLength(); 

				pDC->Polyline(tick, 2);
				pDC->TextOut(tick[1].x- (countS*fontWidth)/2, tick[1].y, tStr);

				// now draw minor ticks
				double xCurrent;
				xCurrent = x+xTickNice*0.2;
				if (xCurrent < pCd.coord.xmax) {
					tick[0] = pCd.mm_coord( xCurrent, ymaxExact, isTime);
					tick[1].x = tick[0].x;
					tick[1].y = tick[0].y + idelty;
					pDC->Polyline(tick, 2);
				}
				xCurrent = x+xTickNice*0.4;
				if (xCurrent < pCd.coord.xmax) {
					tick[0] = pCd.mm_coord( xCurrent, ymaxExact, isTime);
					tick[1].x = tick[0].x;
					tick[1].y = tick[0].y + idelty;
					pDC->Polyline(tick, 2);
				}
				xCurrent = x+xTickNice*0.6;
				if (xCurrent < pCd.coord.xmax) {
					tick[0] = pCd.mm_coord( xCurrent, ymaxExact, isTime);
					tick[1].x = tick[0].x;
					tick[1].y = tick[0].y + idelty;
					pDC->Polyline(tick, 2);
				}
				xCurrent = x+xTickNice*0.8;
				if (xCurrent < pCd.coord.xmax) {
					tick[0] = pCd.mm_coord( xCurrent, ymaxExact, isTime);
					tick[1].x = tick[0].x;
					tick[1].y = tick[0].y + idelty;
					pDC->Polyline(tick, 2);
				}
			}

			x+=xTickNice;
		} while (x<= pCd.coord.xmax);	  //Finish drawing xTicks





		CPen* oldPen;
		CPen gridPen(PS_DOT, 0, RGB(200,200,200));
		double y = yminNice;
		if (y>yminExact) y -= yTickNice;
		do  {
			if (y>=yminExact &&  y <= ymaxExact) {
				tick[0] = pCd.mm_coord( pCd.coord.xmin, y, isTime);
				tick[1].x = tick[0].x + (long)(1.5*ideltx);
				tick[1].y = tick[0].y;

				if(yTickNice < 0.1) tStr.Format(_T("%1.2f"), y);
				else if(yTickNice < 1.) tStr.Format(_T("%1.1f"), y);
				else tStr.Format(_T("%d"), (int)y);
				pDC->MoveTo(tick[0]);
				pDC->LineTo(tick[1]);
				//	pDC->Polyline(tick, 2);
				pDC->TextOut((int)(tick[1].x-tStr.GetLength()*fontWidth), tick[1].y-fontHeight/2, tStr);

				// draw grids
				if (y>yminExact &&  y < ymaxExact) {
					tick[1].x =pCd.mm_coordx((double)pCd.coord.xmax);
					oldPen = pDC->SelectObject(&gridPen);
					pDC->MoveTo(tick[0]);
					pDC->LineTo(tick[1]);
					// pDC->Polyline(tick, 2);
					pDC->SelectObject(oldPen);
				} // if y


				// now draw minor ticks
				double yCurrent;
				yCurrent = y+yTickNice*0.2;
				if (yCurrent>=yminExact &&  yCurrent <= ymaxExact) {
					tick[0] = pCd.mm_coord( pCd.coord.xmin, yCurrent, isTime);
					tick[1].x = tick[0].x + ideltx;
					tick[1].y = tick[0].y;
					pDC->Polyline(tick, 2);
				}
				yCurrent = y+yTickNice*0.4;
				if (yCurrent>=yminExact &&  yCurrent <= ymaxExact) {
					tick[0] = pCd.mm_coord( pCd.coord.xmin, yCurrent, isTime);
					tick[1].x = tick[0].x + ideltx;
					tick[1].y = tick[0].y;
					pDC->Polyline(tick, 2);
				}
				yCurrent = y+yTickNice*0.6;
				if (yCurrent>=yminExact &&  yCurrent <= ymaxExact) {
					tick[0] = pCd.mm_coord( pCd.coord.xmin, yCurrent, isTime);
					tick[1].x = tick[0].x + ideltx;
					tick[1].y = tick[0].y;
					pDC->Polyline(tick, 2);
				}
				yCurrent = y+yTickNice*0.8;
				if (yCurrent>=yminExact &&  yCurrent <= ymaxExact) {
					tick[0] = pCd.mm_coord( pCd.coord.xmin, yCurrent, isTime);
					tick[1].x = tick[0].x + ideltx;
					tick[1].y = tick[0].y;
					pDC->Polyline(tick, 2);
				}
			} // if y

			// now go to the next major tick
			y+= yTickNice;
		} while (y <= ymaxExact);	  //Finish drawing yTicks


	}

	/*
	rect: the overall drawing window
	rectLogicalAxes: the area defined by the X-Y axes

	Our tick marks and labels will be both outside and inside the X-Y axes
	*/
	void CSeisWideDoc::Tick(CDC* pDC)
	{
		CSize size = pDC->GetWindowExt(); 

		this->DrawAxes(pDC, pCd.coord.logicalAxes);


		//	TCHAR s[80];
		CPoint p,p1,tick[2],temp;
		double y;
		int countS, i;
		CString tStr;
		CPen* oldPen;


		// since the tick() needs to consider both time and depth domains, we use general variables to describe the vertical axis
		float yminRound;
		float ymaxRound;
		float ytickRound;
		float yminExact;  // actual 
		float ymaxExact;
		float ytickExact;
		if (isTimeDomain()) {
			yminExact = (float)pCd.coord.tmin;
			ymaxExact = (float)pCd.coord.tmax;
			ytickExact = (float)pCd.coord.tTick;
		}
		else {
			yminExact = (float)pCd.coord.zmin;
			ymaxExact = (float)pCd.coord.zmax;
			ytickExact = (float)vel.zTick;
		}

		yminRound =   (float)niceNum(yminExact, true);
		ymaxRound = (float)niceNum(ymaxExact, true);
		ytickRound = getTickRounded(yminExact, ymaxExact, 2, 50, ytickExact);
		if (yminRound > yminExact) {
			do {
				yminRound -= ytickRound;
			} while (yminRound > yminExact);
		}



		CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
		ASSERT(pFrame);
		ASSERT_KINDOF(CMainFrame, pFrame);
		int numRef = 15700; // cannot make this floating. Need to depreciate it!!!

		if (pFrame->fLabelDistance3 == 0.f) pFrame->fLabelDistance3 = 1.f;
		COLORREF oldColor;
		oldColor = pDC->SetTextColor(RGB(0, 0, 0));

		// Initialize a LOGFONT structure for the fonts.
		LOGFONT logFont; // font for drawing labels such as Distance (km)
		pDC->GetCurrentFont()->GetLogFont(&logFont);
		float xyRatio = (float)logFont.lfWidth / (float)logFont.lfHeight;
		_tcscpy_s(logFont.lfFaceName, _T("Arial"));
		logFont.lfWidth = (LONG)myRound(pFrame->fLabelDistance3 * 250.);
		logFont.lfHeight = (LONG)(logFont.lfWidth / xyRatio);
		logFont.lfEscapement = 0;
		logFont.lfOrientation = 0; //important: make both 900.
		logFont.lfWeight = 700;
		logFont.lfItalic = 0;
		logFont.lfUnderline = 0;
		logFont.lfStrikeOut = 0;
		logFont.lfCharSet = ANSI_CHARSET;
		logFont.lfOutPrecision = OUT_DEFAULT_PRECIS;
		logFont.lfClipPrecision = CLIP_DEFAULT_PRECIS;
		logFont.lfQuality = DEFAULT_QUALITY;
		logFont.lfPitchAndFamily = FF_SWISS;


		LOGFONT logFontNum;  // font for drawing numbers
		pDC->GetCurrentFont()->GetLogFont(&logFontNum);
		_tcscpy_s(logFontNum.lfFaceName, _T("Arial"));
		logFontNum.lfWidth = (LONG)myRound(pFrame->fLabelDistance3 * 225.);
		logFontNum.lfHeight = (LONG)(logFontNum.lfWidth / xyRatio);
		logFontNum.lfEscapement = 0;
		logFontNum.lfOrientation = 0;
		logFontNum.lfWeight = FW_NORMAL;
		logFontNum.lfItalic = 0;
		logFontNum.lfUnderline = 0;
		logFontNum.lfStrikeOut = 0;
		logFontNum.lfCharSet = ANSI_CHARSET;
		logFontNum.lfOutPrecision = OUT_DEFAULT_PRECIS;
		logFontNum.lfClipPrecision = CLIP_DEFAULT_PRECIS;
		logFontNum.lfQuality = DEFAULT_QUALITY;
		logFontNum.lfPitchAndFamily = FF_SWISS;


		LOGFONT logFontH; // header font
		pDC->GetCurrentFont()->GetLogFont(&logFontH);
		_tcscpy_s(logFontH.lfFaceName, _T("Arial"));
		logFontH.lfWidth = (LONG)myRound(pFrame->fLabelDistance3 * 250.);
		logFontH.lfHeight = (LONG)(logFontH.lfWidth / xyRatio);
		logFontH.lfEscapement = 0;
		logFontH.lfOrientation = 0;
		logFontH.lfWeight = 700;
		logFontH.lfItalic = 0;
		logFontH.lfUnderline = 0;
		logFontH.lfStrikeOut = 0;
		logFontH.lfCharSet = ANSI_CHARSET;
		logFontH.lfOutPrecision = OUT_DEFAULT_PRECIS;
		logFontH.lfClipPrecision = CLIP_DEFAULT_PRECIS;
		logFontH.lfQuality = DEFAULT_QUALITY;
		logFontH.lfPitchAndFamily = FF_SWISS;

		LOGFONT logFontHS; // header font
		pDC->GetCurrentFont()->GetLogFont(&logFontHS);
		_tcscpy_s(logFontHS.lfFaceName, _T("Arial"));
		logFontHS.lfWidth = (LONG)myRound(pFrame->fLabelDistance3 * 200.);
		logFontHS.lfHeight = (LONG)(logFontHS.lfWidth / xyRatio);
		logFontHS.lfEscapement = 0;
		logFontHS.lfOrientation = 0;
		logFontHS.lfWeight = 700;
		logFontHS.lfItalic = 0;

		LOGFONT logFontNumS;  // font for drawing numbers
		pDC->GetCurrentFont()->GetLogFont(&logFontNumS);
		_tcscpy_s(logFontNumS.lfFaceName, _T("Arial"));
		logFontNumS.lfWidth = (LONG)myRound(pFrame->fLabelDistance3 * 150.);
		logFontNumS.lfHeight = (LONG)(logFontNumS.lfWidth / xyRatio);
		logFontNumS.lfEscapement = 0;
		logFontNumS.lfOrientation = 0;
		logFontNumS.lfWeight = FW_NORMAL;

		LOGFONT logFontV; // font for drawing labels such as TWTT (s)
		pDC->GetCurrentFont()->GetLogFont(&logFontV);
		_tcscpy_s(logFontV.lfFaceName, _T("Arial"));
		logFontV.lfWidth = (LONG)myRound(pFrame->fLabelDistance3 * 250.);
		logFontV.lfHeight = (LONG)(logFontV.lfWidth / xyRatio);
		logFontV.lfEscapement = 900;
		logFontV.lfOrientation = 900; //important: make both 900.
		logFontV.lfWeight = 700;
		logFontV.lfItalic = 0;
		logFontV.lfUnderline = 0;
		logFontV.lfStrikeOut = 0;
		logFontV.lfCharSet = ANSI_CHARSET;
		logFontV.lfOutPrecision = OUT_DEFAULT_PRECIS;
		logFontV.lfClipPrecision = CLIP_DEFAULT_PRECIS;
		logFontV.lfQuality = DEFAULT_QUALITY;
		logFontV.lfPitchAndFamily = FF_SWISS;


		CFont* oldFont;  // note it's a pointer
		CFont font;  // font for axis labels
		CFont fontN;  // for numbering on the axes
		CFont fontH;  // the biggest title
		CFont fontVertical;  // the verticle axis, such as Distance and Time, Depth
		CFont fontHSmall; // small header, for ?
		CFont fontNumSmall; // small numbers  for meta data texts

		fontN.CreateFontIndirect(&logFontNum);
		font.CreateFontIndirect(&logFont);
		fontH.CreateFontIndirect(&logFontH);
		fontVertical.CreateFontIndirect(&logFontV);
		fontHSmall.CreateFontIndirect(&logFontHS);
		fontNumSmall.CreateFontIndirect(&logFontNumS);



		CPen thinPen(PS_SOLID, 0, RGB(0,0,0));
		CPen gridPen(PS_DOT, 0, RGB(200,200,200));

		bool isTime = isTimeDomain() == TRUE;

		CVelMod vm;
		//****************************
		// print out some meta data for this plot
		oldFont = pDC->SelectObject(&fontNumSmall);
		// && isFloatEqual(velMod.xmax, pCd.coord.xmax)
		if (!this->isTimeDomain() && !draw.isNoLableOutside && 
			isFileExistNotDirectory(velMod.velSecName) && velMod.ncont > 1 ) {
				// if here, print out some extra meta data for the velocity model
				// double depth[MOD_LAYER_MAX],vTop[MOD_LAYER_MAX],vBot[MOD_LAYER_MAX];
				CVelMod::VELMOD_X modX;
				modX.dist = pCd.coord.xmax;
				vm.initModX(&velMod, &modX, isTime, false, true, vel.dz);
				// vm.getZModFromZ(&velMod, &modX, false);

				CVelMod::VELMOD_X modX2;
				modX2.dist = pCd.coord.xmin;
				vm.initModX(&velMod, &modX, isTime, true, true, vel.dz);
				// vm.getZModFromZ(&velMod, &modX2, true);

				CStringArray *sArr = new CStringArray();
				loadParam(draw.rayName, _T("pois"), sArr);

				int xplot;
				int yplot;
				int oldBkMode=pDC->SetBkMode(OPAQUE);


				for (i=0; i<velMod.ncont-1; i++) {
					int n1 = velMod.nzed[i];
					int n2 = velMod.nzed[i+1];
					if (n1<1 || n2<1) continue;  // no points defined for this layer

					float z1 = (float)modX.depthMod[i];
					float z2 = (float)modX.depthMod[i + 1];
					if (z2 <= z1) continue;  // no points defined for this layer
					if (z1 >= pCd.coord.zmin && z1 <= pCd.coord.zmax) {
						CPoint cp = pCd.mm_coord(0.f,z1, isTime);

						if (velMod.anisotropy[i]  != 0.f) {
							if (modX2.depthMod[i + 1] <= modX2.depthMod[i]) continue;  // no points defined for this layer
							if (modX2.depthMod[i] >= pCd.coord.zmin && modX2.depthMod[i] <= pCd.coord.zmax) {
								cp = pCd.mm_coord(0.f, modX2.depthMod[i], isTime);
								yplot = cp.y-logFontNum.lfHeight;
								tStr.Format(_T("[ %1.3f ]"), modX2.vTop[i]);
								oldColor = pDC->SetTextColor(RGB(255, 100, 0));
								pDC->TextOut(pCd.coord.logicalAxes.left+200, cp.y, tStr);
								pDC->SetTextColor(oldColor);
							}
						}
					} // if

					if (z2 >= pCd.coord.zmin && z2 <= pCd.coord.zmax) {
						CPoint cp = pCd.mm_coord(0.f,z2, isTime);

						if (velMod.anisotropy[i]  != 0.f) {
							if (modX2.depthMod[i + 1] <= modX2.depthMod[i]) continue;  // no points defined for this layer
							if (modX2.depthMod[i + 1] >= pCd.coord.zmin && modX2.depthMod[i + 1] <= pCd.coord.zmax) {
								cp = pCd.mm_coord(0.f, modX2.depthMod[i + 1], isTime);
								yplot = cp.y-logFontNum.lfHeight;
								tStr.Format(_T("[ %1.3f ]"), modX2.vBot[i]);
								oldColor = pDC->SetTextColor(RGB(255, 0, 0));
								pDC->TextOut(pCd.coord.logicalAxes.left+200, yplot, tStr);
								pDC->SetTextColor(oldColor);
							}
						}
					} // if

					// now print out the layer number in red on the rightmost side of the model
					float z = (z1+z2)*0.5f;
					if (z1<pCd.coord.zmax && z2>pCd.coord.zmax && z>pCd.coord.zmax) {
						z = (float)(z1+pCd.coord.zmax)*0.5f;
					}


					// if (!draw.isNoLabelInSide && (sArr->GetCount() > i) && i<velMod.ncont-1 && vTop[i]>1. && vTop[i]<10.) {
					if (!draw.isNoLabelInSide && (sArr->GetCount() > i) && i<velMod.ncont-1) {
						float pois = (float)_tstof(sArr->GetAt(i)); // actual Poisson's ratio for a layer numbered i
						if (pois > 0.f) {
							float vsvp = (float)sqrt((2.*pois-1) / (2.*pois-2.));  // vsvp is now the ratio between Vp and Vs
							// if (velMod.anisotropy[i]  != 0.f) pois *= (1 - velMod.anisotropy[i]);
							tStr.Format(_T("( %1.3f - %1.3f ) %0.3f"), modX.vTop[i] * vsvp, modX.vBot[i] * vsvp, pois);
							xplot = pCd.coord.logicalAxes.right-logFontNum.lfWidth*tStr.GetLength();
							CPoint cp = pCd.mm_coord(0.f, z, isTime);
							yplot = cp.y-logFontNum.lfHeight/2;
							if (yplot > pCd.coord.logicalAxes.bottom) yplot = cp.y-logFontNum.lfHeight;
							if (pFrame->gDisplayVsModel == 1)
								pDC->TextOut(xplot, yplot, tStr);


							if (velMod.anisotropy[i]  != 0.f) {
								if (modX2.depthMod[i + 1] <= modX2.depthMod[i]) continue;  // no points defined for this layer
								if (modX2.depthMod[i] >= pCd.coord.zmin && modX2.depthMod[i + 1] <= pCd.coord.zmax) {
									cp = pCd.mm_coord(0.f, z, isTime);
									yplot = cp.y-logFontNum.lfHeight/2;
									if (yplot>0 && yplot < size.cy) {
										if (pFrame->gDisplayVsModel == 1)
											tStr.Format(_T("( %1.3f - %1.3f )   a=%d%%"), modX2.vTop[i] * vsvp, modX2.vBot[i] * vsvp, (int)myRound(velMod.anisotropy[i] * 100.));
										else
											tStr.Format( _T("a=%d%%"), (int)myRound(velMod.anisotropy[i]*100.) );
										pDC->TextOut(pCd.coord.logicalAxes.left+200+logFontNum.lfWidth*8, yplot, tStr);
									}

								}
							}
						} // if pois > 0
					} // if sArr
				} // for i
				sArr->RemoveAll();
				delete sArr;

				pDC->SetBkMode(oldBkMode);

				if (draw.iModelPeglet>=0 && velMod.ncont-1 > 1) {
					float ov = 4.f / (velMod.vf[0][0][0] + velMod.vf[0][0][1]);
					// now, we draw a faint line for the water multiple in the depth domain
					float x,t,zsf,tsf2, tBoundary;

					if (draw.iModelPeglet==1) {
						for (int icont=1; icont<velMod.ncont-1; icont++) {
							CPoint* pint = (CPoint *)malloc( velMod.nzed[icont]*sizeof(CPoint));
							int num = 0;
							for (i=0; i<  velMod.nzed[icont]; i++) {
								x = velMod.xm[i][icont]; // boundary 1 means the seafloor
								zsf = getDepthAtSeafloor(x);
								tsf2 = zsf * ov;  // 2-way time, assumes constant water vel
								modX.dist = x;
								vm.initModX(&velMod, &modX, isTime, true, true, vel.dz);
								// vm.getZModFromZ(&velMod, &modX);
								tBoundary = (float)vm.getTimeAtZ(&modX, velMod.zm[i][icont], vel.dz);
								// now tBoundary is 2-way time at the layer boundary

								register double zMult = vm.my2WayTime2Depth(&velMod, x, tBoundary + tsf2*0.5, vel.dz);  //pass two-way time only to this routine to get the true depth.
								pint[num] = pCd.mm_coord(x,zMult, isTime);
								num++;
							} // for i
							if (num > 1) {
								oldPen = pDC->SelectObject(&gridPen);
								pDC->Polyline(pint, num);
								pDC->SelectObject(oldPen);
							}
							free (pint);
						} // for icont
					}
					else {
						int np = velMod.nzed[draw.iModelPeglet]; // num of points for the boundary
						CPoint* pint = (CPoint *)malloc(np*sizeof(CPoint));
						for (i=0; i< np; i++) {
							x = velMod.xm[i][draw.iModelPeglet]; 
							// zsf = getDepthAtSeafloor(x) - para.gunDepth;
							zsf = getDepthAtSeafloor(x);
							tsf2 = zsf * ov;  // two-way time, assumes constant water vel
							modX.dist = x;
							vm.initModX(&velMod, &modX, isTime, true, true, vel.dz);
							// vm.getZModFromZ(&velMod, &modX);
							t = (float)vm.getTimeAtZ(&modX, (double)velMod.zm[i][draw.iModelPeglet], vel.dz);
							// t -= tsf2*0.5f; // one-way time for peglet
							register double zMult = vm.my2WayTime2Depth(&velMod, x, t - tsf2*0.5, vel.dz);  //pass one-way time only to this routine to get the true depth.
							pint[i] = pCd.mm_coord(x,zMult, isTime);
						} // for i
						oldPen = pDC->SelectObject(&gridPen);
						pDC->Polyline(pint, np);
						pDC->SelectObject(oldPen);
						free (pint);
					}



				} // if
		} // if timedomain
		pDC->SelectObject(oldFont);
		//****************************



		if(this->draw.isNoLableOutside || this->draw.mode<0) {
			font.DeleteObject();
			fontH.DeleteObject();
			fontVertical.DeleteObject();
			fontHSmall.DeleteObject();
			fontN.DeleteObject();
			fontNumSmall.DeleteObject();
			return;
		}




		//Draw tick marks around the axes.
		//controls for the tick length in drawing in X and Y axes, in client coord
		int ideltx = -130; 
		int idelty = 120;
		oldPen = pDC->SelectObject(&thinPen);
		oldFont = pDC->SelectObject(&fontN);
		DrawAxesTicksValues(pDC, yminExact, ymaxExact, yminRound, ytickRound, logFontNum.lfWidth, logFontNum.lfHeight);
		pDC->SelectObject(oldPen);
		pDC->SelectObject(oldFont);


		if (draw.mode == 9 || (draw.mode==10) ) {
			tStr = _T("TWTT (s)");
		} else if (draw.mode == 7) {
			// NMO display
			if (fabs(pCd.coord.vred) > MINAMP) 
				tStr.Format(_T("Time (s), NMO (%5.3f km/s)"), (float)pCd.coord.vred);
			else
				tStr = _T("Time (s)");
		} else if (isTimeDomain()) {
			if(pCd.coord.vred==0 || draw.mode == 6) {
				tStr = _T("Time (s)");
			} else {
				// Reduced time display
				tStr.Format(_T("T - X / %5.3f (s)"), (float)pCd.coord.vred);
			}
		} else {
			tStr = _T("Depth (km)");
		}

		oldFont = pDC->SelectObject(&fontVertical);
		int oldBkMode=pDC->SetBkMode(OPAQUE);
		//	pDC->DrawText(t, &rect, DT_LEFT|DT_VCENTER|DT_SINGLELINE);  // this is bad when copy and paste
		// pDC->TextOut(2, (size.cy-tStr.GetLength()*logFontV.lfWidth)/2, tStr, tStr.GetLength());
		pDC->TextOut(2, (size.cy+tStr.GetLength()*logFontV.lfWidth)/2, tStr);

		pDC->SelectObject(oldFont);
		pDC->SetBkMode(oldBkMode);


		// now we got a chance to better plot the line drawings
		CDigitize pDg;
		if (myFloat2(pCd.coord.vred) == 0.0f &&
			(isFileExistNotDirectory(draw.markerName) || isFileExistNotDirectory(dig.digName)) &&
			!(draw.markerYShift == 0.f && draw.markerYMultFactor == 1.f)
			) {
				if (dig.totCurve>0) {
					if (draw.markerIsRevYAxis) {
						yminRound = -pDg.getDigYMax(&dig);
						ymaxRound = -pDg.getDigYMin(&dig);
					}
					else {
						yminRound = pDg.getDigYMin(&dig);
						ymaxRound = pDg.getDigYMax(&dig);
					}
				}
				y = yminRound;
				oldColor = pDC->SetTextColor(RGB(0, 255, 0));
				do 
				{
					tick[0] = pCd.mm_coord( pCd.coord.xmax, (y*draw.markerYMultFactor+draw.markerYShift), isTime);
					tick[1].x = tick[0].x + (long)(1.5*ideltx);
					tick[1].y = tick[0].y;

					double yPrintedValue = (draw.markerIsRevYAxis)  ?  -y  :  y;
					if(ytickRound < 0.1) tStr.Format(_T("%1.2f"), myFloat2(yPrintedValue));
					else if(ytickRound < 1.) tStr.Format(_T("%1.1f"), myFloat1(yPrintedValue));
					else tStr.Format(_T("%d"), (int)yPrintedValue);
					countS =tStr.GetLength(); 

					//xPos = countS*numRef/63;  //This x is stored for plotting vertical lables.
					if (y>= yminRound && y <= ymaxRound) {
						oldPen = pDC->SelectObject(&thinPen);
						pDC->Polyline(tick, 2);
						pDC->SelectObject(oldPen);

						oldFont = pDC->SelectObject(&fontN);
						pDC->TextOut(tick[0].x+4, tick[0].y-logFontNum.lfHeight/2, tStr);
						pDC->SelectObject(oldFont);
					}
					y+= ytickRound*2;
				} while (y-ymaxExact <= 0.0001);	  //Finish drawing yTicks. 
				pDC->SetTextColor(oldColor);
		} // if myfloat2






		// now print out the date of work
		oldFont = pDC->SelectObject(&fontNumSmall);
		CTime theTime = CTime::GetCurrentTime();
		//if (draw.mode == 7 && fabs(para.vred) > MINAMP ) 
		//	tStr.Format(_T("%s . dT=[sqrt(X^2+dZ^2)+sqrt(Y^2+dW^2)-2*Zw+Zs]/Vred-(Zs-2Zg)/Vw; X=half offset, Y=X*dW/dZ"), theTime.Format( "%H:%M %B %d, %Y" ));
		//else
		tStr.Format(_T("%s "), theTime.Format( "%H:%M %B %d, %Y" ));

		// note: numWidth*0.7  must be the same as  the font width in logfont
		//	pDC->DrawText(tStr, &rect, DT_RIGHT|DT_BOTTOM|DT_SINGLELINE);
		pDC->TextOut(size.cx-tStr.GetLength()*logFontNumS.lfWidth-2, size.cy-logFontNumS.lfHeight-2, tStr, tStr.GetLength());
		pDC->SelectObject(oldFont);



		// label for the X-axis
		//CString tstr; 
		if (draw.strXLabelOverwrite.IsEmpty()) {
			if (draw.mode == 10) {
				tStr = _T("Velocity");
				//tstr += (para.xTick < 1.) ? " (m/s)" : " (km/s)";
				tStr += _T(" (km/s)");
			}
			else if (draw.mode==6) 
				tStr = _T("Trace");
			else {
				if ( (draw.mode==0 || draw.mode==7) && !para.isDistanceDisplay ) 
					tStr = _T("Offset");
				else
					tStr = _T("Distance");
				//tstr += (para.xTick < 1.) ? " (m)" : " (km)";
				tStr += _T(" (km)");
			}
		}
		else {
			tStr = draw.strXLabelOverwrite;
		}
		oldFont = pDC->SelectObject(&font);
		oldBkMode=pDC->SetBkMode(OPAQUE);
		//	pDC->DrawText(tstr, &rect, DT_CENTER|DT_BOTTOM|DT_SINGLELINE);
		pDC->TextOut( (size.cx-tStr.GetLength()*logFont.lfWidth)/2, size.cy-logFont.lfHeight-2, tStr, tStr.GetLength());
		pDC->SetBkMode(oldBkMode);
		pDC->SelectObject(oldFont);
		pDC->SetTextColor(oldColor);




		// finally, print out the title, and segy/vel names in the top left side 
		oldFont = pDC->SelectObject(&fontNumSmall);
		int jpos = 1;
		if ( !draw.timeSecName.IsEmpty() ) {
			CString tStr2;
			if ( fabs(draw.distShift) > 0.f && para.isDistanceDisplay) {
				// we need to print the xmin and xmax before the dist shifting
				tStr2.Format(_T("(%8.3f ~ %8.3f km: xmin,xmax before X-reposition)"), pCd.coord.xmin - draw.distShift, pCd.coord.xmax - draw.distShift);
				//pDC->TextOut( 1, jpos, tStr, tStr.GetLength());
				//jpos += logFontNumS.lfHeight + 1;
			}
			tStr = GetBaseFileName(draw.timeSecName);
			tStr += _T(".");
			tStr += GetFileExtension(draw.timeSecName) + tStr2;
			pDC->TextOut( 1, jpos, tStr, tStr.GetLength());
			jpos += logFontNumS.lfHeight + 1;
		}

		if ( !velMod.velSecName.IsEmpty() ) {
			tStr = _T("(");
			tStr += GetBaseFileName(velMod.velSecName);
			tStr += GetFileExtension(velMod.velSecName);
			pDC->TextOut( 1, jpos, tStr, tStr.GetLength());
			jpos += logFontNumS.lfHeight + 1;
		}
		if ( !draw.depthSecName.IsEmpty() ) {
			tStr = _T("(");
			tStr += GetBaseFileName(draw.depthSecName);
			tStr += _T(".");
			tStr += GetFileExtension(draw.depthSecName);
			tStr += _T(")");
			pDC->TextOut( 1, jpos, tStr, tStr.GetLength());
			jpos += logFontNumS.lfHeight + 1;
		}
		pDC->SelectObject(oldFont);


		if ( !draw.plotTitle.IsEmpty() ) {
			oldFont = pDC->SelectObject(&fontH);
			pDC->TextOut( (size.cx-tStr.GetLength()*logFontH.lfWidth)/2, 2, draw.plotTitle, draw.plotTitle.GetLength());
			pDC->SelectObject(oldFont);
		}


		font.DeleteObject();
		fontH.DeleteObject();
		fontVertical.DeleteObject();
		fontHSmall.DeleteObject();
		fontN.DeleteObject();
		fontNumSmall.DeleteObject();
	}


	void CSeisWideDoc::OnToolbarSavev() 
	{
		CString tStr;
		if (!isModelDisplayed() || velMod.ncont < 2) {
			tStr.Format(_T("Only when a valid model is displayed, can it save to file."));
			myCaption(tStr);
			return;
		}


		//This tells OnDraw() not to initiate velocity arrays when refreshing screen next time.
		CVelMod vm;
		if (vm.saveModelAs(&velMod, velMod.velSecName, vel.dz, isTimeDomain(), TRUE)) {
			//now update the velFile status so that DrawVel() would not complain that another process has changed the model file.
			//CFile::GetStatus( velMod.velSecName, draw.velFileStatus ); // static function
			tStr.Format(_T("Saved successfully."));
		}
		else
			tStr.Format(_T("Failed to saved."));

		myCaption(tStr);
	}

	//BOOL CSeisWideDoc::myModelSaveAs(CString f) {
	//	CVelMod vm;
	//	return vm.saveModelAs(&velMod, f, vel.dz, isTimeDomain(), TRUE);
	//}



	void CSeisWideDoc::OnToolbarSaveasv() 
	{
		CString tStr;
		if (!isModelDisplayed() || velMod.ncont < 2) {
			tStr.Format(_T("Only when a valid model is displayed, can it save to file."));
			myCaption(tStr);
			return;
		}

		CVelMod vm;
		CString newName;
		CdlgNewVelFile dlg;
		dlg.m_velNewFileName =  getFileNameAppend(velMod.velSecName, _T("Mod")); 
		// velMod.velSecName + _T("Mod.bin");
		if(dlg.DoModal() == IDOK) {
			newName = dlg.m_velNewFileName;	 
			draw.velFormat = dlg.m_velFormat;
		}
		else return;

		if(draw.velFormat == 0)	 {
			newName= mySetFileExtension(newName, _T("bin"));
			// mySetFileExtension(getFileNameAppend(draw.timeSecName, _T("_digTrc")),  _T("txt"));

			if (vm.saveModelAs(&velMod, newName, vel.dz, isTimeDomain(), TRUE)) {
				//now update the velFile status so that DrawVel() would not complain that another process has changed the model file.
				//CFile::GetStatus( velMod.velSecName, draw.velFileStatus ); // static function
				tStr.Format(_T("Model saved successfully."));
				//	velMod.velSecName = newName;  // file name already updated
			}
			else
				tStr.Format(_T("Model failed to save."));

			myCaption(tStr);
			//velMod.velSecOld = velMod.velSecName;
			SetModifiedFlag();
			return;
		}

		// now we start to save the model in ascii format. It will stop here if saving in SeisWide's .bin format.
		if (isTimeDomain())
			vm.myModel_TWTT2Depth(&velMod, vel.dz);

		if (draw.velFormat == 1) {
			newName = mySetFileExtension(newName, _T("in"));
			vm.saveModelZelt4(&velMod, newName);
		}
		else if (draw.velFormat == 2) {
			newName = mySetFileExtension(newName, _T("in"));
			vm.saveModelZelt3(&velMod, newName);
		}
		else if (draw.velFormat == 3) {
			newName = mySetFileExtension(newName, _T("in"));
			vm.saveModelZelt2(&velMod, newName);
		}
		else {
			newName = mySetFileExtension(newName, _T("vxml"));
			vm.saveModelXML(&velMod, newName);
		}

		showFileInNotePad(newName);


		// testing
		//	vm.myModel_Depth2TWTT(&velMod, vel.dz);
		//vm.myModel_TWTT2Depth(&velMod, vel.dz);
		//vm.saveModelXML(&velMod, newName);
		//showFileInNotePad(newName);

	}

	void CSeisWideDoc::OnToolbarFlipmod() 
	{
		if( draw.mode<2 || (draw.mode>4 && draw.mode!=9) || velMod.ncont < 2)
		{
			AfxMessageBox(_T("Please show a valid model first."));
			return;
		}

		//new file dialog.
		CFileDialog dlg( FALSE,_T(""),_T("*.bin"),
			OFN_HIDEREADONLY|OFN_EXPLORER,
			_T("File name for the new model (*.bin)|*.bin|"));
		//	dlg.m_ofn.lpstrTitle = _T("Each shot number in one line please";
		if(dlg.DoModal()==IDOK)
			velMod.velSecName = dlg.GetPathName();
		else
			return;

		CVelMod vm;

		//first shift data points.
		float xshift = (float)(velMod.xmin + velMod.xmax);
		int icont, j;

		for (icont=0; icont<velMod.ncont; icont++)
			for (j=0; j<velMod.nzed[icont]; j++) 
				velMod.xm[j][icont] = xshift - velMod.xm[j][icont];

		for (icont=0; icont<velMod.ncont-1; icont++)
			for (j=0; j<velMod.nvel[icont][0]; j++)
				velMod.xvel[j][icont][0] = xshift - velMod.xvel[j][icont][0];

		for (icont=0; icont<velMod.ncont-1; icont++)
			for (j=0; j<velMod.nvel[icont][1]; j++)
				velMod.xvel[j][icont][1] = xshift - velMod.xvel[j][icont][1];

		//now all points have to be flipped....1st becomes last and last becomes 1st.
		float* a;
		int n;
		for (icont=0; icont<velMod.ncont; icont++)
		{
			n = velMod.nzed[icont];
			a = (float *)ealloc1float(n);
			for (j=0; j<n; j++) 
				a[j] = velMod.xm[n-j-1][icont];
			for (j=0; j<n; j++) 
				velMod.xm[j][icont] = a[j];


			if (draw.mode!=9) {
				for (j=0; j<n; j++) 
					a[j] = velMod.zm[n-j-1][icont];
				for (j=0; j<n; j++) {
					velMod.zm[j][icont] = a[j];
				}
			}
			else {
				for (j=0; j<n; j++) 
					a[j] = velMod.tm[n-j-1][icont];
				for (j=0; j<n; j++) {
					velMod.tm[j][icont] = a[j];
				}
			}



			free (a);
		}

		for (icont=0; icont<velMod.ncont-1; icont++)
		{
			n = velMod.nvel[icont][0];
			a = (float *)ealloc1float(n);
			for (j=0; j<n; j++)
				a[j] = velMod.xvel[n-j-1][icont][0];
			for (j=0; j<n; j++)
				velMod.xvel[j][icont][0] = a[j];
			for (j=0; j<n; j++)
				a[j] = velMod.vf[n-j-1][icont][0];
			for (j=0; j<n; j++)
				velMod.vf[j][icont][0] = a[j];
			free (a);

			n = velMod.nvel[icont][1];
			a = (float *)ealloc1float(n);
			for (j=0; j<n; j++)
				a[j] = velMod.xvel[n-j-1][icont][1];
			for (j=0; j<n; j++)
				velMod.xvel[j][icont][1] = a[j];
			for (j=0; j<n; j++)
				a[j] = velMod.vf[n-j-1][icont][1];
			for (j=0; j<n; j++)
				velMod.vf[j][icont][1] = a[j];
			free (a);
		}

		//	xshift = (float)pCd.coord.xmin;
		pCd.coord.xmin = velMod.xmin;
		pCd.coord.xmax = velMod.xmax;
		pCd.coord.xTick = (pCd.coord.xmax - pCd.coord.xmin)*0.1;
		if (draw.mode==9)
			vm.myModel_TWTT2Depth(&velMod, vel.dz);
		OnToolbarSavev();  // finally save it
		//velMod.velSecOld = _T("");
		//This tells OnDraw() not to initiate velocity arrays when refreshing screen next time.

		draw.isSameDataDisplay = FALSE; //indicate display has been changed and will re-load all data in OnDraw().
		SetModifiedFlag();
		UpdateAllViews(NULL);

	}

	void CSeisWideDoc::OnModelShiftxz() 
	{
		CString tStr;

		// TODO: Add your command handler code here
		if( draw.mode<2 || (draw.mode>4 && draw.mode!=9) || velMod.ncont < 2)
		{
			AfxMessageBox(_T("Please show a valid model first."));
			return;
		}

		float dx=0.f, dz=0.f;
		CdlgDigitizeShift dlg0;
		if (dlg0.DoModal() == IDOK) 
		{
			dx = dlg0.m_dx;
			dz = dlg0.m_dt;
		}
		else return;
		delete dlg0;

		CVelMod vm;

		//new file dialog.
		CFileDialog dlg( FALSE,_T(""),_T("*.bin"),
			OFN_HIDEREADONLY|OFN_EXPLORER,
			_T("File name for the new model (*.bin)|*.bin|"));
		//	dlg.m_ofn.lpstrTitle = _T("Each shot number in one line please";
		if(dlg.DoModal()!=IDOK)
			return;

		int icont, j;

		for (icont=0; icont<velMod.ncont; icont++)
			for (j=0; j<velMod.nzed[icont]; j++)  {
				velMod.xm[j][icont] += dx;

				// we only shift zm  when icont>0
				if (icont > 0) {
					if (draw.mode!=9)
						velMod.zm[j][icont] += dz;
					else
						velMod.tm[j][icont] += dz;
				}
			}
			for (icont=0; icont<velMod.ncont-1; icont++)
				for (j=0; j<velMod.nvel[icont][0]; j++)
					velMod.xvel[j][icont][0] += dx;

			for (icont=0; icont<velMod.ncont-1; icont++)
				for (j=0; j<velMod.nvel[icont][1]; j++)
					velMod.xvel[j][icont][1] += dx;
			if (draw.mode==9)
				vm.myModel_TWTT2Depth(&velMod, vel.dz);


			pCd.coord.xmin = velMod.xmin += dx;
			pCd.coord.xmax = velMod.xmax += dx;


			if (vm.saveModelAs(&velMod, dlg.GetPathName(), vel.dz, isTimeDomain())) {
				// velMod.velSecName = dlg.GetPathName();

				//	pCd.coord.zmax += dz;

				//pCd.coord.xmin = pCd.coord.xmin;
				//pCd.coord.xmax = pCd.coord.xmax;

				//if (myModelSaveAs(velMod.velSecName)) {
				//	//now update the velFile status so that DrawVel() would not complain that another process has changed the model file.
				//	//CFile::GetStatus( velMod.velSecName, draw.velFileStatus ); // static function
				//	tStr.Format(_T("Model saved successfully."));
				//	//velMod.velSecOld = _T("");
				//	//This tells OnDraw() not to initiate velocity arrays when refreshing screen next time.
				//}
				//else
				//	tStr.Format(_T("Model failed to save."));

				//myCaption(tStr);
				//velMod.velSecOld = velMod.velSecName;
				SetModifiedFlag();
				UpdateAllViews(NULL);
			}
	}

	void CSeisWideDoc::OnModelingMoveboundary() 
	{
		// Oct 24, 2004  deping
		if(draw.mode<2 || (draw.mode>4 && draw.mode!=9) )
		{
			AfxMessageBox(_T("Please display the model first"));
			return;
		}

		if (draw.iLayerFocus<0) {
			AfxMessageBox(_T("Please select a boundary to shift."));
			return;
		}

		static float xmin= 0.f; 
		static float xmax= 0.f;
		static float dz = 0.f; // make this static is good


		CdlgModelShiftBoundary dlg;
		dlg.m_xmin = xmin;
		dlg.m_xmax = xmax;
		dlg.m_zinc = dz;
		if (dlg.DoModal() == IDOK) 
		{
			xmin = dlg.m_xmin;
			xmax = dlg.m_xmax;
			dz = dlg.m_zinc;
		}
		else return;
		delete dlg;

		CVelMod vm;


		BOOL isCompleteBoundary = isFloatEqual(xmax, xmin);

		int icont = draw.iLayerFocus;

		for (int j=0; j<velMod.nzed[icont]; j++)  {
			float x = velMod.xm[j][icont];
			if (isCompleteBoundary  ||   x >= xmin && x <= xmax) {
				if (draw.mode!=9)
					velMod.zm[j][icont] += dz;
				else {
					velMod.tm[j][icont] += dz;
				}
			}
		}
		if (draw.mode==9)
			vm.myModel_TWTT2Depth(&velMod, vel.dz);

		draw.modelUpInc = dz;
		if ( fabs(draw.modelUpInc) < 0.001f) draw.modelUpInc = 0.001f;
		else
			if ( fabs(draw.modelUpInc) >0.2f) draw.modelUpInc = 0.2f;


		// OnToolbarSavev();
		//velMod.velSecOld = _T("");
		//This tells OnDraw() not to initiate velocity arrays when refreshing screen next time.

		draw.isSameDataDisplay = FALSE; //indicate display has been changed and will re-load all data in OnDraw().
		SetModifiedFlag();
		UpdateAllViews(NULL);

	}

	void CSeisWideDoc::OnModelingAddsineshape()
	{
		// Sept 15, 2009  deping
		if(draw.mode<2 || draw.mode>4) {
			AfxMessageBox(_T("Please display the model first"));
			return;
		}

		if( draw.mode<2 || draw.mode>4 || velMod.ncont < 2) {
			AfxMessageBox(_T("Please show a valid model first."));
			return;
		}

		if (draw.iLayerFocus<1 || draw.iLayerFocus >= velMod.ncont-1) {
			AfxMessageBox(_T("Please select an inside boundary to add sine wave modulation."));
			return;
		}


		float xmin = velMod.xm[0][0];  // this is model limit
		float xmax = velMod.xm[velMod.nzed[0]-1][0];

		static float xmin_modulate = (float)pCd.coord.xmin;  // desired limits for modulation
		static float xmax_modulate = (float)pCd.coord.xmax;
		static float lumda = (xmax_modulate - xmin_modulate) * 0.1f;
		static float amp = lumda*0.05f;
		CdlgSineModulate dlg;
		dlg.m_lumda = lumda;
		dlg.m_modDepth = amp;
		dlg.m_xmin = xmin_modulate;
		dlg.m_xmax = xmax_modulate;
		if (dlg.DoModal() == IDOK) 
		{
			lumda = dlg.m_lumda;
			amp = dlg.m_modDepth;
			xmin_modulate = dlg.m_xmin;
			xmax_modulate = dlg.m_xmax;
		}
		else return;
		delete dlg;

		int icont = draw.iLayerFocus;

		CVelMod::VELMOD velMod2;
		CVelMod vm;
		vm.velModSetArrays(&velMod2);

		// first, we just copy the left side to velMod2
		velMod2.nzed[icont] = 0;
		for (int j=0; j<velMod.nzed[icont]; j++)  {
			if (velMod.xm[j][icont] >= xmin_modulate) {
				// we do not want further
				break;
			}
			velMod2.xm[j][icont] = velMod.xm[j][icont];
			velMod2.zm[j][icont] = velMod.zm[j][icont];
			velMod2.nzed[icont]++;
		}

		// do the modulation for this boundary icont
		float dx = lumda * 0.1f;
		int i = 0;
		bool isLastPoint = false;
		while (!isLastPoint)  {
			float x2 = xmin_modulate + (float)i*dx;
			if (x2 >= xmax_modulate) {
				x2 = xmax_modulate;
				isLastPoint = true;
			}
			int i2 = velMod2.nzed[icont];

			for (int j=0; j<velMod.nzed[icont]-1; j++)  {
				float xleft = velMod.xm[j][icont];
				float xright = velMod.xm[j+1][icont];
				if (xright == xleft) continue;
				float zleft = velMod.zm[j][icont];
				float zright = velMod.zm[j+1][icont];
				if (x2 >= xleft && x2 <= xright) {
					velMod2.xm[i2][icont] = x2;
					velMod2.zm[i2][icont] = zleft + (zright-zleft)*(x2-xleft)/(xright-xleft);
					break;
				}
			} // for j

			// modulate here
			velMod2.zm[i2][icont] += amp * (float)sin(2.f*PI*x2/lumda);
			velMod2.nzed[icont]++; // 1 more point successfully added to velMod2

			i++;
		} // while

		// now, we just copy the right side to velMod2
		for (int j=0; j<velMod.nzed[icont]; j++)  {
			if (velMod2.xm[j][icont] <= xmax_modulate){
				continue;
			}
			int i2 = velMod2.nzed[icont];
			velMod2.xm[i2][icont] = velMod.xm[j][icont];
			velMod2.zm[i2][icont] = velMod.zm[j][icont];
			velMod2.nzed[icont]++;
		}


		// now copy the boundary back to velMod struct
		velMod.nzed[icont] = velMod2.nzed[icont];
		for (int j=0; j<velMod2.nzed[icont]; j++)  {
			velMod.xm[j][icont] = velMod2.xm[j][icont];
			velMod.zm[j][icont] = velMod2.zm[j][icont];
		}
		vm.velModFreeArrays(&velMod2);

		// make sure the boundary does not intercect with adjacent boundaries
		for (int i=0; i<velMod.nzed[icont]; i++)  {
			float x = velMod.xm[i][icont];

			// point [x,z] should not exceed the top limit
			for (int j=0; j<velMod.nzed[icont-1]-1; j++)  {
				float xleft = velMod.xm[j][icont-1];
				float xright = velMod.xm[j+1][icont-1];
				if (xright == xleft) continue;
				float zleft = velMod.zm[j][icont-1];
				float zright = velMod.zm[j+1][icont-1];
				if (x >= xleft && x <= xright) {
					float ztop = zleft + (zright-zleft)*(x-xleft)/(xright-xleft);
					if (velMod.zm[i][icont] < ztop) {
						velMod.zm[i][icont] = ztop + 0.00001f;
					}
					break;
				}
			} // for j

			// point [x,z] should not exceed the bottom limit
			for (int j=0; j<velMod.nzed[icont+1]-1; j++)  {
				float xleft = velMod.xm[j][icont+1];
				float xright = velMod.xm[j+1][icont+1];
				if (xright == xleft) continue;
				float zleft = velMod.zm[j][icont+1];
				float zright = velMod.zm[j+1][icont+1];
				if (x >= xleft && x <= xright) {
					float zbot = zleft + (zright-zleft)*(x-xleft)/(xright-xleft);
					if (velMod.zm[i][icont] > zbot) velMod.zm[i][icont] = zbot - 0.00001f;
					break;
				}
			} // for j
		} // for i



		CString tempStr = velMod.velSecName;
		tempStr.MakeLower();
		velMod.velSecName = getFileNameAppend(tempStr, _T("_sine"));
		OnToolbarSavev(); 

		draw.isSameDataDisplay = FALSE; //indicate display has been changed and will re-load all data in OnDraw().
		SetModifiedFlag();
		UpdateAllViews(NULL);
	}


	// note: if your model is already shifted in displaying, make sure you deduct it from xOld and xNew first
	//   this function is for model editting only. It does not handle digitizing functions!
	BOOL CSeisWideDoc::MyMouseClickMode9(CVelMod::VELMOD *velm, double xOld, double yOld, double xNew, double yNew)
	{
		if (!isTimeDomain() ) return FALSE;
		if (!isModelDisplayed()) return FALSE;
		// The following mouse manipulation is only for editting a model in TWTT domain!

		if (xNew<velm->xmin) {
			xNew  = velm->xmin;
		} else if (xNew>velm->xmax) {
			xNew = velm->xmax;
		}

		CString tStr;
		CPoint p,selPoint;
		int k,icont,jSel;
		//	double dist,distOld,distNew;
		double tempv;
		double z1[MOD_LAYER_MAX];
		CVelMod vm;
		CVelMod::VELMOD_X modX;
		SEI_POINT pNew;
		pNew.x = (float)xNew;
		pNew.y = (float)yNew;



		if( draw.pick == 1 &&  draw.nodes == 1)  {
			draw.iLayerFocus = vm.getClosestLayerNum(velm, pNew, isTimeDomain());
			return TRUE;
		}  //End pick a boundary.

		//pick a layer.
		if( draw.pick == 1 &&  draw.nodes == 2)  {
			draw.iLayerFocus=-1;
			for (icont=0; icont<velm->ncont; icont++) {
				z1[icont] = -1.;
				for (int j=0; j<velm->nzed[icont]-1; j++) {
					if(xOld>=velm->xm[j][icont]&&xOld<=velm->xm[j+1][icont]) {
						z1[icont]=velm->tm[j][icont]+
							(velm->tm[j+1][icont]-velm->tm[j][icont])*
							(xOld-velm->xm[j][icont])/
							(velm->xm[j+1][icont]-velm->xm[j][icont]);
						break;
					}
				}
				if(z1[icont]<0)  {
					tStr.Format(_T("x,x0,x1: %g %g %g"), &xOld,&velm->xm[0][icont],&velm->xm[1][icont]);
					AfxMessageBox(tStr);	
					return FALSE;
				}
			}
			for (icont=0; icont<velm->ncont-1; icont++) {
				if(yOld>=z1[icont] && yOld<=z1[icont+1]) {
					draw.iLayerFocus=icont;
					if ( yOld < pCd.coord.axisY1)
						draw.isTopBound=true;
					else if (yOld > pCd.coord.axisY2)
						draw.isTopBound=false;
					else if(fabs(yOld-z1[icont])<fabs(yOld-z1[icont+1]))
						draw.isTopBound=true;
					else 
						draw.isTopBound=false;
					break;
				}
			}

			if( draw.iLayerFocus<0) {
				return FALSE;
			}
			else {
				return TRUE;
			}
		}  //End pick a layer.

		//Add a point for specified boundary (draw.iLayerFocus).
		if( draw.add == 1 &&  draw.nodes == 1)  {
			icont =  draw.iLayerFocus;
			jSel = vm.getPointIndexBeforeOnBoundary(velm, xNew, icont);
			if(jSel<0) return FALSE;
			if (vm.velModInsPoint(velm, icont, jSel+1, pNew, isTimeDomain())) {
				pCd.coord.xMouse = xNew;
				pCd.coord.yMouse = yNew;
				return TRUE;
			}
			else return FALSE;
		}	//End of add a node for specified boundary.

		//Add a point for specified layer (draw.iLayerFocus).
		//if draw.iTopBound=1, edit nodes  for its top bound, otherwise,
		//edit the layer's lower bound.
		//Need to consider: Low velocity layer not allowed.
		//One layer/boundary may have one point only (done).
		// static int anisotropy_layer0 = -1;
		CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();

		double adepth0, adepth1, adepth2;
		if( draw.add == 1 &&  draw.nodes == 2) {
			// if(!isVisibleOrNot(xNew,yNew)) return FALSE;
			//First calculate the velocity at the clicked point.
			icont =  draw.iLayerFocus;
			jSel = vm.getPointIndexBeforeOnLayer(velm, xNew, icont, draw.isTopBound, &tempv);
			if (jSel < 0) return FALSE;

			// note: in the UI, the user sees 1 meaning the first layer. But in programming, 0=the first layer
			CdlgLayerNodes dlg1;
			dlg1.m_layerNum = icont+1;
			dlg1.m_layerX = (float)((int)(xNew*100+.5)*0.01);  //The float oper. reduce num of digits displayed.
			dlg1.m_isRegressionAlways = velm->isSedRegression;
			dlg1.m_strRegression = CVelMod::getStringRegression(velm);

			modX.dist = xNew;
			vm.initModX(velm, &modX, true, true, true, vel.dz);
			double aDepth = (draw.isTopBound) ? modX.depthMod[icont] : modX.depthMod[icont + 1];
			dlg1.m_layerY = (float)((int)(aDepth*100+.5)*0.01);  // m_layerY is in time domain. We need to convert it to depth
			dlg1.m_layerV = (float)((int)(tempv*100+.5)*0.01);
			dlg1.m_layerV *= 1000.f;
			dlg1.m_waterDepth = (float)CVelMod::getDepthWater(velm, xNew);
			dlg1.m_anisotropy = velm->anisotropy[icont];
			dlg1.m_anisotropy_layer0 = pFrame->psei->anisotropy_layer0+1;
			if (dlg1.DoModal() == IDOK) {
				velm->isSedRegression = dlg1.m_isRegressionAlways;
				CVelMod::parseString2Regression(velm, dlg1.m_strRegression);
				xOld = dlg1.m_layerX;  
				yOld = dlg1.m_layerY;
				tempv = dlg1.m_layerV / 1000.f;
				pFrame->psei->anisotropy_layer0 = dlg1.m_anisotropy_layer0-1;
				if (pFrame->psei->anisotropy_layer0 > -1 && pFrame->psei->anisotropy_layer0 < icont) {
					// this means we need to interpolate for anisotropy for all the overlying layers below anisotropy_layer0
					modX.dist = xNew;
					vm.initModX(velm, &modX, true, true, true, vel.dz);
					adepth2 = (modX.depthMod[icont] + modX.depthMod[icont + 1]) * 0.5;  // we know icont<velm->ncont
					adepth0 = (modX.depthMod[pFrame->psei->anisotropy_layer0] + modX.depthMod[pFrame->psei->anisotropy_layer0 + 1]) * 0.5;
					for (int j=pFrame->psei->anisotropy_layer0; j<icont; j++) {
						adepth1 = (modX.depthMod[j] + modX.depthMod[j + 1]) * 0.5;
						velm->anisotropy[j] = (adepth2 - adepth0)>0 ?   
							dlg1.m_anisotropy * (float)( (adepth1 - adepth0) / (adepth2 - adepth0) )
							:
							dlg1.m_anisotropy;
					}
				}
				velm->anisotropy[icont] = dlg1.m_anisotropy;
			}
			else return FALSE;
			delete dlg1;

			if (vm.velModVelInsPoint(velm, draw.iLayerFocus, jSel+1, draw.isTopBound, (float)xNew, (float)tempv)) {
				return TRUE;
			}
			else return FALSE;
		}	//End of add a node for specified layer.




		//Move boundary points.
		if( draw.move == 1 &&  draw.nodes == 1) {
			//		distOld = 200000.;
			icont =  draw.iLayerFocus;
			jSel = vm.getPointIndexClosestOnBoundary(velm, xOld, icont);
			if(jSel<0) return FALSE;
			pCd.coord.xMouse = xNew;	//Save points for Invalidate(FALSE).
			pCd.coord.yMouse = yNew;
			if(jSel!=0 && jSel!=(velm->nzed[icont]-1)) {
				if(!isVisibleOrNot(xNew,yNew)) return FALSE;
				if(xNew<velm->xm[jSel-1][icont]+0.00001) return FALSE; //The model's resolution has to be 0.00001 km.
				if(xNew>velm->xm[jSel+1][icont]-0.00001) return FALSE; //The model's resolution has to be 0.00001 km.
			}
			else xNew = velm->xm[jSel][icont];  //left/right boundary points cann't change X values.

			if (draw.isControlPressed) {
				if (jSel==0) yNew = velm->tm[jSel+1][icont];
				else yNew = velm->tm[jSel-1][icont];
			}
			else if (jSel == velm->nzed[icont]-1)
				myCaption(_T("Use Ctrl key to flatten the segment"));

			//now make sure the point doesn't go above or below adjacent boundary.
			//to do this: (1) calculate Z for xNew of boundaries jSel-1 and jSel+1; (2) decide.
			modX.dist = xNew;
			vm.initModX(velm, &modX, true, true, true, vel.dz);
			if ((icont>0 && yNew < modX.timeMod[icont - 1]) || (icont<velm->ncont - 1 && yNew>modX.timeMod[icont + 1])) {
				// the new point is above another boundary
				tStr.Format( _T("You tried to move nodes acrossing another boundary. Continue?") );
				if (AfxMessageBox(tStr, MB_YESNO|MB_ICONINFORMATION) == IDNO) return FALSE;
				if (!vm.velModInterceptPointMode9(velm, icont, jSel, pNew, isTimeDomain())) return FALSE;
			} else {
				velm->xm[jSel][icont] = (float)xNew;
				velm->tm[jSel][icont] = (float)yNew;
			}

			// now move all underlying nodes the same way as long as they are at the same point
			if (draw.isAPressed) {
				float xMod = velm->xm[jSel][icont];
				float zMod = velm->tm[jSel][icont];
				for (int i=icont+1; i<velm->ncont; i++) {
					for (register int j=0; j<velm->nzed[i]; j++) {
						if (fabs(xMod-velm->xm[j][i])<=0.00001f && fabs(zMod-velm->tm[j][i])<=0.00001f) {
							velm->xm[j][i] = (float)xNew;
							velm->tm[j][i] = (float)yNew;
						}
					}
				}
			}

			return TRUE;
		}	//End moving boundary points.


		//Move  points defining a velocity layer.
		if( draw.move == 1 &&  draw.nodes == 2) {
			if (draw.iLayerFocus < 0) return FALSE;
			icont =  draw.iLayerFocus;
			if( draw.isTopBound)	k=0;
			else k=1;

			icont =  draw.iLayerFocus;

			// small fixes
			if (velm->nvel[icont][k]<1 || velm->nvel[icont][k]>MOD_LAYER_MAX-2)
				velm->nvel[icont][k] = 2;

			jSel=-1;
			for (int j=0; j<velm->nvel[icont][k]-1; j++) {
				if(xOld>=velm->xvel[j][icont][k]&&xOld<=velm->xvel[j+1][icont][k]) {
					jSel = j;
					break;
				}
			}
			if(jSel < 0 || jSel>velm->nvel[icont][k]-1) jSel = 0;
			if(fabs(xOld-velm->xvel[jSel][icont][k]) >
				fabs(xOld-velm->xvel[jSel+1][icont][k])) jSel++;
			if(jSel < 0 || jSel>velm->nvel[icont][k]-1) return FALSE;

			xOld=velm->xvel[jSel][icont][k];
			tempv=velm->vf[jSel][icont][k];
			//So the old point is at xOld, yOld in km, 
			//The new point is: xNew, yNew in km.

			// note: in the UI, the user sees 1 meaning the first layer. But in programming, 0=the first layer
			static BOOL isApply4All = false;
			CdlgLayerNodes dlg1;
			dlg1.m_layerNum = icont+1;
			dlg1.m_layerX = (float)((int)(xNew*10000+.5)*0.0001);  //The float oper. reduce num of digits displayed.
			dlg1.m_isRegressionAlways = velm->isSedRegression;
			dlg1.m_strRegression = CVelMod::getStringRegression(velm);

			modX.dist = xNew;
			vm.initModX(velm, &modX, true, true, true, vel.dz);
			double aDepth = (draw.isTopBound) ? modX.depthMod[icont] : modX.depthMod[icont + 1];

			dlg1.m_layerY = (float)((int)(aDepth*10000+.5)*0.0001);
			dlg1.m_layerV = (float)((int)(tempv*100000+.5)*0.00001);
			dlg1.m_layerV *= 1000.f;
			dlg1.m_waterDepth = (float)CVelMod::getDepthWater(velm, xNew);
			dlg1.m_apply4All = isApply4All;
			dlg1.m_anisotropy = velm->anisotropy[icont]; 
			dlg1.m_anisotropy_layer0 = pFrame->psei->anisotropy_layer0+1;

			if (dlg1.DoModal() == IDOK) {
				velm->isSedRegression = dlg1.m_isRegressionAlways;
				CVelMod::parseString2Regression(velm, dlg1.m_strRegression);
				xNew = dlg1.m_layerX;  

				draw.modelVelInc = (float)fabs(tempv - dlg1.m_layerV / 1000.f); // this save for people to click the arrows on toolbar.
				if ( fabs(draw.modelVelInc) < 0.01f) draw.modelVelInc = 0.01f;
				else
					if ( fabs(draw.modelVelInc) > 0.05f) draw.modelVelInc = 0.05f;


				tempv = dlg1.m_layerV / 1000.f;


				isApply4All = dlg1.m_apply4All;
				pFrame->psei->anisotropy_layer0 = dlg1.m_anisotropy_layer0-1;
				modX.dist = xOld;
				vm.initModX(velm, &modX, true, true, true, vel.dz);
				if (dlg1.m_anisotropy==-1 && pFrame->psei->anisotropy_layer0 > -1 && pFrame->psei->anisotropy_layer0 < icont) {
					// this means we need to interpolate for anisotropy for all the overlying layers below anisotropy_layer0
					// interpolate using an empirical formula
					for (int j=pFrame->psei->anisotropy_layer0; j<icont; j++) {
						double vh = (modX.vTop[j] + modX.vBot[j]) * 0.5;
						velm->anisotropy[j] = (float)(1. -  (0.393 + 0.74 * vh) / vh);
					}
				} else if (dlg1.m_anisotropy==0.f && pFrame->psei->anisotropy_layer0 > -1 && pFrame->psei->anisotropy_layer0 < icont) {
					for (int j=pFrame->psei->anisotropy_layer0; j<icont; j++) {
						velm->anisotropy[j] = 0.f;
					}
				}

				// note: dlg1.m_anisotropy  can be  -1, 0, or >0
				if (dlg1.m_anisotropy == -1) {
					double vh = (modX.vTop[icont] + modX.vBot[icont]) * 0.5;
					dlg1.m_anisotropy = (float)(1. - (0.393 + 0.74 * vh) / vh);
				}
				velm->anisotropy[icont] = dlg1.m_anisotropy;
			}
			else return FALSE;
			delete dlg1;

			if (isApply4All) {
				for (int j=0; j<velm->nvel[icont][k]; j++) {
					velm->vf[j][icont][k] = (float)tempv;
				}
			} // if

			if(jSel == 0 || jSel==velm->nvel[icont][k]-1) {
				velm->vf[jSel][icont][k] = (float)tempv;
			}
			else {
				if(xNew<velm->xvel[jSel-1][icont][k]+0.00001) return FALSE; //The model's resolution has to be 0.00001 km.
				if(xNew>velm->xvel[jSel+1][icont][k]-0.00001) return FALSE; //The model's resolution has to be 0.00001 km.
				velm->xvel[jSel][icont][k] = (float)xNew;
				velm->vf[jSel][icont][k] = (float)tempv;
			}
			return TRUE;
		} //End of moving layer points.


		//deleting boundary points.
		if( draw.remove == 1 &&  draw.nodes == 1) {
			//	distOld = 200000.;
			icont =  draw.iLayerFocus;
			jSel = vm.getPointIndexClosestOnBoundary(velm, xNew, icont);
			if(jSel<0) return FALSE;
			pCd.coord.xMouse = velm->xm[jSel][icont];
			pCd.coord.yMouse = velm->tm[jSel][icont];

			if (vm.velModDelPoint(velm, icont, jSel)) {
				return TRUE;
			}
			else return FALSE;
		}	//End deleting boundary points.

		//delete  points defining a velocity layer.
		if( draw.remove == 1 &&  draw.nodes == 2) {	
			icont =  draw.iLayerFocus;
			jSel = vm.getPointIndexClosestOnLayer(velm, xNew, icont, draw.isTopBound, &tempv);
			if (jSel < 0) return FALSE;

			if (vm.velModVelDelPoint(velm, icont, jSel, draw.isTopBound)) {
				return TRUE;
			}
			else return FALSE;
		} //End deleting layer points.

		return FALSE;

	}


	BOOL CSeisWideDoc::MyMouseClickDigitizing(double xOld, double yOld, double xNew, double yNew)
	{
		if(!draw.isDigitizing)
			return MyMouseClick(xOld, yOld, xNew, yNew);

		//if (draw.add==1) {
		//	// just to be consistent when adding points. Don't, since we need xOld 
		//	xOld = xNew;
		//	yOld = yNew;
		//}

		if (dig.x==NULL) {
			initDigitizeArray(1000, 1);
		}

		//Digitize points.
		CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
		CDigitize pDg;

		CString tStr;
		CPoint p,selPoint;
		int k,jSel;
		double dist,distOld,distNew;
		SEI_POINT pNew;

		//in case of no time section, do  not use reduction velocity.
		// note: yNew, yOld are whatever screen values are, therefore already reduced if Vred>0,
		//       whereas dig.t[] are absolute time values NOT reduced.
		if( draw.pick == 1 ) {
			// pick digitized curve number
			yOld += this->getReduceTime( getOffsetFromXVal(xOld) , pCd.coord.vred);	   //Apply reduction velocity.
			pNew.x = (float)xOld;
			pNew.y = (float)yOld;
			dig.iCurveSel = pDg.getClosestDigNum(&dig, pNew);
			if (dig.isZeltFormat2) {
				tStr.Format(_T("Curve %d selected."), dig.ivray[dig.iCurveSel]);
				myCaption(tStr);
			}
			return TRUE;
		}
		else if( draw.add == 1 ) {
			// when adding points, ignore xNew,yNew, but only use xOld,yOld.
			// Always add to after the last point of the curve
			if(!isVisibleOrNot(xOld,yOld)) return FALSE;
			int ic = dig.iCurveSel;
			// NOTE: dig.x[]i] can be either in offset mode or in distance mode. The program has to handle both situ
			// what about reduction time? dig.t[][i] is always in absolute time before reduction applied!

			// what about the user dragged from right to left? We just swap the 2 clicks
			if (xNew < xOld) {
				double t = xOld; xOld = xNew; xNew = t;
				t = yOld; yOld = yNew; yNew = t;
			} // if

			//If Zelt's format, make sure xOld is on the same side of the profile source as the first digitized point, otherwise it'll be a mess
			if ( dig.isZeltFormat2 && (draw.mode==0 || draw.mode==7) && dig.nPoint[ic]>0 ) {
				if (!para.isDistanceDisplay && signum(xOld) != signum(dig.x[0][ic]))
					return FALSE;
				else if (para.isDistanceDisplay && signum(dig.x[0][ic]-tx.xShot) != signum(xOld-tx.xShot) )
					return FALSE;

				if ( (draw.isControlPressed || draw.isAPressed) && 
					!isFloatEqual((float)xNew, (float)xOld) &&
					isFileExistNotDirectory(draw.timeSecName) ) 
				{
					if (!para.isDistanceDisplay && signum(xNew)!=signum(dig.x[0][ic]))
						xNew = 0.f;
					else if (para.isDistanceDisplay && signum(dig.x[0][ic]-tx.xShot) != signum(xNew-tx.xShot) )
						xNew = tx.xShot;
				} // if
			} // if

			pCd.coord.xMouse = xOld;
			pCd.coord.yMouse = yOld;

			// correct for reduction velocity. trace display will automatically have zero reduction
			yOld += this->getReduceTime( getOffsetFromXVal(xOld), pCd.coord.vred);
			yNew += this->getReduceTime(getOffsetFromXVal(xNew), pCd.coord.vred);
			//Apply reduction velocity. no effect on displaying by trace!

			// if no points existing in this curve, we need to add a point first, otherwise the auto insersion for drag and drop does not work later.
			if (dig.nPoint[ic] == 0) {
				pDg.myDigAddPoint(&dig, ic, xOld, yOld);
			}

			double winLenWorking = fabs((yNew*2-yOld)*1.0);  // this must be after reduction applied
			if (winLenWorking < dig.twin_min) winLenWorking = dig.twin_min;
			if (winLenWorking > dig.twin_max) winLenWorking = dig.twin_max;
			// float winLenInSec = 0.6f;  // this must be after reduction applied

			pDg.myDigSort(&dig, TRUE, TRUE, pCd.coord.xmin, pCd.coord.xmax);	// this must be done for each loop!

			if (
				(draw.mode==0 || draw.mode==7) && 
				(draw.isControlPressed || draw.isAPressed) && 
				!isFloatEqual((float)xNew, (float)xOld) &&
				isFileExistNotDirectory(draw.timeSecName) ) {
					// find the min time, time window for extract segy data
					double tminExOld = yOld-getReduceTime( getOffsetFromXVal(xOld), pCd.coord.vred);
					double tminExNew = yNew-getReduceTime( getOffsetFromXVal(xNew), pCd.coord.vred);
					double tminOut = min(tminExOld, tminExNew) - winLenWorking*0.5;  // min time for the segy data to extract out

					CSegyMeta::segyHeadInit(draw.timeSecName, &head, 0);
					SegyWrapperEx sw(draw.timeSecName,
						xOld, 
						xNew, 
						tminOut,    
						tminOut + winLenWorking, 
						draw.mode, 
						pCd.coord.vred); 
					// note: when vred is considered, starting time plus reduced time will be absolute time.
					sw.m_dxMin = 0.;
					sw.m_obsDepth = para.obsDepth;  // only used in NMO display
					sw.m_waterDepth = para.waterVelocityAboveObs; // only used in NMO display
					sw.m_zGun = para.gunDepth2; // only used in NMO mode
					sw.m_vWater = para.waterVelocityAboveObs;
					//sw.m_isEnergy = dig.twin_isEnergy != FALSE;  // turn off energy????
					double rvVred = (pCd.coord.vred > 0.1 && pCd.coord.vred < 10.0)  ?   1./pCd.coord.vred  : 0.0f;

					double trcInterval = (para.isDistanceDisplay)  ?  head.distInterval  :  head.offsetInterval;
					if (sw.openDistance(!para.isDistanceDisplay, trcInterval, head.numTraces, &head) &&  sw.nxmax > 1) {
						sw.sortDistance(!para.isDistanceDisplay);
						CDigitize pDg;
						pDg.myDigSort(&dig, TRUE, TRUE, pCd.coord.xmin, pCd.coord.xmax);	
						// float aRange = getOffset(&sw.trArr[0]);
						float aRange = getTraceXVal(&sw.trArr[0], draw.mode, para.isDistanceDisplay);
						int na = -1; // reference trc seq number
						for (int j=0; j<dig.nPoint[ic]; j++) {
							if (isFloatEqual(aRange, dig.x[j][ic])) {
								na = j;
								break;
							} // if
						} // for j
						if (na<0) {
							// this point does not exist in the dig array. we add it
							pDg.myDigAddPoint(&dig, ic, aRange, yOld + (yNew-yOld)*(aRange-xOld)/(xNew-xOld));
							pDg.myDigSort(&dig, TRUE, TRUE, pCd.coord.xmin, pCd.coord.xmax);	// this must be done for each loop!
							for (int j=0; j<dig.nPoint[ic]; j++) {
								if (isFloatEqual(aRange, dig.x[j][ic])) {
									na = j;
									break;
								} // if
							} // for j
						}
						if (na<0) return FALSE; // this should never happen 
						// by now,  na points to the first trace in the sw class

						double slope = (yNew - getReduceTime(getOffsetFromXVal(xNew), pCd.coord.vred) - yOld + getReduceTime(getOffsetFromXVal(xOld), pCd.coord.vred)) / (xNew - xOld);  // here the  reduction velocity is compensated already

						for (int n=0; n<sw.nxmax; n++) {
							pDg.myDigSort(&dig, TRUE, TRUE, pCd.coord.xmin, pCd.coord.xmax);	// this must be done for each loop!  prob: after this sort, na should be changed!
							na = -1; // reference trc seq number, we must re-calculate for each loop since new points may be added and sorted.
							for (int j=0; j<dig.nPoint[ic]; j++) {
								if (isFloatEqual(aRange, dig.x[j][ic])) {
									na = j;
									break;
								} // if
							} // for j
							if (na < 0) continue; // this should never happen
							// now na points to the first trace in the sw class again


							//float bRange = getOffset(&sw.trArr[n]);
							float bRange = getTraceXVal(&sw.trArr[n], draw.mode, para.isDistanceDisplay);
							int nb = -1;  // is this trace n already digitized?
							for (int j=0; j<dig.nPoint[ic]; j++) {
								if (isFloatEqual(bRange, dig.x[j][ic])) {
									nb = j;
									break;
								} // if
							} // for j

							double bTimeEstimate = yOld + (yNew-yOld)*(bRange-xOld)/(xNew-xOld);
							if (nb==na) {
								dig.x[na][ic] = bRange;  // note here aRange and bRange may be slight different because of round off error introduced in isFloatEqual()
								dig.t[na][ic] = (float)bTimeEstimate;
								continue;
							}

							if (!draw.isAPressed && n<sw.nxmax) {
								int iTrc = (para.isDistanceDisplay)?   sw.getClosestTrcIndexAtDistance(bRange) : sw.getClosestTrcIndexAtOffset(bRange);
								//float awin = winLenInSec * 0.5f; // for semb, we only use <half the data window length
								//if (awin < 0.2f) awin = 0.2f;
								//else if (awin > 0.5f) awin = 0.5f;
								//else if (awin < 0.04f) awin = 0.04f;

								// aShift = sw.getShiftFromPrevTrc(iTrc, awin, minlag, maxlag);
								// float aShift = sw.getShiftFromPrevTrcCoh(iTrc, awin, aShiftcenterRaw - bReducedTime, 0.06f);
								//float aShift = sw.getShiftTrcCoh2(0, iTrc, awin, (float)(aShiftcenterRaw - bReducedTime), 0.06f);
								//float bReducedTime = getReduceTime(getOffsetFromXVal(bRange));
								//float aShift = sw.getShiftTrcCoh3(0, iTrc, awin, (float)(bTimeEstimate - bReducedTime), 0.1f, (float)slope);
								float aShift = sw.getShiftTrcCoh3(iTrc, (float)dig.twin_lag, (float)slope, dig.twin_lagWeight,  dig.twin_numSubdivide);

								// note: even if the aShift=0, the absolute shift will be non-zero when vred=1.44km/s !
								if (aShift > -99999.f)
									// bTimeEstimate = dig.t[na][i] + aShift + (bRange-aRange)*rvVred;
										bTimeEstimate += aShift;
							} // if
							else {
								// now "A" is pressed, do nothing since aShiftEstimate is already interpolated
							}

							if (nb>=0) {
								dig.x[nb][ic] = bRange;
								dig.t[nb][ic] = (float)bTimeEstimate;
							}
							else {
								pDg.myDigAddPoint(&dig, ic, bRange, bTimeEstimate);
								pDg.myDigSort(&dig, TRUE, TRUE, pCd.coord.xmin, pCd.coord.xmax);	// this must be done for each loop!  prob: after this sort, na should be changed!
							}



							// now remove all points (if any) between the prev trace and bRange. For simplicity, just remove 1 point at a time
							if (n>0) {
								// float bRange0 = getOffset(&sw.trArr[n-1]);
								float bRange0 = getTraceXVal(&sw.trArr[n-1], draw.mode, para.isDistanceDisplay);
								bool isCheck = true;
								while (isCheck) {
									isCheck = false;
									for (int j=0; j<dig.nPoint[ic]; j++) {
										if (isInsideExFloat(dig.x[j][ic], bRange0, bRange)) {
											pDg.myDigRemove(&dig, j, ic); // note: this changes dig.nPoint[i]
											isCheck = true;  // ask it to check again
											break;
										} // if
									} // for j
								} // while isCheck
							} // if n




						} // for n
					} // if sw.open
			} // if draw.mode==0
			else if ( draw.mode==6 && 
				//	!dig.isZeltFormat2 && 
				draw.isControlPressed && 
				isFileExistNotDirectory(draw.timeSecName) ) {
					pDg.myDigSort(&dig, TRUE, FALSE, pCd.coord.xmin, pCd.coord.xmax);	

					// now interpolate between the previous node and the xOld
					for (k=dig.nPoint[ic]-1; k>=0; k--) {
						if (dig.x[k][ic] < (float)xOld) {
							// we found the index
							// we should interpolate between (x1, xOld)  with  (t1, yOld)
							// Note:  dig.x[k][i]   must have already been sorted! This is true since whenever it saves the dig file, it already sorts before saving!
							CSegyMeta::segyHeadInit(draw.timeSecName, &head, 0);
							SegyWrapperEx sw(draw.timeSecName, (int)myRound(xOld), (int)myRound(xNew), yOld,  yOld+winLenWorking);
							// sw.m_isEnergy = dig.twin_isEnergy != FALSE;  // turn off energy????
							if (sw.openTrace(&head) &&  sw.nxmax > 1){
								for (int n=0; n<sw.nxmax; n++) {
									int xTrc = sw.trArr[n].tracl;  // this must be very close to  xOld
									int nExisting = -1;  // is this trace n already digitized?
									for (int j=0; j<dig.nPoint[ic]; j++) {
										if (xTrc == (int)myRound(dig.x[j][ic])) {
											nExisting = j;
											break;
										} // if
									} // for j
									if (n==0 && nExisting>=0) {
										dig.x[nExisting][ic] = (float)sw.trArr[0].tracl;
										dig.t[nExisting][ic] = (float)yOld;
										continue;
									}
									else if (n==0) {
										pDg.myDigAddPoint(&dig, ic, (double)sw.trArr[0].tracl, yOld);
										pDg.myDigSort(&dig, TRUE, FALSE, pCd.coord.xmin, pCd.coord.xmax);	
										continue;
									}

									int nPrevExisting = -1;  // is this trace n-1 already digitized?
									int xTrcPrev = sw.trArr[n-1].tracl;
									for (int j=0; j<dig.nPoint[ic]; j++) {
										if (xTrcPrev == (int)myRound(dig.x[j][ic])) {
											nPrevExisting = j;
											break;
										} // if
									} // for j
									if (nPrevExisting < 0) continue;

									float tIncCenter = (float) ((yNew - yOld) / (xNew - xOld));
									double aShift = sw.getShiftTrcCoh2(n-1, n, tIncCenter, (float)dig.twin_lag, dig.twin_numSubdivide);
									if (aShift> -99999.f) {
										aShift += tIncCenter;
										if (nExisting < 0) {
											pDg.myDigAddPoint(&dig, ic, 
												(double)sw.trArr[n].tracl, 
												(double)dig.t[nPrevExisting][0] + aShift);
											pDg.myDigSort(&dig, TRUE, FALSE, pCd.coord.xmin, pCd.coord.xmax);	
										}
										else {
											dig.t[nExisting] [ic] = (float)(dig.t[nPrevExisting][0] + aShift);
										}
									} // if 
								} // for n
							} // if
							break;
						} // if dis.x
					} // for k
			}// if
			else {
				// just make sure we do not have exactly duplicated point here
				int num = dig.nPoint[ic];
				if (num>0 && dig.x[num-1][ic] != xOld &&
					!isFloatEqual(dig.x[num-1][ic], (float)xOld) &&
					!isFloatEqual(dig.t[num-1][ic], (float)yOld) ) {
						pDg.myDigAddPoint(&dig, ic, xOld, yOld);
				}
			}

			//if (dig.isZeltFormat2 && head.numTraces>0 && dig.nPoint[i] > 1 && draw.isControlPressed && isFileExistNotDirectory(draw.timeSecName) ) {
			//	// now interpolate between the previous node and the xOld
			//	for (k=dig.nPoint[i]-2; k>=0; k--) {
			//		if (dig.x[k][i] < xOld) {
			//			// we found the index
			//			float x1, t1; // the model point on the left. The model point on the right is: [xOld, tOld]
			//			x1 = dig.x[k][i];
			//			t1 = dig.t[k][i];

			//			// we should interpolate between (x1, xOld)  with  (t1, yOld)
			//			// Note:  dig.x[k][i]   must have already been sorted! This is true since whenever it saves the dig file, it already sorts before saving!
			//			for (int n=0; n<head.numTraces; n++) {
			//				if (head.dist[n] > x1 && head.dist[n] < xOld) {
			//					pDg.myDigAddPoint(&dig, i, 
			//						(double)head.dist[n], 
			//						(double) ( t1 + (yOld - t1) * (head.dist[n] - x1) / (xOld - x1) )  // we already have xOld-x1>0.f for sure
			//						);
			//				} // if
			//			} // for n
			//			break;
			//		} // if
			//	} // for k
			//} // if draw

			pDg.myDigSort(&dig, TRUE, TRUE, pCd.coord.xmin, pCd.coord.xmax);	// this must be done for each loop!

			dig.pt_added.x = xOld;
			dig.pt_added.y = yOld;
			dig.pt_added.isValid = true;  // this will ask the ondraw() to temporarily display this point and then disable it


			return TRUE;
		}
		//Move points.
		else if( draw.move == 1 ) {
			tStr.Format(_T("xOld=%f, xNew=%f, yOld=%f, yNew=%f, xShotInSegy=%f, para.vred=%f, redTime=%f"), 
				xOld, xNew, yOld, yNew, 
				tx.xShot, 
				pCd.coord.vred, 
				getReduceTime(getOffsetFromXVal(xOld), pCd.coord.vred)
				);
			this->myCaption(tStr);

			int ic = dig.iCurveSel;
			if (ic<0) return FALSE;
			distOld = MIL;
			jSel=-1;
			yOld += getReduceTime(getOffsetFromXVal(xOld), pCd.coord.vred);
			//Apply reduction velocity.

			int maxPointsAtCurve = dig.nPoint[ic];
			for (int j=0; j<maxPointsAtCurve; j++) {
				distNew = fabs(dig.x[j][ic]-xOld) +
					fabs(dig.t[j][ic]-yOld) ;
				dist = min(distNew, distOld);
				if(dist == distNew) {
					jSel = j;
					distOld = distNew;
				}
			}
			//So the old point is at x,t[jSel, i] in km, 
			//The new point is: xNew, yNew in km.
			if(jSel<0) return FALSE;
			pCd.coord.xMouse = xNew;	//Save points for Invalidate(FALSE).
			pCd.coord.yMouse = yNew;
			dig.x[jSel][ic] = (float)xNew;
			yNew += getReduceTime(getOffsetFromXVal(xNew), pCd.coord.vred);
			//Apply reduction velocity.

			dig.t[jSel][ic] = (float)yNew;
			if (draw.isControlPressed) {
				if (jSel==0 && maxPointsAtCurve>0) dig.t[jSel][ic] = dig.t[jSel+1][ic];
				else if (jSel>0) dig.t[jSel][ic] = dig.t[jSel-1][ic];
			}


			pDg.myDigSaveAs(&dig, dig.isSorted, dig.isSortedY, tx.xShot); 

			//CString t;
			//t.Format(_T("i=%d, jSel=%d, xOld=%f, xNew=%f, yOld=%f, yNew=%f, xShotInSegy=%f, para.rvVred=%f", i, jSel, xOld, xNew, yOld, yNew, tx.xShotInSegy, para.rvVred);
			//this->myCaption(t);
			return TRUE;
		}
		else if( draw.remove == 1 ) {
			if(!isVisibleOrNot(xNew,yNew)) return FALSE;
			int ic = dig.iCurveSel;
			if (ic<0) return FALSE;

			// first calculate the index for removal
			distOld = 200000.;
			jSel=-1;
			yOld += getReduceTime(getOffsetFromXVal(xOld), pCd.coord.vred);
			//Apply reduction velocity.

			for (int j=0; j<dig.nPoint[ic]; j++) {
				distNew = fabs(dig.x[j][ic]-xOld) +
					fabs(dig.t[j][ic]-yOld) ;
				dist = min(distNew, distOld);
				if(dist == distNew)  {
					jSel = j;
					distOld = distNew;
				}
			}
			//So the removal point is at x,t[jSel, i] 

			if (jSel>=0) {
				//now save the removal point for Invalidate() in onDraw().
				pCd.coord.xMouse = dig.x[jSel][ic];
				pCd.coord.yMouse = dig.t[jSel][ic] - getReduceTime(getOffsetFromXVal(dig.x[jSel][ic]), pCd.coord.vred);
				//Apply reduction velocity.

				// now remove the point.
				dig.nPoint[ic]--;
				for (int j=jSel; j<dig.nPoint[ic]; j++) {
					dig.x[j][ic] = dig.x[j+1][ic];
					dig.t[j][ic] = dig.t[j+1][ic];
				}

				pDg.myDigSaveAs(&dig, dig.isSorted, dig.isSortedY, tx.xShot); 
				return TRUE;
			}
		} //End deleting point.
		return FALSE;

		// end digitizing functions
	}


	BOOL CSeisWideDoc::MyMouseClick(double xOld, double yOld, double xNew, double yNew)
	{
		if(draw.isDigitizing)
			return MyMouseClickDigitizing(xOld, yOld, xNew, yNew);

		if (draw.mode==9) return MyMouseClickMode9(&velMod, xOld, yOld, xNew, yNew);
		if (!isModelDisplayed()) return FALSE;
		// The following mouse manipulation is only for editting a model in depth domain!

		//if ((draw.add==1 || draw.move==1) && (xNew<velMod.xmin || xNew>velMod.xmax)) {
		//	myCaption(_T("Sorry, cannot edit model points outside the X-limits, unless you resize the model first."));
		//	return FALSE;
		//}
		//if (xNew<velMod.xmin) {
		//	xNew  = velMod.xmin;
		//} else if (xNew>velMod.xmax) {
		//	xNew = velMod.xmax;
		//}

		if (draw.add==1) {
			// just to be consistent when adding points
			xOld = xNew;
			yOld = yNew;
		}

		CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();

		CVelMod vm;


		CString tStr;
		CPoint p,selPoint;
		int k,icont,jSel;
		TCHAR s[80];
		//	double dist,distOld,distNew;
		double tempv,z1[MOD_LAYER_MAX];
		// double depth[MOD_LAYER_MAX],vTop[MOD_LAYER_MAX],vBot[MOD_LAYER_MAX];
		CVelMod::VELMOD_X modX;
		SEI_POINT pNew;
		pNew.x = (float)xNew;
		pNew.y = (float)yNew;

		//if (draw.mode == 0 || draw.mode >= 6) 
		//	return FALSE; // no need to click on anything

		//pick boundary.
		if( draw.pick == 1 &&  draw.nodes == 1) {
			draw.iLayerFocus = vm.getClosestLayerNum(&velMod, pNew, isTimeDomain());
			return TRUE;
		}  //End pick a boundary.

		//pick a layer.
		if( draw.pick == 1 &&  draw.nodes == 2)  {
			if(!isVisibleOrNot(xNew,yNew)) {
				draw.iLayerFocus=-1;
				return TRUE;
			}
			draw.iLayerFocus=-1;
			for (icont=0; icont<velMod.ncont; icont++) {
				z1[icont] = -1.;
				for (int j=0; j<velMod.nzed[icont]-1; j++) {
					if(xOld>=velMod.xm[j][icont]&&xOld<=velMod.xm[j+1][icont]) {
						z1[icont]=velMod.zm[j][icont]+
							(velMod.zm[j+1][icont]-velMod.zm[j][icont])*
							(xOld-velMod.xm[j][icont])/
							(velMod.xm[j+1][icont]-velMod.xm[j][icont]);
						break;
					}
				}
				if(z1[icont]<0)  {
					_stprintf_s(s, _T("x,x0,x1: %g %g %g"), &xOld,&velMod.xm[0][icont],&velMod.xm[1][icont]);
					AfxMessageBox(s);	
					return FALSE;
				}
			}
			for (icont=0; icont<velMod.ncont-1; icont++) {
				if(yOld>=z1[icont] && yOld<=z1[icont+1]) {
					draw.iLayerFocus=icont;
					if ( yOld < pCd.coord.axisY1)
						draw.isTopBound=true;
					else if (yOld > pCd.coord.axisY2)
						draw.isTopBound=false;
					else if(fabs(yOld-z1[icont])<fabs(yOld-z1[icont+1]))
						draw.isTopBound=true;
					else 
						draw.isTopBound=false;
					break;
				}
			}
			return draw.iLayerFocus>=0;
		}  //End pick a layer.

		//Add a point for specified boundary (draw.iLayerFocus).
		if( draw.add == 1 &&  draw.nodes == 1)  {
			if(!isVisibleOrNot(xNew,yNew)) return FALSE;
			//		distOld = 200000.;
			icont =  draw.iLayerFocus;
			jSel = vm.getPointIndexBeforeOnBoundary(&velMod, xNew, icont);
			if(jSel<0) return FALSE;
			//if(xNew<velMod.xm[jSel][icont]) jSel--;
			if (vm.velModInsPoint(&velMod, icont, jSel+1, pNew, isTimeDomain())) {
				pCd.coord.xMouse = xNew;
				pCd.coord.yMouse = yNew;
				return TRUE;
			}
			else return FALSE;
		}	//End of add a node for specified boundary.

		//Add a point for specified layer (draw.iLayerFocus).
		//Need to consider: Low velocity layer not allowed.
		//One layer/boundary may have one point only (done).
		// static int anisotropy_layer0 = -1;
		double adepth0, adepth1, adepth2;
		if( draw.add == 1 &&  draw.nodes == 2)  {
			if(!isVisibleOrNot(xNew,yNew)) return FALSE;
			//First calculate the velocity at the clicked point.
			icont =  draw.iLayerFocus;
			jSel = vm.getPointIndexBeforeOnLayer(&velMod, xNew, icont, draw.isTopBound, &tempv);
			if (jSel < 0) return FALSE;

			// note: in the UI, the user sees 1 meaning the first layer. But in programming, 0=the first layer
			CdlgLayerNodes dlg1;
			dlg1.m_isRegressionAlways = velMod.isSedRegression;
			dlg1.m_strRegression = CVelMod::getStringRegression(&velMod);
			dlg1.m_layerNum = icont+1;
			dlg1.m_layerX = (float)((int)(xOld*100+.5)*0.01);  //The float oper. reduce num of digits displayed.
			dlg1.m_layerY = (float)((int)(yOld*100+.5)*0.01);
			dlg1.m_layerV = (float)((int)(tempv*100+.5)*0.01);
			dlg1.m_layerV *= 1000.f;
			dlg1.m_waterDepth = (float)CVelMod::getDepthWater(&velMod, xNew);
			dlg1.m_anisotropy = velMod.anisotropy[icont];
			dlg1.m_anisotropy_layer0 = pFrame->psei->anisotropy_layer0+1;
			if (dlg1.DoModal() == IDOK) {
				velMod.isSedRegression = dlg1.m_isRegressionAlways;
				CVelMod::parseString2Regression(&velMod, dlg1.m_strRegression);
				xOld = dlg1.m_layerX;  
				yOld = dlg1.m_layerY;
				tempv = dlg1.m_layerV / 1000.f;
				pFrame->psei->anisotropy_layer0 = dlg1.m_anisotropy_layer0-1;
				if (pFrame->psei->anisotropy_layer0 > -1 && pFrame->psei->anisotropy_layer0 < icont) {
					// this means we need to interpolate for anisotropy for all the overlying layers below anisotropy_layer0
					modX.dist = xOld;
					vm.initModX(&velMod, &modX, false, true, true, vel.dz);
					adepth2 = (modX.depthMod[icont] + modX.depthMod[icont + 1]) * 0.5;  // we know icont<velMod.ncont
					adepth0 = (modX.depthMod[pFrame->psei->anisotropy_layer0] + modX.depthMod[pFrame->psei->anisotropy_layer0 + 1]) * 0.5;
					for (int j=pFrame->psei->anisotropy_layer0; j<icont; j++) {
						adepth1 = (modX.depthMod[j] + modX.depthMod[j + 1]) * 0.5;
						velMod.anisotropy[j] = (adepth2 - adepth0)>0 ?   
							dlg1.m_anisotropy * (float)( (adepth1 - adepth0) / (adepth2 - adepth0) )
							:
							dlg1.m_anisotropy;
					}
				}
				velMod.anisotropy[icont] = dlg1.m_anisotropy;
			}
			else return FALSE;
			delete dlg1;
			if (vm.velModVelInsPoint(&velMod, draw.iLayerFocus, jSel+1, draw.isTopBound, (float)xNew, (float)tempv)) {
				return TRUE;
			}
			else return FALSE;
		}	//End of add a node for specified layer.


		//Move boundary points.
		if( draw.move == 1 &&  draw.nodes == 1) {
			//		distOld = MIL;
			icont =  draw.iLayerFocus;
			jSel = vm.getPointIndexClosestOnBoundary(&velMod, xOld, icont);
			if(jSel<0) return FALSE;
			pCd.coord.xMouse = xNew;	//Save points for Invalidate(FALSE).
			pCd.coord.yMouse = yNew;
			if(jSel!=0 && jSel!=(velMod.nzed[icont]-1)) {
				if (xNew < velMod.xmin) xNew = velMod.xmin;
				else if (xNew > velMod.xmax) xNew = velMod.xmax;
				if(!isVisibleOrNot(xNew,yNew)) return FALSE;
				if(xNew<velMod.xm[jSel-1][icont]+0.00001) return FALSE; //The model's resolution has to be 0.00001 km.
				if(xNew>velMod.xm[jSel+1][icont]-0.00001) return FALSE; //The model's resolution has to be 0.00001 km.
			}
			else xNew = velMod.xm[jSel][icont];  //left/right boundary points cann't change X values.

			if (draw.isControlPressed) {
				if (jSel==0) yNew = velMod.zm[jSel+1][icont];
				else yNew = velMod.zm[jSel-1][icont];
			}
			else if (jSel == velMod.nzed[icont]-1)
				myCaption(_T("Use Ctrl key to flatten the segment"));

			//now make sure the point doesn't go above or below adjacent boundary.
			//to do this: (1) calculate Z for xNew of boundaries jSel-1 and jSel+1; (2) decide.
			modX.dist = xNew;
			vm.initModX(&velMod, &modX, false, true, true, vel.dz);
			if ((icont>0 && yNew < modX.depthMod[icont - 1]) || (icont<velMod.ncont - 1 && yNew>modX.depthMod[icont + 1])) {
				// the new point is above another boundary
				tStr.Format( _T("You tried to move nodes acrossing another boundary. Continue?") );
				if (AfxMessageBox(tStr, MB_YESNO|MB_ICONINFORMATION) == IDNO) return FALSE;
				if (!vm.velModInterceptPoint(&velMod, icont, jSel, pNew, isTimeDomain())) return FALSE;
			} else {
				velMod.xm[jSel][icont] = (float)xNew;
				velMod.zm[jSel][icont] = (float)yNew;
			}

			return TRUE;
		}	//End moving boundary points.

		//Move  points defining a velocity layer.
		if( draw.move == 1 &&  draw.nodes == 2) {
			if (draw.iLayerFocus < 0) return FALSE;
			icont =  draw.iLayerFocus;
			if( draw.isTopBound)	k=0;
			else k=1;

			icont =  draw.iLayerFocus;
			jSel=-1;
			for (int j=0; j<velMod.nvel[icont][k]-1; j++) {
				if(xOld>=velMod.xvel[j][icont][k]&&xOld<=velMod.xvel[j+1][icont][k]) {
					jSel = j;
					break;
				}
			}
			if(jSel < 0 || jSel>velMod.nvel[icont][k]-1) return FALSE;
			if(fabs(xOld-velMod.xvel[jSel][icont][k]) >
				fabs(xOld-velMod.xvel[jSel+1][icont][k])) jSel++;
			if(jSel < 0 || jSel>velMod.nvel[icont][k]-1) return FALSE;

			xOld=velMod.xvel[jSel][icont][k];
			tempv=velMod.vf[jSel][icont][k];
			//So the old point is at xOld, yOld in km, 
			//The new point is: xNew, yNew in km.

			// note: in the UI, the user sees 1 meaning the first layer. But in programming, 0=the first layer
			static BOOL isApply4All = false;
			CdlgLayerNodes dlg1;
			dlg1.m_isRegressionAlways = velMod.isSedRegression;
			dlg1.m_strRegression = CVelMod::getStringRegression(&velMod);
			dlg1.m_layerNum = icont+1;
			dlg1.m_layerX = (float)((int)(xNew*10000+.5)*0.0001);  //The float oper. reduce num of digits displayed.
			dlg1.m_layerY = (float)((int)(yNew*10000+.5)*0.0001);
			dlg1.m_layerV = (float)((int)(tempv*100000+.5)*0.00001);
			dlg1.m_layerV *= 1000.f;
			dlg1.m_waterDepth = (float)CVelMod::getDepthWater(&velMod, xOld);
			dlg1.m_apply4All = isApply4All;
			dlg1.m_anisotropy = velMod.anisotropy[icont]; 
			dlg1.m_anisotropy_layer0 = pFrame->psei->anisotropy_layer0+1;

			if (dlg1.DoModal() == IDOK) {
				velMod.isSedRegression = dlg1.m_isRegressionAlways;
				CVelMod::parseString2Regression(&velMod, dlg1.m_strRegression);
				xNew = dlg1.m_layerX;  
				draw.modelVelInc = (float)fabs(tempv - dlg1.m_layerV / 1000.f); // this save for people to click the arrows on toolbar.
				if ( fabs(draw.modelVelInc) < 0.01f) draw.modelVelInc = 0.01f;
				else
					if ( fabs(draw.modelVelInc) > 0.05f) draw.modelVelInc = 0.05f;


				tempv = dlg1.m_layerV / 1000.f;


				isApply4All = dlg1.m_apply4All;
				pFrame->psei->anisotropy_layer0 = dlg1.m_anisotropy_layer0-1;
				modX.dist = xOld;
				vm.initModX(&velMod, &modX, false, true, true, vel.dz);
				if (dlg1.m_anisotropy==-1 && pFrame->psei->anisotropy_layer0 > -1 && pFrame->psei->anisotropy_layer0 < icont) {
					// this means we need to interpolate for anisotropy for all the overlying layers below anisotropy_layer0
					// interpolate using an empirical formula
					for (int j=pFrame->psei->anisotropy_layer0; j<icont; j++) {
						double vh = (modX.vTop[j] + modX.vBot[j]) * 0.5;
						velMod.anisotropy[j] = (float)(1. -  (0.393 + 0.74 * vh) / vh);
					}
				} else if (dlg1.m_anisotropy==0.f && pFrame->psei->anisotropy_layer0 > -1 && pFrame->psei->anisotropy_layer0 < icont) {
					for (int j=pFrame->psei->anisotropy_layer0; j<icont; j++) {
						velMod.anisotropy[j] = 0.f;
					}
				}

				// note: dlg1.m_anisotropy  can be  -1, 0, or >0
				if (dlg1.m_anisotropy == -1) {
					double vh = (modX.vTop[icont] + modX.vBot[icont]) * 0.5;
					dlg1.m_anisotropy = (float)(1. - (0.393 + 0.74 * vh) / vh);
				}
				velMod.anisotropy[icont] = dlg1.m_anisotropy;
			}
			else return FALSE;
			delete dlg1;

			if (isApply4All) {
				for (int j=0; j<velMod.nvel[icont][k]; j++) {
					velMod.vf[j][icont][k] = (float)tempv;
				}
			} // if

			if(jSel == 0 || jSel==velMod.nvel[icont][k]-1) {
				velMod.vf[jSel][icont][k] = (float)tempv;
			} else {
				if(xNew<velMod.xvel[jSel-1][icont][k]+0.00001) return FALSE; //The model's resolution has to be 0.00001 km.
				if(xNew>velMod.xvel[jSel+1][icont][k]-0.00001) return FALSE; //The model's resolution has to be 0.00001 km.
				velMod.xvel[jSel][icont][k] = (float)xNew;
				velMod.vf[jSel][icont][k] = (float)tempv;
			} 
			return TRUE;
		} //End of moving layer points.

		//deleting boundary points.
		if( draw.remove == 1 &&  draw.nodes == 1) {
			//		distOld = 200000.;
			icont =  draw.iLayerFocus;
			jSel = vm.getPointIndexClosestOnBoundary(&velMod, xNew, icont);
			if(jSel<0) return FALSE;
			pCd.coord.xMouse = velMod.xm[jSel][icont];
			pCd.coord.yMouse = velMod.zm[jSel][icont];
			if (vm.velModDelPoint(&velMod, icont, jSel)) {
				return TRUE;
			}
			else return FALSE;
		}	//End deleting boundary points.

		//delete  points defining a velocity layer.
		if( draw.remove == 1 &&  draw.nodes == 2) {	
			icont =  draw.iLayerFocus;
			jSel = vm.getPointIndexClosestOnLayer(&velMod, xNew, icont, draw.isTopBound, &tempv);
			if (jSel < 0) return FALSE;

			if (vm.velModVelDelPoint(&velMod, icont, jSel, draw.isTopBound)) {
				draw.isNodeChanged = TRUE;  // setting this to FALSE removes the screen flicker
				return TRUE;
			}
			else return FALSE;
		} //End deleting layer points.
		return FALSE;
	}

	BOOL CSeisWideDoc::myLoadTravelTime(CString txName)
	{
		//when return FALSE, then the tx curves for tx.xShotInSegy cannot be loaded.
		// then you need to consider changing the segy data
		// tx.xShotInSegy should be accurate up to 3 decimal points!

		// calling this routine will reload the data regardless of cachig

		CString tStr;
		CString tExt = GetFileExtension(txName);
		if (tExt != _T("out")) return FALSE;   // txName should be like tx.out

		long j, n, nOld, iShot, curSide;
		float t1, t2, t3;
		BOOL textErr=FALSE ;

		float xShotChosen = ERRORVAL;

		CStringArray *sArr = new CStringArray();
		if (!getXshotListFromTxOut(txName, sArr) || sArr->GetSize() < 1) {
			sArr->RemoveAll();
			delete sArr;
			return FALSE;
		}
		//if (sArr->GetSize() < 2) {
		// tStr = sArr->ElementAt(0);
		// xShotChosen = (float)StringToFloat(tStr);  // only 1 xshot exists
		//}
		//else {
		for (j=0; j<sArr->GetSize(); j++) {
			t1 = (float)StringToFloat(sArr->ElementAt(j));
			if (isFloatEqual((float)tx.xShot, t1)) {
				xShotChosen = t1;
				break;
			}
		}
		//}
		sArr->RemoveAll();
		delete sArr;

		if (xShotChosen == ERRORVAL) return FALSE;

		//#########################################
		//#########################################
		FILE *stream;
		TCHAR line[MAXLINE];


		if( _tfopen_s( &stream, txName, _T("r") ) != 0) {
			return FALSE;
		}

		while (_fgetts(line,MAXLINE,stream)!=NULL) {
			if (_tcslen(line) < 2) continue;
			if (line[0] == _T('#')) continue; // we do not need comment lines
			_stscanf_s(line,_T("%g %g %g %d"), &t1,&t2,&t3,&n);
			if(n<0) {
				fclose( stream );
				return FALSE;
			}

			if ((isFloatEqual(xShotChosen, t1) && isFloatEqual(0.f, t3) && n==0) ) {
				// this indicates the xshot of the matchable TT curves
				iShot = (long)t2;
				break;
			}
		}
		// noe the position in stream is correct.

		// let's reset the arrays first
		j=0;
		int i=0;
		//nOld = 0;
		nOld = -1;

		// the difference between iShot  and curSide: 
		//		iShot is Zelt's tx.out format, either -1  or 1
		//		curSize follows array index format, either 0 or 1
		if(iShot==-1) curSide = 0;
		else if(iShot==1) curSide = 1;
		else {
			fclose( stream );
			return FALSE;
		}

		for (j=0; j<TX_CURVES_MAX; j++) {
			tx.num[j][0] = 0;
			tx.num[j][1] = 0;
		}
		tx.tot[0] = tx.tot[1] = 0;

		// rewind(stream);
		i = 0;
		while (_fgetts(line,MAXLINE,stream)!=NULL) {
			if (_tcslen(line) < 2) continue;
			if (line[0] == '#') continue; // we do not need comment lines
			tStr.Format(_T("%s"), line);
			if (tStr.Find(_T("NaN")) >= 0) continue;
			_stscanf_s(line,_T("%g %g %g %d"), &t1,&t2,&t3,&n);

			if(n==-1 || (!isFloatEqual(t1, xShotChosen)  && t3==0 && n==0)) {
				//last line of the file.
				// tx.num[ tx.tot[curSide] ][curSide] ++;   // this last line does not add any new points!!!
				tx.tot[curSide] ++;
				fclose( stream );
				return TRUE;
			}
			// if(t2>=0. && n!=0)
			if(t2>=0.f && t3>0.f)
			{
				if(n==nOld) {
					//  or the same curve
					i = tx.num[ tx.tot[curSide] ][curSide]; // note that i will change frequently locally
					tx.x[i][ tx.tot[curSide] ][curSide] = t1;
					tx.t[i][ tx.tot[curSide] ][curSide] = t2;
					tx.rayCodePerCurve[ tx.tot[curSide] ][curSide] = n;
					tx.num[ tx.tot[curSide] ][curSide]++;  // only one point exists for that curve
				}
				else {
					if(tx.tot[curSide]==0 && tx.num[ 0 ][curSide] == 0) {
						// starting the first curve
						tx.tot[curSide] = 0; // indicating the current curve number
						tx.x[0][ 0 ][curSide] = t1;
						tx.t[0][ 0 ][curSide] = t2;
						tx.rayCodePerCurve[ 0 ][curSide] = n;
						tx.num[ 0 ][curSide] = 1;
					}
					else {
						// a new curve is found
						if(tx.num[ tx.tot[curSide] ][curSide] >= TX_POINTS_MAX) {
							fclose( stream );
							AfxMessageBox(_T("Maximum number of points in a travel-time curve reached."));
							return FALSE;
						}
						if(tx.tot[curSide] >= TX_CURVES_MAX) {
							fclose( stream );
							AfxMessageBox(_T("Maximum number of travel-time curves reached."));
							return FALSE;
						}

						tx.tot[curSide]++;  // indicating the current curve number
						tx.x[0][ tx.tot[curSide] ][curSide] = t1;
						tx.t[0][ tx.tot[curSide] ][curSide] = t2;
						tx.rayCodePerCurve[ tx.tot[curSide] ][curSide] = n;
						tx.num[ tx.tot[curSide] ][curSide] = 1;
					}
				} // else
				nOld = n;
			} // if t2
			else	{   
				if(t2!=0.f && n==0) 
				{
					if (tx.num[ tx.tot[curSide] ][curSide] > 0) {
						// this means all data from the previous curSide is already read in
						tx.tot[curSide] ++;
					}

					if(t2==-1.f) curSide = 0;
					else if(t2==1.f) curSide = 1;
					nOld=-999;
				}
				else
				{
					fclose( stream );
					return TRUE;
				}
			} // else
		} // while
		fclose( stream );

		// if here, it terminates un-expectedly
		tx.num[ tx.tot[curSide] ][curSide] ++;
		tx.tot[curSide] ++;


		return TRUE;
	}

	void CSeisWideDoc::OnDigitizingStart() 
	{
		if (draw.isDigitizing) {
			AfxMessageBox(_T("You are still digitizing."));
			return;
		}
		CDigitize pDg;

		// initialize the dig array sizes, big enough for most purposes.
		int ncurve=5;
		int npoint = 2000;

		draw.isControlPressed = FALSE;
		draw.isShiftPressed = FALSE;
		CdlgDigitize dlg;

		bool isTxt = draw.mode==10  || draw.mode == 6 || fabs(pCd.coord.vred)<3.0;

		// GetCurrentDirectory()
		//TCHAR curDir[_MAX_PATH];
		//GetCurrentDirectory(_MAX_PATH, curDir);

		//if (isFileExistNotDirectory(dig.digName)) 
		//	dlg.m_digName = dig.digName;
		if (draw.mode==6) {
			dlg.m_digName	= mySetFileExtension(getFileNameAppend(draw.timeSecName, _T("_digTrc")),  _T("txt"));
		} else {
			dlg.m_digName	= mySetFileExtension(
				isTxt ? getFileNameAppend(draw.timeSecName, _T("_digi")) : getFileNameAppend(draw.timeSecName, _T("_digZelt")), 
				isTxt ? _T("txt") : _T("in"));
		}

		if (dlg.m_digName.Find(_T("\\")) < 0) {
			// this file does not contain a path, so we have to add one
			dlg.m_digName = this->getWorkingPathSlash() + dlg.m_digName;
		}

		if (draw.mode == 6)
			dig.xMode = CDigitize::trace;
		else if (para.isDistanceDisplay)
			dig.xMode = CDigitize::distance;
		else
			dig.xMode = CDigitize::offset;

		dlg.m_digFileFormat = isTxt ? 0 : 1;
		dlg.m_obsDist = (float)tx.xShot;
		dlg.m_mode = 0;
		dlg.m_comments = dig.strComment;
		if (dig.isSorted) 
			dlg.m_isSort = 0;
		else if (dig.isSortedY)
			dlg.m_isSort = 1; 
		else
			dlg.m_isSort = 2;

		// additions
		dlg.m_isEnergy = dig.twin_isEnergy;
		dlg.m_tlag = (float)dig.twin_lag;
		dlg.m_lagWeight = dig.twin_lagWeight;
		dlg.m_tmin = (float)dig.twin_min;
		dlg.m_tmax = (float)dig.twin_max;
		dlg.m_numSubdivide = dig.twin_numSubdivide;


		if (dlg.DoModal() == IDOK)
		{
			dig.digName = dlg.m_digName;
			dig.isZeltFormat2 = dlg.m_digFileFormat!=0;
			if (dlg.m_comments == _T("Comments")) dlg.m_comments = _T("");
			dig.strComment = dlg.m_comments;
			ncurve = dlg.m_curves;
			npoint = dlg.m_points;
			tx.xShot = dlg.m_obsDist;
			if (dlg.m_isSort == 0) {
				dig.isSorted = TRUE;
				dig.isSortedY = FALSE;
			}
			else if (dlg.m_isSort == 1) {
				dig.isSorted = FALSE;
				dig.isSortedY = TRUE;
			}
			else {
				dig.isSorted = FALSE;
				dig.isSorted = FALSE;
			}
			dig.twin_isEnergy = dlg.m_isEnergy != FALSE;
			dig.twin_lag = dlg.m_tlag;
			dig.twin_lagWeight = dlg.m_lagWeight;
			dig.twin_min = dlg.m_tmin;
			dig.twin_max = dlg.m_tmax;
			dig.twin_numSubdivide = dlg.m_numSubdivide;
		}
		else return;

		// fix up for users' ignorance
		if (!isTimeDomain()) {
			dig.isZeltFormat2 = FALSE;  // for depth domain, we only allow plain text format
		}

		if (dig.isZeltFormat2 && !para.isDistanceDisplay) {
			AfxMessageBox(_T("For Zelt's format, traveltime picks can only be done when displaying with model distance mode. Please do this change and then rerun."));
			return;
		}

		if (!dig.isZeltFormat2) {
			dig.digName = mySetFileExtension(dig.digName, _T("txt"));
		}
		else {
			dig.digName = mySetFileExtension(dig.digName, _T("in"));
		}
		draw.isDigitizing = TRUE;
		draw.isSameDataDisplay = TRUE;
		dig.noPromptLabel = FALSE; //when loading, prompt for showing labels. This is he only way to recover the dialog box without restarting the SeisWide program.
		draw.isNoLabelInSide = FALSE; //when loading, 
		OnToolbarAdd();

		if (isFileExistNotDirectory(dig.digName) && !dig.isZeltFormat2 ) {
			// already exists, so we simply returm
			if (pDg.myDigitizingLoadTXTUnix2(&dig, dig.isSorted, dig.isSortedY)) {
				if (dig.totCurve<1) dig.totCurve = 1;
				dig.iCurveSel = dig.totCurve-1;
				OnToolbarRefresh();
				return;
			}
		}
		else if(isFileExistNotDirectory(dig.digName) && dig.isZeltFormat2) {
			if (pDg.myDigitizingLoadzeltTx(&dig, tx.xShot)) {
				// For zelt format, never sort on Y-axis
				if (dig.totCurve<1) dig.totCurve = 1;
				dig.iCurveSel = dig.totCurve-1;
				OnToolbarRefresh();
				return;
			}
		}


		// If here, no existing dig files arwe found. So we start a new one.
		if (!initDigitizeArray(npoint, ncurve)) return;
		if(dig.nPoint==NULL || dig.digResolution==NULL || dig.x==NULL || dig.t==NULL) {
			AfxMessageBox(_T("Memory unavailable 14"));
			return;
		}


		// reset contents even if is duplication work (already reset during initDigitizeArray() )
		dig.iCurveSel = 0;	//first curve.
		dig.nPoint[0] = 0; // actual number of points
		dig.totCurve = 1;  // starting from 1 even no points in it yet.

		if(dig.isZeltFormat2) {	
			//Here Zelt's format is chosen, so need to ask for resolution.
			CdlgDigResolution dlg;

			if(dig.iCurveSel==0) {
				dlg.m_digResolution = 0.04f;
				dlg.m_ivray = 1;

			}
			else {
				dlg.m_digResolution = dig.digResolution[dig.iCurveSel-1];
				dlg.m_ivray = dig.ivray[dig.iCurveSel-1] + 1;
			}

			dlg.m_nCurve = dig.iCurveSel; // dlg.m_nCurve is actually the curve seq. number from 0, read-only
			if(dlg.DoModal() == IDOK)
			{
				dig.digResolution[dig.iCurveSel] = dlg.m_digResolution;
				dig.ivray[dig.iCurveSel] = dlg.m_ivray;
			}
			dig.isSorted = TRUE; // always sort Zelt's format.
			dig.isSortedY = FALSE;
			myCaption(_T("Always sort Zelt's format."));
		} else {
			dlgDigOption dlg;
			dlg.m_nCurve =0;
			dlg.m_label.Format(_T("%d"), 1);
			dlg.m_NotShow = FALSE;
			dlg.m_isSort = dig.isSorted;
			dlg.m_isSortY = dig.isSortedY;
			if (dlg.DoModal() == IDOK) 
			{
				dig.labelArr->SetAt(dig.iCurveSel, dlg.m_label);
				dig.noPromptLabel = dlg.m_NotShow;
				dig.isSorted = dlg.m_isSort;
				dig.isSortedY = dlg.m_isSortY;
			}
			digIsUpdatePartial = FALSE; // This is static variable. when a new digitizing starts, we have to update all numbers first. 
		}

		myCaption(_T("Hold the Shift key to temporarily shift the display area."));
		this->NotifyChanged();
		OnToolbarRefresh();

	}

	void CSeisWideDoc::OnDigitizingLoadexisting() 
	{
		// here deals with text only format
		if (draw.isDigitizing) 
		{
			AfxMessageBox(_T("You are still digitizing"));
			return;
		}




		CFileDialog dlgf( TRUE,_T(""),_T("*.txt"),
			OFN_HIDEREADONLY|OFN_EXPLORER,
			_T("Input text File (*.txt)|*.txt|"));
		dlgf.m_ofn.lpstrTitle = _T("Ascii file to load (3 columns; no convert)");
		if(dlgf.DoModal()==IDOK)
			dig.digName = dlgf.GetPathName();
		else
		{
			return;
		}
		delete dlgf;


		//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
		dlgDigOption dlg;
		dlg.m_nCurve =0;
		dlg.m_label = _T("");
		dlg.m_NotShow = FALSE;
		dlg.m_isSort = dig.isSorted;
		dlg.m_isSortY = dig.isSortedY;
		if (dlg.DoModal() == IDOK)  {
			dig.noPromptLabel = dlg.m_NotShow;
			dig.isSorted = dlg.m_isSort;
			dig.isSortedY = dlg.m_isSortY;
		}

		CDigitize pDg;
		if (pDg.myDigitizingLoadTXTUnix2(&dig, dig.isSorted, dig.isSortedY)) {
			draw.isDigitizing = TRUE;
			//	dig.totCurve++;	//start with a new curve.
			dig.iCurveSel = dig.totCurve-1;
			//	dig.nPoint[dig.iCurve] = 0;

			dig.noPromptLabel = FALSE; //when loading, prompt for showing labels. This is he only way to recover the dialog box without restarting the SeisWide program.
			draw.isNoLabelInSide = FALSE; //when loading, 
			//	if( !pCd.coord.isFaceUp==0) pCd.coord.isFaceUp=0;	//Only this mode works for digitizing, a bug to be fixed.
			dig.isZeltFormat2 = FALSE;
			draw.isSameDataDisplay = TRUE;
			OnToolbarRefresh();
			OnToolbarPick();
		}
		else {
			AfxMessageBox(_T("Sorry, failed to load the file."));
		}
		//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

	}

	//BOOL CSeisWideDoc::myDigitizingLoadzeltTx() {
	//	if (!isFileExistNotDirectory(dig.digName)) return FALSE;
	//	return myDigitizingLoadzeltTx(&dig);
	//}


	void CSeisWideDoc::OnDigitizingLoadzeltTx() 
	{
		if (draw.isDigitizing) 
		{
			AfxMessageBox(_T("You are still digitizing. You may finish digitizing and load again."));
			return;
		}

		if (!para.isDistanceDisplay) {
			//	AfxMessageBox(_T("Traveltime picks can only be done when displaying with model distance mode, as opposed to offsets. Please load again.");
			AfxMessageBox(_T("For Zelt's format, traveltime picks can only be done when displaying with model distance mode, as is hereby set so."));
			para.isDistanceDisplay = TRUE;
			this->OnToolbarRefreshAll();
			return;
		}



		BOOL firstTim=TRUE, textErr=FALSE ;


		//new file dialog.
		CFileDialog dlg( TRUE,_T(""),_T("*.in"),
			OFN_HIDEREADONLY|OFN_EXPLORER,
			_T("Input text File (*.in)|*.in|"));
		dlg.m_ofn.lpstrTitle = _T("Zelt's file of TX.IN format)");
		if(dlg.DoModal()==IDOK)
			dig.digName = dlg.GetPathName();
		else
		{
			return;
		}
		delete dlg;

		dig.isZeltFormat2 = TRUE;
		CDigitize pDg;
		if(pDg.myDigitizingLoadzeltTx(&dig, tx.xShot)) {
			draw.isDigitizing = TRUE;
			dig.isZeltFormat2 = TRUE; //Zelt's format with error bars.
			dig.iCurveSel = dig.totCurve - 1;
			CString tStr;
			tStr.Format(_T("Successfully loaded %d curves for digitizing. The last curve with %d points is highlighted and you may continue digitizing this curve."), 
				dig.totCurve, dig.nPoint[dig.iCurveSel]);
			AfxMessageBox(tStr);
			//if (draw.mode == -1) {
			//	draw.mode = 0;
			//	para.isDistanceDisplay = TRUE;
			//	pCd.coord.isFaceUp = 0;
			//}

			draw.isSameDataDisplay = TRUE;
		}
		else {
			CString tmp;
			tmp.Format(_T("Failed to load any points for the current source at %f km distance for the current section \n%s ."), tx.xShot, draw.timeSecName);
			AfxMessageBox(tmp);
		}

		OnToolbarRefresh();
	}

	void CSeisWideDoc::OnDigitizingNewcurve()
	{
		if (!draw.isDigitizing || dig.nPoint==NULL) return;

		// Now if the last curve has no points digitized, remove it 
		while(dig.totCurve>0 && dig.nPoint[dig.totCurve-1] == 0) {
			dig.totCurve--;
		}

		CString str;

		// now jump to the last curve
		dig.totCurve++;
		dig.iCurveSel = dig.totCurve-1;
		dig.nPoint[dig.iCurveSel] = 0;

		if(dig.isZeltFormat2) {	//Here Zelt's format is chosen, so need to ask for resolution.
			CdlgDigResolution dlg;
			if(dig.iCurveSel==0) {
				dlg.m_digResolution = 0.04f;
				dlg.m_ivray = 1;

			}
			else {
				dlg.m_digResolution = dig.digResolution[dig.iCurveSel-1];
				dlg.m_ivray = dig.ivray[dig.iCurveSel-1] + 1;
			}
			dlg.m_nCurve = dig.iCurveSel+1;
			if(dlg.DoModal() == IDOK)
			{
				dig.digResolution[dig.iCurveSel] = dlg.m_digResolution;
				dig.ivray[dig.iCurveSel] = dlg.m_ivray;
			}
		} else { //Here the plain format.
			if (!dig.noPromptLabel)
			{
				dlgDigOption DLG;
				DLG.m_label.Format(_T("%d"), dig.iCurveSel + 1);
				DLG.m_nCurve = dig.iCurveSel;
				DLG.m_isSort = dig.isSorted;
				DLG.m_isSortY = dig.isSortedY;
				if (DLG.DoModal() == IDOK) 
				{
					//   strncpy_s(&dig.label[dig.iCurve*8], 8, DLG.m_label, 8);
					str = DLG.m_label;
					dig.noPromptLabel = DLG.m_NotShow;
					dig.isSorted = DLG.m_isSort;
					dig.isSortedY = DLG.m_isSortY;
				}
			} else {
				str.Format(_T("%d"), dig.iCurveSel + 1);
			}

			dig.labelArr->SetAt(dig.iCurveSel, str);
		}


		draw.isSameDataDisplay = TRUE;
		OnToolbarAdd();
	}

	void CSeisWideDoc::OnDigitizingZeltsformatTogglezplot() 
	{
		// TODO: Add your command handler code here
		if (!draw.isDigitizing) return;
		if(para.isDistanceDisplay) {
			gIsZplotFormat = !gIsZplotFormat;
			if (gIsZplotFormat)
				AfxMessageBox(_T("ZPlot format support is turned on."));
			else
				AfxMessageBox(_T("ZPlot format support is turned off."));
		}
		else {
			AfxMessageBox(_T("ZPlot format support only works in time-distance domain."));
		}

	}

	void CSeisWideDoc::OnDigitizingSavedig() 
	{
		if (!draw.isDigitizing || dig.nPoint==NULL) return;
		CDigitize pDg;
		if (!dig.isZeltFormat2)
			pDg.myDigSaveAs(&dig, dig.isSorted, dig.isSortedY, tx.xShot); 
		else {
			// now save for Zelt format
			pDg.myDigSaveAsZelt(&dig, dig.isSorted, dig.isSortedY, tx.xShot); 
		}

		//CString t = (dig.isZeltFormat2) ?
		//	dig.digName
		//	:
		//	myDigSaveAsPlainTrc(&dig, dig.digName, dig.digName, dig.isSorted, dig.isSortedY); 
		if (isFileExistNotDirectory(dig.digName))
			showFileInNotePad(dig.digName);

	}


	void CSeisWideDoc::OnDigitizeFinishdigitizing() 
	{
		if (!draw.isDigitizing || dig.nPoint==NULL) return;

		CDigitize pDg;
		pDg.myDigSaveAs(&dig, dig.isSorted, dig.isSortedY, tx.xShot); 

		draw.isDigitizing = FALSE;


		velMod.floatNameOld = _T("");  // indicate the file content is changed 
		// so that velMod.floatName will reload if active.
		draw.pick = draw.add=draw.move=draw.remove = 0;

		// now finalize
		showFileInNotePad(dig.digName);

		if (dig.isZeltFormat2) {
			// if here, it was digitizing in Zelt's format, and when finished and after showing results in notepad, 
			// we do not want to show the digitized curves?????
			//	freeDigAll();
			// dig.digName = _T("");
		}
	}

	void CSeisWideDoc::OnDigitizingChangecurveres() 
	{
		//use this routine to update the resolution for the currently digitized curve.
		if (!draw.isDigitizing || dig.nPoint==NULL) return;
		CdlgDigResolution dlg;
		dlg.m_digResolution = dig.digResolution[dig.iCurveSel];
		dlg.m_ivray = dig.ivray[dig.iCurveSel];
		dlg.m_nCurve = dig.iCurveSel; // dlg.m_nCurve is actually the curve seq. number starting from 0

		CDigitize pDg;
		CString tStr;
		if(dlg.DoModal() == IDOK)
		{
			dig.digResolution[dig.iCurveSel] = dlg.m_digResolution;

			for (int i=0; i<dig.totCurve; i++) {
				if (i == dig.iCurveSel) continue;
				int j = dig.ivray[i];
				if (j == dlg.m_ivray) {
					// Another curve already is using the same ray code. In this case, we can let the curve 
				}
			}
			dig.ivray[dig.iCurveSel] = dlg.m_ivray; 



			//	pDg.myDigSaveAs(&dig, dig.digName, dig.isSorted, dig.isSortedY, tx.xShot); 
		}
		//	draw.isSameDataDisplay = FALSE;
		UpdateAllViews(NULL);
		NotifyChanged();
	}

	void CSeisWideDoc::OnDigitizingWhereani() 
	{
		if (!draw.isDigitizing || dig.nPoint==NULL) return;

		TCHAR s[80];
		_stprintf_s(s, _T("You have so far digitized %d points for curve %d for a total of %d curves"), dig.nPoint[dig.iCurveSel],dig.iCurveSel+1,dig.totCurve);
		AfxMessageBox(s);
	}

	void CSeisWideDoc::OnDigitizingSelectCurrent() 
	{
		//use this routine to select a different curve to activate.
		if (!draw.isDigitizing || dig.nPoint==NULL) return;

		CdlgDigSelectCurrent dlg;
		dlg.m_selectCurrent = dig.iCurveSel;

		// Now if the last curve has no points digitized, don't count it as total
		if (dig.nPoint[dig.totCurve-1] == 0) 
			dlg.m_total = dig.totCurve-1;
		else
			dlg.m_total = dig.totCurve;

		if(dlg.DoModal() == IDOK)
		{
			if (dlg.m_selectCurrent<0) dlg.m_selectCurrent=0;
			else if (dlg.m_selectCurrent>= dig.totCurve) {
				OnDigitizingNewcurve();
			}
			else {
				dig.iCurveSel = dlg.m_selectCurrent;
			}
		}

		draw.isNodeChanged = TRUE;
		draw.isSameDataDisplay = TRUE;
		UpdateAllViews(NULL);
		NotifyChanged();
	}

	void CSeisWideDoc::OnDigitizingShiftdigiting() 
	{
		if (! isFileExistNotDirectory(dig.digName)) return;

		float dx=0.f, dt=0.f;
		static float x1 = 0.f;
		static float x2 = 0.f;
		CdlgDigitizeShift dlg;
		dlg.m_x1 = x1;
		dlg.m_x2 = x2;
		if (dlg.DoModal() == IDOK) 
		{
			dx = dlg.m_dx;
			dt = dlg.m_dt;
			x1 = dlg.m_x1;
			x2 = dlg.m_x2;
		}
		else return;
		BOOL isShiftInRange = !isFloatEqual(x1, x2) && !( isFloatEqual(x1, x2) && isFloatEqual(x1, 0.f) );

		double bakXShot = tx.xShot;
		if (! draw.isDigitizing) {
			// if here, the digitized points may be for a different source position. We just move it to here.
			// tx.xShotInSegy =
			FILE *ifh1;
			if (_tfopen_s(&ifh1, dig.digName, _T("r") ) != 0) return;
			TCHAR line[MAXLINE];
			_fgetts(line,MAXLINE,ifh1);
			float t1,t2,t3;
			int k;
			_stscanf_s(line,_T("%f%f%f%d"),&t1, &t2, &t3, &k);
			fclose(ifh1);
			tx.xShot = t1;
		}

		int i,j;
		if(AfxMessageBox(_T("Only shift the selected curve? Select No to shift the all digitized points."), MB_YESNO |MB_ICONINFORMATION) == IDYES)
		{
			i = dig.iCurveSel;
			for (j=0; j<dig.nPoint[i]; j++)
			{
				if (!isShiftInRange || (isShiftInRange && dig.x[j][i]>=x1 && dig.x[j][i]<=x2)) {
					dig.x[j][i]+= dx;
					dig.t[j][i]+= dt;
				}
			}
		}
		else {
			for (i=0; i<dig.totCurve; i++)
			{
				for (j=0; j<dig.nPoint[i]; j++)
				{
					if (!isShiftInRange || (isShiftInRange && dig.x[j][i]>=x1 && dig.x[j][i]<=x2)) {
						dig.x[j][i]+= dx;
						dig.t[j][i]+= dt;
					}
				}
			}

			if(AfxMessageBox(_T("Do you want to shift the source position as well (by the same amount)?"), MB_YESNO |MB_ICONINFORMATION) == IDYES) {
				tx.xShot += dx;
				AfxMessageBox(_T("Since the source for TX picks is changed, you need to update the source position in the segy header as well. Use Processing | Define Source Distance to do this. Otherwise, you will not be able to load the coresponding TX picks the next time."));
			}
		}


		if (draw.mode == -1) {
			draw.modeOld = draw.mode;
			draw.mode = 0;
			para.isDistanceDisplay = TRUE;
		}

		CDigitize pDg;
		pDg.myDigSaveAs(&dig, dig.isSorted, dig.isSortedY, tx.xShot); 

		if (! draw.isDigitizing) {
			tx.xShot = (float)bakXShot;
		}

		draw.isDigitizing = TRUE;
		draw.isSameDataDisplay = TRUE;
		UpdateAllViews(NULL);
		NotifyChanged();

	}


	void CSeisWideDoc::OnDigitizingSplit() 
	{
		if (!draw.isDigitizing || dig.nPoint==NULL) return;

		double xSplit=0.;
		CdlgInputValie dlg;
		if (dlg.DoModal() == IDOK) 
		{
			xSplit = (double)dlg.m_value;
		}
		else return;

		CDigitize pDg;

		//long i,j,jj,ins;

		//i = dig.iCurveSel;  // current curve

		//// first, we make the curve points monotonically increases
		//for (j=0; j<dig.nPoint[i] - 1; j++)
		//{
		//	for (jj=j+1; jj<dig.nPoint[i]; jj++)
		//	{
		//		if (dig.x[j][i] > dig.x[jj][i]) {
		//			// now do the swap
		//			a = dig.x[j][i];
		//			b = dig.t[j][i];
		//			dig.x[j][i] = dig.x[jj][i];
		//			dig.t[j][i] = dig.t[jj][i];
		//			dig.x[jj][i] = a;
		//			dig.t[jj][i] = b;
		//		} // if
		//	} // for jj
		//} // for j


		//// now we do splitting
		//ins = dig.totCurve;  // new curve number
		//dig.nPoint[ins] = 0; // at the beginning there is only zero points for the new curve

		//for (j=0; j<dig.nPoint[i]; j++) {
		//	if (dig.x[j][i] > xSplit) {
		//		for (int k=j; k<dig.nPoint[i]; k++) {
		//			//dig.x[ dig.nPoint[ins] ][ins] = dig.x[k][i];
		//			//dig.t[ dig.nPoint[ins] ][ins] = dig.t[k][i];
		//			//dig.nPoint[ins] ++;
		//			pDg.myDigAddPoint(&dig, ins, dig.x[k][i], dig.t[k][i]);
		//		}
		//		dig.nPoint[i] = j;
		//		break;
		//	}
		//}

		//if (dig.nPoint[ins] > 0) {
		//	dig.totCurve ++;
		//	dig.iCurveSel = ins;
		//	dig.digResolution[ins] = dig.digResolution[i] + 0.001f;  // adding 0.001f to make it recognized as a diff curve
		//	dig.ivray[ins] = dig.ivray[i];
		//}

		//	pDg.myDigSaveAs(&dig, dig.isSorted, dig.isSortedY, tx.xShot); 
		if (pDg.digSplitCurve(&dig, dig.iCurveSel, xSplit)) {
			draw.isSameDataDisplay = TRUE;
			UpdateAllViews(NULL);
			NotifyChanged();
		}

	}


	void CSeisWideDoc::OnDigitizingChangeerrorbarRedefinesource() 
	{
		// only Zelt's format can define source position
		if (!draw.isDigitizing || dig.nPoint==NULL || !dig.isZeltFormat2) return;
		double xShotOld = tx.xShot;
		CDigitize pDg;

		CdlgDigitize dlg1;
		dlg1.m_digName	= dig.digName;
		//	dlg.m_digFileFormat = dig.fileFormat;
		dlg1.m_obsDist = (float)tx.xShot;
		dlg1.m_digFileFormat = 1;
		dlg1.m_mode = 1;  //disable some items.
		if (dlg1.DoModal() == IDOK)
		{
			tx.xShot = dlg1.m_obsDist;
		}
		else return;
		delete dlg1;

		if (para.isDistanceDisplay) {
			// only when displaying as distance should the x be shifted according to source
			for (int i=0; i<dig.totCurve; i++)
			{
				for (int j=0; j<dig.nPoint[i]; j++)
				{
					dig.x[j][i]+= (float)(tx.xShot-xShotOld);
				}
			}
			pDg.myDigSaveAs(&dig, dig.isSorted, dig.isSortedY, tx.xShot); 
		}
		draw.isSameDataDisplay = FALSE;
		UpdateAllViews(NULL);
		NotifyChanged();
	}

	void CSeisWideDoc::OnDigitizingChangeerrorbarAsBar() 
	{
		// TODO: Add your command handler code here
		if (!draw.isDigitizing) return;
		dig.barForm = 0;
		//	draw.isSameDataDisplay = FALSE;
		UpdateAllViews(NULL);
		NotifyChanged();

	}

	void CSeisWideDoc::OnDigitizingChangeerrorbarAscircle() 
	{ //open circles.
		if (!draw.isDigitizing) return;
		dig.barForm = 1;
		//	draw.isSameDataDisplay = FALSE;
		UpdateAllViews(NULL);
		NotifyChanged();

	}

	void CSeisWideDoc::OnDigitizingChangeerrorbarAsfillcircle() 
	{ //filled circles.
		if (!draw.isDigitizing) return;
		dig.barForm = 2;
		//	draw.isSameDataDisplay = FALSE;
		UpdateAllViews(NULL);
		NotifyChanged();

	}

	void CSeisWideDoc::OnDigitizingChangeerrorbarAsstar() 
	{
		if (!draw.isDigitizing) return;
		dig.barForm = 3;
		//	draw.isSameDataDisplay = FALSE;
		UpdateAllViews(NULL);
		NotifyChanged();

	}


	BOOL CSeisWideDoc::rayIntersect(double a, double b, int nx, double xmin, double dx, double *x4, double *z4, double *aBar, float *zCont)
	{
		//a routine to calculate intersect point of a curve defined by 
		// zCont[x], where x=xmin, xmin+dx, ...xmin+(nx-1)*dx with dx>0.
		// It intersects with a straight line defined by Z=aX+b.
		// Output the coordinates (x3, z3). aBar is also output for later usage.
		// if return FALSE. no intersecting point exists.

		//if a is infinite (i.e. 99999), then the incident ray is x=b.

		int ix;
		double x1,x2,z1,z2, bBar;

		*x4 = *z4 = 99999.;
		for (ix=0; ix<nx-1; ix++)
		{
			x1 = xmin + dx*(double)ix;
			x2 = x1 + dx;
			z1 = zCont[ix];
			z2 = zCont[ix+1];
			*aBar = (z2-z1)/(x2-x1);
			bBar = z1-*aBar*x1;
			if(fabs(a)>99998.)
			{ //incident ray is x=const=b.
				if(b<x1 || b>x2) continue;
				*x4 = b;
				*z4 = (*aBar)*(*x4) + bBar;
				break;
			}
			else if(fabs(*aBar-a)<0.00001) 
			{  //the two line segments are parallel.
				continue;
			}
			else
			{
				*x4 = -(bBar-b)/(*aBar-a);
				*z4 = a*(*x4)+b;
				if(*x4<x1 || *x4>x2) continue;
				else break;
			}
		}

		//now the intersection point is found.
		if(fabs(*x4-99999.)<0.1 && fabs(*z4-99999.)<0.1)
			return FALSE;
		else
			return TRUE;
	}

	float CSeisWideDoc::GetContourDepth(float *zContour, int nx, double x0, double xmin, double dx)
	{
		//given zContour[ix], ix=0..nx-1, x=xmin+ix*dx, return depth at x0.
		int ix;
		double x;
		for (ix=0; ix<nx-1; ix++)
		{
			x = xmin + dx*ix;
			if(x0>=x && x0<=(x+dx))
				return (float)(zContour[ix]+(zContour[ix+1]-zContour[ix])*(x0-x)/dx);
		}
		AfxMessageBox(_T("Source not inside the model"));
		return 99999.f;
	}

#define deg2rad 0.017453293 // This is PI/180.
#define rad2deg 57.29577951 // This is 180/PI.
#define ctan(a) (fabs(tan(a))>0.000001)?(1./tan(a)):99999.
	//#define BETWN(a, b, c) ((a<=b && b<=c) || (a>=b && b>=c))?TRUE:FALSE
	void CSeisWideDoc::OnDigitizingMigratelinedrawings() 
	{
		return;

		//this routine migrates line-drawings.
		if (!draw.isDigitizing) 
		{
			AfxMessageBox(_T("Only migrate during digitizing; try start a new digitizing or loading existing digitizing file first"));
			return;
		}

		if(!CheckTime(100)) return;

		//Generate velocity contours.
		int icont, ix, iv, ivRefl, nv, nx, nvLayer[MOD_LAYER_MAX], numTracing,maxTrc,nLayerMig,leftRight,iCurve,iPt,icontRefl;
		double sDepth,theta,thetaDn,thetaDnOld,thetaUp,sinTheta,amin,amax;
		double a,aBar,b,t,t1,t2,t3,tUp,x,x1,x3,x4,xUp,v,v1,v2,dv,z,z3,z4,zUp, temp,xmin,xmax,vminLayer[MOD_LAYER_MAX],vmaxLayer[MOD_LAYER_MAX];
		double oldxArriv1,oldxArriv2,oldtArriv1,oldtArriv2;
		float ***zContour, **tArrival, **angRefl,depthTune[500],depthTune1[500],depthTune2[500], aamin,aamax,xArrivErr,tArrivErr;
		FILE *stream;
		BOOL upToRight, mAppend, rayStop, rayUpStop, rayFound, reflFound;
		CString migName;

		OnDigitizeFinishdigitizing(); //save the points and finish digitizing.
		//MyInitVel();  //discard current (if any) model, initilize given model for velMod.
		if (velMod.ncont >40)
		{
			AfxMessageBox(_T("Too many layers in the velocity model"));
			return;
		}

		CdlgMigLineDraw dlg;
		dlg.m_velName = velMod.velSecName;
		dlg.m_dv = (vel.dv>0.001)? (float)vel.dv : 0.1f;
		dlg.m_nLayer = 5;
		dlg.m_sDepth = 4.f;
		dlg.m_dxv = (float)vel.dxVDesired;
		dlg.m_sDist = (float)tx.xShot;
		dlg.m_migName = velMod.velSecName + _T("Mig.txt");

		if (dlg.DoModal() == IDOK)
		{
			aamax = (float)dlg.m_aamax;  //using (float) to cut string length
			aamin = (float)dlg.m_aamin;
			dv = vel.dv = (float)dlg.m_dv;
			vel.dxVDesired = (float)dlg.m_dxv;
			maxTrc = dlg.m_maxTrc;
			nLayerMig = dlg.m_nLayer;
			sDepth = (float)dlg.m_sDepth;
			tx.xShot = (float)dlg.m_sDist;
			xArrivErr = (float)dlg.m_xErr;
			tArrivErr = (float)dlg.m_tErr;
			velMod.velSecName = dlg.m_velName.Trim();
			migName = dlg.m_migName;
			mAppend = dlg.m_append;
		}
		else return;
		delete dlg;

		CVelMod vm;

		myVelModWholeInterpol(); //calculate velocity interpolation for the whole model based on velMod.
		nx = velMod.grdNx;  //nx was calculated by myWoleVelModInterpol().
		xmin = velMod.xm[0][0];
		xmax = velMod.xm[velMod.nzed[0]-1][0];

		int ifopenReturned;
		if(mAppend)
			ifopenReturned= _tfopen_s( &stream, migName, _T("a+") ); //open for reading and appending
		else
			ifopenReturned = _tfopen_s( &stream, migName, _T("w") ); //open for reading and appending
		if( ifopenReturned != 0 )
		{
			AfxMessageBox( _T("New mig file could not open") );
			return;
		}

		nv = 0;
		for (icont=0; icont<velMod.ncont-1; icont++)
		{
			for (ix=0;ix<nx;ix++) {
				velMod.vTop[icont][ix] = vm.velModUpdAnisotropy((float)velMod.vTop[icont][ix], velMod.anisotropy[icont]);
				velMod.vBot[icont][ix] = vm.velModUpdAnisotropy((float)velMod.vBot[icont][ix], velMod.anisotropy[icont]);
			}

			//Find the min and max vel for this layer.
			vminLayer[icont]=99999.;
			for (ix=0;ix<nx;ix++) 
				if(vminLayer[icont]>velMod.vTop[icont][ix]) vminLayer[icont] = velMod.vTop[icont][ix];
			for (ix=0;ix<nx;ix++) 
				if(vminLayer[icont]>velMod.vBot[icont][ix]) vminLayer[icont] = velMod.vBot[icont][ix];
			vmaxLayer[icont]=0.;
			for (ix=0;ix<nx;ix++) 
				if(vmaxLayer[icont]<velMod.vTop[icont][ix]) vmaxLayer[icont] = velMod.vTop[icont][ix];
			for (ix=0;ix<nx;ix++) 
				if(vmaxLayer[icont]<velMod.vBot[icont][ix]) vmaxLayer[icont] = velMod.vBot[icont][ix];

			nvLayer[icont] = (int)((vmaxLayer[icont]-vminLayer[icont])/dv + 1.999);
			nv = max(nv, nvLayer[icont]);
			if (nvLayer[icont]<2) nvLayer[icont] = 2;
		}

		// Now define an array to hold all the vel contours, zContour[icont][iv][ix],
		//where icont=0..velMod.nlayer-1, iv=0..nv-1, ix=0..nx-1. nv is dynamic.
		zContour = (float ***)alloc3float(nx,nv,velMod.ncont-1); //a small array.
		if(zContour==NULL)
		{
			AfxMessageBox(_T("Unable to allocate memory for zContour array"));
			return;
		}

		//For each velocity contour, calculate for the right depth for each x.
		for (icont=0; icont<velMod.ncont-1; icont++)
		{
			//Loop through vel contours for this layer and store zContour[icont][nv][nx].
			for (iv=0; iv<nvLayer[icont]; iv++)
			{
				v = vminLayer[icont] + iv*dv;

				//Search by interpolation for the curve for v in layer icont.
				for (ix=0; ix<nx; ix++)
				{
					temp=velMod.vBot[icont][ix]-velMod.vTop[icont][ix];
					if (velMod.grdDepth[icont + 1][ix]<velMod.grdDepth[icont][ix]) a = velMod.grdDepth[icont + 1][ix];
					else if(fabs(temp)<0.001)
					{
						//const vel, odd fix.
						if (nvLayer[icont] == 2 && iv == 0) a = velMod.grdDepth[icont][ix];
						else if (nvLayer[icont] == 2 && iv == 1) a = velMod.grdDepth[icont + 1][ix];
						else if (fabs(v - velMod.vTop[icont][ix]) <= dv) a = velMod.grdDepth[icont][ix];
						else if (iv <= nvLayer[icont] - 1) a = velMod.grdDepth[icont][ix];
						else a = velMod.grdDepth[icont + 1][ix];
					}
					else
						a = velMod.grdDepth[icont][ix] + (velMod.grdDepth[icont + 1][ix] - velMod.grdDepth[icont][ix])
						*(v-velMod.vTop[icont][ix])/temp;
					if (a<velMod.grdDepth[icont][ix]) a = velMod.grdDepth[icont][ix];
					if (a>velMod.grdDepth[icont + 1][ix]) a = velMod.grdDepth[icont + 1][ix];
					if(a<0) a=0.;
					//		if(a>pCd.coord.zmax) a=pCd.coord.zmax;
					zContour[icont][iv][ix] = (float)a;
				}
			} //End of loop iv.
		}  //End of loop icont.

		tArrival = (float **)alloc2float(nv,velMod.ncont-1); //a small array.
		angRefl = (float **)alloc2float(nv,velMod.ncont-1); 

		if(tArrival==NULL||angRefl==NULL)
		{
			free3float(zContour);
			AfxMessageBox(_T("Unable to allocate memory for ray tracing"));
			return;
		}

		for (iCurve=0; iCurve<dig.totCurve; iCurve++)
		{
			for (iPt=0; iPt<dig.nPoint[iCurve]; iPt++)
			{ //search for a xArrival and tArrival to match dig.x and dig.t.
				x1 = dig.x[iPt][iCurve];
				t1 = dig.t[iPt][iCurve];
				//(x1,t1) is the observed point.
				if(x1<tx.xShot) leftRight=0;
				else leftRight=1;
				reflFound = TRUE;
				for (icontRefl=0; icontRefl<velMod.ncont-1; icontRefl++)
					for (ivRefl=0; ivRefl<nvLayer[icontRefl]; ivRefl++)
					{
						amin = aamin; //amin and amax will change down a ray to find the correct angle.
						amax = aamax; //but aamin,aamax never change.
						theta = amin; //thetaDn shall be updated while going down.
						numTracing = 1;  //num of ray tracing performed.
						rayFound = TRUE; //indicate successful raytracing.
						temp = GetContourDepth(zContour[icontRefl][ivRefl],nx,(double)tx.xShot,xmin,vel.dxVDesired);
						if(temp < sDepth) continue;
						if (ivRefl == nvLayer[icontRefl]-1)
						{
							temp = 1.; //for testing.
						}
						do
						{ //loop to find the correct theta to match  dig.x[iPt][iCurve];
							x = tx.xShot;  //ray initially at source position.
							z = sDepth; //ray initially at source depth.
							t = 0.;  // at source the time is 0.
							thetaDn = theta;  //theta doesn't change as ray going down. But thetaDn changes.
							rayStop = FALSE;

							//For each reflector contour [ivRefl][icontRefl], a ray goes thru all layers above.
							// assume const vel within that contour.
							for (icont=0; icont<=icontRefl; icont++)
								for (iv=0; iv<nvLayer[icont]; iv++)
								{
									if (rayStop) break;
									if(icont==icontRefl)
									{
										temp = 1.;
									}

									if(icont==icontRefl && iv>ivRefl) break;

									//only start adding up to x,z,t when contour is below source.
									temp = GetContourDepth(zContour[icont][iv],nx,(double)tx.xShot,xmin,vel.dxVDesired);
									if(temp < sDepth) continue;

									//get the formula for the ray curve Z=aX+b that passes thru point (x, z).
									a = ctan(thetaDn*deg2rad);
									if(a>99998.) b = x;
									else
									{
										if(leftRight == 0) a = -a;
										b = z - a*x;
									}
									// determine (x3,z3) where the ray impinges contour zContour[icont][iv][ix].
									if(!rayIntersect(a, b, nx, xmin, vel.dxVDesired, &x3, &z3, &aBar, zContour[icont][iv]))
									{ //no intersecting point exist.
										rayStop = TRUE;
										break;
									}

									//v2 is angle of ray after below into the contour
									v2 = vminLayer[icont] + (iv+0.5)*dv; //v2 is the average vel within the contour
									if(v2>vmaxLayer[icont]) v2=vmaxLayer[icont];
									if(iv==0 && icont==0) v1=v2; //source at surface.
									else if(iv==0) v1=vmaxLayer[icont-1];  //ray impinges at top of layer.
									else v1 = v2-dv;  //ray inside a layer.
									t += sqrt((x3-x)*(x3-x) + (z3-z)*(z3-z))/v1;
									x = x3; z=z3;

									sinTheta = v2/v1*sin(thetaDn*deg2rad);
									if(fabs(sinTheta)>0.99999) //rays cannot go down. Do something!!!
									{ //no intersecting point exist.
										rayStop = TRUE;
										break;
									}
									thetaDnOld = thetaDn;  //thetaOld is that before transmission.
									thetaDn = asin(sinTheta)*rad2deg; //update thetaDn after thru the contour.
								} //end of loop for iv & icont.

								//to trace back to surface for contour ivRefl. first get the reflecting angle.
								if(aBar>=0)
								{
									thetaUp = 2.*atan(aBar)*rad2deg + thetaDnOld; //no change if leftRight changes.
									upToRight = TRUE; //reflects to the right.
								}
								else
								{
									thetaUp = 2.*atan(fabs(aBar))*rad2deg - thetaDnOld; //no change if leftRight changes.
									if(thetaUp>0) upToRight = FALSE; //reflects to the left.
									else 
									{
										upToRight = TRUE; //reflects to the right.
										thetaUp = -thetaUp; //make it positive.
									}
								}
								xUp = x;
								zUp = z;
								tUp = t;
								rayUpStop = FALSE;

								// now back trace.
								//first, trace thru all contours of the same layer above the active one.
								//Need to consider reflecting rays going downwards??? or even upward refl rays 
								// hitting contours deeper than ivRefl which is totally possible ???
								for (iv=ivRefl-1; iv>=0; iv--)
								{
									if(rayStop) break;
									if(upToRight) a = -ctan(thetaUp*deg2rad); //for reflections should be minus.
									else a = ctan(thetaUp*deg2rad);
									if(a>99998.) b = xUp;
									else
									{
										if(leftRight == 0) a = -a;
										b = zUp-a*xUp;
									}
									if(!rayIntersect(a, b, nx, xmin, vel.dxVDesired, &x4, &z4, &aBar, &zContour[icontRefl][iv][0]))
									{ //no intersecting point exist.
										rayUpStop = TRUE;
										break;
									}
									v1 = vminLayer[icontRefl] + (iv+0.5)*dv; //v1 is the average vel within the contour
									if(v1>vmaxLayer[icontRefl]) v1=vmaxLayer[icontRefl];
									tUp += sqrt((xUp-x4)*(xUp-x4) + (zUp-z4)*(zUp-z4)) / v1;
									xUp = x4;
									zUp = z4;
									if(iv==0 && icontRefl==0) v2=v1; //ray reach surface.
									else if(iv==0) v2=vmaxLayer[icontRefl-1];  //ray impinges at boundary.
									else v2 = v1-dv;  //ray inside a layer
									temp = sin(thetaUp*deg2rad)*v2/v1;
									if(fabs(temp)>0.999999)
									{ //no intersecting point exist.
										rayUpStop = TRUE;
										break;
									}
									else
										thetaUp = rad2deg * asin(temp);
								}
								for (icont=icontRefl-1; icont>=0; icont--)
								{ //now loop thru all layers above.
									if (rayStop || rayUpStop) break;
									for (iv=nvLayer[icont]-1; iv>=0; iv--)
									{
										a = -ctan(thetaUp*deg2rad); //for reflections should be minus.
										if(a>99998.) b = xUp;
										else
										{
											if(leftRight == 0) a = -a;
											b = zUp-a*xUp;
										}
										if(!rayIntersect(a, b, nx, xmin, vel.dxVDesired, &x4, &z4, &aBar, zContour[icont][iv]))
										{ //no intersecting point exist.
											rayUpStop = TRUE;
											break;
										}
										v1 = vminLayer[icont] + (iv+0.5)*dv; //v1 is the average vel within the contour
										if(v1>vmaxLayer[icont]) v1=vmaxLayer[icont];
										tUp += sqrt((xUp-x4)*(xUp-x4) + (zUp-z4)*(zUp-z4)) / v1;
										xUp = x4;
										zUp = z4;
										if(iv==0 && icont==0) v2=v1; //ray reach surface.
										else if(iv==0) v2=vmaxLayer[icont-1];  //ray impinges at boundary.
										else v2 = v1-dv;  //ray inside a layer
										temp = sin(thetaUp*deg2rad)*v2/v1;
										if(fabs(temp)>0.999999)
										{ //no intersecting point exist.
											rayUpStop = TRUE;
											break;
										}
										else
											thetaUp = rad2deg * asin(temp);
										if(numTracing==3) 
										{
											//		_ftprintf_s(stream,"icontRefl,ivRefl,icont,iv,t,x,z=%9d %9d %9d %9d %9.3f %9.3f %9.3f\n",icontRefl,ivRefl,icont,iv,tUp,xUp,zUp);
										}
									} //end of iv loop.
								}  //end of icont loop. Finishing ray tracing for refl contour iv and icont.
								if(numTracing==1) 
								{
									if (rayStop || rayUpStop) 
									{
										if(leftRight == 0) xUp = -99999.;
										else xUp = 99999.;
									}
									theta = aamax;
									oldxArriv1 = xUp;
									numTracing = 2;
								}
								else if(numTracing==2)
								{
									if (rayStop || rayUpStop) 
									{
										if(leftRight == 0) xUp = -99999.;
										else xUp = 99999.;
									}
									oldxArriv2 = xUp;
									theta = (aamax + aamin)*0.5; //assume only trace to the right side.
									numTracing = 3;
								}
								else
								{	
									if(rayStop || rayUpStop)
									{ //the current theta of ray does not reach reflector ivRefl.
										//therefore the amax should be smaller.
										amax = theta;
										if(leftRight == 0) oldxArriv2 = -99999.;
										else oldxArriv2 = 99999.;
									}
									if(oldxArriv1 > oldxArriv2)
									{ //make sure oldxArriv1 is always smaller than oldxArriv2.
										temp = oldxArriv1;
										oldxArriv1 = oldxArriv2;
										oldxArriv2 = temp;
										temp = amin;
										amin = amax;
										amax = temp;
										//now amax can be smaller than amin.
									}
									if(xUp < oldxArriv1)
									{
										oldxArriv1 = xUp;
										amin = theta;
									}
									else if(xUp > oldxArriv2)
									{
										oldxArriv2 = xUp;
										amax = theta;
									}
									else if(x1>=oldxArriv1 && x1<=xUp) //x1 = dig.x[iPt][iCurve];
									{
										oldxArriv2 = xUp;
										amax = theta;
									}
									else if(x1>=xUp && x1<=oldxArriv2)
									{
										oldxArriv1 = xUp;
										amin = theta;
									}
									else
									{ //no ray exist.
										AfxMessageBox(_T("Should not be here"));
										rayFound = FALSE;
										break; //break the do...while loop.
									}
									theta = (amax + amin)*0.5; //assume only trace to the right side.
									if(numTracing>maxTrc)
									{
										rayFound = FALSE;
										break; //break the do...while loop.
									}
									numTracing++;
								} //end if for numTracing.
						} while ((fabs(x1-xUp)>(double)xArrivErr)); //end of do loop for theta.
						if (!rayFound)
							//a proper ray can not be found.
								t = x = z = tArrival[icontRefl][ivRefl]=angRefl[icontRefl][ivRefl] = 99999.f;
						else
						{
							tArrival[icontRefl][ivRefl]= (float)tUp;
							angRefl[icontRefl][ivRefl] = (float)theta;  //save this angle for later use.
							if(angRefl[icontRefl][ivRefl] < 0)
							{ //it happens, do something!
								AfxMessageBox(_T("Incidence angle minus"));
							}
						} //end if statement
						_ftprintf(stream,_T("%9d %9d t,theta,xUp,x1=%9.3f %9.3f %9.3f %9.3f\n"),icontRefl,ivRefl,tArrival[icontRefl][ivRefl],angRefl[icontRefl][ivRefl],xUp,x1);
					} //end ivRefl & icontRefl loop.

					//Find the best [ivRefl, ivRefl+1] in icontRefl to match dig.t.
					//Note that icontRefl must be closest to given value nLayerMig (counting from 1 at surface!).
					// note cases when xArrival[icont][ivRefl]==99999. should break.
					reflFound = FALSE;
					for (icontRefl=nLayerMig-1; icontRefl<velMod.ncont-1; icontRefl++)
					{
						for (ivRefl=0; ivRefl<nvLayer[icontRefl]-1; ivRefl++)
						{
							temp=GetContourDepth(zContour[icontRefl][ivRefl],nx,(double)tx.xShot,xmin,vel.dxVDesired);
							if(temp < sDepth) continue;
							t2 = tArrival[icontRefl][ivRefl];
							t3 = tArrival[icontRefl][ivRefl+1];
							//consider cases where angRefl or tArrival is 99999.
							if(fabs(t2-99999.)<0.01) break;
							if(fabs(angRefl[icontRefl][ivRefl]-99999.)<0.01) break;
							if((t1>=t2 && t1<=t3) || (t1>=t3 && t1<=t2))
							{
								reflFound = TRUE;
								break;
							}
						}
						if(reflFound) break;
					}
					if(!reflFound) continue; //this (x1,t1) cannot be migrated.

					//now fine tune in between [ivRefl, ivRefl+1] to match dig.t.
					//We know that a proper reflector exists!
					//	if(t1<tx.xShotInSegy) ...;
					for (ix=0; ix<nx; ix++)
					{
						depthTune1[ix] = zContour[icontRefl][ivRefl][ix];
						depthTune2[ix] = zContour[icontRefl][ivRefl+1][ix];
					}

					oldtArriv1 = tArrival[icontRefl][ivRefl];
					oldtArriv2 = tArrival[icontRefl][ivRefl+1];	
					do
					{ // fine tune loop for depth.
						//first get a new depth array.
						for (ix=0; ix<nx; ix++)
							depthTune[ix] = (float)(depthTune1[ix]+depthTune2[ix])*0.5f;
						amin = angRefl[icontRefl][ivRefl]; //will change during raytracing to find the correct angle.
						amax = angRefl[icontRefl][ivRefl+1]; //but aamin,aamax never change.
						theta = amin; //thetaDn shall be updated while going down.
						numTracing = 1;  //Num of raytracing performed: 1: first, 2: second; 3:others.
						rayFound = TRUE; //indicate successful raytracing.
						do
						{ //loop to find the correct theta to match  dig.x[iPt][iCurve];
							x = tx.xShot;  //ray initially at source position.
							z = sDepth; //ray initially at source depth.
							t = 0.;  // at source the time is 0.
							thetaDn = theta;  //theta doesn't change as ray going down. But thetaDn changes.
							rayStop = FALSE;

							//raytracing must start from the surface, assuming const vel within that contour.
							for (icont=0; icont<=icontRefl; icont++)
								for (iv=0; iv<nvLayer[icont]; iv++)
								{
									if (rayStop) break;

									//only start adding up to x,z,t when contour is below source.
									temp = GetContourDepth(zContour[icont][iv], nx,(double)tx.xShot, xmin,vel.dxVDesired);
									if(temp <sDepth) continue;

									//get the formula for the ray curve Z=aX+b that passes thru point (x, z).
									a = ctan(thetaDn*deg2rad);
									if(a>99998.) b = x;
									else
									{
										if(leftRight == 0) a = -a;
										b = z - a*x;
									}

									// determine (x3,z3) where the ray impinges contour zContour[icont][iv][ix].
									if(icont==icontRefl && iv>ivRefl) break;
									else if(icont==icontRefl)
									{
										if(!rayIntersect(a, b, nx, xmin, vel.dxVDesired, &x3, &z3, &aBar, depthTune))
										{ //no intersecting point exist.
											rayStop = TRUE;
											break;
										}
									}
									else
									{
										if(!rayIntersect(a, b, nx, xmin, vel.dxVDesired, &x3, &z3, &aBar, zContour[icont][iv]))
										{ //no intersecting point exist.
											rayStop = TRUE;
											break;
										}
									}

									//angle of ray after below into the contour
									v2 = vminLayer[icont] + (iv+0.5)*dv; //v2 is the average vel within the contour
									if(v2>vmaxLayer[icont]) v2=vmaxLayer[icont];
									if(iv==0 && icont==0) v1=v2; //source at surface.
									else if(iv==0) v1=vmaxLayer[icont-1];  //ray impinges at top of layer.
									else v1 = v2-dv;  //ray inside a layer.
									t += sqrt((x3-x)*(x3-x) + (z3-z)*(z3-z)/v1);
									x = x3; z=z3;

									sinTheta = v2/v1*sin(thetaDn*deg2rad);
									if(sinTheta>0.99999) //rays cannot go down. Do something!!!
									{ //no intersecting point exist.
										rayStop = TRUE;
										break;
									}
									thetaDnOld = thetaDn;  //thetaOld is that before transmission.
									thetaDn = asin(sinTheta)*rad2deg; //update thetaDn after thru the contour.
								} //end of loop for iv & icont.

								//to trace back to surface for contour iv. first get the reflecting angle.
								if(aBar>=0)
								{
									thetaUp = 2.*atan(aBar)*rad2deg + thetaDnOld; //no change if leftRight changes.
									upToRight = TRUE; //reflects to the right.
								}
								else
								{
									thetaUp = 2.*atan(fabs(aBar))*rad2deg - thetaDnOld; //no change if leftRight changes.
									if(thetaUp>0) upToRight = FALSE; //reflects to the left.
									else 
									{
										upToRight = TRUE; //reflects to the right.
										thetaUp = -thetaUp; //make it positive.
									}
								}
								xUp = x;
								zUp = z;
								tUp = t;
								rayUpStop = FALSE;

								// now back trace.
								//first, trace thru all contours of the same layer above the active one.
								for (iv=ivRefl; iv>=0; iv--)
								{
									if(rayStop) break;
									if(upToRight) a = -ctan(thetaUp*deg2rad); //for reflections should be minus.
									else a = ctan(thetaUp*deg2rad);
									if(a>99998.) b = xUp;
									else 
									{
										if(leftRight == 0) a = -a;
										b = zUp-a*xUp;
									}
									if(!rayIntersect(a, b, nx, xmin, vel.dxVDesired, &x4, &x4, &aBar, zContour[icontRefl][iv]))
									{ //no intersecting point exist.
										rayUpStop = TRUE;
										break;
									}
									v1 = vminLayer[icontRefl] + (iv+0.5)*dv; //v1 is the average vel within the contour
									if(v1>vmaxLayer[icontRefl]) v1=vmaxLayer[icontRefl];
									tUp += sqrt((xUp-x4)*(xUp-x4) + (zUp-z4)*(zUp-z4)) / v1;
									xUp = x4;
									zUp = z4;
									if(iv==0 && icontRefl==0) v2=v1; //ray reach surface.
									else if(iv==0) v2=vmaxLayer[icontRefl-1];  //ray impinges at boundary.
									else v2 = v1-dv;  //ray inside a layer
									temp = sin(thetaUp*deg2rad)*v2/v1;
									if(fabs(temp)>0.999999)
									{ //no intersecting point exist.
										rayUpStop = TRUE;
										break;
									}
									else
										thetaUp = rad2deg * asin(temp);
								}
								for (icont=icontRefl-1; icont>=0; icont--)
								{ //now loop thru all layers above.
									if (rayStop || rayUpStop) break;
									for (iv=nvLayer[icont]-1; iv>=0; iv--)
									{
										a = -ctan(thetaUp*deg2rad); //for reflections should be minus.
										if(a>99998.) b = xUp;
										else 
										{
											if(leftRight == 0) a = -a;
											b = zUp-a*xUp;
										}
										if(!rayIntersect(a, b, nx, xmin, vel.dxVDesired, &x4, &z4, &aBar, zContour[icont][iv]))
										{ //no intersecting point exist.
											rayUpStop = TRUE;
											break;
										}
										if(iv==nvLayer[icont]-1) v1=vmaxLayer[icont+1]; //icont1 is not the last layer.
										else v1 = vminLayer[icont] + (iv+0.5)*dv; //v1 is the average vel within the contour
										if(v1>vmaxLayer[icont]) v1=vmaxLayer[icont];
										tUp += sqrt((xUp-x4)*(xUp-x4) + (zUp-z4)*(zUp-z4)) / v1;
										xUp = x4;
										zUp = z4;
										if(iv==0 && icont==0) v2=v1; //ray reach surface.
										else if(iv==0) v2=vmaxLayer[icont-1];  //ray impinges at boundary.
										else v2 = v1-dv;  //ray inside a layer
										temp = sin(thetaUp*deg2rad)*v2/v1;
										if(fabs(temp)>0.999999)
										{ //no intersecting point exist.
											rayUpStop = TRUE;
											break;
										}
										else
											thetaUp = rad2deg * asin(temp);
									} //end of iv loop.
								}  //end of icont loop. Finishing ray tracing for refl contour iv and icont.
								if(rayStop || rayUpStop)
								{ //the current theta of ray does not reach reflector ivRefl.
									//therefore the amax should be smaller.
									amax = theta;
									if(leftRight == 0) oldxArriv2 = -99999.;
									else oldxArriv2 = 99999.;
								}
								if(oldxArriv1 > oldxArriv2)
								{ //make sure oldxArriv1 is always smaller than oldxArriv2.
									temp = oldxArriv1;
									oldxArriv1 = oldxArriv2;
									oldxArriv2 = temp;
									temp = amin;
									amin = amax;
									amax = temp;
									//now amax can be smaller than amin.
								}
								if(xUp < oldxArriv1)
								{
									oldxArriv1 = xUp;
									amin = theta;
								}
								else if(xUp > oldxArriv2)
								{
									oldxArriv2 = xUp;
									amax = theta;
								}
								else if(x1>=oldxArriv1 && x1<=xUp)
								{
									oldxArriv2 = xUp;
									amax = theta;
								}
								else if(x1>=xUp && x1<=oldxArriv2)
								{
									oldxArriv1 = xUp;
									amin = theta;
								}
								else
								{ //no ray exist.
									AfxMessageBox(_T("Should not be here"));
									rayFound = FALSE;
									break;
								}
								theta = (amax + amin)*0.5; 
								if(numTracing>maxTrc)
								{
									rayFound = FALSE;
									break;
								}
								numTracing++;
						} while (fabs(x1-xUp)>(double)xArrivErr); //end of fine-tune do loop for theta.
						if (!rayFound)
						{
							//ray can not trace further.
							AfxMessageBox(_T("Programing error: no ray found in fine tuning!"));
							reflFound = FALSE;
							break; //break the do loop.
						}
						else
						{
							if(t1>=oldtArriv1 && t1<=tUp)
							{
								oldtArriv2 = tUp;
								for (ix=0; ix<nx; ix++)
									depthTune2[ix] = depthTune[ix];
							}
							else if(t1>=tUp && t1<=oldtArriv2)
							{
								oldtArriv1 = tUp;
								for (ix=0; ix<nx; ix++)
									depthTune1[ix] = depthTune[ix];
							}
							else
							{ //no ray exist.
								AfxMessageBox(_T("Programing error: no ray found in fine tuning!"));
								reflFound = FALSE;
								break; //break the do loop.
							}
						}
					} while (fabs(t1-tUp)>(double)tArrivErr); //end do loop for depth fine-tuning.

					//The migrated result for dig.x and dig.t is (x, z).
					if(reflFound) _ftprintf(stream,_T(" %9.3f %9.3f %9d  Migrated x-z from X-T %9.3f %9.3f\n"),x,z,iCurve,x1,t1);
			}  //end of iPt loop.
		} //end of iCurve loop.

		free3float(zContour);
		free2float(tArrival);
		free2float(angRefl);

		fclose( stream );
		showFileInNotePad(migName);
	}

	int CSeisWideDoc::myClipPoints(int n, float x[], float z[], float x1[], float z1[])
	{
		// given x[] and z[], clip any points outside the current window area, and
		// output as x1[] and z1[]. Total number of points in the output is returned.
		// Note: the current window is defined in depth domain as: 
		// pCd.coord.xmin, pCd.coord.xmax, and pCd.coord.zmin and pCd.coord.zmax
		// NOT used any more?

		int i;
		float xx,zz;
		int n1=0;
		for (i=0; i<n-1; i++)
		{
			if(isVisibleOrNot((double)x[i], (double)z[i]))
			{
				x1[n1] = x[i];
				z1[n1] = z[i];
				n1++;
				continue;
			}
			if(x[i+1]<pCd.coord.xmin) {
				//	x1[n1] = (float)pCd.coord.xmin;
				//	z1[n1] = (float)(z[i-1]+(z[i]-z[i-1])*(pCd.coord.xmax-x[i-1])/(x[i]-x[i-1]));
				//	n1++;
				continue;
			}
			if(x[i]>pCd.coord.xmax)
			{ 
				if(i==0) continue;
				if(x[i-1]>=pCd.coord.xmax) continue;
				zz = (float)(z[i-1]+(z[i]-z[i-1])*(pCd.coord.xmax-x[i-1])/(x[i]-x[i-1]));
				x1[n1] = (float)pCd.coord.xmax;
				z1[n1] = zz;
				n1++;
			}
			if(x[i]<pCd.coord.xmin)
			{
				//Here x[i+1]>pCd.coord.xmin.
				zz = (float)(z[i]+(z[i+1]-z[i])*(pCd.coord.xmin-x[i])/(x[i+1]-x[i]));
				if(zz>=pCd.coord.zmin && zz<=pCd.coord.zmax)
				{x1[n1] = (float)pCd.coord.xmin; z1[n1] = zz;n1++;}
				else if(zz<pCd.coord.zmin)
				{
					xx = (float)(x[i]+(x[i+1]-x[i])*(pCd.coord.zmin-z[i])/(z[i+1]-z[i]));
					if(xx>pCd.coord.xmin){x1[n1]=(float)xx;z1[n1]=(float)pCd.coord.zmin;n1++;}
				}
				else
				{
					xx = (float)(x[i]+(x[i+1]-x[i])*(pCd.coord.zmax-z[i])/(z[i+1]-z[i]));
					if(xx>pCd.coord.xmin){x1[n1]=(float)xx;z1[n1]=(float)pCd.coord.zmax;n1++;}
				}
				continue;
			}
			if(x[i+1]>pCd.coord.xmax)
			{ //Here xmin<=x[i]<=xmax.
				zz = (float)(z[i]+(z[i+1]-z[i])*(pCd.coord.xmax-x[i])/(x[i+1]-x[i]));
				if(zz<pCd.coord.zmin || zz>pCd.coord.zmax) continue;
				x1[n1]=(float)pCd.coord.xmax; z1[n1]=(float)zz; n1++; continue;
			}
			else //Now x[i+1]<=xmax and [i] outside bound.
			{
				if(z[i]<pCd.coord.zmin)
				{
					xx = (float)(x[i]+(x[i+1]-x[i])*(pCd.coord.zmin-z[i])/(z[i+1]-z[i]));
					x1[n1]=(float)xx; 	z1[n1]=(float)pCd.coord.zmin; n1++; continue;
				}
				else
				{
					xx = (float)(x[i]+(x[i+1]-x[i])*(pCd.coord.zmax-z[i])/(z[i+1]-z[i]));
					x1[n1]=(float)xx; z1[n1]=(float)pCd.coord.zmax; n1++; continue;
				}
			}
		}

		//Now deals with the last point.
		if(isVisibleOrNot((double)x[n-1], (double)z[n-1]))
		{
			x1[n1] = x[n-1];
			z1[n1] = z[n-1];
			n1++;
		}
		else
		{
			zz = (float)(z[n-2]+(z[n-1]-z[n-2])*(pCd.coord.xmin-x[n-2])/(x[n-1]-x[n-2]));
			if(x[n-2]<pCd.coord.xmin)
			{
				if(zz>=pCd.coord.zmin && zz<=pCd.coord.zmax)
				{
					x1[n1] = (float)pCd.coord.xmin;
					z1[n1] = (float)zz;
					n1++;
				}
				else if(zz<pCd.coord.zmin)
				{
					xx = (float)(x[n-2]+(x[n-1]-x[n-2])*(pCd.coord.zmin-z[n-2])/(z[n-1]-z[n-2]));
					if(xx>=pCd.coord.xmin && xx<=pCd.coord.xmax)
					{x1[n1]=(float)xx; z1[n1]=(float)pCd.coord.zmin; n1++;}
				}
				else
				{
					xx = (float)(x[n-2]+(x[n-1]-x[n-2])*(pCd.coord.zmax-z[n-2])/(z[n-1]-z[n-2]));
					if(xx>=pCd.coord.xmin && xx<=pCd.coord.xmax)
					{x1[n1]=(float)xx; z1[n1]=(float)pCd.coord.zmax; n1++;}
				}
			}
			zz = (float)(z[n-2]+(z[n-1]-z[n-2])*(pCd.coord.xmax-x[n-2])/(x[n-1]-x[n-2]));
			if(x[n-1]>pCd.coord.xmax)
			{
				if(zz>=pCd.coord.zmin && zz<=pCd.coord.zmax)
				{
					x1[n1]=(float)pCd.coord.xmax; z1[n1]=zz; n1++;
				}
				else if(zz<pCd.coord.zmin)
				{
					xx = (float)(x[n-2]+(x[n-1]-x[n-2])*(pCd.coord.zmin-z[n-2])/(z[n-1]-z[n-2]));
					if(xx>=pCd.coord.xmin && xx<=pCd.coord.xmax)
					{x1[n1]=(float)xx; z1[n1]=(float)pCd.coord.zmin; n1++;}
				}
				else
				{
					xx = (float)(x[n-2]+(x[n-1]-x[n-2])*(pCd.coord.zmax-z[n-2])/(z[n-1]-z[n-2]));
					if(xx>=pCd.coord.xmin && xx<=pCd.coord.xmax)
					{x1[n1]=(float)xx; z1[n1]=(float)pCd.coord.zmax; n1++;}
				}
			}
		}
		return n1;
	}

	//void CSeisWideDoc::airvar(CDC* pDC, int n, double x[], double y[], double range)
	//{
	//	if (n <2) return;
	//	long numfa,i,j0,j1;
	//	double a, b, res=(double)pDC->GetDeviceCaps(HORZRES) / (double)pDC->GetWindowExt().cx;
	//	double Npixel = 0.;
	//	CPen* oldPen;
	//	CBrush* oldBrush;
	//
	//	CPoint *pintAll,*pint,prange;
	//
	//	bool isTime = isTimeDomain() == TRUE;
	//
	//	pintAll = (CPoint *)malloc(n*sizeof(CPoint));
	//	pint = (CPoint *)malloc(2*n*sizeof(CPoint));  //pint will use more than n points.
	//   if( pintAll == NULL || pint == NULL)
	//   {
	//	   AfxMessageBox( _T("Insufficient memory available") );
	//	   return;
	//   }
	//
	//	prange = pCd.mm_coord(range,0., isTime);
	//	for (i=0; i<n; i++)
	//	{
	//		if ( ! _isnan(x[i]))  
	//			pintAll[i] = pCd.mm_coordy(x[i],y[i], isTime);
	//	}
	//
	//	numfa=0; 
	//	j0 = (int)myRound((pintAll[0].x-prange.x)*res);
	//	if(j0 > 0)
	//	{
	//		pint[0] = pCd.mm_coordy(range,y[0], isTime);
	//		pint[1] = pintAll[0];
	//		numfa+=2;
	//	}
	//
	//	for (i=1; i<n; i++) 
	//	{
	//		j0 = (int)myRound((pintAll[i-1].x-prange.x)*res);
	//		j1 = (int)myRound((pintAll[i].x-prange.x)*res);
	//		if(j1==0 && j0==0) continue;
	//		else if(j1<0 && j0<0 ) continue; //do not fill anything.
	//		else if (j1==0 && j0<0)
	//		{ //this case is special for fill once: small fills do not need to consider this.
	//			pint[numfa].y = pintAll[i].y;
	//			pint[numfa].x = prange.x;
	//			numfa++;
	//		}
	//		else if( j1>0 && j0>0)
	//		{
	//			pint[numfa] = pintAll[i];
	//			numfa++;
	//		}
	//		else if( j1>0 && j0<=0)
	//		{
	//			a = x[i]-x[i-1];
	//			if(fabs(a) < 0.0000001) b = y[i-1];
	//			else
	//				b = y[i-1] + (y[i]-y[i-1])*(range-x[i-1])/a;
	//			if(b<y[i-1]) b = y[i-1];
	//			pint[numfa] = pCd.mm_coordy(range,b, isTime);
	//			pint[numfa+1] = pintAll[i];
	//			numfa+=2;
	//		}
	//		else if( j1==0 && j0>0 )
	//		{
	//			pint[numfa] = pintAll[i];
	//			pint[numfa+1].x = prange.x;
	//			pint[numfa+1].y = pintAll[i].y;
	//			numfa+=2;
	//		}
	//		else if( j1<0 && j0>0)
	//		{
	//			a = x[i]-x[i-1];
	//			if(fabs(a) < 0.0000001) b = y[i-1];
	//			else
	//				b = y[i-1] + (y[i]-y[i-1])*(range-x[i-1])/a;
	//			if(b>y[i]) b=y[i];
	//			pint[numfa] = pCd.mm_coordy(range,b, isTime);
	//	//		pint[numfa+1].x = prange.x;
	//	//		pint[numfa+1].y = pint[numfa].y;
	//			numfa++;
	//		}
	//	} // for i
	//
	//	pint[numfa] = pCd.mm_coordy(range,y[n-1], isTime);
	//	numfa++;
	//	if(numfa>2)
	//	{
	//		CPen nullPen(PS_NULL, 0, RGB(255,255,255));
	//		CBrush brush;
	//		brush.CreateSolidBrush(RGB(0,0,0));
	//		int oldFill= pDC->SetPolyFillMode(WINDING);
	//		oldPen = pDC->SelectObject(&nullPen);
	//		oldBrush = pDC->SelectObject(&brush);
	//
	//		pDC->Polygon(pint, numfa);
	//
	//		pDC->SelectObject(oldPen);
	//		pDC->SelectObject(oldBrush);
	//		pDC->SetPolyFillMode(oldFill);
	//		nullPen.DeleteObject();
	//		brush.DeleteObject(); 
	//		
	//	}
	//	free (pintAll);
	//	free (pint);
	//
	//}
	void CSeisWideDoc::airCol1Small(CDC* pDC, int n, double x[], double y[], double range, double offFill2)
	{
		//note that offFill has to be passed into this routine, but not have to for airvar().
		//offFill is scaled by para.gainReal such that if offFill=1, only amplitudes spanning 
		//more than a trace interval get filled. Normally offfill=0.1.

		// note:  ampliutude  head.maxAmp  should be drawn using  
		//        RGB(seisBiColor.maxAmpR,seisBiColor.maxAmpG,seisBiColor.maxAmpB)
		// while the rest should be interpolated
		int numfa,i,j0,j1,pixelOffFill;
		double a, b, range1,res=(double)pDC->GetDeviceCaps(HORZRES) / (double)pDC->GetWindowExt().cx;

		CPen* oldPen;
		CBrush* oldBrush;
		bool isTime = isTimeDomain() == TRUE;

		CPoint *pintAll,*pint,prange,prange1;
		pintAll = (CPoint *)malloc(n*sizeof(CPoint));
		pint = (CPoint *)malloc(2*n*sizeof(CPoint));  //pint will use more than n points.
		if( pintAll == NULL || pint == NULL)
		{
			AfxMessageBox( _T("Insufficient memory available") );
			return;
		}

		int oldFill= pDC->SetPolyFillMode(ALTERNATE);
		for (i=0; i<n; i++)
			if ( ! _isnan(x[i]))  
				pintAll[i] = pCd.mm_coord(x[i],y[i], isTime);

		CPen varPen;

		//START FILL the left half.
		prange = pCd.mm_coord(range,0., isTime);
		range1 = range-offFill2; //real trace line.
		prange1 = pCd.mm_coord(range1,0., isTime);
		pixelOffFill = (int)myRound((prange.x-prange1.x) * res); //no. of pixels to offset from range line.
		numfa=0;

		j0 = (int)myRound((pintAll[0].x-prange.x)*res);
		if(j0 < -pixelOffFill)
		{
			pint[0] = pCd.mm_coord(range1,y[0], isTime);
			pint[1] = pintAll[0];
			numfa+=2;
		}

		CBrush brushRed;
		brushRed.CreateSolidBrush(getAmpRgbSimple(seisBiColor2.negAmpR, seisBiColor2.negAmpG, seisBiColor2.negAmpB));

		varPen.CreatePen(PS_NULL, 0, getAmpRgbSimple(seisBiColor2.negAmpR, seisBiColor2.negAmpG, seisBiColor2.negAmpB));
		oldPen = pDC->SelectObject(&varPen);

		CPoint pZero = pCd.mm_coord(range,0, isTime);
		double trcInterval = (para.isDistanceDisplay)  ?  head.distInterval  :  head.offsetInterval;
		CPoint pFull = pCd.mm_coord(range-head.maxAmp/head.aveAmp*trcInterval*para.gain,0, isTime);
		for (i=1; i<n; i++) 
		{
			j0 = (int)myRound((pintAll[i-1].x-prange.x)*res);
			j1 = (int)myRound((pintAll[i].x-prange.x)*res);
			if( j1<-pixelOffFill && j0<-pixelOffFill)
			{
				pint[numfa] = pintAll[i];
				numfa++;
			}
			else if( j1<-pixelOffFill && j0>=-pixelOffFill)
			{
				a = x[i]-x[i-1];
				if(fabs(a) < 0.0000001) b = y[i-1];
				else
					b = y[i-1] + (y[i]-y[i-1])*(range1-x[i-1])/a;
				if(b<y[i-1]) b = y[i-1];
				pint[numfa] = pCd.mm_coord(range1,b, isTime);
				pint[numfa+1] = pintAll[i];
				numfa+=2;
			}
			else if( j1==-pixelOffFill && j0<-pixelOffFill )
			{
				pint[numfa] = pintAll[i];
				pint[numfa+1].x = prange1.x;
				pint[numfa+1].y = pintAll[i].y;
				numfa+=2;
				if(numfa>2 && numfa<100)
				{
					oldBrush = pDC->SelectObject(&brushRed);
					pDC->Polygon(pint, numfa);
					pDC->SelectObject(oldBrush);
				}
				numfa=0;
			}
			else if( j1>-pixelOffFill && j0<-pixelOffFill)
			{
				a = x[i]-x[i-1];
				if(fabs(a) < 0.0000001) b = y[i-1];
				else
					b = y[i-1] + (y[i]-y[i-1])*(range1-x[i-1])/a;
				if(b>y[i]) b=y[i];
				pint[numfa] = pCd.mm_coord(range1,b, isTime);
				numfa++;

				if(numfa>2 && numfa<100)
				{
					oldBrush = pDC->SelectObject(&brushRed);
					pDC->Polygon(pint, numfa);
					pDC->SelectObject(oldBrush);
				}
				numfa=0;
			}
			else numfa=0;
		}

		pint[numfa] = pCd.mm_coord(range1,y[n-1], isTime);
		numfa++;
		if(numfa>2 && numfa<100) {
			oldBrush = pDC->SelectObject(&brushRed);
			pDC->Polygon(pint, numfa);
			pDC->SelectObject(oldBrush);
		}
		brushRed.DeleteObject();
		pDC->SelectObject(oldPen);
		varPen.DeleteObject(); // must delete before createPen again

		//START FILL the right half.
		CBrush brush;
		brush.CreateSolidBrush(getAmpRgbSimple(seisBiColor2.maxAmpR,seisBiColor2.maxAmpG,seisBiColor2.maxAmpB));

		varPen.CreatePen(PS_NULL, 0, getAmpRgbSimple(seisBiColor2.maxAmpR,seisBiColor2.maxAmpG,seisBiColor2.maxAmpB));
		oldPen = pDC->SelectObject(&varPen);

		prange = pCd.mm_coord(range,0., isTime);
		range1 = range+offFill2; //real trace line.
		prange1 = pCd.mm_coord(range1,0., isTime);
		pixelOffFill = (int)myRound((prange1.x-prange.x) * res); //no. of pixels to offset from range line.
		numfa=0; 

		j0 = (int)myRound((pintAll[0].x-prange.x)*res);
		if(j0 > pixelOffFill)
		{
			pint[0] = pCd.mm_coord(range1,y[0], isTime);
			pint[1] = pintAll[0];
			numfa+=2;
		}

		pFull = pCd.mm_coord(range+head.maxAmp/head.aveAmp*trcInterval*para.gain,0, isTime);
		for (i=1; i<n; i++) 
		{
			j0 = (int)myRound((pintAll[i-1].x-prange.x)*res);
			j1 = (int)myRound((pintAll[i].x-prange.x)*res);
			if( j1>pixelOffFill && j0>pixelOffFill)
			{
				pint[numfa] = pintAll[i];
				numfa++;
			}
			else if( j1>pixelOffFill && j0<=pixelOffFill)
			{
				a = x[i]-x[i-1];
				if(fabs(a) < 0.0000001) b = y[i-1];
				else
					b = y[i-1] + (y[i]-y[i-1])*(range1-x[i-1])/a;
				if(b<y[i-1]) 
				{
					b = y[i-1];
				}
				pint[numfa] = pCd.mm_coord(range1,b, isTime);
				pint[numfa+1] = pintAll[i];
				numfa+=2;
			}
			else if( j1==pixelOffFill && j0>pixelOffFill )
			{
				pint[numfa] = pintAll[i];
				pint[numfa+1].x = prange1.x;
				pint[numfa+1].y = pintAll[i].y;    
				numfa+=2;
				if(numfa>2 && numfa<100)
				{
					oldBrush = pDC->SelectObject(&brush);
					pDC->Polygon(pint, numfa);
					pDC->SelectObject(oldBrush);
				}
				numfa=0;
			}
			else if( j1<pixelOffFill && j0>pixelOffFill)
			{
				a = x[i]-x[i-1];
				if(fabs(a) < 0.0000001) b = y[i-1];
				else
					b = y[i-1] + (y[i]-y[i-1])*(range1-x[i-1])/a;
				if(b>y[i])
				{
					b=y[i];
				}
				pint[numfa] = pCd.mm_coord(range1,b, isTime);
				numfa++;

				if(numfa>2 && numfa<100)
				{
					oldBrush = pDC->SelectObject(&brush);
					pDC->Polygon(pint, numfa);
					pDC->SelectObject(oldBrush);
				}
				numfa=0;
			}
			else numfa=0;
		}

		pint[numfa] = pCd.mm_coord(range1,y[n-1], isTime);
		numfa++;
		if(numfa>2 && numfa<100) {
			oldBrush = pDC->SelectObject(&brush);
			pDC->Polygon(pint, numfa);
			pDC->SelectObject(oldBrush);
		}
		pDC->SetPolyFillMode(oldFill);
		brush.DeleteObject();

		pDC->SelectObject(oldPen);
		varPen.DeleteObject(); // must delete before createPen again

		free (pintAll);
		free (pint);
	}


	void CSeisWideDoc::airColorSmallArr(CDC* pDC, int nx, int nt, float **xArr, float *rangeArr, 
		double ft, double dt, COLORREF colPos, COLORREF colNeg, double offFill)
	{
		// NOTE:  offFill   is not used. Please fix!!!!
		if (nt <2) return;
		int numfa,ix,it;
		int j0, j1;
		double a, b, res=(double)pDC->GetDeviceCaps(HORZRES) / (double)pDC->GetWindowExt().cx;
		int da; 
		bool isTime = isTimeDomain() == TRUE;

		CPoint **pintAll = (CPoint **)alloc2CPoint(nt, nx);
		CPoint *pint = (CPoint *)malloc(2*nt*sizeof(CPoint));  //pint will use more than nt points.
		int *pRangeArr = (int *)ealloc1int(nx); 
		bool *isUseArr = (bool *)ealloc1int(nx); 
		float *yArray = (float *)ealloc1float(nt);
		CString tStr;
		if( pintAll == NULL || pint == NULL)
		{
			tStr.Format( _T("Insufficient memory available") );
			myCaption(tStr);
			return;
		}
		for (it=0; it<nt; it++)
			yArray[it] = (float)(ft + it*dt);

		for (ix=0; ix<nx; ix++) {
			pRangeArr[ix] = pCd.mm_coordx((double)rangeArr[ix]);
		}

		if (isTime) {
			for (ix=0; ix<nx; ix++) {
				for (it=0; it<nt; it++)
					pintAll[ix][it] = pCd.mm_coordt(xArr[ix][it], yArray[it]);
			}
		}
		else {
			for (ix=0; ix<nx; ix++) {
				for (it=0; it<nt; it++)
					pintAll[ix][it] = pCd.mm_coordz(xArr[ix][it], yArray[it]);
			}
		}

		draw.tracePlottedInDisplay = 0;
		draw.traceSkippedInDisplay = 0;
		register CPoint pPrev, pCurr;
		pPrev.y = pCurr.y = 0;
		pPrev.x = pRangeArr[0];
		pDC->LPtoDP(&pPrev);
		for (ix=0; ix<nx; ix++) {
			pCurr = pRangeArr[ix];
			pDC->LPtoDP(&pCurr);
			if (ix>0 && abs(pPrev.x - pCurr.x) < 1) {
				draw.traceSkippedInDisplay++;
				isUseArr[ix] = false;
			}
			else {
				pPrev = pCurr;
				isUseArr[ix] = true;
				draw.tracePlottedInDisplay++;
			}
		}

		// now we want to clip so that no shadings are overlapped.
		int k0,  k, k2, m0, m2;
		int ix1, ix2;
		for (ix=0; ix<nx; ix++) {
			if (ix==0) {
				ix1 = 0;
				ix2 = 1;
				m0 = pRangeArr[0];
				m2 = (pRangeArr[0]+pRangeArr[1])/2;
			}
			else if (ix==nx-1) {
				ix1 = nx-2;
				ix2 = nx-1;
				m0 = (pRangeArr[nx-1]+pRangeArr[nx-2])/2;
				m2 = pRangeArr[nx-1];
			}
			else {
				ix1 = ix-1;
				while (!isUseArr[ix1]) {
					ix1--; 
					if (ix1<=0) break;
				}
				if (ix1<0) ix1=0;

				ix2 = ix+1;
				while (!isUseArr[ix2]) {
					ix2++; 
					if (ix2>=nx-1) break;
				}
				if (ix2>nx-1) ix2=nx-1;

				m0 = (pRangeArr[ix]+pRangeArr[ix1])/2;
				m2 = (pRangeArr[ix]+pRangeArr[ix2])/2;
			}



			for (it=0; it<nt; it++) {
				k = pintAll[ix][it].x;
				k0 = pintAll[ix1][it].x;
				k2 = pintAll[ix2][it].x;

				// check left side only
				if (ix>0) {
					if (k<k0 &&  k0< m0) {
						pintAll[ix][it].x = k0;

						// now the related problem: if the trace on the right side also has great negative amp
						if (ix<nx-1 && k2<k0)
							pintAll[ix2][it].x = k0;
						continue;
					}
				} // if ix

				// now check right side only
				if (ix<nx-1) {
					if (ix<nx-1 && k>k2 && k2 > m2) {
						pintAll[ix][it].x =  k2;

						// now the related problem: if the trace on the left side also has great positive amp
						if (ix>0 && k0>k2)
							pintAll[ix1][it].x = k2;
						continue;
					}
				} // if ix
			} // for it
		} // for ix

		//	double locInKm4MaxAmp = head.aveAmp *2.0*draw.trcIntOavgAmp*para.gain / para.colorFillIllumination;
		//double aMaxAmp = head.maxAmp/head.aveAmp *draw.trcInt*para.gain;
		//double aAvgAmp = draw.trcInt*para.gain;

		CPen* oldPen;
		CBrush* oldBrush;

		CBrush brushNeg;
		brushNeg.CreateSolidBrush(colNeg);

		CPen penNeg;
		penNeg.CreatePen(PS_NULL, 0, colNeg);

		CBrush brushPos;
		brushPos.CreateSolidBrush(colPos);

		CPen penPos;
		penPos.CreatePen(PS_NULL, 0, colPos);

		int pOffFill = (int)myRound(pCd.coord.mm_xscale*offFill);
		int oldFill= pDC->SetPolyFillMode(ALTERNATE);
		for (ix=0; ix<nx; ix++) {
			if ( ix>0 && (int)(ix/10)*10 == ix) {
				tStr.Format(_T("R%d of %d traces."), ix, nx);
				myCaption(tStr);
			}
			if (!isUseArr[ix]) continue;

			//START FILL the left half.
			//prange = pCd.mm_coord(rangeArr[ix],0.);
			//int cFull = pCd.mm_coord((float)(rangeArr[ix]-locInKm4MaxAmp)); 

			if (GetRValue(colNeg)!=255 ||GetGValue(colNeg)!=255 ||GetBValue(colNeg)!=255) {
				pRangeArr[ix] -= pOffFill;
				numfa=0;
				if (pintAll[ix][0].x < pRangeArr[ix]) {
					// if here, the first sample of the trace has negative values, implying we must start from the first point
					// a problem: I found that the first point is not exactly at the pCd.coord.tmin, beacause of the trace delay not exactly line up at
					//         sample timing?
					pint[numfa].x = pRangeArr[ix];
					pint[numfa].y = pintAll[ix][0].y;
					numfa++;
					pint[numfa] = pintAll[ix][0];
					numfa++;
				}


				oldBrush = pDC->SelectObject(&brushNeg);
				oldPen = pDC->SelectObject(&penNeg);
				for (it=1; it<nt; it++) {
					j0 = (int)myRound((pintAll[ix][it-1].x-pRangeArr[ix])*res);
					j1 = (int)myRound((pintAll[ix][it].x-pRangeArr[ix])*res);
					if( j1>=0 && j0>=0 ) {
						numfa=0; 
						continue; //do not fill anything.
					}
					if( j1<0 && j0<0) {
						pint[numfa] = pintAll[ix][it];
						numfa++;
					}
					else if( j1<0 && j0>=0)
					{
						a = xArr[ix][it]-xArr[ix][it-1];
						if(fabs(a) < MINAMP) b = yArray[it-1];
						else
							b = yArray[it-1] + (yArray[it]-yArray[it-1])*(rangeArr[ix]-xArr[ix][it-1])/a;
						if(b>yArray[it]) b=yArray[it];
						else if (b < yArray[it-1]) b = yArray[it-1];
						pint[numfa] = pCd.mm_coord(rangeArr[ix],b, isTime);
						pint[numfa+1] = pintAll[ix][it];
						numfa+=2;
					}
					else if( j1==0 && j0<0 )
					{
						pint[numfa] = pintAll[ix][it];
						pint[numfa+1].x = pRangeArr[ix];
						pint[numfa+1].y = pintAll[ix][it].y;
						numfa+=2;
						if(numfa>2 && numfa<100)
						{
							da = getMinXValueCPoint(pint, numfa) - pRangeArr[ix];
							if (abs(da) > 1) {
								pDC->Polygon(pint, numfa);
							}
						}
						numfa=0;
					}
					else if( j1>0 && j0<0)
					{
						a = xArr[ix][it]-xArr[ix][it-1];
						if(fabs(a) < MINAMP) b = yArray[it-1];
						else
							b = yArray[it-1] + (yArray[it]-yArray[it-1])*(rangeArr[ix]-xArr[ix][it-1])/a;
						if(b>yArray[it]) b=yArray[it];
						else if (b < yArray[it-1]) b = yArray[it-1];
						pint[numfa] = pCd.mm_coord(rangeArr[ix],b, isTime);
						numfa++;

						if(numfa>2 && numfa<100)
						{
							da = getMinXValueCPoint(pint, numfa) - pRangeArr[ix];
							if (abs(da) > 1) {
								pDC->Polygon(pint, numfa);
							}
						}
						numfa=0;
					}
				} // for it

				if (numfa >1) {
					// there are left overs. 
					pint[numfa] = pCd.mm_coord(rangeArr[ix],yArray[nt-1], isTime);
					numfa++;
					da = getMinXValueCPoint(pint, numfa) - pRangeArr[ix];
					if (abs(da) > 1) {
						pDC->Polygon(pint, numfa);
					}
				}
				pDC->SelectObject(oldBrush);
				pDC->SelectObject(oldPen);
				pRangeArr[ix] += pOffFill;
			} // if

			//START FILL the right half.
			if (GetRValue(colPos)!=255 ||GetGValue(colPos)!=255 ||GetBValue(colPos)!=255) {
				pRangeArr[ix] += pOffFill;
				numfa=0; 
				if (pintAll[ix][0].x > pRangeArr[ix]) {
					// if here, the first sample of the trace has positive value, implying we must start from the first point
					pint[numfa].x = pRangeArr[ix];
					pint[numfa].y = pintAll[ix][0].y;
					numfa++;
					pint[numfa] = pintAll[ix][0];
					numfa++;
				}
				oldBrush = pDC->SelectObject(&brushPos);
				oldPen = pDC->SelectObject(&penPos);
				for (it=1; it<nt; it++) {
					j0 = (int)myRound((pintAll[ix][it-1].x-pRangeArr[ix])*res);
					j1 = (int)myRound((pintAll[ix][it].x-pRangeArr[ix])*res);
					if( j1<= 0 && j0<=0 ) {
						numfa=0; 
						continue; //do not fill anything.
					}
					if( j1>0 && j0>0)
					{
						pint[numfa] = pintAll[ix][it];
						numfa++;
					}
					else if( j1>0 && j0<=0)
					{
						a = xArr[ix][it]-xArr[ix][it-1];
						if(fabs(a) < 0.0000001) b = yArray[it-1];
						else
							b = yArray[it-1] + (yArray[it]-yArray[it-1])*(rangeArr[ix]-xArr[ix][it-1])/a;
						if(b>yArray[it]) b=yArray[it];
						else if (b < yArray[it-1]) b = yArray[it-1];
						pint[numfa] = pCd.mm_coord(rangeArr[ix],b, isTime);
						pint[numfa+1] = pintAll[ix][it];
						numfa+=2;
					}
					else if( j1==0 && j0>0 )
					{
						pint[numfa] = pintAll[ix][it];
						pint[numfa+1].x = pRangeArr[ix];
						pint[numfa+1].y = pintAll[ix][it].y;
						numfa+=2;
						if(numfa>2 && numfa<100)
						{
							da = getMaxXValueCPoint(pint, numfa) - pRangeArr[ix];
							if (abs(da) > 1) {
								pDC->Polygon(pint, numfa);
							}
						}
						numfa=0;
					}
					else if( j1<0 && j0>0)
					{
						a = xArr[ix][it]-xArr[ix][it-1];
						if(fabs(a) < 0.0000001) b = yArray[it-1];
						else
							b = yArray[it-1] + (yArray[it]-yArray[it-1])*(rangeArr[ix]-xArr[ix][it-1])/a;
						if(b>yArray[it]) b=yArray[it];
						else if (b < yArray[it-1]) b = yArray[it-1];
						pint[numfa] = pCd.mm_coord(rangeArr[ix],b, isTime);
						numfa++;

						if(numfa>2 && numfa<100)
						{
							da = getMaxXValueCPoint(pint, numfa) - pRangeArr[ix];
							if (abs(da) > 1) {
								pDC->Polygon(pint, numfa);
							}
						}
						numfa=0;
					}
				} // for it

				if (numfa >1) {
					// there are left overs. 
					pint[numfa] = pCd.mm_coord(rangeArr[ix],yArray[nt-1], isTime);
					numfa++;
					da = getMaxXValueCPoint(pint, numfa) - pRangeArr[ix];
					if (abs(da) > 1) {
						pDC->Polygon(pint, numfa);
					}
				}
				pDC->SelectObject(oldBrush);
				pDC->SelectObject(oldPen);
				pRangeArr[ix] -= pOffFill;
			} // if

		} // for ix

		pDC->SetPolyFillMode(oldFill);
		penNeg.DeleteObject(); // must delete before createPen again
		brushNeg.DeleteObject();
		penPos.DeleteObject(); // must delete before createPen again
		brushPos.DeleteObject();

		free2CPoint(pintAll);
		free (pint);
		free1int (pRangeArr);
		free(isUseArr);
		free1float (yArray);
		tStr.Format(_T("%d traces plotted while %d traces skipped."), draw.tracePlottedInDisplay, draw.traceSkippedInDisplay);
		myCaption(tStr);

	}



	void CSeisWideDoc::airColorSmallArr(CDC* pDC, int nx, int nt, float **xArr, float *rangeArr, double ymin,  double dt, double offFill)
	{
		COLORREF colPos = getAmpRgbSimple(seisBiColor2.maxAmpR, seisBiColor2.maxAmpG, seisBiColor2.maxAmpB);
		COLORREF colNeg = getAmpRgbSimple(seisBiColor2.negAmpR, seisBiColor2.negAmpG, seisBiColor2.negAmpB);
		airColorSmallArr(pDC, nx, nt, xArr, rangeArr, ymin, dt, colPos, colNeg, offFill);
	}


	void CSeisWideDoc::airColorBigArr(CDC* pDC, int nx, int nt, float **xArr, float *rangeArr, double ymin, double dt, double offFill)
	{
		COLORREF colPos = getAmpRgbSimple(seisBiColor2.maxAmpR, seisBiColor2.maxAmpG, seisBiColor2.maxAmpB);
		COLORREF colNeg = getAmpRgbSimple(seisBiColor2.negAmpR, seisBiColor2.negAmpG, seisBiColor2.negAmpB);
		airColorBigArr(pDC, nx, nt, xArr, rangeArr, ymin, dt, colPos, colNeg, offFill);
	}


	void CSeisWideDoc::airColorBigArr(CDC* pDC, int nx, int nt, float **xArr, float *rangeArr,  
		double ft, double dt, COLORREF colPos, COLORREF colNeg, double offFill)
	{
		// NOTE:  offFill   is not used. Please fix!!!!
		if (nt <2) return;
		int numfa,ix,it;
		int j0, j1;
		double a, b, res=(double)pDC->GetDeviceCaps(HORZRES) / (double)pDC->GetWindowExt().cx;
		int da; 
		bool isTime = isTimeDomain() == TRUE;

		CPoint **pintAll = (CPoint **)alloc2CPoint(nt, nx);
		CPoint *pint = (CPoint *)malloc(2*nt*sizeof(CPoint));  //pint will use more than nt points.
		int *pRangeArr = (int *)ealloc1int(nx); 
		bool *isUseArr = (bool *)ealloc1int(nx); 
		float *yArray = (float *)ealloc1float(nt);
		CString tStr;
		if( pintAll == NULL || pint == NULL)
		{
			tStr.Format( _T("Insufficient memory available") );
			myCaption(tStr);
			return;
		}

		for (it=0; it<nt; it++)
			yArray[it] = (float)(ft + it*dt);


		for (ix=0; ix<nx; ix++) {
			pRangeArr[ix] = pCd.mm_coordx((double)rangeArr[ix] );
			for (it=0; it<nt; it++)
				pintAll[ix][it] = pCd.mm_coord((double)xArr[ix][it], yArray[it], isTime);
		}

		draw.tracePlottedInDisplay = 0;
		draw.traceSkippedInDisplay = 0;
		register CPoint pPrev, pCurr;
		pPrev.y = pCurr.y = 0;
		pPrev.x = pRangeArr[0];
		pDC->LPtoDP(&pPrev);
		for (ix=0; ix<nx; ix++) {
			pCurr = pRangeArr[ix];
			pDC->LPtoDP(&pCurr);
			if (ix>0 && abs(pPrev.x - pCurr.x) < 1) {
				draw.traceSkippedInDisplay++;
				isUseArr[ix] = false;
			}
			else {
				pPrev = pCurr;
				isUseArr[ix] = true;
				draw.tracePlottedInDisplay++;
			}
		}

		// now we want to clip so that no shadings are overlapped.
		int k0,  k, k2, m0, m2;
		int ix1, ix2;
		for (ix=0; ix<nx; ix++) {
			if (ix==0) {
				ix1 = 0;
				ix2 = 1;
				m0 = pRangeArr[0];
				m2 = (pRangeArr[0]+pRangeArr[1])/2;
			}
			else if (ix==nx-1) {
				ix1 = nx-2;
				ix2 = nx-1;
				m0 = (pRangeArr[nx-1]+pRangeArr[nx-2])/2;
				m2 = pRangeArr[nx-1];
			}
			else {
				ix1 = ix-1;
				while (!isUseArr[ix1]) {
					ix1--; 
					if (ix1<=0) break;
				}
				if (ix1<0) ix1=0;

				ix2 = ix+1;
				while (!isUseArr[ix2]) {
					ix2++; 
					if (ix2>=nx-1) break;
				}
				if (ix2>nx-1) ix2=nx-1;

				m0 = (pRangeArr[ix]+pRangeArr[ix1])/2;
				m2 = (pRangeArr[ix]+pRangeArr[ix2])/2;
			}


			for (it=0; it<nt; it++) {
				k = pintAll[ix][it].x;
				k0 = pintAll[ix1][it].x;
				k2 = pintAll[ix2][it].x;

				// check left side only
				if (ix>0) {
					if (k<k0 &&  k0< m0) {
						pintAll[ix][it].x = k0;

						// now the related problem: if the trace on the right side also has great negative amp
						if (ix<nx-1 && k2<k0)
							pintAll[ix2][it].x = k0;
						continue;
					}
				} // if ix

				// now check right side only
				if (ix<nx-1) {
					if (ix<nx-1 && k>k2 && k2 > m2) {
						pintAll[ix][it].x =  k2;

						// now the related problem: if the trace on the left side also has great positive amp
						if (ix>0 && k0>k2)
							pintAll[ix1][it].x = k2;
						continue;
					}
				} // if ix
			} // for it
		} // for ix

		//	double locInKm4MaxAmp = head.aveAmp *2.0*draw.trcIntOavgAmp*para.gain / para.colorFillIllumination;
		//double aMaxAmp = head.maxAmp/head.aveAmp *draw.trcInt*para.gain;
		//double aAvgAmp = draw.trcInt*para.gain;

		CPen* oldPen;
		CBrush* oldBrush;
		CBrush brushNeg;
		brushNeg.CreateSolidBrush(colNeg);

		CPen penNeg;
		penNeg.CreatePen(PS_NULL, 0, colNeg);

		CBrush brushPos;
		brushPos.CreateSolidBrush(colPos);

		CPen penPos;
		penPos.CreatePen(PS_NULL, 0, colPos);

		int pOffFill = (int)myRound(pCd.coord.mm_xscale*offFill);
		for (ix=0; ix<nx; ix++) {
			if ( ix>0 && (int)(ix/10)*10 == ix) {
				tStr.Format(_T("R%d of %d traces."), ix, nx);
				myCaption(tStr);
			}
			if (!isUseArr[ix]) continue;

			//START FILL the left half.
			if (GetRValue(colNeg)!=255 ||GetGValue(colNeg)!=255 ||GetBValue(colNeg)!=255) {
				pRangeArr[ix] -= pOffFill;
				numfa=0;
				if (pintAll[ix][0].x < pRangeArr[ix]) {
					// if here, the first sample of the trace has negative values, implying we must start from the first point
					// a problem: I found that the first point is not exactly at the pCd.coord.tmin, beacause of the trace delay not exactly line up at
					//         sample timing?
					pint[numfa].x = pRangeArr[ix];
					pint[numfa].y = pintAll[ix][0].y;
					numfa++;
					pint[numfa] = pintAll[ix][0];
					numfa++;
				}


				for (it=1; it<nt; it++) {
					j0 = (int)myRound((pintAll[ix][it-1].x-pRangeArr[ix])*res);
					j1 = (int)myRound((pintAll[ix][it].x-pRangeArr[ix])*res);
					if( j1>=0 && j0>=0 ) {
						pint[numfa].x = pRangeArr[ix];
						pint[numfa].y = pintAll[ix][it].y;
						numfa++;
						continue;
					}
					if( j1<0 && j0<0) {
						pint[numfa] = pintAll[ix][it];
						numfa++;
					}
					else if( j1<0 && j0>=0)
					{
						a = xArr[ix][it]-xArr[ix][it-1];
						if(fabs(a) < MINAMP) b = yArray[it-1];
						else
							b = yArray[it-1] + (yArray[it]-yArray[it-1])*(rangeArr[ix]-xArr[ix][it-1])/a;
						if(b>yArray[it]) b=yArray[it];
						else if (b < yArray[it-1]) b = yArray[it-1];
						pint[numfa] = pCd.mm_coord(rangeArr[ix],b, isTime);
						pint[numfa+1] = pintAll[ix][it];
						numfa+=2;
					}
					else if( j1==0 && j0<0 )
					{
						pint[numfa] = pintAll[ix][it];
						pint[numfa+1].x = pRangeArr[ix];
						pint[numfa+1].y = pintAll[ix][it].y;
						numfa+=2;
					}
					else if( j1>0 && j0<0)
					{
						a = xArr[ix][it]-xArr[ix][it-1];
						if(fabs(a) < MINAMP) b = yArray[it-1];
						else
							b = yArray[it-1] + (yArray[it]-yArray[it-1])*(rangeArr[ix]-xArr[ix][it-1])/a;
						if(b>yArray[it]) b=yArray[it];
						else if (b < yArray[it-1]) b = yArray[it-1];
						pint[numfa] = pCd.mm_coord(rangeArr[ix],b, isTime);
						numfa++;
					}
				} // for it

				pint[numfa] = pCd.mm_coord(rangeArr[ix],yArray[nt-1], isTime);
				numfa++;
				da = getMinXValueCPoint(pint, numfa) - pRangeArr[ix];
				if (abs(da) > 1) {
					int oldFill= pDC->SetPolyFillMode(ALTERNATE);
					oldBrush = pDC->SelectObject(&brushNeg);
					oldPen = pDC->SelectObject(&penNeg);
					pDC->Polygon(pint, numfa);
					pDC->SelectObject(oldBrush);
					pDC->SelectObject(oldPen);
					pDC->SetPolyFillMode(oldFill);
				}
				pRangeArr[ix] += pOffFill;
			} // if

			//START FILL the right half.
			if (GetRValue(colPos)!=255 ||GetGValue(colPos)!=255 ||GetBValue(colPos)!=255) {
				pRangeArr[ix] += pOffFill;
				numfa=0; 
				if (pintAll[ix][0].x > pRangeArr[ix]) {
					// if here, the first sample of the trace has positive value, implying we must start from the first point
					pint[numfa].x = pRangeArr[ix];
					pint[numfa].y = pintAll[ix][0].y;
					numfa++;
					pint[numfa] = pintAll[ix][0];
					numfa++;
				}
				for (it=1; it<nt; it++) {
					j0 = (int)myRound((pintAll[ix][it-1].x-pRangeArr[ix])*res);
					j1 = (int)myRound((pintAll[ix][it].x-pRangeArr[ix])*res);
					if( j1<= 0 && j0<=0 ) {
						pint[numfa].x = pRangeArr[ix];
						pint[numfa].y = pintAll[ix][it].y;
						numfa++;
						continue;
					}
					if( j1>0 && j0>0)
					{
						pint[numfa] = pintAll[ix][it];
						numfa++;
					}
					else if( j1>0 && j0<=0)
					{
						a = xArr[ix][it]-xArr[ix][it-1];
						if(fabs(a) < 0.0000001) b = yArray[it-1];
						else
							b = yArray[it-1] + (yArray[it]-yArray[it-1])*(rangeArr[ix]-xArr[ix][it-1])/a;
						if(b>yArray[it]) b=yArray[it];
						else if (b < yArray[it-1]) b = yArray[it-1];
						pint[numfa] = pCd.mm_coord(rangeArr[ix],b, isTime);
						pint[numfa+1] = pintAll[ix][it];
						numfa+=2;
					}
					else if( j1==0 && j0>0 )
					{
						pint[numfa] = pintAll[ix][it];
						pint[numfa+1].x = pRangeArr[ix];
						pint[numfa+1].y = pintAll[ix][it].y;
						numfa+=2;
					}
					else if( j1<0 && j0>0)
					{
						a = xArr[ix][it]-xArr[ix][it-1];
						if(fabs(a) < 0.0000001) b = yArray[it-1];
						else
							b = yArray[it-1] + (yArray[it]-yArray[it-1])*(rangeArr[ix]-xArr[ix][it-1])/a;
						if(b>yArray[it]) b=yArray[it];
						else if (b < yArray[it-1]) b = yArray[it-1];
						pint[numfa] = pCd.mm_coord(rangeArr[ix],b, isTime);
						numfa++;
					}
				} // for it

				pint[numfa] = pCd.mm_coord(rangeArr[ix],yArray[nt-1], isTime);
				numfa++;
				da = getMaxXValueCPoint(pint, numfa) - pRangeArr[ix];
				if (abs(da) > 1) {
					int oldFill= pDC->SetPolyFillMode(ALTERNATE);
					oldBrush = pDC->SelectObject(&brushPos);
					oldPen = pDC->SelectObject(&penPos);
					pDC->Polygon(pint, numfa);
					pDC->SelectObject(oldBrush);
					pDC->SelectObject(oldPen);
					pDC->SetPolyFillMode(oldFill);
				}
				pRangeArr[ix] -= pOffFill;
			} // if

		} // for ix

		penNeg.DeleteObject(); // must delete before createPen again
		brushNeg.DeleteObject();
		penPos.DeleteObject(); // must delete before createPen again
		brushPos.DeleteObject();

		free2CPoint(pintAll);
		free (pint);
		free1int (pRangeArr);
		free (isUseArr);
		free1float (yArray);
		tStr.Format(_T("%d traces plotted while %d traces skipped."), draw.tracePlottedInDisplay, draw.traceSkippedInDisplay);
		myCaption(tStr);
	}



	void CSeisWideDoc::BackgrdFill(CDC* pDC, int n, double x[], double y[], double range, double offFill)
	{
		//note that offFill has to be passed into this routine, but not have to for airvar().
		//offFill is scaled by para.gainReal such that if offFill=1, only amplitudes spanning 
		//more than a trace interval get filled. Normally offfill=0.1.

		// note:  ampliutude  head.maxAmp  should be drawn using  
		//        RGB(seisBiColor.maxAmpR,seisBiColor.maxAmpG,seisBiColor.maxAmpB)
		// while the rest should be interpolated
		if (n <2) return;
		CPen* oldPen;
		CBrush* oldBrush;
		offFill = 0.; // we do not need to use this???
		bool isTime = isTimeDomain() == TRUE;

		int numfa,i,j0,j1,pixelOffFill;
		double a, b, range1,res=(double)pDC->GetDeviceCaps(HORZRES) / (double)pDC->GetWindowExt().cx;

		CPoint *pintAll,*pint,prange,prange1;
		pintAll = (CPoint *)malloc(n*sizeof(CPoint));
		pint = (CPoint *)malloc(2*n*sizeof(CPoint));  //pint will use more than n points.
		if( pintAll == NULL || pint == NULL)
		{
			AfxMessageBox( _T("Insufficient memory available") );
			return;
		}

		int oldFill= pDC->SetPolyFillMode(ALTERNATE);
		for (i=0; i<n; i++)
			if ( ! _isnan(x[i]))  
				pintAll[i] = pCd.mm_coord(x[i],y[i], isTime);

		//START FILL the left half.
		prange = pCd.mm_coord(range,0., isTime);
		range1 = range-offFill; //real trace line.
		prange1 = pCd.mm_coord(range1,0., isTime);
		pixelOffFill = (int)myRound((prange.x-prange1.x) * res); //no. of pixels to offset from range line.
		numfa=0;

		j0 = (int)myRound((pintAll[0].x-prange.x)*res);
		if(j0 < -pixelOffFill)
		{
			pint[0] = pCd.mm_coord(range1,y[0], isTime);
			pint[1] = pintAll[0];
			numfa+=2;
		}

		CBrush brushRed;
		CPen varPen;

		CPoint pZero = pCd.mm_coord(range,0, isTime);

		// note: 
		//   1. draw.trcIntOavgAmp  is actually the average trace interval divided by 
		// the average amplitude
		//   2. para.gain  is set by the user as a parameter
		//double locInKm4MaxAmp = head.maxAmp*draw.trcIntOavgAmp*para.gain*para.traceStep / para.bgrFillIllumination;
		double trcInterval = (para.isDistanceDisplay)  ?  head.distInterval  :  head.offsetInterval;
		double locInKm4MaxAmp = trcInterval*para.gain / 2.;  // ???
		CPoint pFull = pCd.mm_coord(range-locInKm4MaxAmp,0, isTime); 
		for (i=1; i<n; i++) 
		{
			j0 = (int)myRound((pintAll[i-1].x-prange.x)*res);
			j1 = (int)myRound((pintAll[i].x-prange.x)*res);
			if( j1>= -pixelOffFill && j0>=-pixelOffFill ) continue; //do not fill anything.
			if( j1<-pixelOffFill && j0<-pixelOffFill)
			{
				pint[numfa] = pintAll[i];
				numfa++;
			}
			else if( j1<-pixelOffFill && j0>=-pixelOffFill)
			{
				a = x[i]-x[i-1];
				if(fabs(a) < 0.0000001) b = y[i-1];
				else
					b = y[i-1] + (y[i]-y[i-1])*(range1-x[i-1])/a;
				if(b<y[i-1]) b = y[i-1];
				pint[numfa] = pCd.mm_coord(range1,b, isTime);
				pint[numfa+1] = pintAll[i];
				numfa+=2;
			}
			else if( j1==-pixelOffFill && j0<-pixelOffFill )
			{
				pint[numfa] = pintAll[i];
				pint[numfa+1].x = prange1.x;
				pint[numfa+1].y = pintAll[i].y;
				numfa+=2;
				if(numfa>2 && numfa<100)
				{
					COLORREF aCol = getAmpRgb(pint, numfa, pFull.x, pZero.x);
					brushRed.CreateSolidBrush(aCol);
					varPen.CreatePen(PS_NULL, 0, aCol);
					oldBrush = pDC->SelectObject(&brushRed);
					oldPen = pDC->SelectObject(&varPen);
					pDC->Polygon(pint, numfa);
					pDC->SelectObject(oldBrush);
					pDC->SelectObject(oldPen);
					varPen.DeleteObject(); // must delete before createPen again
					brushRed.DeleteObject();
				}
				numfa=0;
			}
			else if( j1>-pixelOffFill && j0<-pixelOffFill)
			{
				a = x[i]-x[i-1];
				if(fabs(a) < 0.0000001) b = y[i-1];
				else
					b = y[i-1] + (y[i]-y[i-1])*(range1-x[i-1])/a;
				if(b>y[i]) b=y[i];
				pint[numfa] = pCd.mm_coord(range1,b, isTime);
				numfa++;

				if(numfa>2 && numfa<100)
				{
					COLORREF aCol = getAmpRgb(pint, numfa, pFull.x, pZero.x);
					brushRed.CreateSolidBrush(aCol);
					varPen.CreatePen(PS_NULL, 0, aCol);
					oldBrush = pDC->SelectObject(&brushRed);
					oldPen = pDC->SelectObject(&varPen);
					pDC->Polygon(pint, numfa);
					pDC->SelectObject(oldBrush);
					pDC->SelectObject(oldPen);
					varPen.DeleteObject(); // must delete before createPen again
					brushRed.DeleteObject();
				}
				numfa=0;
			}
		} // for i

		pint[numfa] = pCd.mm_coord(range1,y[n-1], isTime);
		numfa++;
		if(numfa>2 && numfa<100) {
			COLORREF aCol = getAmpRgb(pint, numfa, pFull.x, pZero.x);
			brushRed.CreateSolidBrush(aCol);
			varPen.CreatePen(PS_NULL, 0, aCol);
			oldBrush = pDC->SelectObject(&brushRed);
			oldPen = pDC->SelectObject(&varPen);
			pDC->Polygon(pint, numfa);
			pDC->SelectObject(oldBrush);
			pDC->SelectObject(oldPen);
			brushRed.DeleteObject();
			varPen.DeleteObject(); // must delete before createPen again
		}

		//START FILL the right half.
		prange = pCd.mm_coord(range,0., isTime);
		range1 = range+offFill; //real trace line.
		prange1 = pCd.mm_coord(range1,0., isTime);
		pixelOffFill = (int)myRound((prange1.x-prange.x) * res); //no. of pixels to offset from range line.
		numfa=0; 

		j0 = (int)myRound((pintAll[0].x-prange.x)*res);
		if(j0 > pixelOffFill)
		{
			pint[0] = pCd.mm_coord(range1,y[0], isTime);
			pint[1] = pintAll[0];
			numfa+=2;
		}


		pFull = pCd.mm_coord(range+ locInKm4MaxAmp,0, isTime);
		// pFull = pCd.mm_coord(range+head.maxAmp*draw.trcIntOavgAmp*para.gain*para.traceStep,0);
		for (i=1; i<n; i++) 
		{
			j0 = (int)myRound((pintAll[i-1].x-prange.x)*res);
			j1 = (int)myRound((pintAll[i].x-prange.x)*res);
			if( j1<= pixelOffFill && j0<=pixelOffFill ) continue; //do not fill anything.
			if( j1>pixelOffFill && j0>pixelOffFill)
			{
				pint[numfa] = pintAll[i];
				numfa++;
			}
			else if( j1>pixelOffFill && j0<=pixelOffFill)
			{
				a = x[i]-x[i-1];
				if(fabs(a) < 0.0000001) b = y[i-1];
				else
					b = y[i-1] + (y[i]-y[i-1])*(range1-x[i-1])/a;
				if(b<y[i-1]) 
				{
					b = y[i-1];
				}
				pint[numfa] = pCd.mm_coord(range1,b, isTime);
				pint[numfa+1] = pintAll[i];
				numfa+=2;
			}
			else if( j1==pixelOffFill && j0>pixelOffFill )
			{
				pint[numfa] = pintAll[i];
				pint[numfa+1].x = prange1.x;
				pint[numfa+1].y = pintAll[i].y;    
				numfa+=2;
				if(numfa>2 && numfa<100)
				{
					COLORREF aCol = getAmpRgb(pint, numfa, pFull.x, pZero.x);
					brushRed.CreateSolidBrush(aCol);
					varPen.CreatePen(PS_NULL, 0, aCol);
					oldBrush = pDC->SelectObject(&brushRed);
					oldPen = pDC->SelectObject(&varPen);
					pDC->Polygon(pint, numfa);
					pDC->SelectObject(oldBrush);
					pDC->SelectObject(oldPen);
					varPen.DeleteObject(); // must delete before createPen again
					brushRed.DeleteObject();
				}
				numfa=0;
			}
			else if( j1<pixelOffFill && j0>pixelOffFill)
			{
				a = x[i]-x[i-1];
				if(fabs(a) < 0.0000001) b = y[i-1];
				else
					b = y[i-1] + (y[i]-y[i-1])*(range1-x[i-1])/a;
				if(b>y[i])
				{
					b=y[i];
				}
				pint[numfa] = pCd.mm_coord(range1,b, isTime);
				//		pint[numfa+1].x = prange.x;
				//		pint[numfa+1].y = pint[numfa].y;
				numfa++;

				if(numfa>2 && numfa<100)
				{
					COLORREF aCol = getAmpRgb(pint, numfa, pFull.x, pZero.x);
					brushRed.CreateSolidBrush(aCol);
					varPen.CreatePen(PS_NULL, 0, aCol);
					oldBrush = pDC->SelectObject(&brushRed);
					oldPen = pDC->SelectObject(&varPen);
					pDC->Polygon(pint, numfa);
					pDC->SelectObject(oldBrush);
					pDC->SelectObject(oldPen);
					brushRed.DeleteObject();
					varPen.DeleteObject(); // must delete before createPen again
				}
				numfa=0;
			}
		} // for i

		pint[numfa] = pCd.mm_coord(range1,y[n-1], isTime);
		numfa++;
		if(numfa>2 && numfa<100) {
			COLORREF aCol = getAmpRgb(pint, numfa, pFull.x, pZero.x);
			brushRed.CreateSolidBrush(aCol);
			varPen.CreatePen(PS_NULL, 0, aCol);
			oldBrush = pDC->SelectObject(&brushRed);
			oldPen = pDC->SelectObject(&varPen);
			pDC->Polygon(pint, numfa);
			pDC->SelectObject(oldBrush);
			pDC->SelectObject(oldPen);
			brushRed.DeleteObject();
			varPen.DeleteObject(); // must delete before createPen again
		}
		pDC->SetPolyFillMode(oldFill);

		// delete varPen;
		free (pintAll);
		free (pint);
	}


	void CSeisWideDoc::BackgrdFillArr(CDC* pDC, int nx, int nt, float **xArr, float **yArr, double *rangeArr)
	{
		if (nt <2) return;
		CPen* oldPen;
		CBrush* oldBrush;
		CBrush brushRed;
		CPen varPen;
		bool isTime = isTimeDomain() == TRUE;

		int numfa,ix,it;
		int j0, j1;
		double a, b, res=(double)pDC->GetDeviceCaps(HORZRES) / (double)pDC->GetWindowExt().cx;
		double amp;
		int da; 

		CPoint **pintAll = (CPoint **)alloc2CPoint(nt, nx);
		CPoint *pint = (CPoint *)malloc(2*nt*sizeof(CPoint));  //pint will use more than nt points.
		int *pRangeArr = (int *)ealloc1int(nx); 
		//CPoint prange;
		CString tStr;
		if( pintAll == NULL || pint == NULL)
		{
			tStr.Format( _T("Insufficient memory available") );
			myCaption(tStr);
			return;
		}


		for (ix=0; ix<nx; ix++) {
			pRangeArr[ix] = pCd.mm_coordx((double)rangeArr[ix] );
			for (it=0; it<nt; it++)
				pintAll[ix][it] = pCd.mm_coord(xArr[ix][it], yArr[ix][it], isTime);
		}

		// now we want to clip so that no shadings are overlapped.
		int k0,  k, k2, m0, m2;
		for (ix=0; ix<nx; ix++) {
			if (ix>0) 
				m0 = (pRangeArr[ix]+pRangeArr[ix-1])/2;
			if (ix<nx-1) 
				m2 = (pRangeArr[ix]+pRangeArr[ix+1])/2;

			for (it=0; it<nt; it++) {
				k = pintAll[ix][it].x;
				if (ix>0) 
					k0 = pintAll[ix-1][it].x;
				if (ix<nx-1) 
					k2 = pintAll[ix+1][it].x;

				// check left side only
				if (ix>0) {
					if (k<k0 &&  k0< m0) {
						pintAll[ix][it].x = k0;

						// now the related problem: if the trace on the right side also has great negative amp
						if (ix<nx-1 && k2<k0)
							pintAll[ix+1][it].x = k0;
						continue;
					}
				} // if ix

				// now check right side only
				if (ix<nx-1) {
					if (ix<nx-1 && k>k2 && k2 > m2) {
						pintAll[ix][it].x =  k2;

						// now the related problem: if the trace on the left side also has great positive amp
						if (ix>0 && k0>k2)
							pintAll[ix-1][it].x = k2;
						continue;
					}
				} // if ix
			} // for it
		} // for ix

		//	double locInKm4MaxAmp = head.aveAmp *2.0*draw.trcIntOavgAmp*para.gain / para.colorFillIllumination;
		//double aMaxAmp = head.maxAmp/head.aveAmp *draw.trcInt*para.gain;
		//double aAvgAmp = draw.trcInt*para.gain;
		int oldFill= pDC->SetPolyFillMode(ALTERNATE);
		draw.tracePlottedInDisplay = 0;
		draw.traceSkippedInDisplay = 0;
		register CPoint pPrev, pCurr;
		pPrev.y = pCurr.y = 0;
		pPrev.x = pRangeArr[0];
		pDC->LPtoDP(&pPrev);

		for (ix=0; ix<nx; ix++) {
			if ( ix>0 && (int)(ix/10)*10 == ix) {
				tStr.Format(_T("R%d of %d traces."), ix, nx);
				myCaption(tStr);
			}

			if (ix > 0) {
				pCurr = pRangeArr[ix];
				pDC->LPtoDP(&pCurr);
				if (abs(pPrev.x - pCurr.x) < 1) {
					draw.traceSkippedInDisplay++;
					continue;
				}
				else {
					pPrev = pCurr;
				}
			} // if
			draw.tracePlottedInDisplay++;

			//START FILL the left half.
			//prange = pCd.mm_coord(rangeArr[ix],0.);
			//int cFull = pCd.mm_coord((float)(rangeArr[ix]-locInKm4MaxAmp)); 

			numfa=0;
			if (pintAll[ix][0].x < pRangeArr[ix]) {
				// if here, the first sample of the trace has negative values, implying the fill area must start from the first point
				// a problem: I found that the first point is not exactly at the pCd.coord.tmin, beacause of the trace delay not exactly line up at
				//         sample timing?
				pint[numfa].x = pRangeArr[ix];
				pint[numfa].y = pintAll[ix][0].y;
				numfa++;
				pint[numfa] = pintAll[ix][0];
				numfa++;
			}


			for (it=1; it<nt; it++) {
				j0 = (int)myRound((pintAll[ix][it-1].x-pRangeArr[ix])*res);
				j1 = (int)myRound((pintAll[ix][it].x-pRangeArr[ix])*res);
				if( j1>=0 && j0>=0 ) {
					numfa=0; 
					continue; //do not fill anything.
				}
				if( j1<0 && j0<0) {
					pint[numfa] = pintAll[ix][it];
					numfa++;
				}
				else if( j1<0 && j0>=0)
				{
					a = xArr[ix][it]-xArr[ix][it-1];
					if(fabs(a) < MINAMP) b = yArr[ix][it-1];
					else
						b = yArr[ix][it-1] + (yArr[ix][it]-yArr[ix][it-1])*(rangeArr[ix]-xArr[ix][it-1])/a;
					if(b>yArr[ix][it]) b=yArr[ix][it];
					else if (b < yArr[ix][it-1]) b = yArr[ix][it-1];
					pint[numfa] = pCd.mm_coord(rangeArr[ix],b, isTime);
					pint[numfa+1] = pintAll[ix][it];
					numfa+=2;
				}
				else if( j1==0 && j0<0 )
				{
					pint[numfa] = pintAll[ix][it];
					pint[numfa+1].x = pRangeArr[ix];
					pint[numfa+1].y = pintAll[ix][it].y;
					numfa+=2;
					if(numfa>2 && numfa<100)
					{
						da = getMinXValueCPoint(pint, numfa) - pRangeArr[ix];
						if (abs(da) > 1) {
							amp = da / pCd.coord.mm_xscale;
							// and then we use amp, head.maxAmp, draw.avgAmp to determine the color
							COLORREF aCol = getAmpRgb((float)amp);
							brushRed.CreateSolidBrush(aCol);
							varPen.CreatePen(PS_NULL, 0, aCol);
							oldBrush = pDC->SelectObject(&brushRed);
							oldPen = pDC->SelectObject(&varPen);
							pDC->Polygon(pint, numfa);
							pDC->SelectObject(oldBrush);
							pDC->SelectObject(oldPen);
							varPen.DeleteObject(); // must delete before createPen again
							brushRed.DeleteObject();
						}
					}
					numfa=0;
				}
				else if( j1>0 && j0<0)
				{
					a = xArr[ix][it]-xArr[ix][it-1];
					if(fabs(a) < MINAMP) b = yArr[ix][it-1];
					else
						b = yArr[ix][it-1] + (yArr[ix][it]-yArr[ix][it-1])*(rangeArr[ix]-xArr[ix][it-1])/a;
					if(b>yArr[ix][it]) b=yArr[ix][it];
					else if (b < yArr[ix][it-1]) b = yArr[ix][it-1];
					pint[numfa] = pCd.mm_coord(rangeArr[ix],b, isTime);
					numfa++;

					if(numfa>2 && numfa<100)
					{
						da = getMinXValueCPoint(pint, numfa) - pRangeArr[ix];
						if (abs(da) > 1) {
							amp = da / pCd.coord.mm_xscale;
							COLORREF aCol = getAmpRgb((float)amp);
							brushRed.CreateSolidBrush(aCol);
							varPen.CreatePen(PS_NULL, 0, aCol);
							oldBrush = pDC->SelectObject(&brushRed);
							oldPen = pDC->SelectObject(&varPen);
							pDC->Polygon(pint, numfa);
							pDC->SelectObject(oldBrush);
							pDC->SelectObject(oldPen);
							varPen.DeleteObject(); // must delete before createPen again
							brushRed.DeleteObject();
						}
					}
					numfa=0;
				}
			} // for it

			if (numfa >1) {
				// there are left overs. 
				pint[numfa] = pCd.mm_coord(rangeArr[ix],yArr[ix][nt-1], isTime);
				numfa++;
				da = getMinXValueCPoint(pint, numfa) - pRangeArr[ix];
				if (abs(da) > 1) {
					amp = da / pCd.coord.mm_xscale;
					COLORREF aCol = getAmpRgb((float)amp);
					brushRed.CreateSolidBrush(aCol);
					varPen.CreatePen(PS_NULL, 0, aCol);
					oldBrush = pDC->SelectObject(&brushRed);
					oldPen = pDC->SelectObject(&varPen);
					pDC->Polygon(pint, numfa);
					pDC->SelectObject(oldBrush);
					pDC->SelectObject(oldPen);
					brushRed.DeleteObject();
					varPen.DeleteObject(); // must delete before createPen again
				}
			}

			//START FILL the right half.
			numfa=0; 
			if (pintAll[ix][0].x > pRangeArr[ix]) {
				// if here, the first sample of the trace has positive value, implying we must start from the first point
				pint[numfa].x = pRangeArr[ix];
				pint[numfa].y = pintAll[ix][0].y;
				numfa++;
				pint[numfa] = pintAll[ix][0];
				numfa++;
			}
			for (it=1; it<nt; it++) {
				j0 = (int)myRound((pintAll[ix][it-1].x-pRangeArr[ix])*res);
				j1 = (int)myRound((pintAll[ix][it].x-pRangeArr[ix])*res);
				if( j1<= 0 && j0<=0 ) {
					numfa=0; 
					continue; //do not fill anything.
				}
				if( j1>0 && j0>0)
				{
					pint[numfa] = pintAll[ix][it];
					numfa++;
				}
				else if( j1>0 && j0<=0)
				{
					a = xArr[ix][it]-xArr[ix][it-1];
					if(fabs(a) < 0.0000001) b = yArr[ix][it-1];
					else
						b = yArr[ix][it-1] + (yArr[ix][it]-yArr[ix][it-1])*(rangeArr[ix]-xArr[ix][it-1])/a;
					if(b>yArr[ix][it]) b=yArr[ix][it];
					else if (b < yArr[ix][it-1]) b = yArr[ix][it-1];
					pint[numfa] = pCd.mm_coord(rangeArr[ix],b, isTime);
					pint[numfa+1] = pintAll[ix][it];
					numfa+=2;
				}
				else if( j1==0 && j0>0 )
				{
					pint[numfa] = pintAll[ix][it];
					pint[numfa+1].x = pRangeArr[ix];
					pint[numfa+1].y = pintAll[ix][it].y;
					numfa+=2;
					if(numfa>2 && numfa<100)
					{
						da = getMaxXValueCPoint(pint, numfa) - pRangeArr[ix];
						if (abs(da) > 1) {
							amp = da / pCd.coord.mm_xscale;
							COLORREF aCol = getAmpRgb((float)amp);
							brushRed.CreateSolidBrush(aCol);
							varPen.CreatePen(PS_NULL, 0, aCol);
							oldBrush = pDC->SelectObject(&brushRed);
							oldPen = pDC->SelectObject(&varPen);
							pDC->Polygon(pint, numfa);
							pDC->SelectObject(oldBrush);
							pDC->SelectObject(oldPen);
							varPen.DeleteObject(); // must delete before createPen again
							brushRed.DeleteObject();
						}
					}
					numfa=0;
				}
				else if( j1<0 && j0>0)
				{
					a = xArr[ix][it]-xArr[ix][it-1];
					if(fabs(a) < 0.0000001) b = yArr[ix][it-1];
					else
						b = yArr[ix][it-1] + (yArr[ix][it]-yArr[ix][it-1])*(rangeArr[ix]-xArr[ix][it-1])/a;
					if(b>yArr[ix][it]) b=yArr[ix][it];
					else if (b < yArr[ix][it-1]) b = yArr[ix][it-1];
					pint[numfa] = pCd.mm_coord(rangeArr[ix],b, isTime);
					numfa++;

					if(numfa>2 && numfa<100)
					{
						da = getMaxXValueCPoint(pint, numfa) - pRangeArr[ix];
						if (abs(da) > 1) {
							amp = da / pCd.coord.mm_xscale;
							COLORREF aCol = getAmpRgb((float)amp);
							brushRed.CreateSolidBrush(aCol);
							varPen.CreatePen(PS_NULL, 0, aCol);
							oldBrush = pDC->SelectObject(&brushRed);
							oldPen = pDC->SelectObject(&varPen);
							pDC->Polygon(pint, numfa);
							pDC->SelectObject(oldBrush);
							pDC->SelectObject(oldPen);
							brushRed.DeleteObject();
							varPen.DeleteObject(); // must delete before createPen again
						}
					}
					numfa=0;
				}
			} // for it

			if (numfa >1) {
				// there are left overs. 
				pint[numfa] = pCd.mm_coord(rangeArr[ix],yArr[ix][nt-1], isTime);
				numfa++;
				da = getMaxXValueCPoint(pint, numfa) - pRangeArr[ix];
				if (abs(da) > 1) {
					amp = da / pCd.coord.mm_xscale;
					COLORREF aCol = getAmpRgb((float)amp);
					brushRed.CreateSolidBrush(aCol);
					varPen.CreatePen(PS_NULL, 0, aCol);
					oldBrush = pDC->SelectObject(&brushRed);
					oldPen = pDC->SelectObject(&varPen);
					pDC->Polygon(pint, numfa);
					pDC->SelectObject(oldBrush);
					pDC->SelectObject(oldPen);
					brushRed.DeleteObject();
					varPen.DeleteObject(); // must delete before createPen again
				}
			}
		} // for ix

		pDC->SetPolyFillMode(oldFill);
		free2CPoint(pintAll);
		free (pint);
		free1int (pRangeArr);

		tStr.Format(_T("%d traces plotted while %d traces skipped."), draw.tracePlottedInDisplay, draw.traceSkippedInDisplay);
		myCaption(tStr);
	}



	/** testing 
	****/
	void CSeisWideDoc::floodFillArr(CDC* pDC, int nx, int nt, float **xArr, float **yArr, double *rangeArr)
	{
		if (nt <2) return;
		CPen* oldPen;
		CBrush* oldBrush;
		CBrush brushRed;
		CPen varPen;

		int ix,it;
		double a, b, res=(double)pDC->GetDeviceCaps(HORZRES) / (double)pDC->GetWindowExt().cx;
		double amp;
		int i;
		bool isTime = isTimeDomain() == TRUE;

		CPoint **pintAll = (CPoint **)alloc2CPoint(nt, nx);
		CPoint *pint = (CPoint *)malloc(4*sizeof(CPoint));  
		int *pRangeArr = (int *)ealloc1int(nx); 
		bool *isUseArr = (bool *)ealloc1int(nx); 
		CString tStr;
		if( pintAll == NULL || pint == NULL)
		{
			tStr.Format( _T("Insufficient memory available") );
			myCaption(tStr);
			return;
		}


		for (ix=0; ix<nx; ix++) {
			pRangeArr[ix] = pCd.mm_coordx((double)rangeArr[ix] );
			for (it=0; it<nt; it++)
				pintAll[ix][it] = pCd.mm_coord(xArr[ix][it], yArr[ix][it], isTime);
		}

		draw.tracePlottedInDisplay = 0;
		draw.traceSkippedInDisplay = 0;
		register CPoint pPrev, pCurr;
		pPrev.y = pCurr.y = 0;
		pPrev.x = pRangeArr[0];
		pDC->LPtoDP(&pPrev);
		for (ix=0; ix<nx; ix++) {
			isUseArr[ix] = false;
			pCurr = pRangeArr[ix];
			pDC->LPtoDP(&pCurr);
			if (ix>0 && abs(pPrev.x - pCurr.x) < 1) {
			}
			else if (getMaxValueAbsolute(&xArr[ix][0], nt) > head.aveAmp*0.001) {
				// needed to remove a very low amp trace, otherwise, one will see a white strip strongly
				isUseArr[ix] = true;
			}

			if (!isUseArr[ix]) {
				draw.traceSkippedInDisplay++;
			}
			else {
				draw.tracePlottedInDisplay++;
				pPrev = pCurr;
			}
		} // for ix

		int *crossingInd = (int *)malloc(sizeof(int)*nt); // for store index for zero-crossings
		//	float *crossingTime = (float *)malloc(sizeof(float)*nt);
		CPoint *crossingPoint = (CPoint *)malloc(2*nt*sizeof(CPoint));  //pint will use more than nt points.


		//	double locInKm4MaxAmp = head.aveAmp *2.0*draw.trcIntOavgAmp*para.gain / para.colorFillIllumination;
		//double aMaxAmp = head.maxAmp/head.aveAmp *draw.trcInt*para.gain;
		//double aAvgAmp = draw.trcInt*para.gain;
		int oldFill= pDC->SetPolyFillMode(ALTERNATE);

		for (ix=0; ix<nx; ix++) {
			if ( ix>0 && (int)(ix/10)*10 == ix) {
				tStr.Format(_T("R%d of %d traces."), ix, nx);
				myCaption(tStr);
			}
			if (!isUseArr[ix]) continue;

			int nz = 0; // number of zero crossings.
			for (it=0; it<nt-1; it++) {
				if ( !sameSign((float)xArr[ix][it], (float)xArr[ix][it+1]) ) {
					crossingInd[nz] = it+1;
					nz++;
				} // if
			} // for i
			if (nz < 1) continue;
			// crossingInd[0:nz-1] now indicates the index where sign changes occurs

			register int ix1 = ix-1;
			while (!isUseArr[ix1]) {
				ix1--; 
				if (ix1<=0) break;
			}
			if (ix1<0) ix1=0;

			register int ix2 = ix+1;
			while (!isUseArr[ix2]) {
				ix2++; 
				if (ix2>=nx-1) break;
			}
			if (ix2>nx-1) ix2=nx-1;
			pint[3].x = pint[0].x = (pRangeArr[ix1] + pRangeArr[ix])/2;
			pint[2].x = pint[1].x = (pRangeArr[ix2] + pRangeArr[ix])/2;

			int iz;
			for (iz=0; iz<nz; iz++) {
				i = crossingInd[iz];
				if (i<=0) {
					crossingPoint[iz] = pCd.mm_coord(rangeArr[ix], yArr[ix][0], isTime);
					continue;
				}
				a = xArr[ix][i]-xArr[ix][i-1];
				if(fabs(a) < MINAMP) b = 0.0;
				else
					b = -(yArr[ix][i]-yArr[ix][i-1])*xArr[ix][i-1]/a;

				b += yArr[ix][i-1];
				if(b>yArr[ix][i]) {
					b=yArr[ix][i];
				}
				else if (b < yArr[ix][i-1]) {
					b = yArr[ix][i-1];
				}

				crossingPoint[iz] = pCd.mm_coord(rangeArr[ix], b, isTime);
			} // for iz


			// start the color filling
			register int i1;
			register int i2;
			for (iz=0; iz<=nz; iz++) {
				// note: iz=nz actually does not exist in the arrays crossingPoint[][]
				if (iz==0) {
					pint[0].y = pint[1].y = pintAll[ix][0].y;
					pint[2].y = pint[3].y = crossingPoint[iz].y;
					i1 = 0;
					i2 = crossingInd[iz];
				}
				else if (iz==nz) {
					pint[0].y = pint[1].y = crossingPoint[nz-1].y;
					pint[2].y = pint[3].y = pintAll[ix][nt-1].y;
					i1 = crossingInd[nz-1];
					i2 = nt;
				}
				else {
					pint[0].y = pint[1].y = crossingPoint[iz-1].y;
					pint[2].y = pint[3].y = crossingPoint[iz].y;
					i1 = crossingInd[iz-1];
					i2 = crossingInd[iz];
				}

				if (pint[2].y - pint[0].y < 2) continue;
				amp = (xArr[ix][i1] < 0.f)  ?  getMinValue(&xArr[ix][i1], i2-i1)  :  getMaxValue(&xArr[ix][i1], i2-i1);

				// and then we use amp, head.maxAmp, draw.avgAmp to determine the color
				COLORREF aCol = getAmpRgb((float)amp);
				brushRed.CreateSolidBrush(aCol);
				varPen.CreatePen(PS_NULL, 0, aCol);
				oldBrush = pDC->SelectObject(&brushRed);
				oldPen = pDC->SelectObject(&varPen);
				pDC->Polygon(pint, 4);
				pDC->SelectObject(oldBrush);
				pDC->SelectObject(oldPen);
				varPen.DeleteObject(); // must delete before createPen again
				brushRed.DeleteObject();
			} // for iz
		} // for ix

		pDC->SetPolyFillMode(oldFill);
		free(crossingInd);
		//	free(crossingTime);
		free(crossingPoint);
		free2CPoint(pintAll);
		free (pint);
		free1int (pRangeArr);
		free(isUseArr);

		tStr.Format(_T("%d traces plotted while %d traces skipped."), draw.tracePlottedInDisplay, draw.traceSkippedInDisplay);
		myCaption(tStr);
	}

	void CSeisWideDoc::floodFillArr(CDC* pDC, int nx, int nt, float **xArr, float **yArr, double *rangeArr, double offFill)
	{
		if (nt <2) return;
		CPen* oldPen;
		CBrush* oldBrush;
		CBrush brushRed;
		CPen varPen;

		int ix,it, it2;
		double a, b, res=(double)pDC->GetDeviceCaps(HORZRES) / (double)pDC->GetWindowExt().cx;
		double amp;

		CPoint **pintAll = (CPoint **)alloc2CPoint(nt, nx);
		CPoint *pint = (CPoint *)malloc(4*sizeof(CPoint));  
		int *pRangeArr = (int *)ealloc1int(nx); 
		bool *isUseArr = (bool *)ealloc1int(nx); 
		CString tStr;
		if( pintAll == NULL || pint == NULL)
		{
			tStr.Format( _T("Insufficient memory available") );
			myCaption(tStr);
			return;
		}

		bool isTime = isTimeDomain() == TRUE;

		for (ix=0; ix<nx; ix++) {
			pRangeArr[ix] = pCd.mm_coordx((double)rangeArr[ix] );
			for (it=0; it<nt; it++)
				pintAll[ix][it] = pCd.mm_coord(xArr[ix][it], yArr[ix][it], isTime);
		}

		draw.tracePlottedInDisplay = 0;
		draw.traceSkippedInDisplay = 0;
		register CPoint pPrev, pCurr;
		pPrev.y = pCurr.y = 0;
		pPrev.x = pRangeArr[0];
		pDC->LPtoDP(&pPrev);
		for (ix=0; ix<nx; ix++) {
			isUseArr[ix] = false;
			pCurr = pRangeArr[ix];
			pDC->LPtoDP(&pCurr);
			if (ix>0 && abs(pPrev.x - pCurr.x) < 1) {
			}
			else if (getMaxValueAbsolute(&xArr[ix][0], nt) > head.aveAmp*0.001) {
				// needed to remove a very low amp trace, otherwise, one will see a white strip strongly
				isUseArr[ix] = true;
			}

			if (!isUseArr[ix]) {
				draw.traceSkippedInDisplay++;
			}
			else {
				draw.tracePlottedInDisplay++;
				pPrev = pCurr;
			}
		} // for ix

		int *crossingInd = (int *)malloc(sizeof(int)*nt); // for store index for zero-crossings
		int *crossingPy = (int *)malloc(nt*sizeof(int));

		// min fill amp is the usually 0.1 times the average amp
		offFill *= (head.maxAmp / para.gain);
		if (offFill < MINAMP) offFill = MINAMP;

		int oldFill= pDC->SetPolyFillMode(ALTERNATE);

		int iz;
		register int i1;
		register int i2;
		register int ix1;
		register int ix2;
		int nz;

		// ################################start for the negative amp
		for (ix=0; ix<nx; ix++) {
			if ( ix>0 && (int)(ix/100)*100 == ix) {
				tStr.Format(_T("Negtive Amp: %d of %d traces."), ix, nx);
				myCaption(tStr);
			}
			if (!isUseArr[ix]) continue;

			ix1 = ix-1;
			while (!isUseArr[ix1]) {
				ix1--; 
				if (ix1<=0) break;
			}
			if (ix1<0) ix1=0;

			ix2 = ix+1;
			while (!isUseArr[ix2]) {
				ix2++; 
				if (ix2>=nx-1) break;
			}
			if (ix2>nx-1) ix2=nx-1;

			bool isFoundStart = false;
			nz = 0; // number of zero crossings.
			for (it=0; it<nt-1; it++) {
				isFoundStart = false;
				if (it==0 && xArr[ix][0] < -offFill) {
					crossingPy[nz] = pCd.mm_coordy((double)yArr[ix][0], isTime);
					crossingInd[nz] = 0;
					nz++;
					isFoundStart = true;
				}
				else if ( xArr[ix][it] >= -offFill && xArr[ix][it+1] < -offFill ) {
					a = xArr[ix][it+1]-xArr[ix][it];
					if(fabs(a) < MINAMP) b = 0.0;
					else
						b = (yArr[ix][it+1]-yArr[ix][it])*(-offFill-xArr[ix][it])/a;
					b += yArr[ix][it];
					if(b>yArr[ix][it+1]) b=yArr[ix][it+1];
					else if (b < yArr[ix][it]) b = yArr[ix][it];
					crossingPy[nz] = pCd.mm_coordy(b, isTime);
					crossingInd[nz] = it+1;
					nz++;
					isFoundStart = true;
				} // if

				if (isFoundStart) {
					// try to locate the second point for plotting
					for (it2=it+1; it2<nt-1; it2++) {
						if ( xArr[ix][it2] < -offFill && xArr[ix][it2+1] >= -offFill ) {
							// found it
							a = xArr[ix][it2+1]-xArr[ix][it2];
							if(fabs(a) < MINAMP) b = 0.0;
							else
								b = (yArr[ix][it2+1]-yArr[ix][it2])*(-offFill-xArr[ix][it2])/a;
							b += yArr[ix][it2];
							if(b>yArr[ix][it2+1]) b=yArr[ix][it2+1];
							else if (b < yArr[ix][it2]) b = yArr[ix][it2];
							crossingPy[nz] = pCd.mm_coordy(b, isTime);
							crossingInd[nz] = it2;
							nz++;
							it = it2;
							isFoundStart = false; // mark it is completed. 
							break;
						} // if
					} // for it2
					if (isFoundStart) {
						// if here, it second plotting point is not found. We need to add the last point for it
						crossingPy[nz] = pCd.mm_coordy((double)yArr[ix][nt-1], isTime);
						crossingInd[nz] = nt-1;
						nz++;
						it = nt; // this will break out the loop
					}
				} // if isFoundStart
			} // for it
			if (nz < 2) {
				isUseArr[ix] = false;
				continue;
			}

			// nz must be an even number, containing pairs of start and end points for plotting
			// start the color filling
			pint[3].x = pint[0].x = (ix==0) ?  pRangeArr[0]  :  (pRangeArr[ix1] + pRangeArr[ix])/2;
			pint[2].x = pint[1].x = (ix==nx-1)  ?  pRangeArr[nx-1]  :  (pRangeArr[ix2] + pRangeArr[ix])/2;
			for (iz=0; iz<nz-1; iz+=2) {
				pint[0].y = pint[1].y = crossingPy[iz];
				pint[2].y = pint[3].y = crossingPy[iz+1];
				if (abs(pint[2].y - pint[0].y) < 2) continue;
				i1 = crossingInd[iz];
				i2 = crossingInd[iz+1];
				amp = getMinValue(&xArr[ix][i1], i2-i1+1);
				//amp = -head.maxAmp;

				// and then we use amp, head.maxAmp, draw.avgAmp to determine the color
				COLORREF aCol = getAmpRgb((float)amp);
				brushRed.CreateSolidBrush(aCol);
				varPen.CreatePen(PS_NULL, 0, aCol);
				oldBrush = pDC->SelectObject(&brushRed);
				oldPen = pDC->SelectObject(&varPen);
				pDC->Polygon(pint, 4);
				pDC->SelectObject(oldBrush);
				pDC->SelectObject(oldPen);
				varPen.DeleteObject(); // must delete before createPen again
				brushRed.DeleteObject();
			} // for iz
		} // for ix
		// ################################end for the negative amp



		// ################################start for the positive amp
		for (ix=0; ix<nx; ix++) {
			if ( ix>0 && (int)(ix/100)*100 == ix) {
				tStr.Format(_T("Positive Amp: %d of %d traces."), ix, nx);
				myCaption(tStr);
			}
			if (!isUseArr[ix]) continue;

			ix1 = ix-1;
			while (!isUseArr[ix1]) {
				ix1--; 
				if (ix1<=0) break;
			}
			if (ix1<0) ix1=0;

			ix2 = ix+1;
			while (!isUseArr[ix2]) {
				ix2++; 
				if (ix2>=nx-1) break;
			}
			if (ix2>nx-1) ix2=nx-1;
			pint[3].x = pint[0].x = (ix==0) ?  pRangeArr[0]  :  (pRangeArr[ix1] + pRangeArr[ix])/2;
			pint[2].x = pint[1].x = (ix==nx-1)  ?  pRangeArr[nx-1]  :  (pRangeArr[ix2] + pRangeArr[ix])/2;

			bool isFoundStart = false;
			nz = 0; // number of zero crossings.
			for (it=0; it<nt-1; it++) {
				isFoundStart = false;
				if (it==0 && xArr[ix][0] > offFill) {
					crossingPy[nz] = pCd.mm_coordy((double)yArr[ix][0], isTime);
					crossingInd[nz] = 0;
					nz++;
					isFoundStart = true;
				}
				else if ( xArr[ix][it] <= offFill && xArr[ix][it+1] > offFill ) {
					a = xArr[ix][it+1]-xArr[ix][it];
					if(fabs(a) < MINAMP) b = 0.0;
					else
						b = (yArr[ix][it+1]-yArr[ix][it])*(offFill-xArr[ix][it])/a;
					b += yArr[ix][it];
					if(b>yArr[ix][it+1]) b=yArr[ix][it+1];
					else if (b < yArr[ix][it]) b = yArr[ix][it];
					crossingPy[nz] = pCd.mm_coordy(b, isTime);
					crossingInd[nz] = it+1;
					nz++;
					isFoundStart = true;
				} // if

				if (isFoundStart) {
					// try to locate the second point for plotting
					for (it2=it+1; it2<nt-1; it2++) {
						if ( xArr[ix][it2] > offFill && xArr[ix][it2+1] <= offFill ) {
							// found it
							a = xArr[ix][it2+1]-xArr[ix][it2];
							if(fabs(a) < MINAMP) b = 0.0;
							else
								b = (yArr[ix][it2+1]-yArr[ix][it2])*(offFill-xArr[ix][it2])/a;
							b += yArr[ix][it2];
							if(b>yArr[ix][it2+1]) b=yArr[ix][it2+1];
							else if (b < yArr[ix][it2]) b = yArr[ix][it2];
							crossingPy[nz] = pCd.mm_coordy(b, isTime);
							crossingInd[nz] = it2;
							nz++;
							it = it2;
							isFoundStart = false; // mark it is completed. 
							break;
						} // if
					} // for it2
					if (isFoundStart) {
						// if here, it second plotting point is not found. We need to add the last point for it
						crossingPy[nz] = pCd.mm_coordy((double)yArr[ix][nt-1], isTime);
						crossingInd[nz] = nt-1;
						nz++;
						it = nt; // this will break out the loop
					}
				} // if isFoundStart
			} // for it
			if (nz < 2) {
				isUseArr[ix] = false;
				continue;
			}

			// nz must be an even number, containing pairs of start and end points for plotting
			// start the color filling
			pint[3].x = pint[0].x = (ix==0) ?  pRangeArr[0]  :  (pRangeArr[ix1] + pRangeArr[ix])/2;
			pint[2].x = pint[1].x = (ix==nx-1)  ?  pRangeArr[nx-1]  :  (pRangeArr[ix2] + pRangeArr[ix])/2;
			for (iz=0; iz<nz-1; iz+=2) {
				pint[0].y = pint[1].y = crossingPy[iz];
				pint[2].y = pint[3].y = crossingPy[iz+1];
				if (abs(pint[2].y - pint[0].y) < 2) continue;
				i1 = crossingInd[iz];
				i2 = crossingInd[iz+1];
				amp = getMaxValue(&xArr[ix][i1], i2-i1+1);

				// and then we use amp, head.maxAmp, draw.avgAmp to determine the color
				COLORREF aCol = getAmpRgb((float)amp);
				brushRed.CreateSolidBrush(aCol);
				varPen.CreatePen(PS_NULL, 0, aCol);
				oldBrush = pDC->SelectObject(&brushRed);
				oldPen = pDC->SelectObject(&varPen);
				pDC->Polygon(pint, 4);
				pDC->SelectObject(oldBrush);
				pDC->SelectObject(oldPen);
				varPen.DeleteObject(); // must delete before createPen again
				brushRed.DeleteObject();
			} // for iz

		} // for ix
		// ################################end for the positive amp

		pDC->SetPolyFillMode(oldFill);
		free(crossingInd);
		free(crossingPy);
		free2CPoint(pintAll);
		free (pint);
		free1int (pRangeArr);
		free(isUseArr);

		tStr.Format(_T("%d traces plotted; %d traces skipped."), draw.tracePlottedInDisplay, draw.traceSkippedInDisplay);
		myCaption(tStr);
	}



	void CSeisWideDoc::pltFloodFill(CDC* pDC, CPoint *pPoly, int *lpPts,  int np) 
	{
		if (np > 3)
			pDC->PolyPolygon(&pPoly[0], lpPts, np); 
	}






	BOOL CSeisWideDoc::wiggleArr(CDC* pDC, int nx, int nt, float **xArr, float *rangeArr, float *yArr)
	{
		if (nt <2) return FALSE;


		CPoint *plt = (CPoint *)alloc1(nt, sizeof(CPoint));
		bool isTime = isTimeDomain() == TRUE;

		CPoint pPrev, pCurr;
		pPrev.y = pCurr.y = 0;
		pPrev.x = pCd.mm_coordx((double)rangeArr[0]);
		pDC->LPtoDP(&pPrev);

		CPen* oldPen;
		CPen blackPen(PS_SOLID, 0, RGB(0,0,0));

		for (int i=0; i<nx; i++) {
			if (i > 0) {
				pCurr = pCd.mm_coordx((double)rangeArr[i]);
				pDC->LPtoDP(&pCurr);
				if (abs(pPrev.x - pCurr.x) < 1+1) {
					continue;
				} else {
					pPrev = pCurr;
				}
			} // if

			for (int j=0; j<nt; j++)
				plt[j] = pCd.mm_coord( xArr[i][j],   yArr[j], isTime);
			oldPen = pDC->SelectObject(&blackPen);
			pDC->Polyline(plt, nt);
			pDC->SelectObject(oldPen);
		} // for i
		free (plt);

		return TRUE;
	}


	BOOL CSeisWideDoc::floodFillArr5Multi(CDC* pDC, int nx, int nt, float **xArr, float *rangeArr, double xmin,  double xmax, double tmin,  double tmax, int actualMBPerPlotPanel)
	{
		// to deal with large memory issues
		if (nt <2) return FALSE;

		// bitmaps are always generated with positive ncol and nrow
		int ncol = (int)myRound((xmax-xmin) / (pCd.coord.axisX2 - pCd.coord.axisX1) * pCd.coord.deviceAxes.Width());
		int nrow = (int)myRound((tmax-tmin) / (pCd.coord.axisY2 - pCd.coord.axisY1) * pCd.coord.deviceAxes.Height());
		ncol = abs(ncol) + 1;
		nrow = abs(nrow) + 1;
		double actualMBRequired = ncol * nrow * 4 / MIL;


		//if (ampColorDyn.numContours > 100) ampColorDyn.numContours = 100;
		COLORREF *colArr = (COLORREF *)malloc( (ampColorDyn.num + 50) * sizeof(COLORREF));
		// note: here if I only allocate ampColorDyn.num values, it crashes since it is only 11.
		//      

		//if (!getExpandedColorTableDepreciated(colArr, percentAmpExpanded, ampColorDyn.numContours)) {
		//	ampColorDyn.numContours = ampColorDyn.num; // if cannot be expanded, just use the original number of colors
		//} // if
		getAmpColorArray(); // we always read the color table from file whenever plotting starts
		for (int i=0; i<ampColorDyn.num; i++) {
			colArr[i] = RGB(ampColorDyn.r[i], ampColorDyn.g[i], ampColorDyn.b[i]);
		}

		//	free(colArr);

		BOOL isTrueOut;
		if (fabs(actualMBRequired) < actualMBPerPlotPanel)   // actualMBRequired can be minus
			isTrueOut = floodFillArr5(pDC, nx, nt, xArr, rangeArr, 
			xmin, xmax, tmin, tmax, 
			colArr);
		else {
			// now split x axis for plotting
			double xincPlot = (double)actualMBPerPlotPanel / (double)(nrow*4) * MIL * (pCd.coord.axisX2 - pCd.coord.axisX1) / (double)pCd.coord.deviceAxes.Width();
			double xminPlot = xmin;
			do {
				if (xminPlot >= xmax) break;
				double xmaxPlot = xminPlot + xincPlot;
				if (xmaxPlot > xmax) xmaxPlot = xmax;
				floodFillArr5(pDC, nx, nt, xArr, rangeArr, 
					xminPlot, xmaxPlot, tmin, tmax,
					colArr);
				xminPlot += xincPlot;
			} while (xminPlot < xmax);
			isTrueOut = TRUE;
		}
		free(colArr);
		//free(percentAmpExpanded);

		return isTrueOut;
	}

	BOOL CSeisWideDoc::floodFillArr5(CDC* pDC, int nx, int nt, float **xArr, float *rangeArr, 
		double xmin,  double xmax, double tmin,  double tmax, 
		COLORREF *colArr)
	{
		// will use globals: pCd.coord.ix1, ix2, iy1, iy2, x1, x2
		// xmin and xmax may be different from pCd.coord.xmin and pCd.coord.xmax
		if (nt <2) return FALSE;
		CString tStr;
		int ix, iy, irow, icol;
		double y;

		// test for monotonically inceasing
		bool isMonoInc = true;
		for (ix=0; ix<nx-1; ix++) {
			if (rangeArr[ix] > rangeArr[ix+1]) {
				// failed the test
				isMonoInc = false;
				break;
			}
		}
		// note: SegyWrapperEx class will automatically sort segy traces according to either distance or offsets
		//  so here it is usually always monoInc!
		//isMonoInc = false;  // tesing


		// calculate how many rows and columns for the bitmap are needed: pCd.coord.deviceAxes.Height() < 0 when displayed facing up

		// bitmaps are always generated with positive ncol and nrow
		int ncol = (int)myRound((xmax-xmin) / (pCd.coord.axisX2 - pCd.coord.axisX1) * pCd.coord.deviceAxes.Width());
		int nrow = (int)myRound((tmax-tmin) / (pCd.coord.axisY2 - pCd.coord.axisY1) * pCd.coord.deviceAxes.Height());
		ncol = abs(ncol) + 1;
		nrow = abs(nrow) + 1;

		// one can either load an existing bitmap file or create an empty bitmap object
		CDib dib;

		TRY {
			// note: after this call, nrow or ncol can change
			float reduceRate = dib.Create24(&ncol, &nrow, draw.memMaxMB);
			if (reduceRate == 0.f) {
				tStr.Format(_T("Failed to create bitmap with %d MB max memory. Try reduce max memory of usage."), draw.memMaxMB);
				// throw std::runtime_error(std::string("Failed to create %d GB bitmap in memory."));
				myCaption(tStr);
				return FALSE;
			}

			dib.SetPalette(pDC );

			// note:  draw.trcInt  did not include trace skipping. So we have to re-calculate the allowable trace span width during display
			double *ampArr = (double *)ealloc1double(nrow);

			float *dx = (float *)ealloc1float(nx);
			for (ix=1; ix<nx; ix++) {
				dx[ix-1] = (float)fabs(rangeArr[ix]-rangeArr[ix-1]);
			}
			double traceSpanMax = 3.0 * getMedianValue(dx, nx-1);	//This is the average trace interval in km.
			free1float(dx);


			//double xRate = (pCd.coord.axisX2-pCd.coord.axisX1) /(double)(ncol-1);
			double xRate = (xmax-xmin) /(double)(ncol-1);
			double tRate = (tmax - tmin) /(double)(nrow-1);
			// note: yRate is for each pixel increment, while dt is for each data sample. They are different
			//yRate /= reduceRate;
			double dt = (tmax - tmin) / (double)(nt-1);

			int ix0 = 0;
			static COLORREF colWhite = RGB(255, 255, 255);
			for (icol=0; icol<ncol; icol++) {
				register float xfloat = (float)(xmin + icol * xRate);
				ix0 = 0;
				ix = getClosestIndex(rangeArr, nx, xfloat, ix0);
				if (ix<0 || fabs(rangeArr[ix] - xfloat) > traceSpanMax) {
					for (irow=0; irow<nrow; irow++) {
						dib.SetDibBit24(icol, irow, colWhite);
					}
				}
				else {
					if (!isMonoInc) {
						iy = 0;
						for (irow=0; irow<nrow; irow++) {
							y = tmin + irow * tRate;
							iy = getClosestIndex(tmin, dt, nt, y, iy);
							dib.SetDibBit24(icol, irow, 
								getColorRef4Amp( xArr[ix][iy], ampColorDyn.num, ampColorDyn.percentAmp, colArr) );
						} // for irow
					}
					else {
						// note: rangeArr[] should be monotonically increasing or decreasing, what about if not? Then we should use the closest index only!
						register int jx = -1;
						if (xfloat<=rangeArr[0]) jx=0;
						else if (xfloat>=rangeArr[nx-1]) jx=nx-1;
						else {
							for (int i=0; i<nx-1; i++) {
								if ( xfloat>= rangeArr[i] && xfloat<= rangeArr[i+1]) {
									jx = i;
									break;
								}
							}
						}

						if (jx<0) {
							// this would mean the data index cannot be found. Usually meaning no data in the display window. 
							// because of the programming effort above, this has not happened, and should not.
							jx=0;
						}
						else if (jx>nx-1) jx=nx-1;

						register int jx2 = jx+1;
						if (jx2>nx-1) jx2=nx-1;
						register double ax = rangeArr[jx2] - rangeArr[jx];
						register double percentFromJx = fabs(ax) < MINAMP  ?  0.  :  (xfloat - rangeArr[jx]) / ax;
						if (percentFromJx < 0.0) percentFromJx = 0.0;
						else if (percentFromJx>1.0) percentFromJx = 1.0;

						//for (irow=0; irow<nrow; irow++) {
						//	y = tmin + irow * yRate;
						//	register double amp = getAmpAtXY( xArr, nx, nt, tmin, dt, y, jx, jx2, percentFromJx);
						//	dib.SetDibBit24(icol, irow, getColorRef4Amp(amp, ampColorDyn.num, ampColorDyn.percentAmp, colArr));
						//}
						if ( getAmpAtXY( xArr, nx, nt, tmin, dt, 
							tRate, ampArr, nrow,
							jx, jx2, percentFromJx) ) {
								for (irow=0; irow<nrow; irow++) {
									dib.SetDibBit24(icol, irow, getColorRef4Amp(ampArr[irow], ampColorDyn.num, ampColorDyn.percentAmp, colArr));
								}
						} // if
					}
				}
			} // for icol

			// these functions might become useful later
			//pDC->SetStretchBltMode(HALFTONE);
			//CSize size = pDC->GetWindowExt();

			// NOTE: ft (in sec) corresponds to the first data point in y. But pCd.coord.logicalAxes.top in client coordinate is the min Y-axis. They may be different!
			bool isTime = isTimeDomain() == TRUE;
			CPoint p1 = pCd.mm_coord(xmin, tmin, isTime);
			CPoint p2 = pCd.mm_coord(xmax, tmax, isTime);
			iy = min(p1.y, p2.y);
			p2.y = max(p1.y, p2.y);
			p1.y = iy;


			if (! dib.Draw( pDC, p1.x, p1.y, p2.x - p1.x, p2.y - p1.y, !pCd.coord.isFaceUp)) {
				// throw  std::runtime_error("Could not draw bitmap.");   // no effect in this throw. Why???
				throw;
			}

			free1double(ampArr);

			//if (!dib.DrawEx( pDC, p1.x, p1.y, p2.x - p1.x, p2.y - p1.y, 
			//	!pCd.coord.isFaceUp)) {
			//		AfxMessageBox(_T("Could not draw bitmap."));
			//		return;
			//}
			//} catch(std::exception const& e) {
			//	tStr = e.what();
			//	AfxMessageBox(tStr);
			//} catch (CException *e) {
			//	TCHAR   szCause[255];
			//	e->GetErrorMessage(szCause, 255);
			//	tStr = szCause;
			//	AfxMessageBox(tStr);
		} 
		CATCH_ALL(e)
		{ 
			tStr.Format(_T("Failed to create bitmap with %d MB max memory."), draw.memMaxMB);
			return FALSE;
		}
		END_CATCH_ALL

			if (tStr.GetLength() > 0)
				AfxMessageBox(tStr);

		return TRUE;
	}

	void CSeisWideDoc::airColD1Small(CDC* pDC, int n, double x[], double y[], double range, double offFill)
	{
		airCol1Small(pDC, n, &x[0], &y[0], range, offFill);
		return;

		// this special depth drawing routine is depreciated... June 2, 2009

	}

	void CSeisWideDoc::airCol(CDC* pDC, int n, double x[], double y[], double range, double offFill)
	{
		//note that offFill has to be passed into this routine, but not have to for airvar().
		//offFill is scaled by para.gainReal such that if offFill=1, only amplitudes spanning 
		//more than a trace interval get filled. Normally offfill=0.1.
		int numfa,i,j0,j1,pixelOffFill;
		double a, b, range1,res=(double)pDC->GetDeviceCaps(HORZRES) / (double)pDC->GetWindowExt().cx;
		CPen* oldPen;
		CBrush* oldBrush;

		CPoint *pintAll,*pint,prange,prange1;
		pintAll = (CPoint *)malloc(n*sizeof(CPoint));
		pint = (CPoint *)malloc(2*n*sizeof(CPoint));  //pint will use more than n points.
		if( pintAll == NULL || pint == NULL)
		{
			AfxMessageBox( _T("Insufficient memory available") );
			return;
		}

		CPen nullPen(PS_NULL, 0, RGB(255,255,255));
		CBrush brush, brushRed;
		brush.CreateSolidBrush(RGB(seisBiColor2.maxAmpR,seisBiColor2.maxAmpG,seisBiColor2.maxAmpB));
		brushRed.CreateSolidBrush(RGB(seisBiColor2.negAmpR,seisBiColor2.negAmpG,seisBiColor2.negAmpB));
		int oldFill= pDC->SetPolyFillMode(ALTERNATE);

		bool isTime = isTimeDomain() == TRUE;

		for (i=0; i<n; i++)
			if ( ! _isnan(x[i]))  
				pintAll[i] = pCd.mm_coord(x[i],y[i], isTime);
		oldPen = pDC->SelectObject(&nullPen);

		//START FILL the left half.
		oldBrush = pDC->SelectObject(&brushRed);
		prange = pCd.mm_coord(range,0., isTime);
		range1 = range-offFill; //real trace line.
		prange1 = pCd.mm_coord(range1,0., isTime);
		pixelOffFill = (int)myRound((prange.x-prange1.x) * res); //no. of pixels to offset from range line.
		numfa=0;

		j0 = (int)myRound((pintAll[0].x-prange.x)*res);
		if(j0 < -pixelOffFill)
		{
			pint[0] = pCd.mm_coord(range1,y[0], isTime);
			pint[1] = pintAll[0];
			numfa+=2;
		}

		for (i=1; i<n; i++) 
		{
			j0 = (int)myRound((pintAll[i-1].x-prange.x)*res);
			j1 = (int)myRound((pintAll[i].x-prange.x)*res);
			if( j1>-pixelOffFill && j0>=-pixelOffFill ) continue; //do not fill anything.
			else if ( j1==-pixelOffFill && j0>=-pixelOffFill )
			{ //this case is special for fill once: airColD1Small() does not need to consider this.
				//note that the shift to prange1.x is important: when pint[] is mapped to screen coordinates,
				//if VC++ finds two pint[] not identical, it'll fill something even though no pixel exists there.
				pint[numfa].y = pintAll[i].y;
				pint[numfa].x = prange1.x;
				numfa++;
			}
			else if( j1<-pixelOffFill && j0<-pixelOffFill)
			{
				pint[numfa] = pintAll[i];
				numfa++;
			}
			else if( j1<-pixelOffFill && j0>=-pixelOffFill)
			{
				a = x[i]-x[i-1];
				if(fabs(a) < 0.0000001) b = y[i-1];
				else
					b = y[i-1] + (y[i]-y[i-1])*(range1-x[i-1])/a;
				if(b<y[i-1]) b = y[i-1];
				pint[numfa] = pCd.mm_coord(range1,b, isTime);
				pint[numfa+1] = pintAll[i];
				numfa+=2;
			}
			else if( j1==-pixelOffFill && j0<-pixelOffFill )
			{
				pint[numfa] = pintAll[i];
				pint[numfa+1].x = prange1.x;
				pint[numfa+1].y = pintAll[i].y;
				numfa+=2;
			}
			else if( j1>-pixelOffFill && j0<-pixelOffFill)
			{
				a = x[i]-x[i-1];
				if(fabs(a) < 0.0000001) b = y[i-1];
				else
					b = y[i-1] + (y[i]-y[i-1])*(range1-x[i-1])/a;
				if(b>y[i]) b=y[i];
				pint[numfa] = pCd.mm_coord(range1,b, isTime);
				numfa++;
			}
		}

		pint[numfa] = pCd.mm_coord(range1,y[n-1], isTime);
		numfa++;
		if(numfa>2) pDC->Polygon(pint, numfa);
		pDC->SelectObject(oldBrush);

		//START FILL the right half.
		oldBrush = pDC->SelectObject(&brush);
		prange = pCd.mm_coord(range,0., isTime);
		range1 = range+offFill; //real trace line.
		prange1 = pCd.mm_coord(range1,0., isTime);
		pixelOffFill = (int)myRound((prange1.x-prange.x) * res); //no. of pixels to offset from range line.
		numfa=0; 

		j0 = (int)myRound((pintAll[0].x-prange.x)*res);
		if(j0 > pixelOffFill)
		{
			pint[0] = pCd.mm_coord(range1,y[0], isTime);
			pint[1] = pintAll[0];
			numfa+=2;
		}

		for (i=1; i<n; i++) 
		{
			j0 = (int)myRound((pintAll[i-1].x-prange.x)*res);
			j1 = (int)myRound((pintAll[i].x-prange.x)*res);
			if( j1<pixelOffFill && j0<=pixelOffFill ) continue; //do not fill anything.
			else if ( j1==pixelOffFill && j0<=pixelOffFill )
			{ //this case is special for fill once: small fills do not need to consider this.
				pint[numfa].y = pintAll[i].y;
				pint[numfa].x = prange1.x;
				numfa++;
			}
			else if( j1>pixelOffFill && j0>pixelOffFill)
			{
				pint[numfa] = pintAll[i];
				numfa++;
			}
			else if( j1>pixelOffFill && j0<=pixelOffFill)
			{
				a = x[i]-x[i-1];
				if(fabs(a) < 0.0000001) b = y[i-1];
				else
					b = y[i-1] + (y[i]-y[i-1])*(range1-x[i-1])/a;
				if(b<y[i-1]) b = y[i-1];
				pint[numfa] = pCd.mm_coord(range1,b, isTime);
				pint[numfa+1] = pintAll[i];
				numfa+=2;
			}
			else if( j1==pixelOffFill && j0>pixelOffFill )
			{
				pint[numfa] = pintAll[i];
				pint[numfa+1].x = prange1.x;
				pint[numfa+1].y = pintAll[i].y;
				numfa+=2;
			}
			else if( j1<pixelOffFill && j0>pixelOffFill)
			{
				a = x[i]-x[i-1];
				if(fabs(a) < 0.0000001) b = y[i-1];
				else
					b = y[i-1] + (y[i]-y[i-1])*(range1-x[i-1])/a;
				if(b>y[i]) b=y[i];
				pint[numfa] = pCd.mm_coord(range1,b, isTime);
				numfa++;
			}
		}

		pint[numfa] = pCd.mm_coord(range1,y[n-1], isTime);
		numfa++;
		if(numfa>2) pDC->Polygon(pint, numfa);
		pDC->SelectObject(oldBrush);

		pDC->SelectObject(oldPen);
		pDC->SetPolyFillMode(oldFill);

		free (pintAll);
		free (pint);
		nullPen.DeleteObject();
		brush.DeleteObject(); 
	}

	void CSeisWideDoc::airColD(CDC* pDC, int n, double x[], double y[], double range, double offFill)
	{
		airCol(pDC, n, &x[0], &y[0], range, offFill);
		return;

	}

	void CSeisWideDoc::airvarSmall(CDC* pDC, int n, double x[], double y[], double range)
	{
		if (n <2) return;
		int numfa,i,j0,j1;
		double a, b, res=(double)pDC->GetDeviceCaps(HORZRES) / (double)pDC->GetWindowExt().cx;

		CPoint *pintAll,*pint,prange;
		pintAll = (CPoint *)malloc(n*sizeof(CPoint));
		pint = (CPoint *)malloc(2*n*sizeof(CPoint));  //pint will use more than n points.
		if( pintAll == NULL || pint == NULL)
		{
			free (pintAll);
			free (pint);
			AfxMessageBox( _T("Insufficient memory available") );
			return;
		}

		bool isTime = isTimeDomain() == TRUE;

		prange = pCd.mm_coord(range,0., isTime);
		for (i=0; i<n; i++)
			if ( ! _isnan(x[i]))  
				pintAll[i] = pCd.mm_coord(x[i],y[i], isTime);
		CPen nullPen(PS_NULL, 0, RGB(255,255,255));
		CBrush brush;
		brush.CreateSolidBrush(RGB(0,0,0));
		CPen* oldPen;
		CBrush* oldBrush;
		//	int oldFill= pDC->SetPolyFillMode(ALTERNATE);
		oldPen = pDC->SelectObject(&nullPen);
		oldBrush = pDC->SelectObject(&brush);

		numfa=0; 
		j0 = (int)myRound((pintAll[0].x-prange.x)*res);
		if(j0 > 0)
		{
			pint[0] = pCd.mm_coord(range,y[0], isTime);
			pint[1] = pintAll[0];
			numfa+=2;
		}


		for (i=1; i<n; i++) 
		{
			j0 = (int)myRound((pintAll[i-1].x-prange.x)*res);
			j1 = (int)myRound((pintAll[i].x-prange.x)*res);
			if( j1>0 && j0>0)
			{
				pint[numfa] = pintAll[i];
				numfa++;
			}
			else if( j1>0 && j0<=0)
			{
				a = x[i]-x[i-1];
				if(fabs(a) < 0.0000001) b = y[i-1];
				else
					b = y[i-1] + (y[i]-y[i-1])*(range-x[i-1])/a;
				if(b<y[i-1]) b = y[i-1];
				pint[numfa] = pCd.mm_coord(range,b, isTime);
				pint[numfa+1] = pintAll[i];
				numfa+=2;
			}
			else if( j1==0 && j0>0 )
			{
				pint[numfa] = pintAll[i];
				pint[numfa+1].x = prange.x;
				pint[numfa+1].y = pintAll[i].y;
				numfa+=2;
				if(numfa>2 && numfa<100)
				{
					pDC->Polygon(pint, numfa);
				}
				numfa=0;
			}
			else if( j1<0 && j0>=0)
			{
				a = x[i]-x[i-1];
				if(fabs(a) < 0.0000001) b = y[i-1];
				else
					b = y[i-1] + (y[i]-y[i-1])*(range-x[i-1])/a;
				if(b>y[i]) b=y[i];
				pint[numfa] = pCd.mm_coord(range,b, isTime);
				//		pint[numfa+1].x = prange.x;
				//		pint[numfa+1].y = pint[numfa].y;
				numfa++;

				if(numfa>2 && numfa<100)
				{
					pDC->Polygon(pint, numfa);
				}
				numfa=0;
			}
			else numfa=0;
		}

		pint[numfa] = pCd.mm_coord(range,y[n-1], isTime);
		numfa++;
		if(numfa>2 && numfa<100) pDC->Polygon(pint, numfa);

		pDC->SelectObject(oldPen);
		pDC->SelectObject(oldBrush);
		//	pDC->SetPolyFillMode(oldFill);
		free (pintAll);
		free (pint);

		nullPen.DeleteObject();
		brush.DeleteObject(); 
	}

	void CSeisWideDoc::airvarSmallNeg(CDC* pDC, int n, double x[], double y[], double range)
	{
		// this function is depreciated
		airvarSmall(pDC, n, &x[0], &y[0], range);
		return;

		/*
		int numfa,i,j0,j1;
		double a, b, res=(double)pDC->GetDeviceCaps(HORZRES) / (double)pDC->GetWindowExt().cx;

		CPoint *pintAll,*pint,prange;
		pintAll = (CPoint *)malloc(n*sizeof(CPoint));
		pint = (CPoint *)malloc(2*n*sizeof(CPoint));  //pint will use more than n points.
		if( pintAll == NULL || pint == NULL)
		{
		free (pintAll);
		free (pint);
		AfxMessageBox( _T("Insufficient memory available" );
		return;
		}

		prange = pCd.mm_coord(range,0.);
		for (i=0; i<n; i++)
		if ( ! _isnan(x[i]))  
		pintAll[i] = pCd.mm_coord(x[i],y[i]);
		CPen nullPen(PS_NULL, 0, RGB(255,255,255));
		CBrush brush;
		brush.CreateSolidBrush(RGB(0,0,0));
		//	int oldFill= pDC->SetPolyFillMode(ALTERNATE);
		oldPen = pDC->SelectObject(&nullPen);
		oldBrush = pDC->SelectObject(&brush);

		numfa=0; 
		j0 = (int)myRound((pintAll[0].x-prange.x)*res);
		if(j0 > 0)
		{
		pint[0] = pCd.mm_coord(range,y[0]);
		pint[1] = pintAll[0];
		numfa+=2;
		}


		for (i=1; i<n; i++) 
		{
		j0 = -myRound((pintAll[i-1].x-prange.x)*res);
		j1 = -myRound((pintAll[i].x-prange.x)*res);
		if( j1>0 && j0>0)
		{
		pint[numfa] = pintAll[i];
		numfa++;
		}
		else if( j1>0 && j0<=0)
		{
		a = x[i]-x[i-1];
		if(fabs(a) < 0.0000001) b = y[i-1];
		else
		b = y[i-1] + (y[i]-y[i-1])*(range-x[i-1])/a;
		if(b<y[i-1]) b = y[i-1];
		pint[numfa] = pCd.mm_coord(range,b);
		pint[numfa+1] = pintAll[i];
		numfa+=2;
		}
		else if( j1==0 && j0>0 )
		{
		pint[numfa] = pintAll[i];
		pint[numfa+1].x = prange.x;
		pint[numfa+1].y = pintAll[i].y;
		numfa+=2;
		if(numfa>2 && numfa<100)
		{
		pDC->Polygon(pint, numfa);
		}
		numfa=0;
		}
		else if( j1<0 && j0>0)
		{
		a = x[i]-x[i-1];
		if(fabs(a) < 0.0000001) b = y[i-1];
		else
		b = y[i-1] + (y[i]-y[i-1])*(range-x[i-1])/a;
		if(b>y[i]) b=y[i];
		pint[numfa] = pCd.mm_coord(range,b);
		//		pint[numfa+1].x = prange.x;
		//		pint[numfa+1].y = pint[numfa].y;
		numfa++;

		if(numfa>2 && numfa<100)
		{
		pDC->Polygon(pint, numfa);
		}
		numfa=0;
		}
		else numfa=0;
		}

		pint[numfa] = pCd.mm_coord(range,y[n-1]);
		numfa++;
		if(numfa>2 && numfa<100) pDC->Polygon(pint, numfa);

		pDC->SelectObject(oldPen);
		pDC->SelectObject(oldBrush);
		//	pDC->SetPolyFillMode(oldFill);
		free (pintAll);
		free (pint);

		nullPen.DeleteObject();
		brush.DeleteObject(); 
		*/
	}

	//void CSeisWideDoc::airvarD(CDC* pDC, int n, double x[], double y[], double range)
	//{
	//	airvar(pDC, n, &x[0], &y[0], range);
	//	return;
	//
	//	// this routine is depreciated... June 1, 2009
	//}

	void CSeisWideDoc::airvarDSmall(CDC* pDC, int n, double x[], double y[], double range)
	{
		airvarSmall(pDC, n, &x[0], &y[0], range);
		return;

		// this routine is depreciated... June 1, 2009

	}




	// depreciated
	void CSeisWideDoc::bitmapFill(CDC* pDC, int n, double amp[], double y[], double range, int lastTrcPixelPlotted) 
	{
		if (n <2) return;
		for (int i=0; i<n; i++) amp[i] += range;
		BackgrdFill(pDC, n, &amp[0], &y[0], range, 0.);
		return;
		/*
		// plot for other wiggle options
		// note: traces must be ordered for bitmap fill.
		// we now want to let the current trace (trcPixcel) to cover all pixels from the last trace (lastTrcPixelPlotted) 
		//    to this current trace
		if (ampColorDyn.r == NULL && !getAmpColorArray()) return;

		// problem..... fix me
		if (ampColorDyn.num != 11) return; // we can only handle 11 colors here
		CPen penArr[11];
		int i, ii;
		for (i=0; i<ampColorDyn.num; i++) {
		penArr[i].CreatePen(PS_SOLID, 1, RGB(ampColorDyn.r[i], ampColorDyn.g[i], ampColorDyn.b[i]));

		//LOGPEN logpen;
		//CPen pen(PS_SOLID, 1, RGB(ampColorDyn.r[i], ampColorDyn.g[i], ampColorDyn.b[i]));
		//pen.GetLogPen(&logpen);
		//penArr[i].CreatePenIndirect(&logpen);
		//pen.DeleteObject();
		}



		draw.tracePlottedInDisplay = 0;
		draw.traceSkippedInDisplay = 0;

		if (draw.isCopying) {
		int yyy = 1;
		//return;  // testing
		}

		oldPen = pDC->SelectObject(&penArr[0]);


		COLORREF *colArr =  (COLORREF *)malloc(n*sizeof(COLORREF));
		CPoint trcPixel;
		trcPixel.x = (long)mm_coord((float)range);
		trcPixel.y = 0;
		pDC->LPtoDP(&trcPixel);
		if( (abs(lastTrcPixelPlotted - trcPixel.x) < draw.pixelThreshold ) ) {
		draw.traceSkippedInDisplay ++;
		return;  // no need to plot this trace
		}
		draw.tracePlottedInDisplay ++;

		for (i=0; i<n; i++) {
		colArr[i] = getAmpRgbPixel((float)amp[i], -(float)head.maxAmp, (float)head.maxAmp);
		}


		CPoint p1Client = pCd.mm_coord(range,y[0]);
		CPoint p1 = p1Client;
		pDC->LPtoDP(&p1);
		CPoint p2Client = pCd.mm_coord(range,y[n-1]);
		CPoint p2 = p2Client;
		pDC->LPtoDP(&p2);
		if (p2.y - p1.y == 0) return;
		double yrate = (double)(p2Client.y - p1Client.y) / (double)(p2.y - p1.y);
		CPoint p;
		p.y = 0;  // this is not really used, but has to be set properly, otherwie it may crash

		if (lastTrcPixelPlotted < 0) {
		p.x = p1Client.x;
		for (ii = p1.y; ii<= p2.y; ii++) {
		i = (int)myRound(  (double)(n-1) / (double)(p2.y - p1.y) * (double)(ii - p1.y)  ); 
		if (i > n-1) i = n-1;
		if (i < 0) i = 0;

		// we now want to plot the pixel for plt[i].x  with  colArr[i]  color. However, plt[i].y  need to be updated for every pixel !
		p.y = (int)myRound((double)p1Client.y + yrate*(double)(ii - p1.y));
		if (fabs(amp[i]) > MINAMP)
		pDC->SetPixel(p, colArr[i]);
		} // for ii
		}
		else {
		int ix1 = lastTrcPixelPlotted+1;
		int ix2 = trcPixel.x + 1;
		if (trcPixel.x < lastTrcPixelPlotted) {
		// however, when the traces are reversely ordered, we need to do it the other way for ix1, ix2
		ix1 = trcPixel.x;
		ix2 = lastTrcPixelPlotted;
		}
		// now have for sure ix2>ix1
		p.x = ix1;
		p.y = 0;
		pDC->DPtoLP(&p);
		int ix1Client = p.x;
		p.x = ix2;
		p.y = 0;
		pDC->DPtoLP(&p);
		int ix2Client = p.x;

		// array holding the timing info: plt[i].y  in logical coord, where i is calculated for each time sample
		for (ii = p1.y; ii<= p2.y; ii++) {
		i = (int)myRound(  (double)(n-1) / (double)(p2.y - p1.y) * (double)(ii - p1.y)  ); // i here is the client coord, while p1 and p2 are in device coord
		if (draw.isCopying) {
		int yyy = 1;
		//return;  // testing
		}
		if (i > n-1) i = n-1;
		if (i < 0) i = 0;
		if (fabs(amp[i]) > MINAMP) {
		int ind = getAmpRgbIndex(colArr[i]);
		oldPen = pDC->SelectObject(&penArr[ ind ]);
		int iy = (int)myRound( (double)p1Client.y + yrate*(double)(ii - p1.y) );
		pDC->MoveTo(ix1Client, iy);
		pDC->LineTo(ix2Client, iy);
		} // if fabs(amp)
		} // for ii
		} // else if
		free(colArr);
		pDC->SelectObject(oldPen); // must select oldPen before deleteObject of penArr[]
		for (i=0; i<ampColorDyn.num; i++) {
		penArr[i].DeleteObject();
		}
		*/
	}

	void CSeisWideDoc::OnProcessingTracereorder() 
	{
		LONGLONG nByte;
		int shot;
		WORD totShot=0; // we use shot to indicate trace number, since for refractions, shots and trace numbers are 1 to 1
		int trcReverse;
		double range, rangeSel, rangeOld;  
		// note: we use range to indicate trace offsets, due to a traditional reason for refractions

		CString outFile = _T("");
		//	TCHAR s[80];
		bhed bh;
		segy tr;
		BOOL isUnix = false;

		CdlgReorganize dlg;

		dlg.m_procNameIn = draw.timeSecName;

		if (dlg.DoModal() == IDOK)
		{
			draw.timeSecName = dlg.m_procNameIn.Trim();
			outFile = dlg.m_procNameOut;
			trcReverse = dlg.m_trcReverse;
		}
		else return;

		if (!isFileExistNotDirectory(draw.timeSecName)) return;
		if(outFile==_T("")) return;
		outFile = mySetFileExtension(outFile, _T("sgy"));

		CFile file;
		if (!file.Open(draw.timeSecName, CFile::modeRead | CFile::typeBinary)) {
			return;
		}

		file.Seek(0, CFile::begin);
		ULONGLONG bytesRead = file.Read(head.ascHead, 3200L);
		if(bytesRead < 3200) 
			AfxMessageBox(_T("Ascii section header read wrong"));
		file.Read(&bh, 400L);
		if(bytesRead < 400) 
			AfxMessageBox(_T("Binary section header read wrong"));



		if (isUnix = IsUnix(bh.format)) SwapTapeHeader(&bh);
		BOOL dataInt = (bh.format == 3) ? TRUE : FALSE;
		int numsamp = bh.hns;
		int format = bh.format;
		int len = (bh.format==3) ? (2*bh.hns) :  4*bh.hns;
		len += 240;  // total trace length in bytes
		int tpp = bh.hdt;

		CFile filez;
		if (!filez.Open(outFile, CFile::modeCreate|CFile::modeWrite|CFile::typeBinary)) {
			file.Close();
			return;
		}
		filez.Write(head.ascHead, 3200L);
		filez.Write(&bh, 400L);

		//For progress control, need to know the last trace no.
		bytesRead = file.GetLength();
		int iTotTrc = (int)((double)(bytesRead-3600.)/(double)len);
		file.Seek(3600, CFile::begin);

		//Begin progress control.
		CMainFrame* pFrame = 
			(CMainFrame*)AfxGetMainWnd();
		ASSERT(pFrame);
		ASSERT_KINDOF(CMainFrame, pFrame);
		pFrame->BeginProgress();

		rangeOld = -MIL;

		// NOTE: here in reading/writing, we do not convert between IBM and IEEE float at all, since no processing involved.
		do
		{
			if(trcReverse == 0)
				nByte = (iTotTrc-totShot-1)*len + 3600;
			else
			{
				rangeSel = MIL;
				//First find the first trace with range > pCd.coord.xmin.
				while (file.Read(&tr, 90) == (UINT)90L)
				{
					// we only need to read 90 bytes for each trace
					file.Seek(len-90L, CFile::current);
					if (isUnix) {
						SwapTraceHeader(&tr);
					}


					shot = tr.tracl;
					if(trcReverse==1)
					{
						range = getDistance(&tr);
					}
					else if(trcReverse==2)
					{
						range = getOffset(&tr);
					}
					else
						range = tr.gx * 0.001;  //????

					if(range < rangeOld+0.000001) continue;
					if(rangeSel> range && rangeSel>rangeOld) 
					{
						rangeSel = range;
						nByte = file.Seek(-len, CFile::current);
					}
				} // while
				if(rangeSel==rangeOld) break;		//No new trace to output.
			}
			file.Seek(nByte, CFile::begin);
			BOOL x = (file.Read(&tr, len) == (UINT)len);

			if (isUnix) {
				SwapTraceHeader(&tr);
				SwapN(&tr, bh.format);
			}
			if(!x)
			{
				rangeOld = rangeSel;
				break; 
			}

			int iPos = (int)((double)totShot/(double)iTotTrc*100.);
			pFrame->SetProgress(iPos);

			totShot++;
			tr.tracl = totShot;	//Re-number the trace no.

			filez.Write(&tr, len);

			file.Seek(3600L, CFile::begin);
			rangeOld = rangeSel;
		} while (totShot < iTotTrc);

		pFrame->EndProgress();

		filez.Seek(3212L, CFile::begin);
		filez.Write(&totShot, 2);
		file.Close();
		filez.Close();

		para.trace1 = 1;
		para.trace2 = totShot;
		draw.timeSecName = outFile;
		head.modifiedtime = zeroTime;	//recalculate gain.
		draw.isSameDataDisplay = FALSE; //indicate display has been changed and will re-load all data in OnDraw().
		SetModifiedFlag();
		UpdateAllViews(NULL);
		NotifyChanged();

		//	AfxMessageBox(_T("Succesfully re-organizing traces in increasing ranges!");
	}

	void CSeisWideDoc::OnProcessingCohmix() 
	{
		return this->OnReflectionCoherencyplot();
	}


	void CSeisWideDoc::OnToolbarNewmod() 
	{

		int icont;
		CDlgNewModel dlg;

		dlg.m_xmax = (float)pCd.coord.xmax;
		dlg.m_xmin = (float)pCd.coord.xmin;
		dlg.m_zmax = (float)pCd.coord.zmax;
		dlg.m_nLayer = 6;

		if (dlg.DoModal() == IDOK)
		{
			pCd.coord.xmax = dlg.m_xmax;
			pCd.coord.xmin = dlg.m_xmin;
			pCd.coord.zmax = dlg.m_zmax;
			velMod.ncont = dlg.m_nLayer+1;
		}
		else return;

		if(velMod.ncont<1) 
		{
			AfxMessageBox(_T("Please specify at least 1 layer"));
			return;
		}

		for (icont=0; icont<velMod.ncont; icont++)
		{
			velMod.xm[0][icont] = (float)pCd.coord.xmin;
			velMod.xm[1][icont] = (float)pCd.coord.xmax;
			velMod.zm[1][icont] = velMod.zm[0][icont] = (float)(pCd.coord.zmax/(double)(velMod.ncont-1)*icont);

			velMod.nzed[icont] = 2;
		}

		for (icont=0; icont<velMod.ncont-1; icont++)
		{
			velMod.nvel[icont][0] = 2;
			velMod.nvel[icont][1] = 2;
			velMod.xvel[0][icont][0] = (float)pCd.coord.xmin;
			velMod.xvel[1][icont][0] = (float)pCd.coord.xmax;
			velMod.xvel[0][icont][1] = (float)pCd.coord.xmin;
			velMod.xvel[1][icont][1] = (float)pCd.coord.xmax;

			velMod.vf[0][icont][0] = 1.5f + icont*1.3f;
			velMod.vf[1][icont][0] = 1.5f + icont*1.3f;
			velMod.vf[0][icont][1] = 1.5f + icont*1.3f+0.1f;
			velMod.vf[1][icont][1] = 1.5f + icont*1.3f+0.1f;
			velMod.anisotropy[icont] = 0.f;
		}
		//	_stprintf(s, "ncont=%d, nzed7,8=%d %d", velMod.ncont,velMod.nzed[6],velMod.nzed[7]);
		//	AfxMessageBox(s);


		OnToolbarSaveasv();
		//velMod.velSecOld = _T("");
		draw.modeOld = draw.mode;
		draw.mode = 2;

		draw.pick = 1;
		draw.move =0;
		draw.remove = 0;
		draw.add = 0;
		//draw.isSameDataDisplay = FALSE; //indicate display has been changed and will re-load all data in OnDraw().

		SetModifiedFlag();
		UpdateAllViews(NULL);
		NotifyChanged();

	}

	void CSeisWideDoc::OnProcessingReverserange() 
	{

		int refShot,refShot2, shot, option;
		BOOL blOffset,blDistance;
		CdlgChangeRanges dlg;
		dlg.m_refName = draw.timeSecName;
		//	dlg.m_refShot = para.trace1;
		//	dlg.m_refShot2 = para.trace2;
		if (dlg.DoModal() == IDOK)
		{
			draw.timeSecName = dlg.m_refName.Trim();
			refShot = dlg.m_refShot;
			refShot2 = dlg.m_refShot2;
			blOffset = dlg.m_offset;
			blDistance = dlg.m_distance;
			option = dlg.m_option;
		}
		else return;
		delete dlg;

		if (!isFileExistNotDirectory(draw.timeSecName)) return;
		CFile file;
		if (!file.Open(draw.timeSecName, CFile::modeReadWrite | CFile::typeBinary)) return;
		ULONGLONG bytesRead = file.Seek(3200L, CFile::begin);
		if(bytesRead < 3200) 
		{
			AfxMessageBox(_T("Ascii section header read wrong"));
			return;
		}
		short i2buf[40000];
		bytesRead = file.Read(i2buf, 400);
		if(bytesRead < 400) 
		{
			AfxMessageBox(_T("Binary section header read wrong"));
			return;
		}
		int numsamp = (unsigned short)i2buf[10];
		int format = i2buf[12];
		int len;
		if(format!=3)  
			len = numsamp*4 + 240;
		else
			len = numsamp*2 + 240;
		int tpp = (unsigned short)i2buf[8];

		segy tr;
		while (file.Read(&tr, 240) == 240)
		{
			shot = tr.tracl;

			if(option == 0)
			{ //reverse sign according to trace number.
				if(shot>=refShot && shot<=refShot2)
				{
					if(blOffset)
					{
						setOffset(&tr, -1.f*getOffset(&tr));
					}
				}
			}
			else
			{ // reverse sign according to azimuth.
				// NOTE: for 1 OBS 3E Erable, I have to use 18000 as the condition
				// if(!(i2buf[109]>=-9000 && i2buf[109]<=9000))
				if(blOffset)
				{
					setOffset(&tr, -1.f*getOffset(&tr));
				}
			}
			if(blDistance)
			{
				setDistance(&tr, -getDistance(&tr));
			}
			file.Seek(-240, CFile::current);
			file.Write(&tr, 240);
			file.Seek((long)(len-240), CFile::current);
		} //end of while loop.





		if(blOffset && !blDistance) {
			AfxMessageBox(_T("Reversing offset done!"));
		}
		// head.timeSecModTime = NULL;  // it will auto reload
	}

	void CSeisWideDoc::colBarPos (double v, CPoint p, CPoint p1)
	{
		double x1, y1;
		BOOL colVert = FALSE;
		bool isTime = isTimeDomain() == TRUE;

		if(!colVert)
		{
			x1 = vel.cxPos + (v-vel.vmin)*(vel.vmax-vel.vmin)/vel.cxExt;
			p = pCd.mm_coord(x1, vel.cyPos, isTime);
			p1 = pCd.mm_coord(x1 + vel.cxExt/20., vel.cyPos+vel.cyExt, isTime);
		}
		else
		{
			y1 = vel.cyPos + (v-vel.vmin)*(vel.vmax-vel.vmin)/vel.cyExt;
			p = pCd.mm_coord(vel.cxPos, y1, isTime);
			p1 = pCd.mm_coord(vel.cxPos+vel.cxExt, y1+vel.cyExt/20., isTime);
		}
		return;

	}

	void CSeisWideDoc::OnProcessingLoadzeltsmodel() 
	{
		CString tStr;
		CdlgLoadZelt dlg;
		CString zeltName;
		static int is4Decimal = 0;

		//	dlg.m_velName = velMod.velSecName;
		dlg.m_is4Decimal = is4Decimal;
		if (dlg.DoModal() == IDOK)
		{
			zeltName = dlg.m_ZeltName;
			velMod.velSecName = dlg.m_velName.Trim();
			velMod.velSecName = mySetFileExtension(velMod.velSecName, _T("bin"));
			is4Decimal = dlg.m_is4Decimal;
		}
		else return;

		int  i, j;
		BOOL isSuc = FALSE;
		CVelMod vm;
		if (GetFileExtension(zeltName).CompareNoCase(_T("vxml"))  == 0) {
			isSuc = vm.loadModelXML(&velMod, zeltName, vel.dz);
		}
		else {
			// note: an ill-formatted .in file or a wrong selection of format can easily cause the program to freeze.
			// So we must be very cautious here.
			tStr = getLineFirst(zeltName);
			i = tStr.Find('.', 0);
			if (i<0) return;
			j = tStr.Find(' ', i);
			if (j<0) {
				j = tStr.Find('\r', i);
			}
			if (j>i) {
				// found a decimal.
				int delta = j-i-1; // delta is the number of decimals as calculated from file
				if (delta==4 && is4Decimal != 0) {
					if(AfxMessageBox(_T("First line seems to contain 4 decimals. Is this true?"), MB_YESNO |MB_ICONINFORMATION) == IDYES)
						is4Decimal = 0;
				}
				else
					if (delta==3 && is4Decimal != 1) {
						if(AfxMessageBox(_T("First line seems to contain 3 decimals. Is this true?"), MB_YESNO |MB_ICONINFORMATION) == IDYES)
							is4Decimal = 1;
					}
					if (delta==2 && is4Decimal != 2) {
						if(AfxMessageBox(_T("First line seems to contain 2 decimals. Is this true?"), MB_YESNO |MB_ICONINFORMATION) == IDYES)
							is4Decimal = 2;
					}
			}

			if (is4Decimal == 0)
				isSuc = vm.loadModelZelt4(&velMod, zeltName);
			else if  (is4Decimal == 1)
				isSuc = vm.loadModelZelt3(&velMod, zeltName);
			else
				isSuc = vm.loadModelZelt2(&velMod, zeltName);
			velMod.xmin = velMod.xmax = velMod.zmin = velMod.zmax = 0.0;
		}

		if (!isSuc) {
			tStr.Format(_T("Sorry, Loading failed."));
			AfxMessageBox(tStr);
			return;
		}

		//// final fix up for some
	//	if ( fabs(velMod.xmax - velMod.xmin) < 0.00001 )  
		vm.formatCalcVelLimits(&velMod);
		vm.myModel_Depth2TWTT(&velMod, vel.dz);
		vm.saveModelAs(&velMod, velMod.velSecName, vel.dz, FALSE, 0);

		OnToolbarSavev();
		pCd.coord.xmax = (float)velMod.xmax;	
		pCd.coord.xmin = velMod.xmin;
		pCd.coord.zmin = velMod.zmin;
		pCd.coord.zmax = velMod.zmax;

		draw.modeOld = draw.mode;
		draw.mode = 2;
		//draw.isSameDataDisplay = FALSE; //indicate display has been changed and will re-load all data in OnDraw().
		SetModifiedFlag();
		UpdateAllViews(NULL);
		NotifyChanged();


	}

	void CSeisWideDoc::OnModelingLoadreidsmodel() 
	{
		// return; //designing in progress.

		CdlgLoadReid dlg;
		CString reidName;
		TCHAR *jpfile;

		if (dlg.DoModal() == IDOK)
		{
			reidName = dlg.m_reidName;
			velMod.velSecName = dlg.m_velName.Trim();
			velMod.velSecName = mySetFileExtension(velMod.velSecName, _T("bin"));
		}
		else 
		{
			return;
		}

		//start Steve Perry's code:
#define MAXLAYERS 40
#define MAXPOINTS 400
#define MAXVELS 40
#define DX 0.01
#define DZ 0.01

		FILE *infil;
		int iaz, nlayers, npts[MAXLAYERS], nvels[MAXLAYERS], i, j=0, l;
		float vels[MAXLAYERS], grad[MAXLAYERS];
		float x[MAXLAYERS][MAXPOINTS], z[MAXLAYERS][MAXPOINTS];
		float xmin=99999.f,xmax=ERRORVAL, zmax=0.0f;
		float ttx[MAXPOINTS],ttz[MAXPOINTS];
		float veltop[MAXLAYERS][MAXVELS], velbot[MAXLAYERS][MAXVELS];
		float xvel[MAXLAYERS][MAXVELS], zvel[MAXLAYERS][MAXVELS];

		jpfile = reidName.GetBuffer(reidName.GetLength());
		if((_tfopen_s(&infil, jpfile, _T("r") )) != 0) 
		{
			reidName.ReleaseBuffer();
			AfxMessageBox(_T("Error opening input file"));
			return;
		}
		reidName.ReleaseBuffer();

		_ftscanf_s(infil,_T("%d"),&iaz);
		_ftscanf_s(infil,_T("%f %f"),&vels[j],&grad[j]);
		do {
			_ftscanf_s(infil,_T("%d"),&npts[j]);
			for (i=0; i<npts[j]; i++) {
				_ftscanf_s(infil,_T("%f %f"),&x[j][i],&z[j][i]);
				if (z[j][i] > zmax) zmax = z[j][i];
				if (x[j][i] > xmax) xmax = x[j][i];
				if (x[j][i] < xmin) xmin = x[j][i];
			}
			j++;
		} while (_ftscanf_s(infil,_T("%f %f"),&vels[j],&grad[j]) > 0);
		nlayers = j;
		x[j][0] = x[j-1][0]; x[j][1] = x[j-1][npts[j-1]-1];
		z[j][0] = (float)(zmax + 0.1/grad[j-1]); 
		z[j][1] = z[j][0];
		npts[j] = 2;

		/*
		*   Look for horizontal transition layers.
		*/

		l = 0;
		do {
			int l1, l2;
			float v1, v2;
			l1 = -1; l2 = -1;
			if (vels[l] == 0.0) {
				for (j=0; j<=nlayers; j++) {
					if (j != l ) {
						for (i=0; i<npts[j]; i++) {
							if ((fabsf(x[j][i]-x[l][0]) <= DX) 
								&& (fabsf(z[j][i]-z[l][0]) <= DZ)) {
									l1 = j;
									v1 = vels[j];
							}
							else if ((fabsf(x[j][i]-x[l][npts[l]-1]) <= DX)
								&& (fabsf(z[j][i]-z[l][npts[l]-1]) <= DZ)) {
									l2 = j;
									v2 = vels[j];
							}
						}
					}
				}
			}
			if (l1 >= 0 && l2 >= 0) {
				for (i=1; i<(npts[l]-1); i++) {
					x[l1][npts[l1]+i-1] = x[l][i];
					z[l1][npts[l1]+i-1] = z[l][i];
				}
				npts[l1] += (npts[l]-2);
				for (i=0; i<npts[l2]; i++) {
					x[l1][npts[l1]+i] = x[l2][i];
					z[l1][npts[l1]+i] = z[l2][i];
				}
				npts[l1] += npts[l2];
				veltop[l1][nvels[l1]] = vels[l2];
				xvel[l1][nvels[l1]] = x[l2][0];
				velbot[l1][nvels[l1]] = grad[l2];
				zvel[l1][nvels[l1]] = z[l2][0];
				veltop[l1][nvels[l1]+1] = vels[l2];
				xvel[l1][nvels[l1]+1] = x[l2][npts[l2]-1];
				velbot[l1][nvels[l1]+1] = grad[l2];
				zvel[l1][nvels[l1]+1] = z[l2][npts[l2]-1];
				nvels[l1] += 2;
				npts[l] = -npts[l]; npts[l2] = -npts[l2];
			}
			else {
				veltop[l][0] = vels[l]; xvel[l][0] = x[l][0];
				velbot[l][0] = grad[l]; zvel[l][0] = z[l][0];
				veltop[l][1] = vels[l]; xvel[l][1] = x[l][npts[l]-1];
				velbot[l][1] = grad[l]; zvel[l][1] = z[l][npts[l]-1];
				nvels[l] = 2;
			}
			l++;
		} while (l <= nlayers);

		/*
		*   Look for vertical transition layers.
		*/

		l = 1;
		do {
			float dh;
			if ((vels[l] == 0.0) && (vels[l-1] != 0.0) && (npts[l] > 0)) {
				if ((fabsf(x[l][0]-x[l-1][0]) <= DX) 
					&& (fabsf(x[l][npts[l]-1]-x[l-1][npts[l-1]-1]) <= DX)) {
						dh = z[l][0] - z[l-1][0];
						for (i=0; i<npts[l-1]; i++) {
							x[l][i] = x[l-1][i];
							z[l][i] = z[l-1][i] + dh;
						}
						npts[l] = npts[l-1];
						for (i=0; i<nvels[l-1]; i++) {
							veltop[l][i] = veltop[l-1][i] + dh*velbot[l-1][i];
							xvel[l][i] = xvel[l-1][i];
							velbot[l][i] = velbot[l-1][i];
							zvel[l][i] = zvel[l-1][i] + dh;
						}
						nvels[l] = nvels[l-1];
				}
			}
			l++;
		} while (l < nlayers);

		/*
		*   Calculate layer bottom velocities.
		*/

		l = 0;
		do {
			if (npts[l] > 0) {
				int il, ij, bottom_found;
				for (il=0; il<nvels[l]; il++) {
					bottom_found = 0;
					j = l + 1;
					do {
						if (npts[j] > 0) {
							ij = 0;
							do {
								if (fabsf(xvel[l][il]-x[j][ij]) < DX) {
									velbot[l][il] = (z[j][ij]-zvel[l][il]) 
										* velbot[l][il];
									velbot[l][il] += veltop[l][il];
									bottom_found = 1;
								}
								else if (ij > 0 && x[j][ij] > xvel[l][il]) {
									float zslope;
									zslope = (z[j][ij]-z[j][ij-1]) 
										/ (x[j][ij]-x[j][ij-1]);
									velbot[l][il] = (z[j][ij-1] + zslope 
										* (xvel[l][il]-x[j][ij-1]) - zvel[l][il])
										* velbot[l][il];
									velbot[l][il] += veltop[l][il];
									bottom_found = 1;
								}
								ij++;
							} while (!bottom_found && ij < npts[j]);
						}
						j++;
					} while (!bottom_found && j<=nlayers);
				}
			}
			l++;
		} while (l < nlayers);



		//back to Deping's coding
		//found Steve's program a problem in dealing with blocks. So here is fix:


		velMod.ncont = nlayers+1;

		for (j=0; j<MOD_POINTS_MAX; j++) 
		{
			for (i=0; i<40; i++)
			{
				velMod.nzed[i] = 0;
				velMod.xm[j][i] = 0.f;
				velMod.zm[j][i] = 0.f;
				velMod.xvel[j][i][0] = 0.f;
				velMod.xvel[j][i][1] = 0.f;
				velMod.vf[j][i][0] = 0.f;
				velMod.vf[j][i][1] = 0.f;
			}
		}


		for (i=0;i<velMod.ncont; i++) 
		{
			velMod.nzed[i]=npts[i];
			for (j=0; j<velMod.nzed[i]; j++)
			{
				velMod.xm[j][i] = x[i][j];
				velMod.zm[j][i] = z[i][j];
			}
		}
		for (i=0;i<velMod.ncont-1; i++) 
		{
			velMod.nvel[i][0] =velMod.nvel[i][1] = nvels[i];
			for (j=0; j<nvels[i]; j++)
			{
				velMod.xvel[j][i][0] = velMod.xvel[j][i][1] = xvel[i][j];
				velMod.vf[j][i][0] = veltop[i][j];
				velMod.vf[j][i][1] = velbot[i][j];
			}
		}

		//try to merge two blocks to form a layer
		for (i=0;i<velMod.ncont-1; i++) 
		{
			int iNew,jNew;
			float xJoin = velMod.xm[velMod.nzed[i]-1][i];
			if(xJoin<xmax && xJoin==velMod.xm[0][i+1])
			{
				for (j=1; j<velMod.nzed[i+1]; j++)
				{  //use j=1 to skip the first point.
					jNew = velMod.nzed[i];
					velMod.xm[jNew+j-1][i] = velMod.xm[j][i+1];
					velMod.zm[jNew+j-1][i] = velMod.zm[j][i+1];
				}
				velMod.nzed[i] += velMod.nzed[i+1]-1;
				for (iNew=i+1;iNew<velMod.ncont-1; iNew++) 
				{
					for (j=0; j<velMod.nzed[iNew+1]; j++)
					{
						velMod.xm[j][iNew] = velMod.xm[j][iNew+1];
						velMod.zm[j][iNew] = velMod.zm[j][iNew+1];
					}
					velMod.nzed[iNew] = velMod.nzed[iNew+1];
				}
				velMod.ncont--;

				for (j=1; j<velMod.nvel[i+1][0]; j++)
				{ //use j=1 to skip the first point.
					jNew = velMod.nvel[i][0];
					velMod.xvel[jNew+j-1][i][0] = velMod.xvel[j][i+1][0];
					velMod.vf[jNew+j-1][i][0] = velMod.vf[j][i+1][0];
				}
				velMod.nvel[i][0] += velMod.nvel[i+1][0]-1;
				for (j=1; j<velMod.nvel[i+1][1]; j++)
				{
					jNew = velMod.nvel[i][1];
					velMod.xvel[jNew+j-1][i][1] = velMod.xvel[j][i+1][1];
					velMod.vf[jNew+j-1][i][1] = velMod.vf[j][i+1][1];
				}
				velMod.nvel[i][1] += velMod.nvel[i+1][1]-1;
				for (iNew=i+1;iNew<velMod.ncont-1-1; iNew++) 
				{
					for (j=0; j<velMod.nvel[iNew+1][0]; j++)
						velMod.xvel[j][iNew][0] = velMod.xvel[j][iNew+1][0];
					for (j=0; j<velMod.nvel[iNew+1][1]; j++)
						velMod.xvel[j][iNew][1] = velMod.xvel[j][iNew+1][1];
					velMod.nvel[iNew][0] =velMod.nvel[iNew+1][0];
					velMod.nvel[iNew][1] =velMod.nvel[iNew+1][1];
				}
				//velMod.nlayer--;
			} //end of block merging.

			//now check for blocks starting from >xmin.
			if(velMod.xm[0][i] > xmin)
			{
				//backup xm and zm first.
				for (j=0; j<velMod.nzed[i]; j++)
				{
					ttx[j] = velMod.xm[j][i];
					ttz[j] = velMod.zm[j][i];
				}
				for (iNew=i+1; iNew<velMod.nzed[iNew]; iNew++)
				{
					if(velMod.xm[0][iNew]==xmin)
					{
						for (j=0; j<velMod.nzed[iNew]; j++)
						{
							if(velMod.xm[j][iNew]<ttx[0])
							{
								velMod.xm[j][i] = velMod.xm[j][iNew];
								velMod.zm[j][i] = velMod.zm[j][iNew];
							}
							else break;
							//	AfxMessageBox(_T("problem");
						}
						for (jNew=0; jNew<velMod.nzed[i]; jNew++)
						{
							velMod.xm[jNew+j][i] = ttx[jNew];
							velMod.zm[jNew+j][i] = ttz[jNew];
						}
						break;
					}  
				} //end of fixing the small block for boundaries.
				velMod.nzed[i] += j;
				velMod.xvel[0][i][0] = xmin;
				velMod.xvel[0][i][1] = xmin;
			}//end of fixing the small block.

			/*
			//now check for blocks ending at <xmax.
			if(velMod.xm[velMod.nzed[i]-1][i] < xmax && i>0)
			{
			for (iNew=i+1; iNew<velMod.nzed[iNew]; iNew++)
			{
			int jJoin = velMod.nzed[iNew];
			xJoin = velMod.xm[jJoin-1][iNew];
			if(xJoin==xmax)
			{
			for (j=0; j<velMod.nzed[iNew]; j++)
			{
			if(velMod.xm[j][iNew]>xJoin)
			{
			velMod.xm[jJoin+j][i] = velMod.xm[j][iNew];
			velMod.zm[jJoin+j][i] = velMod.zm[j][iNew];
			velMod.nzed[i]++;
			}
			}
			break;
			}  
			} //end of fixing the small block for boundaries.
			jNew = velMod.nvel[i][0]-1;
			velMod.xvel[jNew][i][0] = xmax;
			jNew = velMod.nvel[i][1]-1;
			velMod.xvel[jNew][i][1] = xmax;
			}//end of fixing the small block.
			*/
		}  //end of checking irregularities.

		fclose(infil);

		//make sure all ends at xmin and xmax.
		for (i=0;i<velMod.ncont; i++) 
		{
			velMod.xm[0][i] = velMod.xvel[0][i][0] = velMod.xvel[0][i][1] = xmin;
			velMod.xm[velMod.nzed[i]-1][i] = xmax;
		}

		for (i=0;i<velMod.ncont-1; i++) 
		{
			velMod.xvel[velMod.nvel[i][0]-1][i][0] = xmax;
			velMod.xvel[velMod.nvel[i][1]-1][i][1] = xmax;
		}

		OnToolbarSavev();
		pCd.coord.xmax = xmax;	//problem: double pCd.coord.xmax is not 3.2 even if float xmax is 3.2.
		pCd.coord.zmax = zmax;
		//velMod.velSecOld = _T("");	//Vel file is changed so initialize the next time use it.

		draw.modeOld = draw.mode;
		draw.mode = 2;
		SetModifiedFlag();
		UpdateAllViews(NULL);
		NotifyChanged();

	}



	void CSeisWideDoc::OnProcessingDatareductionandfilter() 
	{
		CString tstr;
		int trc,i;
		CString outFile = _T("");

		CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();

		static BOOL norm=FALSE;
		static BOOL multiply=FALSE;
		static float multiplyValue = 1.0f; // not effecting in display, but can be useful when merging 2 segy files et al.
		float obsDepth = 0.f;  // do not make this static since we do not want to make the same correction again.

		static BOOL isHilbert = FALSE;

		// for new freq filter only
		int locut=1;		/* flag for low cut filtering		*/
		int hicut=1;		/* flag for high cut filtering		*/
		float a1;		/* amp at f1			*/
		float a2;		/* amp at f2			*/
		float a3;		/* amp at f3			*/
		float a4;		/* amp at f4			*/
		int npoleslo;		/* poles in low cut filter		*/
		int npoleshi;		/* poles in high cut filter		*/
		float f3dblo;		/* 3 db point of low cut filter		*/
		float f3dbhi;		/* 3 db point of high cut filter	*/
		float dt;		/* sample spacing			*/
		float nyq;		/* nyquist frequency			*/
		// end for new freq filter only

		if (pFrame->psei->freq1s >= pFrame->psei->freq2s) pFrame->psei->freq1s = pFrame->psei->freq2s - 1.f;  // we need to keep f2s since time filter will only use f2s, f3s
		if ( pFrame->psei->freq4s <= pFrame->psei->freq3s) pFrame->psei->freq4s = pFrame->psei->freq3s + 1.f;  // we need to keep f3s since time filter will only use f2s, f3s


		CdlgFilter1 dlg;

		dlg.m_nameIn = draw.timeSecName;
		dlg.m_nameOut = getFileNameAppend(draw.timeSecName, _T("F"));

		dlg.m_filter = pFrame->psei->yesFilterT;
		dlg.m_f1 = pFrame->psei->f1a;
		dlg.m_f2 = pFrame->psei->f2a;
		dlg.m_ta = pFrame->psei->ta;
		dlg.m_f1b = 0.f;
		dlg.m_f2b = 0.f;
		dlg.m_tb = pFrame->psei->tb;

		dlg.m_filterF = pFrame->psei->yesFilterF;
		dlg.m_zerophase = pFrame->psei->zerophase;
		dlg.m_ff0 = pFrame->psei->freq1s;
		dlg.m_ff1 = pFrame->psei->freq2s;
		dlg.m_ff2 = pFrame->psei->freq3s;
		dlg.m_ff3 = pFrame->psei->freq4s;
		dlg.m_norm = norm;
		dlg.m_normValue = pFrame->psei->normValue;
		dlg.m_multiply = multiply;
		dlg.m_multiplyValue = multiplyValue;

		dlg.m_isHilbert = isHilbert;
		dlg.m_numTFilter = pFrame->psei->num_tfilter;
		dlg.m_obsDepth = 0.f;
		dlg.m_velWater = pFrame->psei->velWater;

		float tminOut = 0.f;
		float tmaxOut = 0.f;
		dlg.m_tmin = dlg.m_tmax = 0.f;


		draw.isNodeChanged = FALSE;	
		if (dlg.DoModal() == IDOK)
		{
			draw.timeSecName = dlg.m_nameIn.Trim();
			outFile = dlg.m_nameOut;
			pFrame->psei->yesFilterT = dlg.m_filter == TRUE;
			pFrame->psei->num_tfilter = dlg.m_numTFilter;
			pFrame->psei->yesFilterF = dlg.m_filterF == TRUE;
			pFrame->psei->zerophase = dlg.m_zerophase == TRUE;
			if(pFrame->psei->yesFilterF)
			{
				// filtering in frequency domain
				pFrame->psei->freq1s=dlg.m_ff0;
				pFrame->psei->freq2s=dlg.m_ff1;
				pFrame->psei->freq3s=dlg.m_ff2;
				pFrame->psei->freq4s=dlg.m_ff3;
			}
			else {
				// filtering in time domain
				pFrame->psei->f1a = dlg.m_f1;
				pFrame->psei->f2a = dlg.m_f2;
				pFrame->psei->f1b = dlg.m_f1b;
				pFrame->psei->f2b = dlg.m_f2b;
				if (pFrame->psei->f1b == 0.f) pFrame->psei->f1b = pFrame->psei->f1a;
				if (pFrame->psei->f2b == 0.f) pFrame->psei->f1b = pFrame->psei->f1b;
				pFrame->psei->ta = dlg.m_ta;
				pFrame->psei->tb = dlg.m_tb;
			}

			norm = dlg.m_norm;
			pFrame->psei->normValue = dlg.m_normValue;
			multiply = dlg.m_multiply;
			multiplyValue = dlg.m_multiplyValue;
			isHilbert = dlg.m_isHilbert;
			obsDepth = dlg.m_obsDepth;
			pFrame->psei->velWater = dlg.m_velWater;
			tminOut = dlg.m_tmin;
			tmaxOut = dlg.m_tmax;
		}
		else 
		{
			return;
		}


		BOOL zerophase=pFrame->psei->zerophase;		/* flag for zero phase filtering	*/

		double *tData = NULL;
		float *fData = NULL; // for frequency filter only
		double *ampl = NULL;
		double *phase = NULL;
		double *omega = NULL;

		float f1 = pFrame->psei->freq1s;
		float f2 = pFrame->psei->freq2s;
		float f3 = pFrame->psei->freq3s;
		float f4 = pFrame->psei->freq4s;  // we will update f1,f2,f3,f4 values later in this router

		//dlg.m_f1 = f2s;
		//dlg.m_f2 = f3s;
		if(pFrame->psei->yesFilterT) {
			if(pFrame->psei->f1a >= pFrame->psei->f2a) {
				AfxMessageBox(_T(" f1a>=f2a. Please correct this."));
				return;
			}
			if (pFrame->psei->f1b == 0.f || pFrame->psei->f2b==0.f) {
				pFrame->psei->f1b = pFrame->psei->f1a;
				pFrame->psei->f2b = pFrame->psei->f2a;
			}
		}


		if(pFrame->psei->yesFilterF && (pFrame->psei->freq1s >= pFrame->psei->freq2s || pFrame->psei->freq2s >= pFrame->psei->freq3s || pFrame->psei->freq3s >= pFrame->psei->freq4s)) {
			AfxMessageBox(_T(" f1>=f2 or f2>=f3 or f3>=f4. Please correct this."));
			return;
		}


		SegyWrapper sw(draw.timeSecName);
		if (CSegyMeta::segyHeadInit(draw.timeSecName, &head, 0) == 1) {
			//sw.m_tminFile = head.tminFile;
			//sw.m_tmaxFile = head.tmaxFile;
			if (!sw.open(&head, 0)) {
				tstr.Format(_T("Valid input file cannot be opened"));
				AfxMessageBox(tstr);
				return;
			}
		}
		tstr.Format(_T("Loaded segy with %d traces."), sw.nxmax);
		myCaption(tstr);

		CFile fileout;
		if (!fileout.Open(outFile, CFile::modeCreate  |CFile::modeWrite | CFile::typeBinary)) {
			tstr.Format(_T("Outfile cannot be created"));
			AfxMessageBox(tstr);
			return;
		}

		segy tr;
		bhed bhout;
		fileout.Write(sw.ascHead, 3200L);
		memcpy((void *)&bhout, (void *)&sw.bh, 240L);

		int format = bhout.format;
		int sampByte = (bhout.format==3) ? 2 :  4;
		int len = sampByte*bhout.hns + 240;
		dt = (float) (sw.bh.hdt /(double)MIL);
		double odt = 1. / dt;

		int nsIn = bhout.hns;
		int nsOut = bhout.hns;
		if (tmaxOut>tminOut+dt) 
			nsOut = bhout.hns = (int)myRound((tmaxOut - tminOut)*odt) + 1;
		if (nsOut > nsIn) {
			// output length is too big, which will cause problem, so we do not do it
			nsOut = nsIn;
			tmaxOut = tminOut = 0.f;
		}
		bhout.format = pFrame->gIsIBMFloatSegy2  ?  1  :  5; // only floating is adopted for output
		fileout.Write(&bhout, 400);


		if (pFrame->psei->velWater < 1.f) {
			obsDepth = 0.f;
			pFrame->psei->velWater = 1.f;
		}
		float tcorr4ObsDepth = obsDepth / pFrame->psei->velWater;
		if (tcorr4ObsDepth > 0.f) {
			outFile = getFileNameAppend(outFile, _T("Surf"));
		}

		nyq = (float)(0.5/dt);
		if (pFrame->psei->f1a <= 0.f) pFrame->psei->f1b = pFrame->psei->f1a = 0.00001f;
		if (pFrame->psei->f2a > nyq) pFrame->psei->f2b = pFrame->psei->f2a = nyq;

		double a,b, c0,c1,c2, d1,d2;
		if(pFrame->psei->yesFilterT)
		{
			tData = (double *)malloc((size_t)(nsIn*sizeof(double)));
			if( tData == NULL)
			{
				AfxMessageBox( _T("Insufficient memory available" ));
				return;
			}
		}
		else if(pFrame->psei->yesFilterF) {
			fData = (float *)malloc((size_t)(nsIn*sizeof(float)));
			if( fData == NULL)
			{
				AfxMessageBox( _T("Insufficient memory available" ));
				return;
			}

			// for freq filtering only
			if (locut) {
				if (pFrame->psei->freq1s <= 0.)  pFrame->psei->freq1s = .10f * nyq;
				if (pFrame->psei->freq2s <= pFrame->psei->freq1s)  pFrame->psei->freq2s = pFrame->psei->freq1s + 1.f;
			}
			if (hicut) {
				if (f4 > nyq)  f4 = nyq;
				if (f3 > f4)  f3 = f4 - 1.f;
			}

			/* Normalize frequencies to [0, 0.5] for bfdesign */
			f1 *= (float)dt;
			f2 *= (float)dt;
			f4 *= (float)dt;
			f3 *= (float)dt;

			a1 = .05f;
			a2 = .95f;
			a3 = .95f;
			a4 = .05f;
			/* Adapt user frequencies if zerophase selected */
			if (zerophase) {	
				a1 = sqrt(a1);
				a2 = sqrt(a2);
				a4 = sqrt(a4);
				a3 = sqrt(a3);
			}

			/* Use bdesign to make low and high cut filters */
			if (locut) bfdesign(f2,a2,f1,a1,&npoleslo,&f3dblo);
			if (hicut) bfdesign(f3,a3,f4,a4,&npoleshi,&f3dbhi);
			// end for freq filtering only
		}

		double temp=0.;
		for (int nxStore=0; nxStore < sw.nxmax; nxStore++) {
			memset((void *)tr.dat.data,(int) '\0', sampByte*nsIn); 
			trc = sw.trArr[nxStore].tracl;
			float aDelay = getTraceDelay(&sw.trArr[nxStore]);
			if (aDelay != 0.001f) {
				// 
				int sdfsd = 1;
			}
			if(pFrame->psei->yesFilterT)	//apply filter
			{
				// debias 
				temp=0.;
				for (i=0; i<nsIn; i++)
					temp+= sw.trArr[nxStore].data[i];
				if(fabs(temp)>MINAMP){ 
					temp /= (double)nsIn;
					for (i=0; i<nsIn; i++) sw.trArr[nxStore].data[i] -= (float)temp;
				}


				int ita = (int)myRound( (pFrame->psei->ta - aDelay) * odt );
				int itb = (int)myRound( (pFrame->psei->tb - aDelay) * odt );
				bool isTimeVaryingFilter = (pFrame->psei->tb != 0.f && pFrame->psei->ta != pFrame->psei->tb && (pFrame->psei->f1a != pFrame->psei->f1b|| pFrame->psei->f2a != pFrame->psei->f2b) );
				for (int n=0; n<pFrame->psei->num_tfilter; n++) {

					if (isTimeVaryingFilter) {
						a=tan(PI*pFrame->psei->f1a*dt);
						b=tan(PI*pFrame->psei->f2a*dt);
						c0 = -b/(1.+a)/(1.+b);
						c1 = 0.;
						c2 = -c0;
						d1 = ((1.+a)*(1.-b)+(1.-a)*(1.+b))/((1.+a)*(1.+b));
						d2 = -((1.-a)*(1.-b))/((1.+a)*(1.+b));

						// prepare for time varying filter
						double aRatioA = (pFrame->psei->f1b - pFrame->psei->f1a) / (double)(itb - ita);
						double aRatioB = (pFrame->psei->f2b - pFrame->psei->f2a) / (double)(itb - ita);
						tData[0] = c0*sw.trArr[nxStore].data[0];
						tData[1] = c0*sw.trArr[nxStore].data[1]+c1*sw.trArr[nxStore].data[0] + d1*tData[0];
						for (i=2; i<nsIn; i++) {
							if (i>ita && i<itb) {
								f1 = pFrame->psei->f1a + (float)((i - ita) *  aRatioA);
								f2 = pFrame->psei->f2a + (float)((i - ita) *  aRatioB);
								a=tan(PI*f1*dt);
								b=tan(PI*f2*dt);
								c0 = -b/(1.+a)/(1.+b);
								c1 = 0.;
								c2 = -c0;
								d1 = ((1.+a)*(1.-b)+(1.-a)*(1.+b))/((1.+a)*(1.+b));
								d2 = -((1.-a)*(1.-b))/((1.+a)*(1.+b));
							}
							tData[i] = c0*sw.trArr[nxStore].data[i]+
								c1*sw.trArr[nxStore].data[i-1]+
								c2*sw.trArr[nxStore].data[i-2] + 
								d1*tData[i-1]+d2*tData[i-2];
						} // for i
					} // if
					else {
						a=tan(PI*pFrame->psei->f1a*dt);
						b=tan(PI*pFrame->psei->f2a*dt);
						c0 = -b/(1.+a)/(1.+b);
						c1 = 0.;
						c2 = -c0;
						d1 = ((1.+a)*(1.-b)+(1.-a)*(1.+b))/((1.+a)*(1.+b));
						d2 = -((1.-a)*(1.-b))/((1.+a)*(1.+b));
						tData[0] = c0*sw.trArr[nxStore].data[0];
						tData[1] = c0*sw.trArr[nxStore].data[1]+c1*sw.trArr[nxStore].data[0] + d1*tData[0];
						for (i=2; i<nsIn; i++)
							tData[i] = c0*sw.trArr[nxStore].data[i]+
							c1*sw.trArr[nxStore].data[i-1]+
							c2*sw.trArr[nxStore].data[i-2] + 
							d1*tData[i-1]+d2*tData[i-2];
					}

					for (i=0; i<nsIn; i++)
						sw.trArr[nxStore].data[i] = -(float)tData[i];
				} // for n

				//for (i=0; i<nsout; i++)
				//	tr.dat.data[i] = -(float)sw.trArr[nxStore][i];
				memcpy( (void *)&tr.dat,   (void *)&sw.trArr[nxStore].data[0],  sampByte*nsIn);
			} // if  yesFilterT
			else if(pFrame->psei->yesFilterF) {
				for (i=0; i<nsIn; i++)
					fData[i] = (float)sw.trArr[nxStore].data[i];

				if (locut) {
					bfhighpass(npoleslo,f3dblo,nsIn,fData,fData);
					if (zerophase) {
						register int i;
						for (i=0; i<nsIn/2; ++i) { /* reverse trace in place */
							register float tmp = fData[i];
							fData[i] = fData[nsIn-1 - i];
							fData[nsIn-1 - i] = tmp;
						}
						bfhighpass(npoleslo,f3dblo,nsIn,fData,fData);
						for (i=0; i<nsIn/2; ++i) { /* flip trace back */
							register float tmp = fData[i];
							fData[i] = fData[nsIn-1 - i];
							fData[nsIn-1 - i] = tmp;
						}
					} // if zerophase
				} // if locut

				if (hicut) {
					bflowpass(npoleshi,f3dbhi,nsIn,fData,fData);
					if (zerophase) {
						register int i;
						for (i=0; i<nsIn/2; ++i) { /* reverse trace */
							register float tmp = fData[i];
							fData[i] = fData[nsIn-1 - i];
							fData[nsIn-1 - i] = tmp;
						}
						bflowpass(npoleshi,f3dbhi,nsIn,fData,fData);
						for (i=0; i<nsIn/2; ++i) { /* flip trace back */
							register float tmp = fData[i];
							fData[i] = fData[nsIn-1 - i];
							fData[nsIn-1 - i] = tmp;
						}
					} // if zerophase
				} // if hicut
				//for (i=0; i<nsout; i++)
				//	sw.trArr[nxStore].data[i] = fData[i];
				memcpy( (void *)&tr.dat,   (void *)&fData[0],  sampByte*nsIn);
			} // freq filter

			if (!pFrame->psei->yesFilterT && !pFrame->psei->yesFilterF) {
				// if here, tr.dat.data[]  is empty
				memcpy( (void *)&tr.dat,   (void *)&sw.trArr[nxStore].data[0],  sampByte*nsIn);
			}

			if(norm)	{
				//apply normalization.
				temp=0.;
				for (i=0; i<nsIn; i++)
					if(temp < fabs(sw.trArr[nxStore].data[i])) temp = fabs(sw.trArr[nxStore].data[i]);
				if(temp>MINAMP){ 
					for (i=0; i<nsIn; i++) 
						tr.dat.data[i] = sw.trArr[nxStore].data[i] * (float)(pFrame->psei->normValue / temp);
				}
			}

			if(multiplyValue != 1.f)	{
				for (i=0; i<nsIn; i++)
					tr.dat.data[i] = sw.trArr[nxStore].data[i] * multiplyValue;
			}

			if (isHilbert) {
				// bool hilbertTransform(double* x, double* ampl, double* phase, double *omega, int npt, int lfilt = 64)
				if (ampl == NULL) ampl = (double *)malloc( (size_t)( nsIn*sizeof(double)) );
				if (phase == NULL) phase = (double *)malloc( (size_t)( nsIn*sizeof(double)) );
				if (omega == NULL) omega = (double *)malloc( (size_t)( nsIn*sizeof(double)) );
				hilbertTransform(&tr.dat.data[0], ampl, phase, omega, nsIn, 64);
				for (i=0; i<nsIn; i++) {
					tr.dat.data[i] = (float)ampl[i];
				}
			}

			if (bhout.format == 1) {
				float_to_ibm((int *) tr.dat.data, (int *) tr.dat.data, nsIn); // we always output as floating pt
			}

			// now need to modify the trace length
			// original length= bhout.hns
			//     we want output: itminOut= ; itmaxOut= ; numOut=itmaxOut-itminOut+1
			//if (tmaxOut > tminOut + dt) {
			//int itminOut = (int)myRound( (tminOut - aDelay) * odt );
			//int itmaxOut = (int)myRound( (tmaxOut - aDelay) * odt );
			//if (itminOut<0) itminOut = 0;
			//itmaxOut = itminOut + nsOut - 1; 
			//	// this guarentees we have the same num of samples per trace

			//if (itmaxOut > nsIn-1) {
			//	// output too long, back a little
			//	itmaxOut = nsIn-1;
			//	itminOut = itmaxOut + 1 - nsOut;
			//} 
			//setTraceDelayF(&sw.trArr[nxStore], itminOut);
			//sw.trArr[nxStore].nhs = sw.trArr[nxStore].ns = nsOut;
			//fileout.Write(&sw.trArr[nxStore], 240);
			//fileout.Write(&tr.dat.data[itminOut], nsOut*sizeof(float));
			//} else {
			//}

			fileout.Write(&sw.trArr[nxStore], 240);
			fileout.Write(&tr.dat.data[0], nsIn*sizeof(float));



			if (nxStore /10 * 10 == nxStore) { 
				tstr.Format(_T("F%d...."), nxStore);
				myCaption(tstr);
			}
		} // for nxStore
		fileout.Close();
		draw.timeSecName = outFile;

		if (tData != NULL) free(tData);
		if (fData != NULL) free(fData);

		if (ampl != NULL) free(ampl);
		if (phase != NULL) free(phase);
		if (omega != NULL) free(omega);

		if (tcorr4ObsDepth > 0.f) {
			tstr.Format(_T("Static correction of %f sec is done for sonobuoy/OBS depth of %f using a water velocity of %f."), tcorr4ObsDepth, obsDepth, pFrame->psei->velWater);
			myCaption(tstr);
		}

		if (tmaxOut > tminOut + dt) {
			pCd.coord.tmin = tminOut;
			pCd.coord.tmax = tmaxOut;
		}

		OnToolbarRefreshAll();

	}

	void CSeisWideDoc::OnProcessingDatanormalize()
	{
		CString tstr;
		if (!isFileExistNotDirectory(draw.timeSecName)) return;
		SegyWrapper sw(draw.timeSecName);
		CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
		if (CSegyMeta::segyHeadInit(draw.timeSecName, &head, 0) == 1) {
			//sw.m_tminFile = head.tminFile;
			//sw.m_tmaxFile = head.tmaxFile;
			if (!sw.open(&head, 0)) {
				tstr.Format(_T("Valid input file cannot be opened"));
				AfxMessageBox(tstr);
				return;
			}
		}
		tstr.Format(_T("Loaded segy with %d traces."), sw.nxmax);
		myCaption(tstr);
		CString outfile=  getFileNameAppend(draw.timeSecName, _T("Norm"));
		CFile fileout;
		if (!fileout.Open(outfile, CFile::modeCreate  |CFile::modeWrite | CFile::typeBinary)) {
			tstr.Format(_T("Outfile cannot be created"));
			AfxMessageBox(tstr);
			return;
		}
		// double dt = (double) sw.bh.hdt /(double)MIL;
		int i;
		bhed bhout;
		fileout.Write(sw.ascHead, 3200L);
		memcpy((void *)&bhout, (void *)&sw.bh, 240L);
		int nsout = bhout.hns;
		// bhout.format = 1; // only floating is adopted for output
		bhout.format = pFrame->gIsIBMFloatSegy2  ?  1  :  5; // only floating is adopted for output
		fileout.Write(&bhout, 400);

		for (int nxStore=0; nxStore < sw.nxmax; nxStore++) {
			float aMax = getMaxValueAbsolute(&sw.trArr[nxStore].data[0], bhout.hns);
			if(aMax>MINAMP){ 
				aMax = 1000.f / aMax;
				for (i=0; i<bhout.hns; i++) 
					sw.trArr[nxStore].data[i] *= aMax;
			}

			if ( bhout.format==5 ) {
				//sw.trArr[nxStore].idistopt = 8;
				float_to_ibm((int *) &sw.trArr[nxStore].data[0], (int *) &sw.trArr[nxStore].data[0], (int)bhout.hns); // we always output as floating pt
			}

			fileout.Write(&sw.trArr[nxStore], 240);
			fileout.Write(&sw.trArr[nxStore].data[0], bhout.hns*sizeof(float));
			if (nxStore /10 * 10 == nxStore) { 
				tstr.Format(_T("A%d...."), nxStore);
				myCaption(tstr);
			}
		} // for nxStore
		fileout.Close();

		tstr.Format(_T("Finished normalization for %d traces. Load the new data?"), sw.nxmax);
		//	myCaption(tstr);
		if(AfxMessageBox((tstr), MB_YESNO |MB_ICONINFORMATION) == IDYES) {
			draw.timeSecName = outfile;
			UpdateAllViews(NULL);
			NotifyChanged();
		}

	}


	void CSeisWideDoc::OnProcessingLateralshift() 
	{
		// shift segy data in distance/offset and time
		static float refKm = 0.f;
		static float refSec = 0.f;
		int intOffset, shot1, shot2;

		CdlgLatShift dlg;
		dlg.m_refName = draw.timeSecName;
		dlg.m_refKm = refKm;
		dlg.m_refSec = refSec;
		dlg.m_offset = (para.isDistanceDisplay || draw.mode==6)  ?  1  :  0;
		dlg.m_shot1 = 0;
		dlg.m_shot2 = 0;
		if (dlg.DoModal() == IDOK) {
			draw.timeSecName = dlg.m_refName.Trim();
			refKm = dlg.m_refKm;
			refSec = dlg.m_refSec;
			intOffset = dlg.m_offset;
			shot1 = dlg.m_shot1;
			shot2 = dlg.m_shot2;
		}
		else return;
		delete dlg;

		if (!isFileExistNotDirectory(draw.timeSecName)) return;

		if (refKm != 0.f || refSec != 0.f) {
			segy tr;
			CFile file;
			if (!file.Open(draw.timeSecName, CFile::modeReadWrite | CFile::typeBinary)) {
				return;
			}
			//For progress control, need to know the last bytes no.
			ULONGLONG curBytesRead, totBytesRead = file.GetLength();
			file.Seek(0, CFile::begin);
			//Begin progress control.
			CMainFrame* pFrame = 
				(CMainFrame*)AfxGetMainWnd();
			ASSERT(pFrame);
			ASSERT_KINDOF(CMainFrame, pFrame);
			pFrame->BeginProgress();

			ULONGLONG bytesRead = file.Seek(3200L, CFile::begin);
			if(bytesRead < 3200)  {
				file.Close();
				AfxMessageBox(_T("Ascii section header read wrong"));
				return;
			}
			short i2buf[40000];
			bytesRead = file.Read(i2buf, 400);
			if(bytesRead < 400) {
				file.Close();
				AfxMessageBox(_T("Binary section header read wrong"));
				return;
			}
			int numsamp = (unsigned short)i2buf[10];
			int format = i2buf[12];
			int len;
			if(format!=3)  
				len = numsamp*4 + 240;
			else
				len = numsamp*2 + 240;
			int tpp = (unsigned short)i2buf[8];

			while (file.Read(&tr, 240) == 240) {
				curBytesRead = file.Seek(0, CFile::current);
				int iPos = (int)((double)curBytesRead/(double)totBytesRead*100.);
				if(iPos<0)iPos=0;
				if(iPos>100)iPos=100;
				pFrame->SetProgress(iPos);
				if ((shot1==shot2 && shot2==0) || (tr.tracl>=shot1 && tr.tracl<=shot2)) {
					if (fabs(refKm) > 0.0001f) {
						if(intOffset==0) {
							tr.offset += (int)(refKm*1000);
						} else if(intOffset==1) {
							setDistance(&tr, getDistance(&tr) + refKm );
						} else {
							tr.offset += (int)(refKm*1000);
							setDistance(&tr, getDistance(&tr) + refKm );
						}
					}
					setTraceDelayF( &tr, getTraceDelay(&tr) + refSec );
					file.Seek(-240, CFile::current);
					file.Write(&tr, 240);
				}
				file.Seek(len-240, CFile::current);
			}
			file.Close();
			pFrame->EndProgress();
			draw.isSameDataDisplay = FALSE; //indicate display has been changed and will re-load all data in OnDraw().
		} // if (refKm

		if (isTimeDomain()) {
			draw.isSegyKeyXShift = TRUE;
			draw.segyKeyXShift = 0.f;
			myCaption(_T("Left/right arrow keys will start shifting segy"));
			SetModifiedFlag();
			UpdateAllViews(NULL);
			NotifyChanged();
		}
	}

	void CSeisWideDoc::OnModelingRaytrace() 
	{
		CString tStr;

		if (!velMod.isTraceAuto) {
			CdlgRaytrace1 dlg;
			dlg.m_rayTracing = draw.rayName;
			dlg.m_velName = velMod.velSecName;

			dlg.tmax = (float)pCd.coord.tmax;
			dlg.tmin = (float)pCd.coord.tmin;
			dlg.vred = (float)pCd.coord.vred;
			dlg.xmax = (float)velMod.xmax;
			dlg.xmin = (float)velMod.xmin;
			dlg.xshot = (float)tx.xShot;
			dlg.zshot = (float)para.obsDepth;
			dlg.zmax = (float)pCd.coord.zmax;
			dlg.zmin = (float)pCd.coord.zmin;
			dlg.m_velName = velMod.velSecName;
			dlg.m_floatName = velMod.floatName;
			dlg.timeSecName = draw.timeSecName;
			dlg.m_txName = draw.txRaytraceName;
			dlg.m_isTraceAuto = velMod.isTraceAuto;
			dlg.m_kmShift = para.gunDepth2;
			if (dlg.DoModal() == IDOK) {
				draw.rayName = dlg.m_rayTracing;
				velMod.velSecName = dlg.m_velName.Trim();
				velMod.floatName = dlg.m_floatName;
				draw.txRaytraceName = dlg.m_txName;
				draw.timeSecName = dlg.timeSecName.Trim();
				para.obsDepth = dlg.zshot;
				velMod.isTraceAuto = dlg.m_isTraceAuto;
				para.gunDepth2 = dlg.m_kmShift;
			}
			else return;
			delete dlg;
		}

		if(velMod.velSecName.IsEmpty())  {
			tStr.Format(_T("Please specify a velocity model in .bin format"));
			AfxMessageBox(tStr);
			return;
		}
		//check to see if some other processes have changed the vel file since this document last initilized it.
		//	CFileStatus status;
		//	if(!CFile::GetStatus( velMod.velSecName, status )) 

		if (!isFileExistNotDirectory(velMod.velSecName)) {
			AfxMessageBox(_T("The model ")+velMod.velSecName+_T(" is not found"));
			return; // static function
		}

		CString name = velMod.velSecName;
		CString txPath = getWorkingPathSlash();
		SetCurrentDirectory(txPath);
		CString rinFile = txPath+_T("r.in");


		tStr = draw.rayName;
		tStr.MakeLower();
		if (tStr != rinFile) {
			if(!CopyFile(draw.rayName, rinFile, FALSE))  {
				AfxMessageBox(_T("Input ray parameter file cann't be copied to r.in in the working directory. It can happen if r.in is locked by some process, or the working directory is read-only. If r.in already exists, I will continue without updating r.in."));
				if (!isFileExistNotDirectory(rinFile))
					return;
			}
		}

		tStr.Format(_T("Output velocity file cann't be copied to v.bin in the working directory. It can happen if %s directory is not writable or v.bin is locked by some process."), txPath);
		CString vbinFile = txPath+_T("v.bin");


		CVelMod::VELMOD velMod2;
		CVelMod vm;
		vm.velModSetArrays(&velMod2);

		// we need to revise the velocity in each layer of velMod2 for anisotropy 
		// Note that the vel file on disk may be different from the one in memory velMod struct. But we want to use the one on disk for raytracing.
		velMod2.velSecName = velMod.velSecName;
		vm.velModSetArrays(&velMod2);
		if (!vm.loadInitVel(&velMod2, velMod2.velSecName, vel.dz))
			vm.velModCloneArrays(&velMod, &velMod2);

		for (int icont=1; icont<velMod2.ncont; icont++) {
			for (int j=0; j<velMod2.nzed[icont]; j++) {
				velMod2.zm[j][icont] -= para.gunDepth2;
			}
		} // for icont
		if (vm.saveModelAs(&velMod2, vbinFile, vel.dz, isTimeDomain(), TRUE))
			vm.velModFreeArrays(&velMod2);
		else {
			AfxMessageBox(tStr);
			vm.velModFreeArrays(&velMod2);
			return;
		}



		// now deals with floating reflectors.
		if (velMod.floatName.IsEmpty() && !velMod.floatNameOld.IsEmpty())
		{ // free arrays since they may have been used before.
			freeModelArrayEx();
			velMod.floatNameOld = _T("");
		}
		if (! myLoadFloatReflectors() ) velMod.floatName=_T(""); // always load again here: user may change from other places.
		// end of loading float reflectors.

		// now need to save as f.in format.
		if (!velMod.floatName.IsEmpty()) {
			int j,icont;
			FILE *stream;
			tStr = _T("f.in");
			if( _tfopen_s(&stream, tStr, _T("w") ) != 0 ) {
				AfxMessageBox( _T("New files could not open in the working directory.") );
				return;
			}
			// fseek( stream, 0L, SEEK_SET );
			for (icont=0; icont<velMod.totCurve; icont++) {
				_ftprintf_s(stream, _T("%2d\n"), velMod.npArray[icont]);
				_ftprintf_s(stream, _T("%2d "), icont+1);
				for (j=0; j<velMod.npArray[icont]; j++)
					_ftprintf_s(stream, _T("%10.4f"), velMod.xArray[j][icont]);
				_ftprintf_s(stream, _T("\n   "));
				for (j=0; j<velMod.npArray[icont]; j++)
					_ftprintf_s(stream, _T("%10.4f"), velMod.tArray[j][icont]);
				_ftprintf_s(stream, _T("\n   "));
				for (j=0; j<velMod.npArray[icont]; j++)
					_ftprintf_s(stream, _T("%10d"), 0);
				_ftprintf_s(stream, _T("\n"));
			}
			fclose( stream );
			// showFileInNotePad(tempStr);
		}
		//end of dealing with floating reflectors.


		// now copy tx.in file
			//if(!CopyFile(draw.txRaytraceName, _T("tx.in"), FALSE)) {
			//	AfxMessageBox(_T("tx.in file cann't be copied to the working directory"));
			//}
		tStr = GetFileExtension(draw.txRaytraceName);
		if ( !draw.txRaytraceName.IsEmpty() && tStr.MakeLower()==_T("in") ) {
			CStringArray arr;
			CStringArray arr3;
			float t1,t2,t3;
			int k;
			if (draw.txRaytraceName.Find(_T("*"), 0) >= 0) {
				// with wildcards, we need to concatenate into a single tx.in file
				TCHAR line[MAXLINE];
				CStringArray *arr5 = getAllPathArray(draw.txRaytraceName);	// CString Array to hold Directory Structures
				for (int io = 0; io< arr5->GetSize() ; io++) {
					register FILE *ifh1;  /* Input file handle */
					if (_tfopen_s(&ifh1, arr5->ElementAt(io), _T("r")) != 0) continue;
					while (_fgetts(line,MAXLINE,ifh1)!=NULL) {
						if (_tcslen(line) < 2) continue;
						if (_stscanf_s(line,_T("%f%f%f%d"),&t1, &t2, &t3, &k)==0) {
							continue;
						}
						if  (t1 != 0.f && t2 != 0.f && t3 != 0.f && k != -1)
							arr.Add(line);
					} // while fgets
					fclose(ifh1);
				} // for io=0
				arr5->RemoveAll();  arr5 = NULL;
				arr.Add(_T("     0.000     0.000     0.000        -1\n"));
			}
			else if (isFileExistNotDirectory(draw.txRaytraceName)) {
				getLinesFromFile2(&arr, draw.txRaytraceName, false, 0);
			}

			if (arr.GetCount() > 0) {
				for (int i=0; i<arr.GetCount(); i++) {
					tStr = arr.ElementAt(i);
					if (tStr[0] == '#') continue; // we do not need comment lines
					if (_stscanf_s(tStr,_T("%f%f%f%d"),&t1, &t2, &t3, &k)==0) {
						continue;
					}

					// the fortran program only reads in %10.3f  format, so we have to reformat all lines
					tStr.Format(_T("%10.3f%10.3f%10.3f%10d"), t1, t2, t3, k);
					arr3.Add(tStr);
				} // for i
				saveStringArrayToFile(&arr3, txPath + _T("tx.in"));
			}
			arr3.RemoveAll(); 
			arr.RemoveAll();
		} // if draw.tx

		// if raytracing fails, my display routine still uses the old "tx.out". This line avoids this.
		// if(CFile::GetStatus("tx.out", status )) DeleteFile("tx.out"); 
		// if(CFile::GetStatus("rPath.out", status )) DeleteFile("rPath.out"); 
		DeleteFile(_T("tx.out")); 
		DeleteFile(_T("rPath.out")); 
		DeleteFile(_T("r1.out")); 

		//   name = m_strPathName;
		//   int nPathLength =  GetModuleFileName (NULL,name.GetBuffer(_MAX_PATH), _MAX_PATH );
		//name.ReleaseBuffer();
		//CString progPathBak = name.Left(name.ReverseFind( '\\' ));  // it is the path only
		// CString progPath = progPathBak + _T("\\myRayinvr.exe");
		CString progPath = getSeisWidePath() + _T("\\myRayinvr.exe");
		CString exeNameQuoted = addQuotes(progPath);

		//Do not refresh screen in any way until raytracing finished. Otherwise, 
		// it may refresh screen while raytracing is running!
		draw.isSameDataDisplay = TRUE; 

		PROCESS_INFORMATION proc_i = myProcess(exeNameQuoted, txPath, !velMod.isTraceAuto);  // info returned from CreateProcess



		//WaitForInputIdle
		if(WaitForSingleObject(proc_i.hProcess, INFINITE) == WAIT_TIMEOUT) {
			AfxMessageBox(_T("Failed due to time-out in raytracing")) ;
			//	return;
		} else {
			if (draw.mode!=9)
				para.traveltime = TRUE;	//Time section will be drawn.
			// note: we do not want to enforce raypath in TWTT domain since it is very costly in CPU

			SetModifiedFlag();
			UpdateAllViews(NULL);
			//NotifyChanged();

			// try to refresh the previous windows
			this->myUpdateAllFramesExcept(this);
		} // else	
		CloseHandle(proc_i.hProcess);
		CloseHandle(proc_i.hThread);
	}

	void CSeisWideDoc::OnModelingRaypath() 
	{
		// disable this routine -- Oct. 20, 2003, by Deping
		return;

		if(AfxMessageBox(_T("This will do raytracing using old DOS display. Do you want to use Windows display instead?"), MB_YESNO |MB_ICONINFORMATION) == IDYES) {
			OnModelingRaytrace();
			return;
		}

		//	return;
		// _searchenv( searchfile, envvar, pathbuffer );

		if(AfxMessageBox(_T("Do you want to perform raytracing first (Choose Yes if you haven't done so after last velocity change)?"), MB_YESNO |MB_ICONINFORMATION) == IDYES)
			OnModelingRaytrace();

		//make tx.out file in the same directory as velMod.velSecName.
		CString name = velMod.velSecName, txPath;
		int pathLen = name.ReverseFind( '\\' );
		if(pathLen>(-1))
			SetCurrentDirectory(name.Left(pathLen));

		TCHAR curDir[_MAX_PATH];
		GetCurrentDirectory(_MAX_PATH, curDir);
		_tcscat_s(curDir, _T("\0"));

		name = m_strPathName;
		int nPathLength =  GetModuleFileName (NULL,name.GetBuffer(_MAX_PATH), _MAX_PATH );
		name.ReleaseBuffer();

		CString progPath = name.Left(nPathLength-12);
		progPath += _T("p.out");
		if(!CopyFile(_T("p.out"), progPath, FALSE)) 
		{
			AfxMessageBox(_T("p.out file in working directory cann't be copied to program install directory"));
			return;
		}

		SetCurrentDirectory(name.Left(nPathLength-12));

		if(_tsystem(_T("Rayplt.bat")) == -1) 
			AfxMessageBox(_T("Cannot run Rayplt.bat program to plot the rays"));
		else
		{
			progPath = _T(" This raypath graphics is saved as test.cgm file in ") + name.Left(nPathLength-12) + _T(" directory. To read/modify it, you could use a Lotus Software, CorelDraw, or CGM readers from Corel.com; Other softwares may not import properly.");
			progPath += _T("\n Alternatively, you can get PostScipt plot files by running separate executables (see extra downloads from http://foflg.net/seisweb).");
			AfxMessageBox(progPath );
		}

		SetCurrentDirectory(curDir);
		//draw.isSameDataDisplay = FALSE; //indicate display has been changed and will re-load all data in OnDraw().
		// SetModifiedFlag();
		UpdateAllViews(NULL);
		NotifyChanged();
	}

	void CSeisWideDoc::OnViewSegyinfo() 
	{
		CdlgSegyInfo dlg;

		dlg.m_timeSecName = draw.timeSecName;
		//	draw.isSameNodeDisplay = FALSE;

		static BOOL isAuto = FALSE;
		if (!isAuto && dlg.DoModal() == IDOK) {
			isAuto = dlg.m_isAuto;
		}
		else {
			// since we do not show dialog box, we directly dump trace header info. This can save user's time
			dlg.OnButton8DumpMoreTraceInfo();
		}
		//	draw.isSameNodeDisplay = TRUE;
	}

	void CSeisWideDoc::OnProcessingDefinesourceposition() 
	{
		float distTrc;
		int options;
		int isCalcFromUTM = 0;

		// para.isDistanceLeftOfShot controls how distance is calculated: if TRUE, Dist=xShot+offset. If FALSE, Dist=xShot-offset.
		int isSxsyOverwrite = (para.isDistanceLeftOfShot)  ?  1  :  0;

		CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
		//static float sxLong = -61.8982f;
		//static float syLat  = 84.4585f;
		static BOOL isNegativeFromLat = false;
		CString xyFileName;
		long FFID[20000];
		float dist[20000];
		int i=1, num, recPlus;

		bhed bh;
		segy tr;
		BOOL isUnix = false;
		//	short *i2buf;
		//	i2buf = (short *) &tr;
		//	float *trcdat;
		//	trcdat = (float *) &i2buf[120];

		CdlgSourcePos dlg;
		dlg.m_timeSecName = draw.timeSecName;
		dlg.m_xShot = myFloat5(tx.xShot);
		dlg.m_isNegativeFromLat = isNegativeFromLat;
		//	dlg.m_recPlus = 0.25;
		dlg.m_sxsyOverwrite = 0;
		if (pFrame->psei->sxLong > ERRORVAL) {
			dlg.m_sx = pFrame->psei->sxLong;
			dlg.m_sy = pFrame->psei->syLat;
		}
		else {
			dlg.m_sx = 0.f;
			dlg.m_sy = 0.f;
		}
		if (dlg.DoModal() == IDOK)
		{
			draw.timeSecName = dlg.m_timeSecName.Trim();
			tx.xShot = dlg.m_xShot;
			options = dlg.m_options;

			// the first option
			isSxsyOverwrite = dlg.m_sxsyOverwrite;
			if (isSxsyOverwrite==1)
				para.isDistanceLeftOfShot = TRUE;
			else
				para.isDistanceLeftOfShot = FALSE;

			pFrame->psei->sxLong = dlg.m_sx;
			pFrame->psei->syLat = dlg.m_sy;

			xyFileName = dlg.m_xyFileName;
			recPlus = dlg.m_recPlus;
			isNegativeFromLat = dlg.m_isNegativeFromLat;
			dlg.m_isCalcFromUTM;
		}
		else 
		{
			return;
		}
		delete dlg;

		if (isSxsyOverwrite>1 && pFrame->psei->sxLong==0.f && pFrame->psei->syLat==0.f) {
			AfxMessageBox(_T("Sorry, source long/lat cannot be all zero when calculating offset."));
			return;
		}

		if (!isFileExistNotDirectory(draw.timeSecName)) 
		{
			draw.isSameDataDisplay = FALSE;
			SetModifiedFlag();
			UpdateAllViews(NULL);
			NotifyChanged();
			return;
		}
		CFile file;
		if (!file.Open(draw.timeSecName, CFile::modeReadWrite | CFile::typeBinary)) {
			return;
		}

		//For progress control, need to know the last bytes no.
		ULONGLONG curBytesRead, totBytesRead = file.GetLength();
		file.Seek(0, CFile::begin);
		//Begin progress control.
		pFrame->BeginProgress();

		ULONGLONG bytesRead = file.Seek(3200L, CFile::begin);
		if(bytesRead < 3200) 
		{
			file.Close();
			AfxMessageBox(_T("Ascii section header read wrong"));
			return;
		}
		bytesRead = file.Read(&bh, 400);
		if(bytesRead < 400) 
		{
			file.Close();
			AfxMessageBox(_T("Binary section header read wrong"));
			return;
		}
		if (isUnix = IsUnix(bh.format)) {
			file.Close();
			AfxMessageBox(_T("Sorry, please convert to PC format (small-endian) before continue."));
			return;
		}

		BOOL dataInt = (bh.format == 3) ? TRUE : FALSE;
		int numsamp = bh.hns;
		int format = bh.format;
		int len = (bh.format==3) ? (2*bh.hns) :  4*bh.hns;
		len += 240;  // total trace length in bytes
		int tpp = bh.hdt;

		if(options==2)
		{
			if (!isFileExistNotDirectory(xyFileName)) {
				file.Close();
				AfxMessageBox(_T("please specify a FFID-Distance file name in ascii format"));
				return;
			}
			FILE *stream;
			if ( _tfopen_s(&stream, xyFileName, _T("r")) != 0) {
				file.Close();
				return;
			}
			_ftscanf_s(stream, _T("%ld %f"), &FFID[0], &dist[0]);
			while (_ftscanf_s(stream,_T("%ld %f"),&FFID[i],&dist[i]) > 0) {
				if(i==20000)
				{
					AfxMessageBox(_T("No more than 20,000 lines are read in! Program continues though."));
					break;
				}
				i++;
			}
			fclose(stream);
			num = i;
			for (i=0; i<num-1; i++) {
				if(FFID[i+1]<FFID[i]) {
					file.Close();
					AfxMessageBox(_T("FFID table not in sequential order"));
					return;
				}
			} // for
		} // if

		double aDistance = 0.0;
		int utmXOld = -1;
		int utmYOld = -1;


		while (file.Read(&tr, 240) == 240)
		{
			curBytesRead = file.Seek(0, CFile::current);
			int iPos = (int)((double)curBytesRead/(double)totBytesRead*100.);
			if(iPos<0)iPos=0;
			if(iPos>100)iPos=100;
			pFrame->SetProgress(iPos);

			if(options==0)
			{
				// single OBS/source for wide-angle data
				//now overwrite display to be offset+source position.
				if (isSxsyOverwrite>1) {
					// now, we calculate offset between (sx,sy) and (gx,gy); assuming sxLong, syLat already in long/lat degrees:
					setOffset(&tr, (float)calcDist(pFrame->psei->sxLong, pFrame->psei->syLat, tr.gx*0.0001, tr.gy*0.0001));
					if (isNegativeFromLat) {
						if (pFrame->psei->syLat < tr.gy*0.0001) tr.offset *= -1;
					}
					else {
						if (pFrame->psei->sxLong > tr.gx*0.0001) tr.offset *= -1;
					}
				}
				else if (isSxsyOverwrite==1) {
					setDistance(&tr, tx.xShot - getOffset(&tr));
				}
				else {
					setDistance(&tr, tx.xShot + getOffset(&tr));
				}
			}
			else if(options==1)
			{
				// near-offset MCS data, for simulating post-stack data for pre-stack algorithm
				// i2buf[36] = i2buf[40] = i2buf[10];
				// i2buf[37] = i2buf[41] = i2buf[11];
				if (isCalcFromUTM==0) 
					tr.sx = tr.gx = tr.cdp;
				else {
					// now need to overwrite sx,gx,cdp according to UTM coordinates 
					if (utmXOld==-1) {
						utmXOld = tr.sx;
						utmYOld = tr.sy;
					}
					else {

						aDistance += sqrt( (double)((tr.sx-utmXOld)*(tr.sx-utmXOld) + (tr.sy-utmYOld)*(tr.sy-utmYOld)) );
						utmXOld = tr.sx;
						utmYOld = tr.sy;
					}
					tr.sx = tr.gx = (int)myRound(aDistance);
					setDistance(&tr, aDistance );
				}
			}
			else
			{
				// modify source/receiver positions for pre-stack migration
				//ssmic.hw[0] = i2buf[4];
				// ssmic.hw[1] = i2buf[5]; //ssmic.iv is now FFID.

				if(tr.fldr<FFID[0])
					distTrc = dist[0];
				else if(tr.fldr>FFID[num-1])
					distTrc = dist[num-1];
				else
				{
					for (i=0; i<num-1; i++)
					{
						if(tr.fldr>=FFID[i] && tr.fldr<=FFID[i+1])
						{
							if(abs(tr.fldr-FFID[i])<1)
							{
								distTrc = dist[i];
								break;
							}
							distTrc = dist[i]+(dist[i+1]-dist[i])/
								(FFID[i+1]-FFID[i])*(tr.fldr-FFID[i]);
							break;
						}
					}
				}
				tr.sx = (long)(distTrc*1000.);

				if(recPlus == 0)
					tr.gx = tr.sx + tr.offset; //receiver pos.
				else
					tr.gx = tr.sx - tr.offset; //receiver pos.

			}

			//	i2buf[44] = 1;
			//meters used.
			//	tr.counit = 1;

			file.Seek(-240, CFile::current);
			file.Write(&tr, 240);
			file.Seek((long)(len-240), CFile::current);
		}

		file.Close();
		pFrame->EndProgress();

		if (options==0 && setXPosForSegy(draw.timeSecName, tx.xShot)) 
			para.traveltime = TRUE;;

		if (para.isDistanceDisplay) {
			// draw.timeSecOld = _T("");
			draw.isSameDataDisplay = FALSE; //indicate display has been changed and will re-load all data in OnDraw().
		}
		// in offset display, no need to change anything in display

		SetModifiedFlag();
		UpdateAllViews(NULL);
		NotifyChanged();
	}

	void CSeisWideDoc::OnEditNolables() 
	{
		if(draw.isNoLableOutside != TRUE)draw.isNoLableOutside=TRUE;
		else draw.isNoLableOutside=FALSE;
		//draw.isSameDataDisplay = FALSE; //ask to reload the data to display.
		draw.isNodeChanged = TRUE;

		//	SetModifiedFlag();
		//	draw.isSameDataDisplay = FALSE;
		UpdateAllViews(NULL);
		NotifyChanged();


	}

	void CSeisWideDoc::OnEditTuneupNoboundary() 
	{
		//if(draw.isNoBoundary != TRUE)draw.isNoBoundary=TRUE;
		//else draw.isNoBoundary=FALSE;
		draw.isNoBoundary = !draw.isNoBoundary;
		draw.isNoNodes = draw.isNoBoundary;
		draw.isNodeChanged = TRUE;

		//	draw.isSameDataDisplay = FALSE; //indicate display has been changed and will re-load all data in OnDraw().
		//	SetModifiedFlag();
		UpdateAllViews(NULL);
		NotifyChanged();

	}

	void CSeisWideDoc::OnEditTuneupNocolormap() 
	{
		draw.isNoColorMap= !draw.isNoColorMap;
		draw.isNodeChanged = TRUE;

		//if (draw.mode == 2 || draw.mode == 4) draw.isSameDataDisplay = FALSE; 
		// note: I do not have a special case for simple refresh in ondraw() in draw.mode==4, so I need to re-calculate all for this case
		UpdateAllViews(NULL);
	}

	void CSeisWideDoc::OnEditTuneupObspositions() 
	{
		//if(!draw.isNoOBSPos)draw.isNoOBSPos=TRUE;
		//else draw.isNoOBSPos=FALSE;
		draw.isNoOBSPos = !draw.isNoOBSPos;
		draw.isNodeChanged = TRUE;

		// draw.isSameDataDisplay = FALSE; //indicate display has been changed and will re-load all data in OnDraw().
		//	SetModifiedFlag();
		UpdateAllViews(NULL);
		NotifyChanged();

	}

	void CSeisWideDoc::OnEditDisplaytuneupFillareaonce() 
	{
		draw.isFillSmall = !draw.isFillSmall;
		draw.isSameDataDisplay = FALSE;
		UpdateAllViews(NULL);
		NotifyChanged();

	}

	void CSeisWideDoc::OnEditDisplaytuneupBigmodelnodes() 
	{
		if(draw.bigNodes==3) draw.bigNodes = 1;
		else if(draw.bigNodes==2) draw.bigNodes = 3;
		else if(draw.bigNodes==1) draw.bigNodes = 2;
		else draw.bigNodes = 1;
		//	draw.isSameDataDisplay = FALSE; //indicate display has been changed and will re-load all data in OnDraw().
		UpdateAllViews(NULL);
		NotifyChanged();

	}

	void CSeisWideDoc::OnEditDisplaytuneupChangcolorttcurves() 
	{
		draw.TTCurveColor ++;
		if(draw.TTCurveColor>4) draw.TTCurveColor = 0;
		else if (draw.TTCurveColor<0) draw.TTCurveColor=0;

		//	draw.isSameDataDisplay = FALSE; //indicate display has been changed and will re-load all data in OnDraw().
		UpdateAllViews(NULL);
		NotifyChanged();

	}

	void CSeisWideDoc::OnEditDisplaytuneupRemovettoverlay() 
	{
		para.traveltime = !para.traveltime;

		//	if(para.traveltime) para.traveltime = FALSE;
		//	else para.traveltime = TRUE;

		//if (!isTimeDomain())
		//	draw.isSameDataDisplay = FALSE; //indicate display has been changed and will re-load all data in OnDraw().
		UpdateAllViews(NULL);
		NotifyChanged();

	}

	void CSeisWideDoc::OnEditDisplaytuneupExternalDrawings() 
	{
		if(draw.isDigitizing)
		{
			AfxMessageBox(_T("You are still digitizing; Please finish it before clicking here!"));
			return;
		}


		if (!dig.digName.IsEmpty())
		{ //this means the arrays for dig.x and dig.t ... are already assigned and should free before continue.
			freeDigAll();
		}

		if(isTimeDomain())
		{
			CdlgLineDrawTim dlg0;
			if(dlg0.DoModal()!=IDOK)
			{
				UpdateAllViews(NULL);
				NotifyChanged();
				return;
			}
			delete dlg0;
		}
		else
		{
			CdlgLineDrawDep dlg0;
			if(dlg0.DoModal()!=IDOK)
			{
				UpdateAllViews(NULL);
				NotifyChanged();
				return;
			}
			delete dlg0;
		}


		// BOOL error_nmax=FALSE, error_lmax=FALSE;
		//new file dialog.
		CFileDialog dlg( TRUE,_T(""),_T("*.txt"),
			OFN_HIDEREADONLY|OFN_EXPLORER,
			_T("Input text File (*.txt)|*.txt|"));
		dlg.m_ofn.lpstrTitle = _T("Ascii file (3 columns: Distance, Depth(km), No.)");
		if(dlg.DoModal()==IDOK)
			dig.digName = dlg.GetPathName();
		else
		{
			return;
		}

		CDigitize pDg;
		if(!pDg.myDigitizingLoadTXTUnix2(&dig, dig.isSorted, dig.isSortedY)) 
			AfxMessageBox(_T("Failed reading input text file."));


		UpdateAllViews(NULL);
		NotifyChanged();

	}



	float CSeisWideDoc::getDepthAtSeafloor(float dist)
	{
		long icont,j;
		float depth = -1.f;
		if (velMod.ncont < 1) return depth;

		// this is the seafloor
		// icont = (velMod.vf[0][1][0]>1.55) ?  1  :  2;
		icont = (velMod.vf[0][1][0]>1.55 || velMod.vf[0][1][1]>1.55) ?  1  :  2;
		// here, if only 1 water layer exists, icont=1. If the second layer has a V<=1.55 at the top
		//  we should have icont=2

		for (j=1; j<velMod.nzed[icont]; j++) {
			if(dist < velMod.xm[0][icont]) {
				depth = velMod.zm[0][icont];
				break;
			} else if(dist>=velMod.xm[j-1][icont] && dist<=velMod.xm[j][icont]) {
				if (fabs(velMod.xm[j][icont]-velMod.xm[j-1][icont]) < 0.00001f)
					depth = velMod.zm[j][icont];
				else
					depth = velMod.zm[j-1][icont] + (dist-velMod.xm[j-1][icont])*
					(velMod.zm[j][icont]-velMod.zm[j-1][icont])/(velMod.xm[j][icont]-velMod.xm[j-1][icont]);
				break;
			} else if(dist>velMod.xm[velMod.nzed[icont] - 1][icont]) {
				depth = velMod.xm[velMod.nzed[icont] - 1][icont];
				break;
			}
		}
		return depth;
	}


	void CSeisWideDoc::OnProcessingTimeDepthDrawings() 
	{
		// this  will convert line drawings from time to depth
		BOOL error_nmax=FALSE, error_lmax=FALSE, firstTim=TRUE, textErr=FALSE ;
		//TCHAR line[MAXLINE];
		//FILE *ifh1;  /* Input file handle */
		FILE *stream;
		int i,j;
		//float x1,t1;

		if (!isModelDisplayed()) {
			AfxMessageBox(_T("Please display a valid model before continue."));
			return;
		}

		//new file dialog.
		CFileDialog dlg( FALSE,_T("txt;lstpc"),_T("*.txt; *.lstpc"),
			OFN_HIDEREADONLY|OFN_ALLOWMULTISELECT|OFN_EXPLORER,
			_T("Input text File (*.txt;*.lstpc)|*.txt;*.lstpc|"));
		dlg.m_ofn.lpstrTitle = _T("Select a valid ascii files in Digitize format");
		TCHAR* buff=new TCHAR[65535];
		buff[0]='\0';
		dlg.m_ofn.lpstrFile=buff;
		dlg.m_ofn.nMaxFile = 1;//sizeof(buff);


		CString t;
		bool isTime2Depth;
		int isTrue;
		t.Format(_T("Convert between time and depth domains. Yes=Time to depth. No=Depth to Time."));
		isTrue = AfxMessageBox(t, MB_YESNO |MB_ICONINFORMATION);
		if( isTrue == IDYES )
			isTime2Depth = true;
		else if( isTrue == IDNO )
			isTime2Depth = false;
		else return;


		CDigitize pDg;
		if (!isFileExistNotDirectory(dig.digName) || 
			!pDg.myDigitizingLoadTXTUnix2(&dig, dig.isSorted, dig.isSortedY) || 
			dig.totCurve<1) {
				AfxMessageBox(_T("Valid distance-TWTT pair not loaded."));
				return;
		}

		CString outFile = dig.digName + 
			(isTime2Depth  ?  _T(".ConvertedDepth.txt") : _T(".ConvertedTWTT.txt"));
		if (_tfopen_s(&stream, outFile, _T("w") ) != 0) return;
		//FILE *streamQM;
		//if (_tfopen_s(&streamQM, dig.digName + _T(".QingmuDepth.txt"), _T("w") ) != 0) return;
		//_ftprintf_s(streamQM,_T("#Sonobuoy 34-1\n"));
		//_ftprintf_s(streamQM,_T("#Comparison of Qingmu's formula with wide-angle model\n"));
		//_ftprintf_s(streamQM,_T("#z = (float)(-0.0578892255+2.067082*(t - tsf)+0.363685727*(t - tsf)*(t - tsf) );\n"));
		//_ftprintf_s(streamQM,_T("#  where t-tsf is one-way time below seafloor. z is the depth below seafloor. Below, *Depth_qm* will be computed depth plus seafloor depth\n"));
		//_ftprintf_s(streamQM,_T("#    Dist   *Depth_qm*  *Depth_Mod(km)*   Bound_No   TWTT_Picked(s) TWTT_seafl(s) Depth_seafl(s)\n"));

		CVelMod vm;
		for (i=0; i<dig.totCurve; i++)
			for (j=0; j<dig.nPoint[i]; j++) {
				register float y = dig.t[j][i];
				register double yout;
				if (isTime2Depth) {
					yout = vm.my2WayTime2Depth(&velMod, dig.x[j][i], y, vel.dz); 
				}
				else {
					yout = vm.myDepth2Time2Way(&velMod, dig.x[j][i], y, vel.dz);
				}
				_ftprintf_s(stream, _T(" %9.3f %9.3f %9d\n"),dig.x[j][i], yout, i+1);

				//float zsf = getDepthAtSeafloor(dig.x[j][i]);
				//float tsf = 4.f * zsf / (velMod.vf[0][0][0] + velMod.vf[0][0][1]);  // assumes constant water vel
				//float dqm = (float)(-0.0578892255+2.067082*(t - tsf)/2.+0.363685727*(t - tsf)*(t - tsf)/4. );
				//_ftprintf_s(streamQM," %9.3f %9.3f  %9.3f       %9d  twtt=%9.3f tsf=%9.3f zsf=%9.3f\n",dig.x[j][i], dqm+zsf, z, i+1, t, tsf, zsf);
			}
			fclose( stream );
			//fclose( streamQM );


			t = _T("Input time data are successfully converted and saved to the same directory as:\n")+
				dig.digName + _T("\n")+
				"using the current velocity model. Showing it in notepad first?";
			dig.digName = outFile;

			if( (AfxMessageBox(t, MB_YESNO |MB_ICONINFORMATION) == IDYES) )
			{
				showFileInNotePad(outFile);
			}

			UpdateAllViews(NULL);
			NotifyChanged();
	}


	BOOL CSeisWideDoc::MyLoadDistTwttDrawings4John(CString sgyName, CString lstpcName, CString digName)
	{
		// this will load John's CMP-TWTT ascii file inName, compare with 
		// draw.timeSecName or draw.depthSecName segy file to obtain distance information, 
		// and store to global variables: dig.x[][]  dig.t[][] struct, 
		// as well as saving to local file digName 


		CString tStr;
		tStr.Format(_T("Loading/long processing file %s ......"), lstpcName);
		myCaption(tStr);
		CStringArray *lst = getLinesFromFile(lstpcName);

		if (lst->GetSize() < 1) return FALSE;

		float *lst_twtt = (float *)malloc( sizeof(float)*lst->GetSize() );
		float *lst_fcmp = (float *)malloc( sizeof(float)*lst->GetSize() );
		int *lst_curve = (int *)malloc( sizeof(int)*lst->GetSize() );

		float f3;
		double d3;
		int i2, i3, i4;
		int i, ii = 0, j, np;
		int lst_size = 0;
		CString stmp;
		TCHAR ch[256];

		// skip the first 2 lines
		for (i=2; i<lst->GetSize(); i++) {
			// if ( _stscanf_s(lst->ElementAt(i).Trim(), "%16E%16E%3d%3d%f%f%f%d%lf%d%s",&d1, &d2, &lst_curve[ii],&i2,&lst_twtt[ii], &lst_fcmp[ii],   &f3, &i3, &d3, &i4, stmp) == 0 ) continue;
			if ( _stscanf_s(lst->ElementAt(i).Mid(32), _T("%d%d%f%f%f%d%lf%d%s"),&lst_curve[ii],&i2,&lst_twtt[ii], &lst_fcmp[ii],   &f3, &i3, &d3, &i4, ch, 256) == 0 ) continue;
			stmp = CString(ch, (int)_tcslen(ch)).Trim();
			if (sgyName.Find(stmp) >= 0) {
				lst_twtt[ii] *= 0.001f;  // convert to seconds
				ii++;
			}
		} // for i
		//lst_twtt[2800];
		lst->RemoveAll();
		delete lst;
		lst_size = ii;

		if (lst_size == 0) {
			// no points are read in. Let's exit this routine
			free(lst_curve);
			free(lst_twtt);
			free(lst_fcmp);
			//draw.isSameNodeDisplay = FALSE;
			myCaption(_T("No data read in. The last column must match: ") + sgyName);
			return FALSE;
		}


		// calculate how many curves exist
		int max_curves = 0;
		for (j=1; j<lst_size; j++) {
			if (lst_curve[j] != lst_curve[j-1]) max_curves++;
		} // for j

		int max_points = head.numTraces;


		CDigitize pDg;
		CDigitize::DIGITIZE dig2;
		pDg.initDigitizeArray(&dig2, max_points, max_curves); 
		dig2.isZeltFormat2 = FALSE;  // we only allow plain text format

		// start assigning for dig.xxx struct
		for (j=0; j<max_curves; j++) dig2.nPoint[j] = 0;
		dig2.totCurve = 1;
		dig2.iCurveSel = 0;

		/*
		...........................lst_curve...lst_ftwtt..lst_fcmp.....................................
		-6.34595099E+05  7.36724142E+05  2 14  4167.92    112.00    112.00    1 3.4028235E+38 2 lsl0914
		-6.34573900E+05  7.36711017E+05  2 14  4168.53    114.00    114.00    2 3.4028235E+38 2 lsl0914
		......
		-6.12287107E+05  7.11329916E+05  2 14  4147.33   2860.00   2860.00 1375 3.4028235E+38 2 lsl0914                                                       
		-6.12273682E+05  7.11308910E+05  2 14  4146.00   2862.00   2862.00 1376 3.4028235E+38 2 lsl0914                                                       
		-6.12221643E+05  7.11223842E+05  3 14  4129.45   2870.00   2870.00 1380 3.4028235E+38 2 lsl0914                                                       
		-6.12208772E+05  7.11202488E+05  3 14  4128.90   2872.00   2872.00 1381 3.4028235E+38 2 lsl0914                                                       
		......
		-6.34531503E+05  7.36684767E+05 25 14  4540.44    118.00    118.00    4 3.4028235E+38 2 lsl0914                                                       
		-6.34510304E+05  7.36671642E+05 25 14  4540.49    120.00    120.00    5 3.4028235E+38 2 lsl0914                                                       
		-6.34491477E+05  7.36655309E+05 25 14  4538.72    122.00    122.00    6 3.4028235E+38 2 lsl0914                                                       
		......
		-6.11556226E+05  7.08250887E+05 28 14  4576.01   3130.00   3130.00 1510 3.4028235E+38 2 lsl0914                                                       
		-6.11567083E+05  7.08231818E+05 28 14  4575.33   3132.00   3132.00 1511 3.4028235E+38 2 lsl0914                                                       
		-6.11577940E+05  7.08212750E+05 28 14  4574.46   3134.00   3134.00 1512 3.4028235E+38 2 lsl0914                                                       
		*/
		int ic;
		for (j=0; j<lst_size; j++) {
			ic = dig2.iCurveSel;
			np = dig2.nPoint[ic];  // total number of points for the current curve

			// now loop thru the segy traces to match the corresponding cmp[] in order to find the correct model distance dist[]
			for (i=0; i<head.numTraces; i++) {
				if (head.cmp[i] == (int)myRound(lst_fcmp[j])) {
					// make sure the num points do not exceed limit of dig2
					// in our case, max_points = numTraces
					if (np >= max_points-1)  break;

					if (np > 1) {
						if ( (j>0 && lst_fcmp[j] < lst_fcmp[j-1]) ||
							head.dist[i] < dig2.x[np-1][ic] ||
							(j>0 && lst_curve[j] != lst_curve[j-1]) ) 
						{

							if (ic >= max_curves-1) continue;  // max num of curves reached

							dig2.iCurveSel++;
							ic = dig2.iCurveSel; // iCurve updated already
							np = dig2.nPoint[ic] = 0;
							dig2.totCurve = ic+1;
						} // if
					} // if np>1
					dig2.x[np][ic] = head.dist[i];
					dig2.t[np][ic] = lst_twtt[j];
					dig2.nPoint[ic]++;
					np = dig2.nPoint[ic];  // total number of points for the current curve updated

					// we stop for this lst_fcmp[] anyway by breaking
					break;
				} // if
			} // for i
		} // for j

		// now we need to append dig2  to dig
		if (dig.nPoint == NULL) {
			initDigitizeArray(max_points, dig2.totCurve); 
			dig.isZeltFormat2 = FALSE;
			dig.totCurve = dig2.totCurve;
			for (int j=0; j<dig.totCurve; j++)
			{
				dig.nPoint[j] = dig2.nPoint[j];
			}
			for (ic=0; ic<dig.totCurve; ic++) {
				for (int ip=0; ip<dig.nPoint[ic]; ip++) {
					dig.x[ip][ic] = dig2.x[ip][ic];
					dig.t[ip][ic] = dig2.t[ip][ic];
				}
			}
		} // if dig.nPoint
		else {
			// first backup dig  to dig3
			CDigitize::DIGITIZE dig3;
			pDg.initDigitizeArray(&dig3, dig.DIG_POINT_MAX, dig.DIG_LAYER_MAX); 
			dig3.totCurve = dig.totCurve;
			for (int j=0; j<dig.totCurve; j++)
			{
				dig3.nPoint[j] = dig.nPoint[j];
			}
			for (ic=0; ic<dig.totCurve; ic++) {
				for (int ip=0; ip<dig.nPoint[ic]; ip++) {
					dig3.x[ip][ic] = dig.x[ip][ic];
					dig3.t[ip][ic] = dig.t[ip][ic];
				}
			}

			// re-define dig  and  append dig3 followed by dig2    to   dig
			pDg.initDigitizeArray(&dig, MAX(dig3.DIG_POINT_MAX, dig2.DIG_POINT_MAX), dig3.DIG_LAYER_MAX + dig2.DIG_LAYER_MAX); 
			dig.totCurve = dig3.totCurve + dig2.totCurve;
			for (int j=0; j<dig3.totCurve; j++)
			{
				dig.nPoint[j] = dig3.nPoint[j];
			}
			for (int j=0; j<dig3.totCurve; j++)
			{
				dig.nPoint[j] = dig3.nPoint[j];
			}
			for (ic=0; ic<dig3.totCurve; ic++) {
				for (int ip=0; ip<dig3.nPoint[ic]; ip++) {
					dig.x[ip][ic] = dig3.x[ip][ic];
					dig.t[ip][ic] = dig3.t[ip][ic];
				}
			}

			// append dig2 to  dig
			int cMax = dig3.totCurve;
			for (int j=0; j<dig2.totCurve; j++)
			{
				dig.nPoint[j + cMax] = dig2.nPoint[j];
			}
			for (int j=0; j<dig2.totCurve; j++)
			{
				dig.nPoint[j + cMax] = dig2.nPoint[j];
			}
			for (ic=0; ic<dig2.totCurve; ic++) {
				for (int ip=0; ip<dig2.nPoint[ic]; ip++) {
					dig.x[ip][ic + cMax] = dig2.x[ip][ic];
					dig.t[ip][ic + cMax] = dig2.t[ip][ic];
				}
			}

			pDg.freeDigAll(&dig3);
		}
		pDg.freeDigAll(&dig2);


		free(lst_curve);
		free(lst_twtt);
		free(lst_fcmp);
		// showFileInNotePad(latLongName + _T(".dist.txt");

		//SetModifiedFlag();
		//UpdateAllViews(NULL);
		//NotifyChanged();
		return TRUE;
	}


	BOOL CSeisWideDoc::MyLoadDistTwttDrawings4John(CString inName) 
	{
		// DEPRECIATED!!!!
		// this will load John's CMP-TWTT ascii file inName, compare with 
		// draw.timeSecName or draw.depthSecName segy file to obtain distance information, 
		// and store to global variables: dig.x[][]  dig.t[][] struct, as well as saving to file dig.digName 

		CStringArray *lst = getLinesFromFile(inName);
		if (lst->GetSize() < 1) return FALSE;

		float *lst_twtt = (float *)malloc( sizeof(float)*lst->GetSize() );
		float *lst_fcmp = (float *)malloc( sizeof(float)*lst->GetSize() );
		int *lst_curve = (int *)malloc( sizeof(int)*lst->GetSize() );

		float f3;
		double d3;
		int i2, i3, i4;
		int i, ii = 0, j, np;
		int lst_size = 0;
		CString stmp;
		TCHAR ch[256];

		CString fileSegy;
		if ( isFileExistNotDirectory(draw.timeSecName) )  {
			fileSegy = draw.timeSecName;
		}
		else {
			fileSegy = draw.depthSecName;
		}

		// skip the first 2 lines
		for (i=2; i<lst->GetSize(); i++) {
			if ( _stscanf_s(lst->ElementAt(i).Mid(32), _T("%d%d%f%f%f%d%lf%d%s"),&lst_curve[ii],&i2,&lst_twtt[ii], &lst_fcmp[ii],   &f3, &i3, &d3, &i4, ch, 256) == 0 ) continue;
			stmp = CString(ch, (int)_tcslen(ch)).Trim();
			if (fileSegy.Find(stmp) >= 0) {
				lst_twtt[ii] *= 0.001f;  // convert to seconds
				ii++;
			}
		} // for i
		//lst_twtt[2800];
		lst->RemoveAll();
		delete lst;
		lst_size = ii;

		if (lst_size == 0) {
			// no points are read in. Let's exit this routine
			free(lst_curve);
			free(lst_twtt);
			free(lst_fcmp);
			//draw.isSameNodeDisplay = FALSE;
			myCaption(_T("No data read in. The last column must match: ") + fileSegy);
			return FALSE;
		}


		// dig.digName	= getFileNameTemp( getFileNameAppend(fileSegy, "_lst"), "txt" );
		dig.digName	= GetFileNameAppendExt(fileSegy, _T("_lst"), _T("txt"));

		// calculate how many curves exist
		int max_curves = 0;
		for (j=1; j<lst_size; j++) {
			if (lst_curve[j] != lst_curve[j-1]) max_curves++;
		} // for j
		initDigitizeArray(head.numTraces, max_curves); 
		dig.isZeltFormat2 = FALSE;  // we only allow plain text format

		// start assigning for dig.xxx struct
		for (j=0; j<max_curves; j++) dig.nPoint[j] = 0;
		dig.totCurve = 1;
		dig.iCurveSel = 0;

		/*
		...........................lst_curve...lst_ftwtt..lst_fcmp.....................................
		-6.34595099E+05  7.36724142E+05  2 14  4167.92    112.00    112.00    1 3.4028235E+38 2 lsl0914
		-6.34573900E+05  7.36711017E+05  2 14  4168.53    114.00    114.00    2 3.4028235E+38 2 lsl0914
		......
		-6.12287107E+05  7.11329916E+05  2 14  4147.33   2860.00   2860.00 1375 3.4028235E+38 2 lsl0914                                                       
		-6.12273682E+05  7.11308910E+05  2 14  4146.00   2862.00   2862.00 1376 3.4028235E+38 2 lsl0914                                                       
		-6.12221643E+05  7.11223842E+05  3 14  4129.45   2870.00   2870.00 1380 3.4028235E+38 2 lsl0914                                                       
		-6.12208772E+05  7.11202488E+05  3 14  4128.90   2872.00   2872.00 1381 3.4028235E+38 2 lsl0914                                                       
		......
		-6.34531503E+05  7.36684767E+05 25 14  4540.44    118.00    118.00    4 3.4028235E+38 2 lsl0914                                                       
		-6.34510304E+05  7.36671642E+05 25 14  4540.49    120.00    120.00    5 3.4028235E+38 2 lsl0914                                                       
		-6.34491477E+05  7.36655309E+05 25 14  4538.72    122.00    122.00    6 3.4028235E+38 2 lsl0914                                                       
		......
		-6.11556226E+05  7.08250887E+05 28 14  4576.01   3130.00   3130.00 1510 3.4028235E+38 2 lsl0914                                                       
		-6.11567083E+05  7.08231818E+05 28 14  4575.33   3132.00   3132.00 1511 3.4028235E+38 2 lsl0914                                                       
		-6.11577940E+05  7.08212750E+05 28 14  4574.46   3134.00   3134.00 1512 3.4028235E+38 2 lsl0914                                                       
		*/
		for (j=0; j<lst_size; j++) {
			np = dig.nPoint[dig.iCurveSel];  // total number of points for the current curve

			// now loop thru the segy traces to match the corresponding cmp[] in order to find the correct model distance dist[]
			for (i=0; i<head.numTraces; i++) {
				if (head.cmp[i] == (int)myRound(lst_fcmp[j])) {
					if (
						np >= head.numTraces-1 ||
						(dig.nPoint[dig.iCurveSel] > 0 && j>0 && lst_fcmp[j] < lst_fcmp[j-1]) ||
						(np>0 && head.dist[i] < dig.x[np-1][dig.iCurveSel]) ||
						(dig.nPoint[dig.iCurveSel] > 0 && j>0 && lst_curve[j] != lst_curve[j-1])
						) {
							dig.iCurveSel++;
							np = dig.nPoint[dig.iCurveSel] = 0;
							dig.totCurve = dig.iCurveSel+1;
					} // if
					dig.x[np][dig.iCurveSel] = head.dist[i];
					dig.t[np][dig.iCurveSel] = lst_twtt[j];
					dig.nPoint[dig.iCurveSel]++;

					// we stop for this lst_fcmp[] anyway by breaking
					break;
				} // if
			} // for i
		} // for j

		CDigitize pDg;
		pDg.myDigSaveAs(&dig, FALSE, FALSE, tx.xShot); 

		free(lst_curve);
		free(lst_twtt);
		free(lst_fcmp);
		// showFileInNotePad(latLongName + _T(".dist.txt");

		//draw.isSameNodeDisplay = TRUE;
		//draw.isSameDataDisplay = TRUE; //indicate display has NOT been changed and do not re-load all data in OnDraw().
		//SetModifiedFlag();
		//UpdateAllViews(NULL);
		//NotifyChanged();
		return TRUE;
	}



	void CSeisWideDoc::myLineDrawing(CDC * pDC)
	{
		if (!isFileExistNotDirectory(dig.digName)) return;
		if (GetFileExtension(dig.digName) != _T("txt")) return;

		CDigitize pDg;
		if (!dig.digName.IsEmpty()) 
			pDg.myDigitizingLoadTXTUnix2(&dig, dig.isSorted, dig.isSortedY);
		if (dig.totCurve<1 || dig.nPoint==NULL) return;  // this avoids program crash

		long i, j;
		//double xpos,ypos;
		CPoint *plt;
		// CPoint plt[DIG_POINT_MAX];
		// plt = (CPoint *)malloc(numsamp*sizeof(CPoint));
		CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
		bool isReduceNeeded = isTimeDomain() && draw.mode != 10;
		int lineThicikess = min(30, (int)myRound(10.0* pFrame->thicknessLines));


		// label specific
		LOGFONT logFontNum;
		pDC->GetCurrentFont()->GetLogFont(&logFontNum);
		float xyRatio = (float)logFontNum.lfWidth / (float)logFontNum.lfHeight;
		int numWidth = (LONG)myRound(pFrame->fLabelDistance3 * 150.);
		int numHeight = (LONG)(numWidth / xyRatio);

		logFontNum.lfHeight = (int)numHeight;
		logFontNum.lfWidth = (int)numWidth;
		logFontNum.lfEscapement = 0;
		logFontNum.lfOrientation = 0;
		logFontNum.lfWeight = FW_NORMAL;
		logFontNum.lfWeight = FW_BOLD;
		logFontNum.lfItalic = 0;
		logFontNum.lfUnderline = 0;
		logFontNum.lfStrikeOut = 0;
		logFontNum.lfCharSet = ANSI_CHARSET;
		logFontNum.lfOutPrecision = OUT_DEFAULT_PRECIS;
		logFontNum.lfClipPrecision = CLIP_DEFAULT_PRECIS;
		logFontNum.lfQuality = DEFAULT_QUALITY;
		logFontNum.lfPitchAndFamily = FF_SWISS;
		_tcscpy_s(logFontNum.lfFaceName, _T("Arial"));
		CFont* fontN = new CFont(); 
		fontN->CreateFontIndirect(&logFontNum);
		CFont* oldFont = pDC->SelectObject(fontN);

		CDigitize::DIGITIZE dig3;
		myClipReducePoints4(&dig, &dig3, pCd.coord.axisX1, pCd.coord.axisX2, pCd.coord.axisY1, pCd.coord.axisY2);

		CPen* oldPen;
		bool isTime = isTimeDomain() == TRUE;
		plt = (CPoint *)malloc(dig3.DIG_POINT_MAX*sizeof(CPoint));
		if(plt==NULL) {
				myCaption(_T("Memory un-available 9"));
				return;
		}
		for (i=0; i<dig3.totCurve; i++) {
			register int n = dig3.nPoint[i];
			for (j=0; j<n; j++) {
				plt[j] = pCd.mm_coord(dig3.x[j][i], dig3.t[j][i], isTime);
			}

			int ind = i;
			while (ind >= lineColors.NUM_LINECOLORS)  
				ind -= lineColors.NUM_LINECOLORS;
			COLORREF rgb = RGB(lineColors.r[ind],
				lineColors.g[ind],
				lineColors.b[ind]);
			CPen aBluePen(PS_SOLID, lineThicikess, rgb);

			if(n>1) {
				oldPen = pDC->SelectObject(&aBluePen);
				pDC->Polyline(plt, n);
			}
			pDC->SelectObject(oldPen);

			// !draw.isNoLabelInSide is not affecting here since we have  dig.isLabelShow 
			if (dig.isLabelShow && 
				n>1 && 
				_tcslen(dig.labelArr->ElementAt(i)) > 0) {
					// now we plot the label for this curve
					// CPoint p = pCd.mm_coord(xpos,ypos);
					COLORREF oldColor = pDC->SetTextColor(rgb);
					pDC->TextOut((int)(plt[n-1].x), (int)(plt[n-1].y-numHeight*0.5), dig.labelArr->ElementAt(i));
					pDC->SetTextColor(oldColor);
			}
		} // for i
		free (plt);
		CDigitize::freeDigAll(&dig3);

		pDC->SelectObject(oldFont);
		fontN->DeleteObject();
		delete fontN;
		//	myLineDrawingLabel(pDC);	
		return;
	}

	//void CSeisWideDoc::myLineDrawingTim(CDC * pDC)
	//{
	//	// this routine is depreciated. Should use myLineDrawing()
	//	myLineDrawing(pDC);
	//	return;
	//}

	void CSeisWideDoc::DrawMarkers(CDC* pDC)
	{
		if(draw.isNoNodes) return;

		int j,k;
		double xpos,ypos;
		double ymin;
		double ymax;
		if (isTimeDomain()) {
			ymin = pCd.coord.tmin;
			ymax = pCd.coord.tmax;
		}
		else {
			ymin = pCd.coord.zmin;
			ymax = pCd.coord.zmax;
		}
		CString tstr;
		CPen* oldPen;
		//	CBrush* oldBrush;
		CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
		int dPlt = (int)(MIN(pCd.coord.logicalAxes.Width(), pCd.coord.logicalAxes.Height())/350. * pFrame->thicknessLines);


		CDigitize pDg;
		draw.digMarker.digName = draw.markerName;
		if (!draw.markerName.IsEmpty() 
			&& getFileModifiedTime(draw.markerName)!=draw.markerModifiedTime 
			&& pDg.myDigitizingLoadTXTUnix2(&draw.digMarker, 
					draw.digMarker.isSorted, draw.digMarker.isSortedY)) {
				CBrush brush, *oldBrush;
				brush.CreateSolidBrush(RGB(0,255,0));
				//int numMax = 0;
				//for (k=0; k<draw.digMarker.totCurve; k++) {
				//	if (numMax < draw.digMarker.nPoint[k]) numMax = draw.digMarker.nPoint[k];
				//}
				CPoint *pltV = (CPoint *)malloc(draw.digMarker.DIG_POINT_MAX*sizeof(CPoint));
				bool isTime = isTimeDomain() == TRUE;

				CDigitize::DIGITIZE dig3;
				myClipReducePoints4(&draw.digMarker, &dig3, pCd.coord.axisX1, pCd.coord.axisX2, pCd.coord.axisY1, pCd.coord.axisY2);
		
				for (k=0; k<dig3.totCurve; k++) {
					register int n = dig3.nPoint[k];
					for (j=0; j<n; j++) {
						pltV[j] = pCd.mm_coord(dig3.x[j][k], dig3.t[j][k], isTime);
					} // for j

					CPen redPen(PS_SOLID,5, RGB(255,0,0));
					oldBrush = pDC->SelectObject(&brush);
					oldPen = pDC->SelectObject(&redPen);
					for (j=0; j<n; j++)
							pDC->Ellipse(
							pltV[j].x - dPlt,
							pltV[j].y - dPlt,
							pltV[j].x + dPlt,
							pltV[j].y + dPlt
							);
					pDC->SelectObject(oldBrush);
					pDC->SelectObject(oldPen);
				} // for k

				brush.DeleteObject(); // this will be done automatically even if you do not do it here
				free(pltV);
				CDigitize::freeDigAll(&dig3);
		} // if

		if (isModelDisplayed() && isFileExistNotDirectory(draw.rayName)) {
			CVelMod vm;
			bool isTime = isTimeDomain() == TRUE;
			CStringArray *sArr = new CStringArray();
			CStringArray *sArrZ = new CStringArray();
			int nx = 0, nz = 0;
			if (loadParam(draw.rayName, _T("xshot"), sArr)) {
				nx = sArr->GetCount();
			} // if loadParam
			if (loadParam(draw.rayName, _T("zshot"), sArrZ)) {
				nz = sArrZ->GetCount();
			} // if loadParam
			if (nx==nz) {
				for (j=0; j<nx; j++) {
					xpos = StringToFloat(sArr->GetAt(j));
					ypos = StringToFloat(sArrZ->GetAt(j));  // ypos is in km depth
					if (isTimeDomain())
						ypos = vm.myDepth2Time2Way(&velMod, xpos, ypos, vel.dz);  // ypos is now in TWTT
					if (isVisibleOrNot(xpos, ypos)) {
						register CPoint p = pCd.mm_coord(xpos, ypos, isTime);
						pDC->Ellipse(
							p.x - dPlt,
							p.y - dPlt,
							p.x + dPlt,
							p.y + dPlt
							);
					}
				} // for j
			} // if nx

			sArr->RemoveAll();
			sArrZ->RemoveAll();
			delete sArr;
			delete sArrZ;
		}



		// the following should be later simplified using myLoadDigFile() function!!!
		return;
	}



	void CSeisWideDoc::OnProcessingCheckmodelintegrity() 
	{
		// TODO: Add your command handler code here
		//	if(draw.mode < 2 || draw.mode>4) 
		//	{
		//		AfxMessageBox(_T("Please show the model first", MB_OK|MB_ICONEXCLAMATION);
		//		return;
		//	}
		if(!checkModelError(velMod.velSecName))
		{
			AfxMessageBox(_T("There are boundary overlaps in the currently active model; Raytracing this model may hang up the raytracing program"));
			// CString newName = velMod.velSecName + _T(".tempErrInfo.txt";

			//CString newName = GetFileNameAppendExt(velMod.velSecName, _T(".tempErrInfo", _T("txt");
			//showFileInNotePad(newName);
			return;
		}
		else AfxMessageBox(_T("No errors found"));

	}


	void CSeisWideDoc::ClipModelDepreciated(float cmMin, float cmMax)
	{
		// **************NOT USED *****************
		return;

		if(velMod.velSecName.IsEmpty()) 
		{
			AfxMessageBox(_T(" Please save your current model before clipping"));
			return;
		}

		if(cmMin<velMod.xm[0][0] || cmMax>velMod.xm[velMod.nzed[0]-1][0]) 
		{
			AfxMessageBox(_T(" Please clip, not extend the model"));
			return;
		}
		int icont, j, k, k1, k2, n;
		float x[500], z[500];

		//clip a model between distance cmMin and cmMax.
		for (icont=0; icont<velMod.ncont; icont++)
		{
			for (j=0; j<velMod.nzed[icont]; j++)
			{
				if(velMod.xm[j][icont]<cmMin) continue;
				else
				{
					k1 = j;
					break;
				}
			}
			for (j=velMod.nzed[icont]-1; j>=0; j--)
			{
				if(velMod.xm[j][icont]>cmMax) continue;
				else
				{
					k2 = j;
					break;
				}
			}

			if(velMod.xm[k1][icont] != cmMin)
			{
				x[0] = cmMin;
				z[0] = velMod.zm[k1-1][icont] + 
					(velMod.zm[k1][icont]-velMod.zm[k1-1][icont])*
					(x[0]-velMod.xm[k1-1][icont])
					/(velMod.xm[k1][icont]-velMod.xm[k1-1][icont]);
				for (j=k1; j<=k2; j++)
				{
					x[j-k1+1] = velMod.xm[j][icont];
					z[j-k1+1] = velMod.zm[j][icont];
				}
				n = k2-k1+2;
			}
			else
			{
				for (j=k1; j<=k2; j++)
				{
					x[j-k1] = velMod.xm[j][icont];
					z[j-k1] = velMod.zm[j][icont];
				}
				n = k2-k1+1;
			}

			if(velMod.xm[k2][icont] != cmMax)
			{ //need change.
				n++;
				z[n-1] = velMod.zm[k2][icont] + 
					(velMod.zm[k2+1][icont]-velMod.zm[k2][icont])*
					(cmMax-velMod.xm[k2][icont])
					/(velMod.xm[k2+1][icont]-velMod.xm[k2][icont]);
				x[n-1] = cmMax;
			}

			velMod.nzed[icont] = n;
			for (j=0; j<n; j++)
			{
				velMod.xm[j][icont] = x[j];
				velMod.zm[j][icont] = z[j];
			}
		}  // End of clipping boundaries.

		//clip vel nodes between distance cmMin and cmMax.
		for (k=0; k<2; k++)
		{
			for (icont=0; icont<velMod.ncont-1; icont++)
			{
				for (j=0; j<velMod.nvel[icont][k]; j++)
				{
					if(velMod.xvel[j][icont][k]<cmMin) continue;
					else
					{
						k1 = j;
						break;
					}
				}
				for (j=velMod.nvel[icont][k]-1; j>=0; j--)
				{
					if(velMod.xvel[j][icont][k]>cmMax) continue;
					else
					{
						k2 = j;
						break;
					}
				}

				if(velMod.xvel[k1][icont][k] != cmMin)
				{
					x[0] = cmMin;
					//here z[0] is the velocity value.
					z[0] = velMod.vf[k1-1][icont][k] +
						(velMod.vf[k1][icont][k]-velMod.vf[k1-1][icont][k])*
						(x[0]-velMod.xvel[k1-1][icont][k])
						/(velMod.xvel[k1][icont][k]-velMod.xvel[k1-1][icont][k]);
					for (j=k1; j<=k2; j++)
					{
						x[j-k1+1] = velMod.xvel[j][icont][k];
						z[j-k1+1] = velMod.vf[j][icont][k];
					}
					n = k2-k1+2;
				}
				else
				{
					for (j=k1; j<=k2; j++)
					{
						x[j-k1] = velMod.xvel[j][icont][k];
						z[j-k1] = velMod.vf[j][icont][k];
					}
					n = k2-k1+1;
				}

				if(velMod.xvel[k2][icont][k] != cmMax)
				{ //need change.
					n++;
					x[n-1] = cmMax;
					z[n-1] = velMod.vf[k2][icont][k] +
						(velMod.vf[k2+1][icont][k]-velMod.vf[k2][icont][k])*
						(cmMax-velMod.xvel[k2][icont][k])
						/(velMod.xvel[k2+1][icont][k]-velMod.xvel[k2][icont][k]);
				}

				velMod.nvel[icont][k] = n;
				for (j=0; j<n; j++)
				{
					velMod.xvel[j][icont][k] = x[j];
					velMod.vf[j][icont][k] = z[j];
				}
			}  // End of clipping vel nodes.
		}

		pCd.coord.xmin = cmMin;
		pCd.coord.xmax = cmMax;
		velMod.xmin=cmMin;
		velMod.xmax=cmMax;
	}

	void CSeisWideDoc::OnToolbarResizemod() 
	{
		// isModelShown()

		if(!isVelModShown(&velMod)) {
			AfxMessageBox(_T(" Please show a model on the screen for editing"));
			return;
		}
		CdlgModelResize dlg;
		dlg.m_xmin = (float)pCd.coord.xmin;
		dlg.m_xmax = (float)pCd.coord.xmax;

		if(dlg.DoModal() == IDOK) {
			CVelMod vm;
			vm.ClipModeXmin(&velMod, dlg.m_xmin);
			vm.ClipModeXmax(&velMod, dlg.m_xmax);
		}
		else return;

		OnToolbarSaveasv();
		//	velMod.velSecOld = _T("");	//refresh velocity.
		//	draw.isSameDataDisplay = FALSE; //indicate display has been changed and will re-load all data in OnDraw().
		SetModifiedFlag();
		UpdateAllViews(NULL);
		NotifyChanged();
	}

	void CSeisWideDoc::OnDigitizeUndopoint() 
	{
		if (!draw.isDigitizing || dig.nPoint==NULL) return;
		if(dig.nPoint[dig.iCurveSel]>0) 
		{
			dig.nPoint[dig.iCurveSel] --;
			myCaption(_T(" Your lastly-digitized point has been removed; Refresh screen to show the removal"));
		}
		//else if(dig.iCurveSel>0)
		//{
		////	if(AfxMessageBox(s, MB_YESNO |MB_ICONINFORMATION) == IDYES)
		//	if(AfxMessageBox(_T(" This will delete the last point in the previous curve; Stop? "), MB_YESNO |MB_ICONINFORMATION) == IDNO)
		//	{
		//		dig.iCurveSel--;
		//		dig.totCurve--;
		//		dig.nPoint[dig.iCurveSel]--;
		//	}
		//}
		else AfxMessageBox(_T(" No points to undo"));
		myDigSaveAs(dig.digName); 
		draw.isSameDataDisplay = TRUE; //indicate display has been changed and will re-load all data in OnDraw().
		draw.isNodeChanged = TRUE;
		UpdateAllViews(NULL);
		NotifyChanged();
	}

	BOOL CSeisWideDoc::CheckTime(long daySet)
	{
		// Now I allow unlimited usage.....Deping,June 16, 2002!
		return TRUE;


		//	CTime t( 1997, 3, 19, 22, 15, 0 ); // 10:15PM March 19, 1997
		ULONGLONG nSize, nDays, nDays1;
		short FirstTime=0;                           /* size of string */ 
		CTime curTime = CTime::GetCurrentTime();
		CTime t, t1;

		CString WinSeis, WinSeisLast;

		TCHAR lpszSystemInfo[MAX_PATH];   /* buffer for concat'd. str. */ 
		nSize = GetSystemDirectory(lpszSystemInfo, MAX_PATH);
		_tcscat_s(lpszSystemInfo, _T("\\Winseidp.dll"));
		WinSeis = lpszSystemInfo;

		nSize = GetSystemDirectory(lpszSystemInfo, MAX_PATH);
		_tcscat_s(lpszSystemInfo, _T("\\chssmcd0.dll"));
		WinSeisLast = lpszSystemInfo;

		//Test if the file exists.
		CFileStatus status;
		extern CFile cfile;
		BOOL initFileStatus = CFile::GetStatus( WinSeis, status ); // static function
		BOOL initFileStatus1 = CFile::GetStatus( WinSeisLast, status ); // static function
		if(!initFileStatus && initFileStatus1)
		{	//this means chssmcd0.dll exists, but Winseidp.dll does not.
			//somebody must have deleted Winseidp.dll file.
			AfxMessageBox(_T("Entering into trial version due to usage expiration; you'll need to get an updated copy to perform time-depth conversion and migration (http://foflg.net/seisweb)!  All other functionality is still available"));
			return FALSE;
		}

		if(!initFileStatus || status.m_ctime<=0 || status.m_size<0)
		{	//if here then the file does not exist. Should not happen.
			return TRUE;
		}

		if(!initFileStatus1 || status.m_ctime<=0 || status.m_size<0)
		{	//if here then the file does not exist. Should not happen.
			return TRUE;
		}


		//If here then the two files all exist.
		CFile file;
		if (!file.Open( WinSeis, CFile::modeRead|CFile::typeBinary)) {
			return FALSE;
		}
		file.Seek(4*4, CFile::begin); //skip 4 records.
		file.Read(&t, 4);
		file.Close();

		CFile file1;
		if (!file.Open( WinSeisLast, CFile::modeRead|CFile::typeBinary)) {
			return FALSE;
		}
		file1.Seek(4*4, CFile::begin); //skip 4 records.
		file1.Read(&t1, 4);
		file1.Close();

		//t is first run, t1 is last run, curTime is this run.
		//note that t and t1 are the time in the 4th line of each file.
		CTimeSpan timeSpan1 = curTime - t1;
		nDays1 = timeSpan1.GetDays();
		CTimeSpan timeSpan = curTime - t;
		nDays = timeSpan.GetDays();
		if(nDays1<0 || nDays<0 || nDays>daySet)
		{
			AfxMessageBox(_T("Entering into trial version due to usage expiration; you'll need to get an updated copy to perform time-depth conversion and migration (http://phys.ocean.dal.ca/~deping)!  All other functionality is still available"));
			return FALSE;
		}
		else return TRUE;
	}


	void CSeisWideDoc::OnProcessingAppendasegyfile() 
	{
		int totShot=0, lastTrc,lastCDP;
		int i,numsamp2, len2; // actual numsample for the 2nd segy file.
		int numTracesIns = 0;
		CString inFile = _T(""), outFile=_T("");
		CString str;
		BOOL yesFilter=FALSE,reNumCDP;
		// TCHAR s[80];
		CdlgSegyAppend dlg;

		dlg.m_1stName = draw.timeSecName;
		dlg.m_traces_insert = 0;


		draw.isNodeChanged = FALSE;	
		if (dlg.DoModal() == IDOK)
		{
			reNumCDP = dlg.m_reNumCDP;
			inFile = dlg.m_1stName;
			outFile = dlg.m_2ndName;
			numTracesIns = dlg.m_traces_insert;
		}
		else 
		{
			return;
		}

		if (!isFileExistNotDirectory(inFile)) return;
		if(outFile==_T("")) return;
		if(outFile == inFile)
		{
			AfxMessageBox(_T("Output file name is the same as the input file name!"));
			return;
		}
		CFile file;
		if (!file.Open(inFile, CFile::modeReadWrite | CFile::typeBinary)) {
			return;
		}
		UINT bytesRead = file.Read(head.ascHead, 3200L);
		if(bytesRead < 3200) 
			AfxMessageBox(_T("Ascii section header read wrong"));

		bhed bh;
		segy tr;
		//short i2buf[40000];
		file.Read(&bh, 400L);
		if(bytesRead < 400) 
			AfxMessageBox(_T("Binary section header read wrong"));
		//The following numbers have to be recalculated everytime,
		//because plotting the depth section will change these numbers.
		int numsamp = (unsigned short)bh.hns;
		BOOL dataInt;
		//float *trcdat;
		//trcdat = (float *) &i2buf[120];
		//short *i2short;
		//i2short = (short *) &i2buf[120];
		int len;
		if(bh.format!=3)  
		{
			dataInt = FALSE;
			len = numsamp*4 + 240;
		}
		else 
		{
			dataInt = TRUE;
			len = numsamp*2 + 240;
		}
		short iDatForm = bh.format;
		int tpp = bh.hdt;
		file.SeekToEnd();
		file.Seek(-len, CFile::current);
		file.Read(&tr, len);
		lastTrc = tr.tracl;
		lastCDP = tr.cdp;
		ULONGLONG bytes = file.SeekToEnd();

		CFile file2;
		if (!file2.Open(outFile, CFile::modeRead | CFile::typeBinary)) {
			file.Close();
			return;
		}

		//For progress control, need to know the last bytes no.
		ULONGLONG curBytesRead, totBytesRead = file2.GetLength();
		file2.Seek(0, CFile::begin);

		bytesRead = file2.Read(head.ascHead, 3200L);
		if(bytesRead < 3200) 
		{
			AfxMessageBox(_T("Ascii section header for 2nd file read wrong"));
			file.Close();
			file2.Close();
			return;
		}
		bytesRead = file2.Read(&bh, 400L);
		if(bytesRead < 400) 
		{
			AfxMessageBox(_T("Binary section header for 2nd file read wrong"));
			file.Close();
			file2.Close();
			return;
		}
		if (tpp != bh.hdt )
		{
			str.Format(_T("Sample rate in 2nd file is %d, different from the 1st file which is %d"), bh.hdt, tpp);
			AfxMessageBox(str);
			file.Close();
			file2.Close();
			return;
		}
		if(iDatForm != bh.format)  
		{
			AfxMessageBox(_T("Data format in 2nd file is different from the 1st file"));
			file.Close();
			file2.Close();
			return;
		}
		numsamp2 = (long)bh.hns;
		if (iDatForm != 3)
			len2 = numsamp2*4 + 240;
		else
			len2 = numsamp2*2 + 240;
		if(numsamp != numsamp2) {
			if (AfxMessageBox(_T("Num of samples in 2nd file is different from the 1st file, and therefore will be clipped or zero-padded accordingly if continue."), MB_YESNO |MB_ICONINFORMATION) != IDYES) {
				file.Close();
				file2.Close();
				return;
			}
		}

		str.Format(_T("The last trace of first segy file is %d . Continue ?"), lastTrc);
		if(AfxMessageBox(str, MB_YESNO|MB_ICONQUESTION)!=IDYES)
		{
			file.Close();
			file2.Close();
			return;
		}

		if (numTracesIns > 0) {
			memset((void *) &tr.dat.data[0],(int) '\0', len-240); 
			tr.trid = 2; // mark as dead trace
			for (i=0; i<numTracesIns; i++) {
				tr.tracl++;
				tr.fldr++;
				tr.cdp++;
				file.Write(&tr, len);
				totShot++;
			} // for i
			file.Flush();
		}
		lastTrc = tr.tracl;
		lastCDP = tr.cdp;

		//Begin progress control.
		CMainFrame* pFrame = 
			(CMainFrame*)AfxGetMainWnd();
		ASSERT(pFrame);
		ASSERT_KINDOF(CMainFrame, pFrame);
		pFrame->BeginProgress();

		// NOTE: here in reading/writing, we do not convert between IBM and IEEE float at all, since no processing involved.
		while (file2.Read(&tr, len) == (UINT)len2)
		{
			curBytesRead = file2.Seek(0, CFile::current);
			int iPos = (int)((double)curBytesRead/(double)totBytesRead*100.);
			if(iPos<0)iPos=0;
			if(iPos>100)iPos=100;
			pFrame->SetProgress(iPos);

			//All trc numbers in 2nd file will be renumbered.
			lastTrc ++;
			tr.tracl = lastTrc;  // trace must be re-numbered
			if(reNumCDP)
			{
				lastCDP ++;
				tr.cdp = lastCDP;
			}
			if(numsamp2 < numsamp)
			{ // pad with zero if too short in trace length.
				for (i=numsamp2; i<numsamp; i++) {
					if (iDatForm == 1) tr.dat.data[i] = 0.f;
					else if (iDatForm == 2) tr.dat.dataint[i] = 0;
					else if (iDatForm == 3) tr.dat.datashort[i] = 0;
				} // for i
			}

			tr.ns = (unsigned short)numsamp;  // to be safe
			file.Write(&tr, len);
			file.Flush();
			totShot++;
		}
		pFrame->EndProgress();

		if(totShot>0) 
		{
			str.Format(_T("Succesfully appended %d traces incl. %d blank ones"), totShot, numTracesIns);
			myCaption(str);
		}
		else
			AfxMessageBox(_T("Not even one trace appended!"));

		file.Close();
		file2.Close();
	}

	BOOL CSeisWideDoc::reduction2TrcHeader(float vred)
	{
		double rrv, range;
		bhed bh;
		segy tr;

		if (!isFileExistNotDirectory(draw.timeSecName)) 
		{
			return FALSE;
		}
		CFile file;
		if (!file.Open(draw.timeSecName, CFile::modeReadWrite | CFile::typeBinary)) {
			return FALSE;
		}

		ULONGLONG bytesRead = file.Seek(3200L, CFile::begin);
		if(bytesRead < 3200) 
		{
			file.Close();
			AfxMessageBox(_T("Ascii section header read wrong"));
			return FALSE;
		}
		bytesRead = file.Read(&bh, 400);
		if(bytesRead < 400) 
		{
			file.Close();
			AfxMessageBox(_T("Binary section header read wrong"));
			return FALSE;
		}
		int numsamp = bh.hns;
		int format = bh.format;
		int len;
		if(format!=3)  
			len = numsamp*4 + 240;
		else
			len = numsamp*2 + 240;
		int tpp = bh.hdt;

		if(fabs(vred)<MINAMP) rrv = 0.;
		else rrv = 1./vred;

		while (file.Read(&tr, 240) == 240)
		{
			range = getOffset(&tr); //actual range in km.


			setTraceDelayF( &tr, getTraceDelay(&tr) + fabs(range) * rrv );

			file.Seek(-240, CFile::current);
			file.Write(&tr, 240);
			file.Seek(len-240, CFile::current);
		}

		file.Close();

		return TRUE;

	}

	void CSeisWideDoc::OnProcessingReducemanual() 
	{
		if (!isFileExistNotDirectory(draw.timeSecName)) 
		{
			AfxMessageBox(_T("Please display a segy data first"), MB_OK |MB_ICONINFORMATION);
			return;
		}
		CFile file;
		if (!file.Open(draw.timeSecName, CFile::modeRead | CFile::typeBinary)) {
			return;
		}
		ULONGLONG bytesRead = file.Seek(3200L, CFile::begin);
		if(bytesRead < 3200L) 
		{
			file.Close();
			AfxMessageBox(_T("Ascii section header read wrong"));
			return;
		}
		bhed bh;
		// short i2buf[40000];
		bytesRead = file.Read(&bh, 400);
		if(bytesRead < 400) 
		{
			file.Close();
			AfxMessageBox(_T("Binary section header read wrong"));
			return;
		}
		file.Close();

		int numsamp = bh.hns;;
		BOOL dataInt;
		int len;
		if(bh.format!=3)  
		{
			dataInt = FALSE;
			len = numsamp*4 + 240;
		}
		else 
		{
			dataInt = TRUE;
			len = numsamp*2 + 240;
		}
		int tpp = bh.hdt;

		CdlgVred dlg;
		dlg.m_vred = 0.f;
		dlg.m_timeSecName = draw.timeSecName;
		if(dlg.DoModal() == IDOK)
			//	_stprintf(s, _T("Your data has a reduction velocity %d (m/s) written at byte 46-47 in binary section header. Is the data already reduced by this velocity?", ssmic.iv);
				//	if(AfxMessageBox(s, MB_YESNO |MB_ICONINFORMATION) == IDYES)
		{
			if(reduction2TrcHeader(dlg.m_vred))
			{
				draw.isSameDataDisplay = FALSE; //indicate display has been changed and will re-load all data in OnDraw().
				SetModifiedFlag();
				UpdateAllViews(NULL);
				NotifyChanged();
				// draw.timeSecOld = _T("");
				return;
			}
		}
		else
		{
			return;
		}
	}

	void CSeisWideDoc::OnViewSegypreview() 
	{
		AfxMessageBox(_T("This view is under construction"));
		return;
		draw.modeOld = draw.mode;
		draw.mode = 5;	//Time section will be drawn.

		// if(!myParas()) return;
		CdlgSegyPreview dlg;
		dlg.m_clip = (float)para.clip;
		dlg.m_faceDown = pCd.coord.isFaceUp;
		if(fabs(para.fillOff) > 10.) para.fillOff = 0.1;
		dlg.m_fillOff = (float)para.fillOff;
		dlg.m_gain = (float)para.gain;
		dlg.m_shot1 = para.trace1;
		dlg.m_shot2 = para.trace2;
		dlg.m_timeSecTitle = draw.plotTitle;
		dlg.m_tmax = (float)pCd.coord.tmax;
		dlg.m_tmin = (float)pCd.coord.tmin;
		dlg.m_tTick = (float)pCd.coord.tTick;
		dlg.m_wiggle = para.wiggle;

		if(dlg.DoModal() == IDOK)
		{
			para.clip = dlg.m_clip;
			pCd.coord.isFaceUp = dlg.m_faceDown != 0;
			para.fillOff = dlg.m_fillOff;
			para.gain = dlg.m_gain;
			para.trace1 = dlg.m_shot1;
			para.trace2 = dlg.m_shot2;
			draw.plotTitle = dlg.m_timeSecTitle;
			pCd.coord.tmax = dlg.m_tmax;
			pCd.coord.tmin = dlg.m_tmin;
			pCd.coord.tTick = dlg.m_tTick;
			para.wiggle = dlg.m_wiggle;
		}
		else return;

		SetModifiedFlag();
		draw.isSameDataDisplay = FALSE;
		UpdateAllViews(NULL);
		NotifyChanged();

	}


	void CSeisWideDoc::OnModelingExtractvzcurve() 
	{
		long icont;
		double dist;
		static double subbasementVel2 = 4.699f;
		static double subbasementDepth_static = -1.f;

		if(!isModelDisplayed()) {
			AfxMessageBox(_T("Please display the model before extracting a V-Z curve"));
			return;
		}

		setXShotAll();

		tx.xShot = myFloat3(tx.xShot);
		CdlgVZCurve dlg;
		dlg.m_xShot = (float)tx.xShot;
		dlg.m_basementVel = myFloat3(subbasementVel2);
		dlg.m_basementDepth = myFloat3(subbasementDepth_static);
		if(dlg.DoModal() == IDOK) {
			dist = dlg.m_xShot;
			// we do not use float3() since it may change user's preference
			subbasementVel2 = dlg.m_basementVel;
			subbasementDepth_static = dlg.m_basementDepth;
		}
		else
			return;

		double offset = fabs(getOffsetFromXVal(dist));  // we only need the absolute value of offset here!

		FILE *stream;
		//CString outName = velMod.velSecName + _T(".tmpVZCurve";
		CString outName = GetFileNameAppendExt(velMod.velSecName, _T(".tmpVZCurve"), _T("txt"));
		if( _tfopen_s(&stream, outName, _T("w+") ) != 0 ) {
			AfxMessageBox ( _T("Could not open a temporary file") );
			return;
		}

		CVelMod vm;
		if (isTimeDomain())
			vm.myModel_TWTT2Depth(&velMod, vel.dz);

	//	double *twttMod = (double *)malloc(sizeof(double)*velMod.ncont);

		CVelMod::VELMOD_X modXOrig;
		modXOrig.dist = dist;
		vm.initModX(&velMod, &modXOrig, isTimeDomain()==TRUE, false, true, vel.dz);
		// vm.getZModFromZ(&velMod, &modXOrig, false);

		CVelMod::VELMOD_X modX;
		modX.dist = dist;
		vm.initModX(&velMod, &modX, isTimeDomain() == TRUE, true, true, vel.dz);
		// note: here we will need to ignore depthOri[] since it didn't consider anisotropy!!!
		//vm.getZModFromZ(&velMod, &modX, true);
		// vm.getTModFromZMod(&modX, vel.dz);
	//	int numWaterLayers = (modX.vTop[1]>1.55 || modX.vBot[1]>1.55) ? 1 : 2;
		// icont = (velMod.vf[0][1][0]>1.55 || velMod.vf[0][1][1]>1.55) ?  1  :  2;
		int numWaterLayers = NUM_WATER_LAYER;
		

		_ftprintf_s(stream,_T("# Model: %s\n"), velMod.velSecName);
		_ftprintf_s(stream,_T("# Reflection data: %s\n"), draw.timeSecName);
		_ftprintf_s(stream,_T("# Station information\n"));
		_ftprintf_s(stream,_T("#   Water depth (TWTT, s): %6.3f\n"), modX.timeMod[numWaterLayers]);
		_ftprintf_s(stream, _T("#   Water depth (km): %6.3f\n"), modX.depthMod[numWaterLayers]);
		_ftprintf_s(stream, _T("#   Water velocity at surface (km/s): %6.3f\n"), modX.vTop[0]);
		_ftprintf_s(stream, _T("#   Water velocity at seafloor (km/s): %6.3f\n"), modX.vBot[numWaterLayers - 1]);
		SegyWrapper sw(draw.timeSecName, true);
		if (CSegyMeta::segyHeadInit(draw.timeSecName, &head, 0) == 1) {
			//sw.m_tminFile = head.tminFile;
			//sw.m_tmaxFile = head.tmaxFile;
			if (sw.open(&head, 0) && sw.nxmax > 1) {
				if (fabs(draw.distShift) > MIL) draw.distShift = 0.f;
				int ix = sw.getClosestTrcIndexAtDistance(tx.xShot + draw.distShift);
				if (ix >= 0) {
					int gx = sw.trArr[ix].gx;
					int gy = sw.trArr[ix].gy;
					_ftprintf_s(stream,_T("#   Nearest shotpoint (FFID) in refl data: %d\n"), sw.trArr[ix].fldr);
					_ftprintf_s(stream,_T("#   Longitude, Latitude at FFID (arc value assumed at trace headers): %11.6f, %11.6f\n"), (float)gx/360000.0f, (float)gy/360000.0f);
				}
			} 
		}
		// _ftprintf_s(stream,_T("#   Model distance (km): %7.3f\n"),(float)dist);


		// 1. print out RMS numbers; they may need this more?
		float *VrmsTopMod = (float *)malloc(sizeof(float)*velMod.ncont);
		float *VrmsBotMod = (float *)malloc(sizeof(float)*velMod.ncont);
		vm.getVelocityRmsMod(&modX, vel.dz, tx.xShot, modX.timeMod, VrmsTopMod, VrmsBotMod);



		int iBasement = 0;  // starting layer number for basement
		double basementDepth; // depth for the starting layer for basement
		if (subbasementDepth_static < 0.f) {
			// must calculate basement depth and layer index
			for (icont=1; icont<velMod.ncont-1; icont++) {
				if (modX.vTop[icont] >= subbasementVel2 - 0.001) {   //  why  -0.001 ? This way, the exact number of user input included
					iBasement = icont;
					break;
				}
			}
			basementDepth = modX.depthMod[iBasement];
		}
		else  {
			// user fixed basement depth
			basementDepth = subbasementDepth_static;
			for (icont=0; icont<velMod.ncont-1; icont++) {
				if (modX.depthMod[icont] <= basementDepth && modX.depthMod[icont + 1] >= basementDepth) {
					iBasement = icont;
					break;
				}
			}
		}



		// 2. print out at decimal scales
		_ftprintf_s(stream,_T("#Pseudo-well at Model Distance %7.3f (offset %7.3f km; V4 marker at %7.3f km)(Params: %7.3f km/s; %7.3f km)\n"),
			(float)dist, (float)offset, basementDepth, subbasementVel2, subbasementDepth_static);
		_ftprintf_s(stream,_T("#TWT    VEL    DEPTH   VRMS  DBEPTH-BV4 MODEL (sec-km/s-km-km)\n"));

		CString velSecNameProcessed = velMod.velSecName;
		velSecNameProcessed.Replace(_T(" "), _T("_")); // we really do not want any spaces inside this string
		int indDrive = velSecNameProcessed.Find(_T(":\\"));
		if (indDrive > 0) {
			// we do not want the drive letter to appear as well
			velSecNameProcessed = velSecNameProcessed.Mid(indDrive + 2);
		}
		velSecNameProcessed.TrimRight(_T(".bin"));

		for (icont=0; icont<velMod.ncont-1; icont++)
		{
			float tz = (float)modX.timeMod[icont];
			float zz = (float)modX.depthMod[icont];
			if (icont>0) {
				tz += 0.01f;
				zz += 0.01f;
			}
			_ftprintf_s(stream, _T("%6.3f %6.3f %6.3f %6.3f"), tz, modX.vTop[icont], zz, VrmsTopMod[icont]);
			_ftprintf_s(stream,_T(" %6.3f"), (zz - basementDepth)>0  ?  zz - basementDepth  :  0.0f);
			_ftprintf_s(stream,_T("      %s  "), velSecNameProcessed);
			_ftprintf_s(stream,_T("\n"));

			tz = (float)modX.timeMod[icont+1];
			zz = (float)modX.depthMod[icont + 1];
			if (tz - modX.timeMod[icont] < 0.01f) {
				tz = (float)modX.timeMod[icont] + 0.01f;
				zz = (float)modX.depthMod[icont] + 0.01f;
			}
			_ftprintf_s(stream, _T("%6.3f %6.3f %6.3f %6.3f"), tz, modX.vBot[icont], zz, VrmsBotMod[icont]);
			_ftprintf_s(stream,_T(" %6.3f"), (zz - basementDepth)>0  ?  zz - basementDepth  :  0.0f);
			_ftprintf_s(stream,_T("      %s  "), velSecNameProcessed);
			_ftprintf_s(stream,_T("\n"));
		}
		_ftprintf_s(stream,_T("\n"));




		_ftprintf_s(stream,_T("# Note: the following are average velocities at the centre of each layer.\n"));
		_ftprintf_s(stream,_T("# Time (msbsf), Depth (mbsf), Layer velocity (km/s), 1=(observed refraction; 2=From reflection event)\n"));
		double avgTwttBsf;
		double avgDepthBsf;
		double avgVel;
		for (icont=1; icont<velMod.ncont-1; icont++) {
			avgTwttBsf = (modX.timeMod[icont]+modX.timeMod[icont+1])*0.5 - modX.timeMod[numWaterLayers];
			avgDepthBsf = (modX.depthMod[icont] + modX.depthMod[icont + 1])*0.5 - modX.depthMod[numWaterLayers];
			avgVel = (modX.vTop[icont] + modX.vBot[icont]) * 0.5;
			int fsdf = (int)myRound(avgDepthBsf*1000.);
			_ftprintf_s(stream,_T("%5d  %5d  %5d  "), (int)myRound(avgTwttBsf*1000.), (int)myRound(avgDepthBsf*1000.), (int)myRound(avgVel*1000.));
			_ftprintf_s(stream,_T("\n"));
		}
		_ftprintf_s(stream,_T("#\n"));




		if (iBasement>0) {
			_ftprintf_s(stream,_T("#\n# Note: the following line is for areal mapping of velocities, can be put to mapping softwares (e.g. surfer et al.).\n"));
			_ftprintf_s(stream, _T("#   Water depth %11.6f km;  %s\n"), modX.depthMod[numWaterLayers], velMod.velSecName);
			_ftprintf_s(stream,_T("#   Layer boundaries below basement with velocity greater than %8.3f km/s; You may manually change unreliable values to zero.\n"), subbasementVel2);
			_ftprintf_s(stream,_T("#   Vel(km/s) Depth(km) DBB(km)\n"));

			_ftprintf_s(stream, _T("   %6.3f    %6.3f    %6.3f  \n"), modX.vBot[iBasement - 1], modX.depthMod[iBasement], 0.0);
			for (icont=iBasement; icont<velMod.ncont-1; icont++) {
				_ftprintf_s(stream, _T("   %6.3f    %6.3f    %6.3f  \n"), modX.vTop[icont], modX.depthMod[icont] + 0.01, modX.depthMod[icont] - basementDepth + 0.01);
				_ftprintf_s(stream, _T("   %6.3f    %6.3f    %6.3f  \n"), modX.vBot[icont], modX.depthMod[icont + 1], modX.depthMod[icont + 1] - basementDepth);
			}

			_ftprintf_s(stream,_T("  \n\n" ));

			_ftprintf_s(stream,_T("#   Vel(km/s) DBB(km)\n"));
			for (icont=iBasement; icont<velMod.ncont-1; icont++) {
				_ftprintf_s(stream, _T("   %6.3f    %6.3f"), modX.vTop[icont], modX.depthMod[icont] - basementDepth + 0.01);
				_ftprintf_s(stream,_T("      %s\n"), velSecNameProcessed);
				_ftprintf_s(stream, _T("   %6.3f    %6.3f"), modX.vBot[icont], modX.depthMod[icont + 1] - basementDepth);
				_ftprintf_s(stream,_T("      %s\n"), velSecNameProcessed);
			}
		} // if iBasement







		_ftprintf_s(stream,_T("#\n#At model distance %7.3f; %s\n"),(float)dist,velMod.velSecName);
		_ftprintf_s(stream,_T("#Vrefr-intv   Twtt  msbsf  mbsf   Depth  Vrms\n"));
		for (icont=0; icont<velMod.ncont-1; icont++)
		{
			_ftprintf_s(stream,_T("       %4d  %5d  %5d  %5d  %5d  %4d"), 
				(int)myRound(1000.f* modX.vTop[icont]),
				(int)myRound(1000.f* modX.timeMod[icont]),  
				(int)myRound(1000.f* (modX.timeMod[icont]-modX.timeMod[numWaterLayers])),  
				(int)myRound(1000.f* (modX.depthMod[icont] - modX.depthMod[numWaterLayers])),
				(int)myRound(1000.f* modX.depthMod[icont]),
				(int)myRound(1000.f* VrmsTopMod[icont])
				);
			_ftprintf_s(stream,_T("\n"));

			_ftprintf_s(stream,_T("       %4d  %5d  %5d  %5d  %5d  %4d"), 
				//_ftprintf_s(stream,"       %4d  %4d  %5d  %5d  %4d  %4d", 
				(int)myRound(1000.f* modX.vBot[icont]),
				(int)myRound(1000.f* modX.timeMod[icont+1]),  
				(int)myRound(1000.f* (modX.timeMod[icont+1]-modX.timeMod[numWaterLayers])),  
				(int)myRound(1000.f* (modX.depthMod[icont + 1] - modX.depthMod[numWaterLayers])),
				(int)myRound(1000.f* modX.depthMod[icont + 1]),
				(int)myRound(1000.f* VrmsBotMod[icont])
				);
			_ftprintf_s(stream,_T("\n"));
		}
		free1float(VrmsTopMod);
		free1float(VrmsBotMod);
		_ftprintf_s(stream,_T("\n"));





		//_ftprintf_s(stream,"#TWT(SL)-TWT(BSF)-V, psudo well at Model Distance %7.3f (units: sec-sec-km/s):\n#  %s\n",(float)dist,velMod.velSecName);
		//for (icont=0; icont<velMod.nlayer; icont++)
		//{
		//	_ftprintf_s(stream,"%6.3f %6.3f %6.3f\n",twttMod[icont], vTop[icont],  vTopOri[icont]);
		//	_ftprintf_s(stream,"%6.3f %6.3f %6.3f\n",twttMod[icont+1], depth[icont+1], vBot[icont], vBotOri[icont]);
		//}





		_ftprintf_s(stream,_T("#VEL    DBEPTH-BV4 MODEL\n"));
		for (icont=0; icont<velMod.ncont-1; icont++)
		{
			float zz = (float)modX.depthMod[icont];
			if (icont>0) {
				zz += 0.01f;
			}
			_ftprintf_s(stream, _T("%6.3f"), modX.vTop[icont]);
			_ftprintf_s(stream,_T("     %6.3f  "), (zz - basementDepth)>0  ?  zz - basementDepth  :  0.0f);
			_ftprintf_s(stream,_T("\n"));

			zz = (float)modX.depthMod[icont + 1];
			if (zz - modX.depthMod[icont] < 0.01f) {
				zz = (float)modX.depthMod[icont] + 0.01f;
			}
			_ftprintf_s(stream, _T("%6.3f"), modX.vBot[icont]);
			_ftprintf_s(stream,_T("     %6.3f  "), (zz - basementDepth)>0  ?  zz - basementDepth  :  0.0f);
			_ftprintf_s(stream,_T("\n"));
		}


		_ftprintf_s(stream,_T("#\n#Tbsf-Zbsf-V-Vh at Model Distance %7.3f (units: ms-m-m/s; Tbsf=TWTT in sec below seafloor, or 2nd boundary; zbsf=depth in m below seafloor):\n#  %s\n"),(float)dist,velMod.velSecName);
		for (icont=1; icont<velMod.ncont-1; icont++)
		{
			register int itest = (int)myRound(1000.f*modX.vTop[icont]);
			_ftprintf_s(stream,_T("%4d  %4d  %4d"), (int)myRound(1000.f*(modX.timeMod[icont]-modX.timeMod[numWaterLayers])),  
				(int)myRound(1000.f*(modX.depthMod[icont] - modX.depthMod[numWaterLayers])), itest);
			_ftprintf_s(stream,_T("\n"));
			itest = (int)myRound(1000.f*modX.vBot[icont]);
			_ftprintf_s(stream,_T("%4d  %4d  %4d"), (int) myRound(1000.f*(modX.timeMod[icont+1]-modX.timeMod[numWaterLayers])), 
				(int)myRound(1000.f*(modX.depthMod[icont + 1] - modX.depthMod[numWaterLayers])), itest);
			_ftprintf_s(stream,_T("\n"));
		}
















		//free(twttMod);


		if (!velMod.isGrdInitialised)
			myVelModWholeInterpol();

		_ftprintf_s(stream,_T("\n\n#X-Z-V Dump of Model color gridding below. \n#All control points on the top and bottom boundaries within each layer will be dumped separately, layer by layer. \n#Anisotropy not included. Maybe useful for contouring in other programs.\n"));
		for (icont=0; icont<velMod.ncont-1; icont++) {
			for (int ix = 0; ix<velMod.grdNx; ix++) {
				float x = (float)(velMod.xmin + ix * vel.dxVDesired);
				_ftprintf_s(stream, _T("%10.4f %10.4f %10.4f\n"), x, velMod.grdDepth[icont][ix], velMod.vTop[icont][ix]);
			}
			for (int ix = 0; ix<velMod.grdNx; ix++) {
				float x = (float)(velMod.xmin + ix * vel.dxVDesired);
				_ftprintf_s(stream, _T("%10.4f %10.4f %10.4f\n"), x, velMod.grdDepth[icont + 1][ix], velMod.vBot[icont][ix]);
			}
		}


		if( stream != NULL ) fclose( stream );
		showFileInNotePad(outName);
	} 

	void CSeisWideDoc::OnModelingExtractlayerinfor() 
	{
		long icont,j;
		int mode; //boundary or vel mode; different from draw.mode.
		static float xx1 = 0.f, xx2=0.f, yy1=0.f, yy2=0.f;
		if(draw.mode<2 || draw.mode>4) {
			AfxMessageBox(_T("Please display the model before extracting layer information"));
			return;
		}
		CdlgTablizeLayer dlg;
		dlg.m_x1 = xx1;
		dlg.m_x2 = xx2;
		dlg.m_y1 = yy1;
		dlg.m_y2 = yy2;
		if(draw.nodes == 1) dlg.m_mode = 0;	//boundary mode.
		else dlg.m_mode = 1;	//vel mode.

		if(draw.isTopBound) dlg.m_top = 0; //unfortunately they are defined reverse.
		else dlg.m_top = 1;
		dlg.m_layerNum = draw.iLayerFocus;

		if(dlg.DoModal() == IDOK) {
			xx1 = xx1 = dlg.m_x1;
			xx2 = xx2 = dlg.m_x2;
			yy1 = yy1 = dlg.m_y1;
			yy2 = yy2 = dlg.m_y2;
			mode = dlg.m_mode;
			draw.isTopBound = dlg.m_top==0; //temoporily use a reversed iTopBound.
		}
		else return;
		if(xx1==0 && xx2==0 && yy1==0 && yy2==0) {
			AfxMessageBox(_T("Please specify spacial coordinate system for the model for text dumping"));
			draw.isTopBound = !draw.isTopBound; //reverse back to normal.
			return;
		}

		//start writing nodes into file.
		double temp, xRange;
		FILE *stream;
		//CString outName = velMod.velSecName + _T(".ModelXYVDump.txt";
		CString outName = GetFileNameAppendExt(velMod.velSecName, _T(".ModelXYVDump"), _T("txt"));
		if( _tfopen_s(&stream, outName, _T("w+") ) != 0 )
		{
			AfxMessageBox ( _T("Could not open a temporary file" ));
			fclose( stream );
			return;
		}

		xRange = velMod.xmax - velMod.xmin;
		if(xRange < MINAMP) 
		{
			AfxMessageBox ( _T("The xmax and xmin of the model are too close to each other" ));
			fclose( stream );
			return;
		}
		xRange = 1./xRange;

		CString sTemp;
		sTemp.Format(_T("%s\n Ascii dump: X, Y, Z in km for layer number %d"), velMod.velSecName, draw.iLayerFocus); 
		if(mode!=1) { //boundary mode.
			_ftprintf_s(stream, _T("%s\n"),sTemp);
			icont = draw.iLayerFocus;
			for (j=0; j<velMod.nzed[icont]; j++) {
				temp = (velMod.xm[j][icont] - velMod.xmin)*xRange;
				_ftprintf_s(stream,_T(" %9.3f %9.3f %9.3f\n"), 
					(float)((xx2-xx1)*temp+xx1), 
					(float)((yy2-yy1)*temp+yy1), 
					(float)velMod.zm[j][icont]);
			}
		} else { //velocity mode.
			if(!draw.isTopBound) 
				_ftprintf_s(stream, _T("%s; For top of the layer\n"),sTemp);
			else 
				_ftprintf_s(stream, _T("%s; For bottom of the layer\n"),sTemp);

			icont = draw.iLayerFocus;
			for (j=0; j<velMod.nvel[icont][!draw.isTopBound]; j++) {
				temp = (velMod.xvel[j][icont][!draw.isTopBound] - velMod.xmin)*xRange;
				_ftprintf_s(stream,_T(" %9.3f %9.3f %9.3f\n"), (float)((xx2-xx1)*temp+xx1), (float)((yy2-yy1)*temp+yy1), velMod.vf[j][icont][!draw.isTopBound]);
			}
		}

		fclose( stream );
		draw.isTopBound = !draw.isTopBound; //reverse back to normal.

		showFileInNotePad(outName);
	}

	void CSeisWideDoc::OnProcessingMigps() 
	{
		AfxMessageBox(_T("PS migration routines not working in this version"));
		return;
	}

	void CSeisWideDoc::OnProcessingPc2unixbatch() 
	{
		//Initilize.
		CString inFile = _T(""), outFile=_T("");

		segy tr;

		short *i2buf;
		i2buf = (short *) &tr;

		int *i2int;
		i2int = (int *) &i2buf[0];
		float *trcdat;
		trcdat = (float *) &i2buf[120];
		short *i2short;
		i2short = (short *) &i2buf[120];

		//Openfiles.
		CFileDialog dlg( TRUE,_T("sgy; SEG"),_T("*.sgy"),
			OFN_HIDEREADONLY|OFN_OVERWRITEPROMPT|OFN_ALLOWMULTISELECT|OFN_EXPLORER,
			_T("Input Segy File (*.sgy)|*.sgy|"));

		TCHAR* buff=new TCHAR[65535];
		buff[0]='\0';
		dlg.m_ofn.lpstrTitle = _T("Select all files for batch conversion");
		dlg.m_ofn.lpstrFile=buff;
		dlg.m_ofn.nMaxFile = 65535;//sizeof(buff);


		POSITION Position;

		if(dlg.DoModal()==IDOK)
		{

			Position=dlg.GetStartPosition();
			while(Position)
			{
				inFile = dlg.GetNextPathName(Position);
				outFile = 	getFileNameAppend(inFile, _T("Unix"));
				if (!isFileExistNotDirectory(inFile)) continue;
				CFile file;
				if (!file.Open(inFile, CFile::modeRead | CFile::typeBinary)) {
					continue;
				}

				if(outFile==_T("")) return;

				//For progress control, need to know the last bytes no.
				ULONGLONG curBytesRead, totBytesRead = file.GetLength();
				file.Seek(0, CFile::begin);
				//Begin progress control.
				CMainFrame* pFrame = 
					(CMainFrame*)AfxGetMainWnd();
				ASSERT(pFrame);
				ASSERT_KINDOF(CMainFrame, pFrame);
				pFrame->BeginProgress();

				UINT bytesRead = file.Read(head.ascHead, 3200L);
				if(bytesRead < 3200) 
					AfxMessageBox(_T("Ascii section header read wrong"));
				file.Read(i2buf, 400L);
				if(bytesRead < 400) 
					AfxMessageBox(_T("Binary section header read wrong"));
				//The following numbers have to be recalculated everytime,
				//because plotting the depth section will change these numbers.
				int numsamp = (unsigned short)i2buf[10];
				BOOL dataInt;
				int len;
				if(i2buf[12]!=3)  
				{
					dataInt = FALSE;
					len = numsamp*4 + 240;
				}
				else 
				{
					dataInt = TRUE;
					len = numsamp*2 + 240;
				}
				short iDatForm = i2buf[12];

				CFile file2;
				if (!file2.Open(outFile, CFile::modeWrite|CFile::modeCreate|CFile::typeBinary)) {
					file.Close();
					continue;
				}

				asc2ebc(head.ascHead, 3200);
				file2.Write(head.ascHead, 3200L);

				SwapTapeHeader((bhed *)&i2buf[0]);
				file2.Write(i2buf, 400L);


				ULONGLONG byteFileEnd = file.SeekToEnd();
				file.Seek(3600L, CFile::begin);

				int itemp;
				while (file.Read(&tr, len) == (UINT)len)
				{
					// first, swap cdp and cdpbak because oil softs do not like 
					// cdp to be in meters, a problem that I cannot solve.
					// this is only a temporary fix
					itemp = tr.cdp;
					tr.cdp = tr.cdpbak;
					tr.cdpbak = itemp;


					// now convert small to big endians
					SwapTraceHeader(&tr);
					SwapN(&tr, iDatForm);

					// note: since I do not convert between IBM and IEEE during reading, 
					// I do not convert during writing here!!!
					file2.Write(i2buf, len);

					curBytesRead = file.Seek(0, CFile::current);
					int iPos = (int)((double)curBytesRead/(double)totBytesRead*100.);
					if(iPos<0)iPos=0;
					if(iPos>100)iPos=100;
					pFrame->SetProgress(iPos);
				}
				file.Close();
				file2.Close();
				// draw.timeSecOld = _T("");	//recalculate gain.
				pFrame->EndProgress();


			} //end the while file POSITION loop.
		} //end dlg.DoModal function.
		delete [] buff;

	}


	void CSeisWideDoc::OnProcessingUnix2pcbatch() 
	{
		// this routine converts input data file in segy format (see segy.h file for definition) 
		// from big-endian to small-endian or Intel platform. It must consider input data in the 
		// formats of short integer, long integer, and floating point. See file suSwapByte.c for
		// routines of conversion.

		// A segy file contains an 3200-byte ascii section header, 400-byte binary section header, 
		// and many traces. Each trace is mapped in the struct "segy" which contains 240-byte 
		// binary header followed by data chunk.
		short *i2buf;
		long k;
		long *i4buf;
		segy tr;
		bhed bh;
		BOOL isUnix = FALSE;
		BOOL isOffsetMM = FALSE;
		BOOL isSwapIEEE_IBM = FALSE;
		BOOL isResetZero = FALSE;
		CString tStr;

		BOOL isDeadTrcExist, isUseReducedTime, GSCformat, trcRenum;
		static BOOL isConvertEbc2Ascii = FALSE;
		CString inFile = _T(""), outFile=_T("");

		i2buf = (short *) &tr;
		i4buf = (long *) &i2buf[0];

		CdlgUnix2PC dlg0;
		dlg0.m_isConvertEbc2Ascii = isConvertEbc2Ascii;
		if (dlg0.DoModal() == IDOK)
		{
			isConvertEbc2Ascii = dlg0.m_isConvertEbc2Ascii;
			isDeadTrcExist = dlg0.m_isDeadTrcExisting;
			isUseReducedTime = dlg0.m_useReducedTime;
			isResetZero = dlg0.m_isResetZero;
			GSCformat = dlg0.m_gsca;
			trcRenum = dlg0.m_reNum;
			isOffsetMM = dlg0.m_isOffsetMM;
			isSwapIEEE_IBM = dlg0.m_isSwapIEEE_IBM;
		}
		else return;

		CFileDialog dlg( TRUE,_T("sgy; SEG"),_T("*.sgy; *.SEG"),
			OFN_HIDEREADONLY|OFN_OVERWRITEPROMPT|OFN_ALLOWMULTISELECT|OFN_EXPLORER,
			_T("Input Segy File (*.sgy;*.SEG)|*.sgy; *.SEG|"));

		TCHAR* buff=new TCHAR[65535];
		buff[0]='\0';
		dlg.m_ofn.lpstrTitle = _T("Select all files for conversion in batch");
		dlg.m_ofn.lpstrFile=buff;
		dlg.m_ofn.nMaxFile = 65535;//sizeof(buff);

		//Begin progress control.
		CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
		ASSERT(pFrame);
		ASSERT_KINDOF(CMainFrame, pFrame);
		pFrame->BeginProgress();


		POSITION Position;

		if(dlg.DoModal()==IDOK)
		{
			Position=dlg.GetStartPosition();
			while(Position)
			{
				inFile = dlg.GetNextPathName(Position);
				CString tempStr = inFile;
				tempStr.MakeLower();
				// must make it lower case before comparing, in case some file has extension
				// like ".Sgy" or ".sGY".
				outFile = getFileNameAppend(inFile, _T("PC"));
				if(outFile==_T("")) {
					delete [] buff;
					return;
				}

				if (!isFileExistNotDirectory(inFile)) continue;
				CFile file;
				if (!file.Open(inFile, CFile::modeRead | CFile::typeBinary)) {
					continue;
				}

				//For progress control, need to know the last bytes no.
				ULONGLONG curBytesRead, totBytesRead = file.GetLength();
				file.Seek(0, CFile::begin);

				register UINT bytesRead = file.Read(head.ascHead, 3200L);
				if(bytesRead < 3200) {
					file.Close();
					myCaption(_T("File ") + inFile + _T(" Ascii section header read wrong"));
					continue;
				}
				file.Read(&bh, 400L);
				if(bytesRead < 400) {
					file.Close();
					myCaption(_T("File ") + inFile + _T(" Binary section header read wrong"));
					continue;
				}


				isUnix = IsUnix(bh.format);
				if (!isUnix) {
					tStr.Format(_T("Header of input file %s indicates %d as format. Are you sure it is unix format?"), inFile, bh.format);
					int id = AfxMessageBox(tStr, MB_YESNO |MB_ICONINFORMATION);
					if(id == IDNO) continue;
					else isUnix = TRUE;
				}

				if (isUnix) {
					SwapTapeHeader(&bh);
				}

				if (bh.format == 0) {
					tStr.Format(_T("Data format marked as 0. Is it floating point? If No, it is assumed to be short integer format"));
					int id = AfxMessageBox(tStr, MB_YESNO |MB_ICONINFORMATION);
					if(id == IDYES) bh.format = 1;
					else bh.format = 3;
				}

				if (isSwapIEEE_IBM) {
					if (bh.format==1)
						bh.format = 5;
					else if (bh.format==5)
						bh.format = 1;
				}


				int numsamp = bh.hns;
				int len;
				if(bh.format==1 || bh.format==2)
					len = numsamp*4 + 240;
				else if (bh.format==3)
					len = numsamp*2 + 240;
				else if(bh.format == 4) {
					file.Close();
					myCaption(_T("File ") + inFile + _T(" Data in 4-byte fixed point w/gain code is not supported in SeisWide; Try using NSCU in UNIX to convert"));
					continue;
				}
				else if (bh.format==5)
					len = numsamp*4 + 240;
				else {
					file.Close();
					myCaption(_T("File ") + inFile + _T(" has unknown format"));
					continue;
				}
				int tpp = bh.hdt;
				ULONGLONG byteFileEnd = file.SeekToEnd();
				file.Seek(3600L, CFile::begin);

				CFile file2;
				if (!file2.Open(outFile, CFile::modeWrite|CFile::modeCreate|CFile::typeBinary)) {
					file.Close();
					continue;
				}

				if (isConvertEbc2Ascii) ebc2asc(head.ascHead, 3200L);
				file2.Write(head.ascHead, 3200L);
				file2.Write(&bh, 400L);

				k = 0;
				while (file.Read(&tr, len) == (UINT)len)
				{
					k ++; //trace counter

					if (isUnix) {
						SwapTraceHeader(isUseReducedTime, isDeadTrcExist, &tr);
						SwapN(&tr, bh.format);
					}


					if(GSCformat) {
						double aDelay = 0.001 * (i4buf[45] + i4buf[52]);
						setTraceDelayF(&tr,  aDelay);
					}
					if (isResetZero)
						setTraceDelayF(&tr,  0.0);

					if (trcRenum) tr.tracl = k;

					if (isDeadTrcExist) {
						tr.trid = 1;  // mark it as always valid trace
					}

					if (isOffsetMM) {
						register double offset = tr.offset * 0.000001;
						setOffset(&tr, (float)offset);  // here offset must be in km
					}

					file2.Write(&tr, len);

					curBytesRead = file.Seek(0, CFile::current);
					int iPos = (int)((double)curBytesRead/(double)totBytesRead*100.);
					if(iPos<0)iPos=0;
					if(iPos>100)iPos=100;
					pFrame->SetProgress(iPos);
				} //end the while Read loop.
				file.Close();
				file2.Close();


			} //end the while file POSITION loop.
		} //end dlg.DoModal function.
		delete [] buff;

		pFrame->EndProgress();

		if(GSCformat) {
			AfxMessageBox(_T("Please note: for GSC segy that uses azymuth for the signs of trace offset, set them by running 'Processing|Reverse Signs'"));
		}
	}

	BOOL CSeisWideDoc::GetVelGrid(float fx, int nx, float dx, float fz, int nz, float dz, float *v)
	{
		//this routine calculates a velocity grid based on information
		//in struct velMod.
		/* Required parameters:
		(1) global struct velMod has all velocity information stored.
		(2) global tpp, a sample interval.
		Output: vt[0 to nt-1], with vt[0] pointing to sample it0.
		written by: Deping Chian on Aug. 1, 1997.
		*/

		TCHAR s[80];
		long iz,icont,ix,j;
		WORD totShot=0;
		double z,depth[MOD_LAYER_MAX],vTop[MOD_LAYER_MAX],vBot[MOD_LAYER_MAX];
		float range;
		double x1,x2,x3,x4,v1,v2,v3,v4;
		BOOL vStat;

		for (ix=0; ix<nx; ix++) {
			range = fx + ix*dx;

			for (icont=0; icont<velMod.ncont; icont++) {
				if(range<velMod.xm[0][icont])  {
					depth[icont] = velMod.zm[0][icont];
					continue;
				}
				if(range>velMod.xm[velMod.nzed[icont]-1][icont])  {
					depth[icont] = velMod.zm[velMod.nzed[icont]-1][icont];
					continue;
				}

				for (j=1; j<velMod.nzed[icont]; j++) {
					if(range>=velMod.xm[j-1][icont] && range<=velMod.xm[j][icont]) {
						if (fabs(velMod.xm[j][icont]-velMod.xm[j-1][icont]) < 0.00001f)
							depth[icont] = velMod.zm[j][icont];
						else
							depth[icont] = velMod.zm[j-1][icont] + (range-velMod.xm[j-1][icont])*
							(velMod.zm[j][icont]-velMod.zm[j-1][icont])/(velMod.xm[j][icont]-velMod.xm[j-1][icont]);
						break;
					}
				}
			}

			//_stprintf(s, "Depth: %d %d %d %d",(long)(1000*depth[0]),(long)(1000*depth[1]),(long)(1000*depth[2]),(long)(1000*depth[3]));
			//AfxMessageBox(s);
			//Now locate the four corners that define the velocity of for all points at range.
			//*****x1***********x2******* with range at depth[icont]
			//**********range************
			//***************************
			//**x3*********************x4 with range at depth[icont+1]
			for (icont=0; icont<velMod.ncont-1; icont++) {
				if(range<velMod.xm[0][icont]) 
				{
					vTop[icont] = velMod.vf[0][icont][0];
					vBot[icont] = velMod.vf[0][icont][1];
					continue;
				}
				if(range>velMod.xm[velMod.nzed[icont]-1][icont]) 
				{
					vTop[icont] = velMod.vf[velMod.nvel[icont][0]-1][icont][0];
					vBot[icont] = velMod.vf[velMod.nvel[icont][1]-1][icont][1];
					continue;
				}
				for (j=1; j<velMod.nvel[icont][0]; j++)
				{
					if(range>=velMod.xvel[j-1][icont][0] && range<=velMod.xvel[j][icont][0])
					{
						x1=velMod.xvel[j-1][icont][0];
						x2=velMod.xvel[j][icont][0];
						v1=velMod.vf[j-1][icont][0];
						v2=velMod.vf[j][icont][0];
						break;
					}
				}
				for (j=1; j<velMod.nvel[icont][1]; j++)
				{
					if(range>=velMod.xvel[j-1][icont][1] && range<=velMod.xvel[j][icont][1])
					{
						x3=velMod.xvel[j-1][icont][1];
						x4=velMod.xvel[j][icont][1];
						v3=velMod.vf[j-1][icont][1];
						v4=velMod.vf[j][icont][1];
						break;
					}
				}
				vTop[icont] = v1 + (v2-v1)*(range-x1)/(x2-x1);
				vBot[icont] = v3 + (v4-v3)*(range-x3)/(x4-x3);
			}

			//Bilinear interpolation and stores into vTrc[]:
			//Note that depth[0:nlayer], while vBot[0:nlayer-1].
			for (iz=0; iz<nz; iz++)
			{
				z = fz + iz*dz;
				vStat = FALSE;
				if(z > depth[velMod.ncont-1]) 
				{
					v[ix*nz+iz] = (float)vBot[velMod.ncont-1-1];
					vStat = TRUE;
					continue;
				}
				for (icont=0; icont<velMod.ncont-1; icont++)
				{
					if(depth[icont] >= (depth[icont+1]-MINAMP))
					{
						if(z>=depth[icont] && z<=depth[icont+1])
						{
							vStat = TRUE;
							v[ix*nz+iz] = (float)(vTop[icont] + vBot[icont])*0.5f;
							break;
						}
						else continue;
					}
					else if(z>=depth[icont] && z<=depth[icont+1])
					{
						v[ix*nz+iz] = (float)(vTop[icont] + (vBot[icont]-vTop[icont])*
							(z-depth[icont])/(depth[icont+1]-depth[icont]));
						vStat = TRUE;
						break;
					}
					else continue;
				}
				if(!vStat) 
				{
					_stprintf_s(s, _T("Depth z= %d in meters not determined, Stop!"),(long)(z*1000));
					AfxMessageBox(s);
					return FALSE;
				}

			}  //end of iz loop.
		}  //end of ix loop.
		for (ix=0; ix<nx; ix++)
			for (iz=0; iz<nz; iz++)
				v[ix*nz+iz] *= 1000.f;

		return TRUE;
	}

	int Lius2draytracingMod(float *v, Geo2d geo2dv, Geo2d geo2dt, 
		int nt, float dt, float fs, float ds, float aperx, 
		float fa, int na, float da, float amin, float amax, 
		float fac, float sourceDepth, int ek, int npv, FILE *jpfp, CString rayName) 
	{
		/*
		* Author:  Zhenyue Liu, 10/11/94,  Colorado School of Mines 
		*
		* This modified routine only outputs t[nxt*nzt].
		*
		* References:
		*
		* Beydoun, W. B., and Keho, T. H., 1987, The paraxial ray method:
		*   Geophysics, vol. 52, 1639-1653.
		*
		* Cerveny, V., 1985, The application of ray tracing to the numerical
		*   modeling of seismic wavefields in complex structures, in Dohr, G.,
		*   ED., Seismic shear waves (part A: Theory): Geophysical Press,
		*   Number 15 in Handbook of Geophysical Exploration, 1-124.
		* 
		*/
		/**************** end self doc ********************************/

		int	nat,nxo,nzo,nx,nz,nxt,nx0,mx;
		float	xs,exs,fxo,fzo,dxo,dzo,exo,ezo,
			ea,eat,fat,tmax,
			fx,fz,dx,dz,ex,ez,fxt,ext,
			*vt,*ov2,*pvt,*pv,*tv,*cs,*vo,*t;
		int ixs0,nsize,isize,ms;
		Raytr raytr;

		nx = geo2dv.nx; nz = geo2dv.nz;
		if(nx<3 || nz<3) 
		{
			_ftprintf_s(jpfp, _T("  Raytracing failed since nxv<=3 or nzv<=3 "));
			AfxMessageBox(_T("Raytracing's nx and nz must be not less than 3!"));
			return 0;
		}
		fx = geo2dv.fx; fz = geo2dv.fz; 
		dx = geo2dv.dx; dz = geo2dv.dz; 
		ex = fx+(nx-1)*dx;
		ez = fz+(nz-1)*dz;

		nxo = geo2dt.nx; nzo = geo2dt.nz;
		if(nxo<3 || nzo<3)
		{
			_ftprintf_s(jpfp, _T("  Raytracing failed since nxo<=3 or nzo<=3 "));
			return 0;
		}
		fxo = geo2dt.fx; fzo = geo2dt.fz; 
		dxo = geo2dt.dx; dzo = geo2dt.dz;
		exo = fxo+(nxo-1)*dxo;
		ezo = fzo+(nzo-1)*dzo;

		exs = exo;
		mx = (int)(2.0*aperx/dx+2.99);
		if(mx>nx) mx = nx;

		tmax = (nt-1)*dt;
		if(amax>180 || amin<0)  
		{
			_ftprintf_s(jpfp, _T("  Raytracing failed since amin and amax not within 0-180 degrees "));
			return 0;
		}
		fa *= PI/180;
		da *= PI/180;
		ea = fa+(na-1)*da;
		amin *= PI/180;
		amax *= PI/180;
		raytr.nt = nt;		raytr.dt = dt;
		raytr.da = da;		raytr.fac = fac;
		raytr.amin = amin;	raytr.amax = amax;
		raytr.zs = sourceDepth;


		ms = 10;
		ixs0 = 0; isize = 0; nsize = nzo*nxo;
		//End of parameter section

		/* ensure sources and output are in velocity grid	*/
		if(fx>fxo || ex<exs || fz>0) 
		{
			_ftprintf_s(jpfp, _T("  Raytracing failed since source lies outside of specified x grid "));
			return 0;
		}
		if(fx>fxo || ex<exo || fz>fzo || ez<ezo) 
		{
			_ftprintf_s(jpfp, _T("  Raytracing failed since output trace lies outside of specified x grid "));
			return 0;
		}

		/* allocate space */
		ov2 = (float *)alloc1float(nxo*nzo);
		t = (float *)alloc1float(nxo*nzo);
		if (ov2 == NULL || t == NULL) 
		{
			_ftprintf_s(jpfp, _T("  Raytracing failed since memory not allocated "));
			return 0;
		}

		// these arrays actually not used.
		if(npv) {
			pv = alloc1float(nx*nz);
			tv = alloc1float(nxo*nzo);
			vo = alloc1float(nxo*nzo);
			cs = alloc1float(nxo*nzo);
		}

		/*interpolate velocity and compute slowness squares  */
		// output ov2[nxo*nzo], which is 1/(v*v).
		voint(geo2dv,v,geo2dt,ov2,npv,vo);

		CFile filet(rayName, CFile::modeCreate|CFile::modeWrite|CFile::typeBinary);

		xs = fs;
		int scount = 0;
		while (xs <= exo)
		{
			/* redefine the velocity model due to aperture	*/
			//	temp = fxo;
			//	if(xs<temp) temp = xs;
			//	if(xs-aperx>temp) temp = xs-aperx;
			nx0 = (int)((fxo-fx)/dx); // fx is always smaller than fxo.
			fxt = fx+nx0*dx;
			//	temp = exo;
			//	if(xs>temp) temp = xs;
			//	if(xs+aperx<temp) temp = xs+aperx;
			nxt = 1+(int)((exo-fx)/dx+0.99)-nx0;
			ext = fxt+(nxt-1)*dx;
			//note the above that I made fx always smaller than fxo, so I simplify.

			vt = alloc1float(nxt*nz);
			if (vt == NULL) 
			{
				_ftprintf_s(jpfp, _T("  Raytracing failed since memory vt not allocated "));
				free1float(ov2);
				return FALSE;
			}
			if(npv) pvt = alloc1float(nxt*nz);

			/* reducing velocity voluem due to aperture: 
			* output vt[] which is from v[]: covering 2*aperx wide area only: from nx0 to nx0+nxt */
			trans(nz,nxt,nx0,v,vt);
			if(npv) trans(nz,nxt,nx0,pv,pvt);

			/* determine range of take-off angles	*/
			/*
			fat = fa;
			nat = na;
			if(xs==fxt && fat<0) {
			fat = 0.;
			nat = (int)(ea/da+1.5);
			} else if(xs==ext && ea>0)
			nat = (int)(1.5-fa/da);
			*/
			fat = fa;
			eat = ea;
			nat = na;
			if (fat<-(PI/2)) fat = -PI/2;
			if (eat>(PI/2)) eat = PI/2;
			if(xs==fxt && fat<0) {
				fat = 0.;
				nat = (int)(eat/da+1.5);
			} else if(xs==ext && eat>0)
				nat = (int)(1.5-fa/da);

			/* update geometry information	*/
			raytr.xs = xs;		raytr.zs = sourceDepth;
			raytr.na = nat;		raytr.fa = fat;		

			geo2dv.nx = nxt;	geo2dv.fx = fxt;

			/* compute traveltime by paraxial ray tarcing	*/
			raytime2d(raytr,geo2dv,vt,geo2dt,t,npv,vo,pvt,tv,cs);

			/*make up in shadow zones by eikonal equation	*/
			if(ek) eiknl(geo2dt,t,ov2,tmax);
			free1float(vt);

			/*write traveltime	*/
			// int numwritten = fwrite(t,sizeof(float),nxo*nzo,tfp);
			filet.Write(t, (UINT)(nxo*nzo*sizeof(float)));
			scount++;
			filet.Flush();

			_ftprintf_s(jpfp,_T(" traveltime computed for xs=%g\n"),xs);
			fflush(jpfp);

			xs+=ds;
		}

		_ftprintf_s(jpfp,_T(" finish program rayt2d\n\n"));
		free1float(ov2);
		free1float(t);
		filet.Close();
		return scount;
	}

	BOOL Lius2draytracingSingle(float *v, Geo2d geo2dv, Geo2d geo2dt, 
		int nt, float dt, float fxs, float *t, float aperx, 
		float fa, int na, float da, float amin, float amax, 
		float fac, float sourceDepth, int ek, int npv, FILE *jpfp) 
	{
		/*
		* Author:  Zhenyue Liu, 10/11/94,  Colorado School of Mines 
		*
		* This modified routine only outputs t[nxt*nzt].
		*
		* References:
		*
		* Beydoun, W. B., and Keho, T. H., 1987, The paraxial ray method:
		*   Geophysics, vol. 52, 1639-1653.
		*
		* Cerveny, V., 1985, The application of ray tracing to the numerical
		*   modeling of seismic wavefields in complex structures, in Dohr, G.,
		*   ED., Seismic shear waves (part A: Theory): Geophysical Press,
		*   Number 15 in Handbook of Geophysical Exploration, 1-124.
		* 
		*/
		/**************** end self doc ********************************/

		int	nat,nxo,nzo,nx,nz,nxt,nx0,mx;
		float	xs,exs,fxo,fzo,dxo,dzo,exo,ezo,
			ea,fat,tmax,temp,
			fx,fz,dx,dz,ex,ez,fxt,ext,
			*vt,*ov2,*pvt,*pv,*tv,*cs,*vo;
		int ixs0,nsize,isize,ms;
		Raytr raytr;

		nx = geo2dv.nx; nz = geo2dv.nz;
		if(nx<3 || nz<3) 
		{
			_ftprintf_s(jpfp, _T("  Raytracing failed since nxv<=3 or nzv<=3 "));
			AfxMessageBox(_T("Raytracing's nx and nz must be not less than 3!"));
			return FALSE;
		}
		fx = geo2dv.fx; fz = geo2dv.fz; 
		dx = geo2dv.dx; dz = geo2dv.dz; 
		ex = fx+(nx-1)*dx;
		ez = fz+(nz-1)*dz;

		nxo = geo2dt.nx; nzo = geo2dt.nz;
		if(nxo<3 || nzo<3)
		{
			_ftprintf_s(jpfp, _T("  Raytracing failed since nxo<=3 or nzo<=3 "));
			return FALSE;
		}
		fxo = geo2dt.fx; fzo = geo2dt.fz; 
		dxo = geo2dt.dx; dzo = geo2dt.dz;
		exo = fxo+(nxo-1)*dxo;
		ezo = fzo+(nzo-1)*dzo;

		exs = fxs;
		mx = (int)(2.0*aperx/dx+2.99);
		if(mx>nx) mx = nx;

		tmax = (nt-1)*dt;
		if(amax>180 || amin<0)  
		{
			_ftprintf_s(jpfp, _T("  Raytracing failed since amin and amax not within 0-180 degrees "));
			return FALSE;
		}
		fa *= PI/180;
		da *= PI/180;
		ea = fa+(na-1)*da;
		amin *= PI/180;
		amax *= PI/180;
		raytr.nt = nt;		raytr.dt = dt;
		raytr.da = da;		raytr.fac = fac;
		raytr.amin = amin;	raytr.amax = amax;
		raytr.zs = sourceDepth;

		ms = 10;
		ixs0 = 0; isize = 0; nsize = nzo*nxo;
		//End of parameter section

		/* ensure sources and output are in velocity grid	*/
		if(fx>fxs || ex<exs || fz>0) 
		{
			_ftprintf_s(jpfp, _T("  Raytracing failed since source lies outside of specified x grid "));
			return FALSE;
		}
		if(fx>fxo || ex<exo || fz>fzo || ez<ezo) 
		{
			_ftprintf_s(jpfp, _T("  Raytracing failed since output trace lies outside of specified x grid "));
			return FALSE;
		}

		/* allocate space */
		ov2 = (float *)alloc1float(nxo*nzo);
		if (ov2 == NULL) 
		{
			_ftprintf_s(jpfp, _T("  Raytracing failed since memory ov2 not allocated "));
			return FALSE;
		}


		if(npv) {
			pv = alloc1float(nx*nz);
			tv = alloc1float(nxo*nzo);
			vo = alloc1float(nxo*nzo);
			cs = alloc1float(nxo*nzo);
		}

		/*interpolate velocity and compute slowness squares  */
		// output ov2[nxo*nzo], which is 1/(v*v).
		voint(geo2dv,v,geo2dt,ov2,npv,vo);

		/* redefine the velocity model due to aperture	*/
		xs=fxs;
		temp = fxo;
		if(xs<temp) temp = xs;
		if(xs-aperx>temp) temp = xs-aperx;
		nx0 = (int)((temp-fx)/dx);
		fxt = fx+nx0*dx;
		temp = exo;
		if(xs>temp) temp = xs;
		if(xs+aperx<temp) temp = xs+aperx;
		nxt = 1+(int)((temp-fx)/dx+0.99)-nx0;
		ext = fxt+(nxt-1)*dx;

		vt = alloc1float(nxt*nz);
		if (vt == NULL) 
		{
			_ftprintf_s(jpfp, _T("  Raytracing failed since memory vt not allocated "));
			free1float(ov2);
			return FALSE;
		}
		if(npv) pvt = alloc1float(nxt*nz);

		/* reducing velocity voluem due to aperture: 
		* output vt[] which is from v[]: covering 2*aperx wide area only: from nx0 to nx0+nxt */
		trans(nz,nxt,nx0,v,vt);
		if(npv) trans(nz,nxt,nx0,pv,pvt);

		/* determine range of take-off angles	*/
		fat = fa;
		nat = na;
		if(xs==fxt && fat<0) {
			fat = 0.;
			nat = (int)(ea/da+1.5);
		} else if(xs==ext && ea>0)
			nat = (int)(1.5-fa/da);


		/* update geometry information	*/
		raytr.xs = xs;		raytr.zs = sourceDepth;
		raytr.na = nat;		raytr.fa = fat;		
		geo2dv.nx = nxt;	geo2dv.fx = fxt;

		/* compute traveltime by paraxial ray tarcing	*/
		raytime2d(raytr,geo2dv,vt,geo2dt,t,npv,vo,pvt,tv,cs);

		/*make up in shadow zones by eikonal equation	*/
		if(ek) eiknl(geo2dt,t,ov2,tmax);

		free1float(vt);
		free1float(ov2);

		return TRUE;
	}

	BOOL CSeisWideDoc::KdmigGeneral(FILE* jpfp, CFile* file2, BOOL useExist, BOOL preStack, BOOL appendOutput)
	{
		/* Copyright (c) Colorado School of Mines, 1996.*/
		/* All rights reserved.                       */

		/* SUKDMIG2D: $Revision: 1.9 $ ; $Date: 1996/01/25 22:01:33 $	*/

		/*********************** self documentation **********************/
		char *sdoc[] = {
			" 									",
			"SUKDMIG2D - Kirchhoff Depth Migration of 2D poststack/prestack data	",
			" 									",
			"    sukdmig2d  infile=  outfile=  [parameters] 			",
			"									",
			" Required parameters:							",
			" infile=stdin		file for input seismic traces			",
			" outfile=stdout	file for common offset migration output  	",
			" ttfile		file for input traveltime tables		",
			"   The following 9 parameters describe traveltime tables:		",
			" fzt 			first depth sample in traveltime table		",
			" nzt 			number of depth samples in traveltime table	",
			" dzt			depth interval in traveltime table		",
			" fxt			first lateral sample in traveltime table	",
			" nxt			number of lateral samples in traveltime table	",
			" dxt			lateral interval in traveltime table		",
			" fs 			x-coordinate of first source			",
			" ns 			number of sources				",
			" ds 			x-coordinate increment of sources		",
			"									",
			" Optional Parameters:							",
			" dt= or from header (dt) 	time sampling interval of input data	",
			" ft= or from header (ft) 	first time sample of input data	",
			" dxm= or from header (d2) 	sampling interval of midpoints 		",
			" fzo=fzt                z-coordinate of first point in output trace 	",
			" dzo=0.2*dzt		vertical spacing of output trace 		",
			" nzo=5*(nzt-1)+1 	number of points in output trace		",	
			" fxo=fxt                x-coordinate of first output trace 		",
			" dxo=0.5*dxt		horizontal spacing of output trace 		",
			" nxo=2*(nxt-1)+1  	number of output traces 			",	
			" off0=0               	first offest in output 				",
			" doff=99999		offset increment in output 			",
			" noff=1       		number of offsets in output 			",	
			" fmax=0.25/dt		frequency-highcut for input traces		",
			" offmax=99999		maximum absolute offset allowed in migration 	",
			" aperx=nxt*dxt/2  	migration lateral aperature 			",
			" angmax=60		migration angle aperature from vertical 	",
			" v0=1500(m/s)		reference velocity value at surface		",	
			" dvz=0.0  		reference velocity vertical gradient		",
			" ls=1	                flag for line source				",
			" ntr=100000		maximum number of input traces to be migrated	",
			" npv=0			flag of computing quantities for velocity analysis",
			"   ...if npv>0 specify the following three files:			",
			" tvfile=tvfile		input file of traveltime variation tables	",
			"			tv[ns][nxt][nzt]				",
			"									",
			" Notes:								",
			" 1. Traveltime tables were generated by program rayt2d (or other ones)	",
			"    on relatively coarse grids, with dimension ns*nxt*nzt. In the	",
			"    migration process, traveltimes are interpolated into shot/gephone 	",
			"    positions and output grids.					",
			" 2. Input seismic traces must be SU format and can be any type of 	",
			"    gathers (common shot, common offset, common CDP, and so on).	", 
			" 3. Migrated traces are output in CDP gathers if velocity analysis	",
			"    is required, with dimension nxo*noff*nzo.  			", 
			" 4. If the offset value of an input trace is not in the offset array 	",
			"    of output, the nearest one in the array is chosen. 		",
			" 5. Memory requirement for this program is about			",
			"    	[ns*nxt*nzt+noff*nxo*nzo+4*nr*nzt+5*nxt*nzt+npa*(2*ns*nxt*nzt   ",
			"	+noff*nxo*nzo+4*nxt*nzt)]*4 bytes				",
			"    where nr = 1+min(nxt*dxt,0.5*offmax+aperx)/dxo. 			",
			" 6. Amplitudes are computed using the reference velocity profile, v(z),",
			"    specified by the parameters v0= and dvz=.				",
			" 7. Input traces must specify source and receiver positions via the header",
			"    fields tr.sx and tr.gx. Offset is computed automatically.		",
			"									",
			NULL};
		/*
		* Author:  Zhenyue Liu, 03/01/95,  Colorado School of Mines 
		*
		* Trace header fields accessed: ns, dt, delrt, d2
		* Trace header fields used in input and has to be modified in output: sx, gx
		*
		* For KD migration, all you need to do with the pre-stack data: 
		* assign sx and gx fields to each trace.
		*/

		/**************** end self doc ***********************************/

		/* segy trace */
		segy tr, tro;

		int 	nt,ntRay,nxv,nzv,nzt,nxt,nzo,nxo,noff, nr,ix,iz,ixo,izo, j, io;
		int 	ls,jtr,ktr,mtmax,ek,npv;
		float   ft,fxv,fzv,fzt,fxt,fs,fzo,fxo,off0,dt,dtRay,dxv,dzv,dzt,dxt,dzo,dxo,doff,dxm,ds,
			ext,ezt,ezo,exo,scal, x;	
		float v0,dvz,fmax,angmax,offmax,rmax,sx,gx;
		float ***mig,**tb,**pb,**cs0b,**angb,**tsum,**tt, **t1, *v;
		float **tvsum=NULL,***mig1=NULL,**cssum=NULL; // initilize to NULL to avoid compiler warning
		BOOL useOnDemand=FALSE;

		Geo2d geo2dv, geo2dt;
		CString inF, outF;


		// Deping's notes: 
		// (1) this routine is called by OnProcessingKdmigsimple() or OnProcessingKdmigPost(),
		//     which invokes dialog boxes for parameters. No dialog boxes are called here.
		// (2) Those dialog boxes MUST handle parameters like:
		//		draw.timeSecName, velMod.velSecName, draw.depthSecName, pCd.coord.xmin, pCd.coord.xmax, 
		//		pCd.coord.zmin, vel.dz, pCd.coord.zmax, and struct kd...
		// (3) if useExist is true, skip raytracing. If preStack is true, a pre-stack case.
		// (4) if appendOutput=TRUE, output data will be appended to existing one: for  
		//	   migration of several sections, this is useful.
		inF = draw.timeSecName;
		outF = draw.depthSecName;
		if(kd.ek) ek = 1;
		else ek = 0;


		//All parameters are entered in km, but this routine only uses m.
		ds = (float)(kd.ds*1000.);
		dxm = 1000.f*kd.dxm;

		off0 = 1000.f*kd.off0;
		doff = 99999.f;
		noff = 1;
		offmax = 1000.f*kd.offmax;
		ls = kd.ls;
		fmax = kd.fmax;
		angmax = kd.angmax;

		if(kd.dt<0.0000001f)kd.dt=0.008f;
		dtRay = kd.dt;
		ntRay = (int)(kd.tmaxRay/kd.dt + 1.5f);

		npv=0; //do not do velocity analysis.

		if(kd.aperx<kd.dxo) kd.aperx = kd.dxo;

		fxo = 1000.f*((float)pCd.coord.xmin - kd.aperx);
		fzo = (float)pCd.coord.zmin*1000.f;
		dxo = 1000.f*kd.dxo;
		dzo = 1000.f*(float)vel.dz;  
		nxo = (int)((pCd.coord.xmax-pCd.coord.xmin+2.*kd.aperx)/kd.dxo + 0.9999);
		nzo = (int)((pCd.coord.zmax-pCd.coord.zmin)/vel.dz + 0.9999);
		exo = fxo+(nxo-1)*dxo;
		ezo = fzo+(nzo-1)*dzo;

		fxt = 1000.f*((float)pCd.coord.xmin - kd.aperx);
		fzt = (float)pCd.coord.zmin*1000.f;
		dxt = 1000.f*kd.dxt;
		dzt = 1000.f*kd.dzt;  if (dzt<dzo) dzt = dzo; // this can be coarser than vel.dz
		nxt = (int)((pCd.coord.xmax-pCd.coord.xmin+2.*kd.aperx)*1000.f/dxt + 0.9999);
		nzt = (int)((pCd.coord.zmax-pCd.coord.zmin)*1000.f/dzt + 0.9999);
		ext = fxt+(nxt-1)*dxt;
		ezt = fzt+(nzt-1)*dzt;

		//be careful to get raytracing wide enough to cover all output areas.
		fxv = fxo;
		fzv = 0.f; 	//Found that raytracing requires fzv<=0 
		dxv = kd.dxv*1000;
		dzv = 1000.f*kd.dzv;	//depth increment for vel model.
		nxv = (int)((exo-fxv)/dxv + 2.f); //this should come last.
		nzv = (int)((ezo-fzv)/dzv+2.f);

		fs = kd.fs*1000.f;

		// some defaults

		// velMod.velSecName is already loaded in calling routine.
		if(kd.v0 < 0.00001f)
			v0 = 1000.f*velMod.vf[0][0][0];
		else 
			v0 = 1000.f*kd.v0;	
		if(kd.dvz < 0.000000001f)
		{
			if((velMod.zm[0][1]-velMod.zm[0][0])>0.00001f)
				dvz=(velMod.vf[0][0][1]-velMod.vf[0][0][0])/
				(velMod.zm[0][1]-velMod.zm[0][0]);
			else
				dvz=0.f;
		}
		else
			dvz = kd.dvz;	//vertical gradient.

		v = (float *) alloc1float(nxv*nzv);
		//must be in km for GetVelGrid().
		if(!GetVelGrid((float)(0.001f*fxv), nxv, 0.001f*dxv, 
			0.001f*fzv, nzv, 0.001f*dzv, v) )
		{
			AfxMessageBox(_T("Gridding of input velocity file had problem"));
			free1float(v);
			return FALSE;
		}
		// Note v[] is now in meters.

		// set traveltime tabel parameters
		geo2dv.nx = nxv;		geo2dv.fx = fxv;	
		geo2dv.dx = dxv;		geo2dv.odx = 1.0f/dxv;
		geo2dv.nz = nzv;		geo2dv.fz = fzv;	
		geo2dv.dz = dzv;		geo2dv.odz = 1.0f/dzv;

		// note that the complete section needs nxo*nzo floats.
		geo2dt.nx = nxt;	geo2dt.fx = fxt;
		geo2dt.dx = dxt;	geo2dt.odx = 1.0f/dxt;
		geo2dt.nz = nzt;	geo2dt.fz = fzt;
		geo2dt.dz = dzt;	geo2dt.odz = 1.0f/dzt;


		if (!useExist && !useOnDemand)
		{
			kd.ns = Lius2draytracingMod(v, geo2dv, geo2dt,ntRay, dtRay, fs, ds,
				kd.aperx*1000.f, kd.fa, kd.na, kd.da, kd.amin, kd.amax, kd.fac, kd.sourceDepth*1000.f, (int)ek, (int)npv, jpfp, _T(".tempMigRayParaSrc"));
			if(kd.ns == 0)
			{
				free1float(v);
				fclose(jpfp);
				AfxMessageBox(_T("Unable to perform raytracing"));
				return FALSE;
			}
			else {
				// now calculate raytracing for receivers. The receivers can at a different depth from the source
				_ftprintf_s(jpfp,_T("Finished raytracing for the sources. The receivers can at a different depth from the source.\n"));
				kd.ns = Lius2draytracingMod(v, geo2dv, geo2dt,ntRay, dtRay, fs, ds,
					kd.aperx*1000.f, kd.fa, kd.na, kd.da, kd.amin, kd.amax, kd.fac, 0.f, (int)ek, (int)npv, jpfp, _T(".tempMigRayParaRec"));
				_ftprintf_s(jpfp,_T("Finished raytracing for the receivers.\n"));
				fflush(jpfp);
			}
		}
		if (!useOnDemand) free1float(v);

		CFile file;
		if (!file.Open(inF, CFile::modeRead | CFile::typeBinary)) {
			free1float(v);
			fclose(jpfp);
			return FALSE;
		}

		UINT bytesRead = file.Read(head.ascHead, 3200L);
		if(bytesRead < 3200) 
			AfxMessageBox(_T("Ascii section header read wrong"));
		if (!appendOutput) file2->Write(head.ascHead, 3200L);

		short *i2buf;
		i2buf = (short *) &tr;
		float *trcdat;
		trcdat = (float *) &i2buf[120];

		bytesRead = file.Read(i2buf, 400L);
		if(bytesRead < 400) 
			AfxMessageBox(_T("Binary section header read wrong"));
		int numsamp = (unsigned short)i2buf[10];
		//BOOL dataInt;
		int len;
		int dformatIn = i2buf[12];
		if(dformatIn==1) {
			//dataInt = FALSE;
			len = numsamp*4 + 240;
		}
		else if(dformatIn==3)  {
			//dataInt = TRUE;
			len = numsamp*2 + 240;
		}
		else {
			AfxMessageBox(_T("Sorry, only floating point is supported"));
			file.Close();
			return FALSE;
		}
		int tpp = (unsigned short)i2buf[8];
		nt = numsamp;
		dt = (float)(((double) tpp)/(double)MIL);

		//assign section headers, same as in ViewConv().
		i2buf[10] = (unsigned short) nzo; // numsamp;
		i2buf[11] = i2buf[10];
		i2buf[12] = 1;
		i2buf[8] = (unsigned short)(dzo*1000);	//Sampling rate in micro sec;
		i2buf[9] = i2buf[8];
		if (!appendOutput) file2->Write(i2buf, 400L);

		//determine initial time.
		while (file.Read(&tr, len) == (UINT)len)
		{
			if(tr.trid != 2) //dead traces.
				ft = getTraceDelay(&tr); //tr.delrt is i2buf[54]. Use t1 field????
			break;
		}

		mtmax = (int)(2*dxm*sin(angmax*PI/180.)/(v0*dt));
		if(mtmax<1) mtmax = 1;
		if(fmax>(0.25f/dt)) fmax=0.25f/dt;

		_ftprintf_s(jpfp,_T("\n"));
		_ftprintf_s(jpfp,_T(" Migration parameters\n"));
		_ftprintf_s(jpfp,_T(" ================\n"));
		_ftprintf_s(jpfp,_T(" nzt=%d fzt=%g dzt=%g\n"),nzt,fzt,dzt);
		_ftprintf_s(jpfp,_T(" nxt=%d fxt=%g dxt=%g\n"),nxt,fxt,dxt);
		_ftprintf_s(jpfp,_T(" \n"));
		_ftprintf_s(jpfp,_T(" nzo=%d fzo=%g dzo=%g\n"),nzo,fzo,dzo);
		_ftprintf_s(jpfp,_T(" nxo=%d fxo=%g dxo=%g\n"),nxo,fxo,dxo);
		_ftprintf_s(jpfp,_T(" \n"));

		//	rmax = (float)MAX(es-fxt,ext-fs);
		rmax = ext;
		rmax = (float)MIN(rmax,0.5*offmax+kd.aperx*1000.f);
		nr = 2+(int)(rmax/dxo);
		_ftprintf_s(jpfp,_T(" nt=%d ft=%g dt=%g \n"),nt,ft,dt);
		_ftprintf_s(jpfp,_T(" dxm=%g fmax=%g\n"),dxm,fmax);
		_ftprintf_s(jpfp,_T(" off0=%d offmax=%g\n"),off0,offmax);
		_ftprintf_s(jpfp,_T(" v0=%g dvz=%g \n"),v0,dvz);
		_ftprintf_s(jpfp,_T(" aperx=%g angmax=%g\n"),kd.aperx*1000.f,angmax);
		_ftprintf_s(jpfp,_T(" ls=%d npv=%d\n"),ls,npv);
		_ftprintf_s(jpfp,_T(" ================\n"));
		fflush(jpfp);
		// Finish initializing local parameters.

		// compute reference traveltime and slowness  
		tb = (float **) ealloc2float(nzt,nr);
		if(tb==NULL) 
		{
			free2float(tb);
			free1float(v);
			file.Close();
			return FALSE;
		}
		pb = (float **)ealloc2float(nzt,nr);
		if(pb==NULL)
		{
			free2float(tb);
			free2float(pb);
			free1float(v);
			file.Close();
			return FALSE;
		}
		cs0b = (float **)ealloc2float(nzt,nr);
		if(cs0b==NULL)
		{
			free2float(tb);
			free2float(pb);
			free2float(cs0b);
			free1float(v);
			file.Close();
			return FALSE;
		}
		angb = (float **)ealloc2float(nzt,nr);
		if(angb==NULL)
		{
			free2float(tb);
			free2float(pb);
			free2float(cs0b);
			free2float(angb);
			free1float(v);
			file.Close();
			return FALSE;
		}
		timeb(nr,nzt,dxo,dzt,fzt,dvz,v0,tb,pb,cs0b,angb);

		tsum = (float **)ealloc2float(nzt,nxt);
		if(tsum==NULL)
		{
			free2float(tb);
			free2float(pb);
			free2float(cs0b);
			free2float(angb);
			free2float(tsum);
			free1float(v);
			file.Close();
			return FALSE;
		}

		int iError=0;
		int trac0 = 1;	//firat trace number in one migration loop.
		// int nAperx = (int)(aperx/dxo); only useful for post-stack.

		mig = (float ***)ealloc3float(nzo,nxo,1);
		if(mig==NULL)
		{
			free2float(tb);
			free2float(pb);
			free2float(cs0b);
			free2float(angb);
			free2float(tsum);
			free3float(mig);
			free1float(v);
			file.Close();
			return FALSE;
		}
		mig1 = ealloc3float(1,1,1);

		_ftprintf_s(jpfp,_T(" start migration \n"));
		fflush(jpfp);

		jtr = 1;
		ktr = 0;
		memset((void *) mig[0][0],(int) '\0',nxo*nzo*sizeof(float)); 

		//For progress control, need to know the last bytes no.
		ULONGLONG curBytesRead, totBytesRead = file.GetLength();
		//Begin progress control.
		CMainFrame* pFrame = 
			(CMainFrame*)AfxGetMainWnd();
		ASSERT(pFrame);
		ASSERT_KINDOF(CMainFrame, pFrame);
		pFrame->BeginProgress();

		file.Seek(3600, CFile::begin);
		file.Read(&tr, 240); // read the data here.
		CFile fileRaySrc(_T(".tempMigRayParaSrc"), CFile::modeRead|CFile::typeBinary);
		CFile fileRayRec(_T(".tempMigRayParaRec"), CFile::modeRead|CFile::typeBinary);
		long nnxzt = nxt*nzt*sizeof(float);
		float as,res, sxOld=MIL, *t;
		int is;
		do {
			if(tr.trid == 2 ) 
			{
				file.Seek(len-240, CFile::current);
				continue;	//dead traces.
			}
			ft = getTraceDelay(&tr); //tr.delrt is i2buf[54]. Use t1 field???
			if (preStack)
			{
				sx = (float)tr.sx;
				gx = (float)tr.gx;
			}
			else sx=gx=getDistance(&tr);

			/* determine offset index	*/
			io = (int)((gx-sx-off0)/doff+0.5);
			if(io<0) io = 0;
			if(io>=noff) io = noff-1;

			if(MIN(sx, gx)>=fxt && MAX(sx,gx)<=ext
				&& fabs(gx-sx)<=offmax )
			{ //     migrate this trace	
				if (file.Read(&tr.dat.data, len-240)!=(UINT)(len-240) ) continue; // read the data here.
				if(dformatIn==3) {
					for (j=0; j<numsamp; j++)
						tro.dat.data[j] = i2buf[120+j];  //here two bytes data is converted to 4 bytes.
					for (j=0; j<numsamp; j++)
						tr.dat.data[j] = tro.dat.data[j];
				} else if (dformatIn==2) {
					for (j=0; j<numsamp; j++)
						tr.dat.data[j] = (float)tro.dat.dataint[j];
				} else if (dformatIn==1) {
					// floating point needs to convert from iBM to IEEE
					ibm_to_float((int *) tr.dat.data, (int *) tr.dat.data, (int)numsamp);
				}

				t1 = (float **)ealloc2float(nzt,nxt);
				tt = (float **)ealloc2float(nzt,nxt);
				if(t1==NULL || tt==NULL)
				{
					AfxMessageBox(_T("memory shortage"));
					free2float(tb);
					free2float(pb);
					free2float(cs0b);
					free2float(angb);
					free2float(tt);
					free2float(tsum);
					free3float(mig);
					free1float(v);
					file.Close();
					return FALSE;
				}

				if(!useOnDemand)
				{
					// this will interpolate between travel-time table already calculated
					as = (sx-fs)/ds;
					is = (int)as;
					if (is==kd.ns-1) is=kd.ns-2;
					if (is<0) is = 0;
					fileRaySrc.Seek(is*nnxzt, CFile::begin);
					for (ix=0; ix<nxt; ix++) {
						fileRaySrc.Read((void *)tt[ix], nzt*sizeof(float));
					}
					UINT numRead = 0;
					for (ix=0; ix<nxt; ix++) {
						numRead = fileRaySrc.Read((void *)t1[ix], nzt*sizeof(float));
					}
					if (numRead == nzt*sizeof(float)) {
						// this would mean the second round of reading is done correctly
						res = as-is;
						if (res<=0.01f) res = 0.f;
						if (res>=0.99f) res = 1.0;
						for (ix=0; ix<nxt; ix++)
						{ 
							for (iz=0; iz<nzt; iz++)
								tt[ix][iz] = (1.f-res)*tt[ix][iz] + res*t1[ix][iz];
						}
					}
					else {
						// this would mean the second round of reading is NOT done correctly
						// let's only use the previous reading and shift a little by (sx-fs)
						int tShift = (int)myRound((sx-fs)/dxt);
						for (iz=0; iz<nzt; iz++) {
							for (ix=0; ix<nxt; ix++)
							{ 
								int iShifted = ix - tShift;
								if (iShifted>=0 && iShifted<nxt)
									t1[ix][iz] = tt[iShifted][iz];
								else
									t1[ix][iz] = 99999.f;
							}
							for (ix=0; ix<nxt; ix++)
							{ 
								tt[ix][iz] = t1[ix][iz];
							}
						}
					}
					resit(nxt,fxt,dxt,nzt,nr,dxo,tb,tt,sx); // compute traveltime residueal

					as = (gx-fs)/ds;
					is = (int)as;
					if (is==kd.ns-1) is=kd.ns-2;
					if (is<0) is = 0;
					fileRayRec.Seek(is*nnxzt, CFile::begin);
					for (ix=0; ix<nxt; ix++)
						fileRayRec.Read((void *)tsum[ix], nzt*sizeof(float));
					numRead = 0;
					for (ix=0; ix<nxt; ix++)
						numRead = fileRayRec.Read((void *)t1[ix], nzt*sizeof(float));
					if (numRead == nzt*sizeof(float)) {
						// this would mean the second round of reading is done correctly
						res = as-is;
						if (res<=0.01f) res = 0.f;
						if (res>=0.99f) res = 1.0;
						for (ix=0; ix<nxt; ix++)
						{
							for (iz=0; iz<nzt; iz++)
								tsum[ix][iz] = (1.f-res)*tsum[ix][iz] + res*t1[ix][iz];
						}
					}
					else {
						// this would mean the second round of reading is NOT done correctly
						// let's only use the previous reading and shift a little by (gx-fs)
						int tShift = (int)myRound((gx-fs)/dxt);
						for (iz=0; iz<nzt; iz++) {
							for (ix=0; ix<nxt; ix++)
							{ 
								int iShifted = ix - tShift;
								if (iShifted>=0 && iShifted<nxt)
									t1[ix][iz] = tsum[iShifted][iz];
								else
									t1[ix][iz] = 99999.f;
							}
							for (ix=0; ix<nxt; ix++)
							{ 
								tsum[ix][iz] = t1[ix][iz];
							}
						}
					}
					resit(nxt,fxt,dxt,nzt,nr,dxo,tb,tsum,gx); // compute traveltime residueal
				}
				else
				{ 
					// use on demand: call Lius2draytracingSimple() to raytrace for sx and gx.
					// should be changed to make it work.
					t = (float *) alloc1float(nxo*nzo);
					if ( fabs(sx-sxOld) > 0.0001)
					{ // re-calculate only if sx is different from sxOld.
						if(!Lius2draytracingSingle(v, geo2dv, geo2dt,ntRay, dtRay, sx, t,
							kd.aperx*1000.f, kd.fa, kd.na, kd.da, kd.amin, kd.amax, kd.fac, kd.sourceDepth, (int)ek, 
							(int)npv, jpfp))
						{
							_ftprintf_s(jpfp, _T("   Raytracing failed when raytracing a source at %d (m)\n"), sx);
							continue;
						}
						for (ix=0; ix<nxo; ix++)
							memcpy((void *)tt[ix], &t[ix*nzo], nzo*sizeof(float));
						sxOld = sx; // save for the next round.
					}

					if( fabs(gx-sx) > 0.0001)
					{
						if(!Lius2draytracingSingle(v, geo2dv, geo2dt,ntRay, dtRay, gx, t,
							kd.aperx*1000.f, kd.fa, kd.na, kd.da, kd.amin, kd.amax, kd.fac, kd.sourceDepth,(int)ek, 
							(int)npv, jpfp))
						{
							_ftprintf_s(jpfp, _T("   Raytracing failed when raytracing a receiver at %d (m)\n"), gx);
							continue;
						}
						for (ix=0; ix<nxo; ix++)
							memcpy((void *)tsum[ix], &t[ix*nzo], nzo*sizeof(float));
					}
					else
					{
						for (ix=0; ix<nxo; ix++)
							memcpy((void *)tsum[ix], (const void *)tt[ix], nzo*sizeof(float));
					}
					free1float(t);
				} // end of  use on demand

				free2float(t1);
				_ftprintf_s(jpfp, _T(" Finish raytracing for sx=%g and gx=%g."), sx, gx);
				for (ix=0; ix<nxt; ix++)
					for (iz=0; iz<nzt; iz++)
						tsum[ix][iz] += tt[ix][iz];

				free2float(tt);

				// mig[0][][] is a 3-D array.
				mig2d(tr.dat.data,nt,ft,dt,sx,gx,mig[io],kd.aperx*1000.f,
					nxo,fxo,dxo,nzo,fzo,dzo,
					ls,mtmax,dxm,fmax,angmax,
					tb,pb,cs0b,angb,nr,tsum,nzt,fzt,dzt,nxt,fxt,dxt,
					npv,cssum,tvsum,mig1[io]);

				ktr++;
				_ftprintf_s(jpfp, _T(" Success migrating this trace: %d\n"),jtr);
			}
			else
			{
				file.Seek(len-240, CFile::current);
				_ftprintf_s(jpfp, _T(" Skip trace %d: sx=%d gx=%d (m)\n"),jtr,(int)sx,(int)gx);
			}
			fflush(jpfp);
			jtr++;

			curBytesRead = file.Seek(0, CFile::current);
			int iPos = (int)((double)curBytesRead/(double)totBytesRead*100.);
			if(iPos<0)iPos=0;
			if(iPos>100)iPos=100;
			pFrame->SetProgress(iPos);

			//	if (ktr == 3) break; // testing
		} while (file.Read(&tr, 240)==240);

		if (useOnDemand) free1float(v);
		file.Close();
		free2float(tsum);
		free2float(pb);
		free2float(tb);
		free2float(cs0b);
		free2float(angb);
		fileRaySrc.Close();
		fileRayRec.Close();
		_ftprintf_s(jpfp, _T(" migrated %d traces in total\n"),ktr);

		memset((void *) &tro, (int) '\0', 240);
		tro.ns = nzo;
		tro.d1 = dzo;
		tro.dt = (unsigned short)(dzo*1000);	//Sampling rate in micro sec, or cm.
		tro.delrt = 0;
		tro.t1 = (int)fzo;
		tro.f1 = fzo;
		tro.d2 = dxo;
		tro.trid = 1;

		scal = (float)(4/sqrt(PI)*dxm/v0);
		ktr = 1;
		//	if (appendOutput) file2.SeekToEnd();
		for(ixo=0; ixo<nxo; ixo++)
		{
			x = fxo + (ixo*dxo);
			x *= 0.001f;
			if (x<pCd.coord.xmin) continue;
			if (x>=pCd.coord.xmax) break;
			// mig[0][][] is a 3-D array.
			memcpy((void *)tro.dat.data, (const void *)mig[0][ixo], nzo*sizeof(float));
			//	tro.f2 = fxo;
			tro.offset = (int)off0;
			tro.tracr = tro.tracl = trac0+ktr;
			ktr++;
			setDistance(&tro, fxo+ixo*dxo );

			tro.cdpt = 1;

			for(izo=0; izo<nzo; ++izo) tro.dat.data[izo] *=scal;

			//	memcpy((void*) &i2buf, (void*)&tro, nzo*sizeof(float)+240); 
			file2->Write(&tro, nzo*sizeof(float)+240);
		}

		_ftprintf_s(jpfp, _T(" \n"));
		_ftprintf_s(jpfp, _T(" output done\n"));
		fclose(jpfp);

		free3float(mig);
		free3float(mig1);
		_heapmin();

		pFrame->EndProgress();

		//	if (isFileExistNotDirectory(kd.migLog))
		//		showFileInNotePad(kd.migLog);

		return TRUE;
	}

	void CSeisWideDoc::OnProcessingKdmigsimple() 
	{
		int 	nxv,nzv,nzo,nxo,nr, ns;
		float   fxv,fzv,fzo,fxo,dt,dzv,ezo,exo, rmax,temp, xmin, xmax;
		TCHAR *jpfile;
		BOOL useExist, appendOutput=FALSE;
		FILE *jpfp;
		CString tempStr;

		CdlgKdmig dlg;
		dlg.m_timeSecName = draw.timeSecName;
		dlg.m_velSecName  = velMod.velSecName;
		dlg.m_depthSecName = draw.depthSecName;
		dlg.m_ek = kd.ek;
		dlg.m_amax = kd.amax;
		dlg.m_amin = kd.amin;
		dlg.m_angmax = kd.angmax;
		dlg.m_da = kd.da;
		dlg.m_dt = kd.dt;	//dt for raytracing, not for output mig
		dlg.m_dxt = (kd.dxt<kd.dxo)?kd.dxo*4.f:kd.dxt;
		dlg.m_dzt = (float)((kd.dzt<vel.dz)?vel.dz*4.f:kd.dzt);

		dlg.m_dxv = kd.dxv = (float)((pCd.coord.xmax-pCd.coord.xmin)*0.01);
		dlg.m_dzv = kd.dzv = (float)((pCd.coord.zmax-pCd.coord.zmin)*0.01); //dzv is depth increment for model gridding.
		dlg.m_dvz = kd.dvz;	//dvz is vertical gradient.
		dlg.m_dxm = kd.dxm;
		dlg.m_dxo = kd.dxo;

		dlg.m_fs = (float)((kd.fs<0 || kd.fs>99999.f)?pCd.coord.xmin:kd.fs);
		dlg.m_dxs = kd.ds;
		dlg.m_srcDepth = (kd.sourceDepth<0 || kd.sourceDepth>99999.f)?0:kd.sourceDepth;

		dlg.m_dzo = (float)vel.dz; //use existing vel.dz
		dlg.m_fa = kd.fa;
		dlg.m_fac = kd.fac;
		dlg.m_fxo = (float)pCd.coord.xmin;	//equals to pCd.coord.xmin
		dlg.m_xmax = (float)pCd.coord.xmax;
		dlg.m_fzo = (float)pCd.coord.zmin;
		dlg.m_zmax = (float)pCd.coord.zmax;
		dlg.m_na = kd.na;
		dlg.m_tmaxRay = kd.tmaxRay;
		dlg.m_off0 = kd.off0;
		if (kd.offmax<0.00001f) kd.offmax = 99999.f;
		dlg.m_offmax = kd.offmax;
		dlg.m_v0 = kd.v0;
		dlg.m_fmax = kd.fmax;
		dlg.m_ls = kd.ls;
		dlg.m_aperx = kd.aperx;
		dlg.m_memMax = kd.memMax;

		if(dlg.DoModal() == IDOK)
		{
			draw.timeSecName = dlg.m_timeSecName.Trim();
			velMod.velSecName = dlg.m_velSecName.Trim();

			dlg.m_depthSecName = mySetFileExtension(dlg.m_depthSecName, _T("sgy"));


			draw.depthSecName = dlg.m_depthSecName;
			kd.ek = dlg.m_ek;  //ek does not exist in this routine, instead kd.ek is used.
			kd.amax = dlg.m_amax; // max angle used during raytracing (0-180)
			kd.amin = dlg.m_amin; // min angle used during raytracing (0-180)
			kd.angmax = dlg.m_angmax;  // migration angle aperture from vertical: default 60.
			kd.da = dlg.m_da;
			kd.fa = dlg.m_fa;
			kd.na = dlg.m_na;
			kd.fac = dlg.m_fac;  if (kd.fac<0.000001) kd.fac = 0.01f;
			kd.aperx = dlg.m_aperx;
			kd.dxm = dlg.m_dxm;

			kd.fs = dlg.m_fs;
			kd.ds = dlg.m_dxs;
			kd.sourceDepth = dlg.m_srcDepth;  // testing for a OBS

			pCd.coord.xmin = dlg.m_fxo;
			kd.dxo = dlg.m_dxo;
			pCd.coord.xmax = dlg.m_xmax;
			pCd.coord.zmin = dlg.m_fzo;
			vel.dz = dlg.m_dzo;
			pCd.coord.zmax = dlg.m_zmax;
			kd.off0 = dlg.m_off0;
			kd.offmax = dlg.m_offmax;
			kd.v0 = dlg.m_v0;
			kd.dvz = dlg.m_dvz;
			kd.fmax = dlg.m_fmax;
			kd.ls = dlg.m_ls;
			kd.memMax = dlg.m_memMax;

			kd.tmaxRay = dlg.m_tmaxRay;
			kd.dt = dlg.m_dt;	//kd.dt, dtRay are for raytracing, not for output mig
			kd.dxt = dlg.m_dxt;
			kd.dzt = dlg.m_dzt;

			kd.dxv= dlg.m_dxv;
			kd.dzv= dlg.m_dzv;

			useExist = dlg.m_useExist;
		}
		else 
		{
			return;
		}
		delete dlg;

		if(!CheckTime(200))
		{
			return;
		}
		if(velMod.velSecName.IsEmpty())
		{
			AfxMessageBox(_T("Please specify a velocity name in .BIN format"));
			return;
		}
		//if(velMod.velSecOld != velMod.velSecName)
		//{
		//	if(!velMod.velSecName.IsEmpty())
		//	{
		//		if(!MyInitVel()) return;
		//		else velMod.velSecOld = velMod.velSecName;
		//	}
		//}
		//	OnToolbarSavev(); //save velocity file first, in case people ...

		if(draw.timeSecName.IsEmpty() || draw.depthSecName.IsEmpty()) 
		{
			AfxMessageBox(_T("Please specify an input/output file name"));
			return;
		}

		//	kd.fs = pCd.coord.xmin;
		//	kd.fs = 4.196f;  // test for a OBS location

		//All parameters are entered in km, but this routine only uses m.
		fxo = (float)pCd.coord.xmin*1000.f - kd.aperx*1000.f;
		nxo = (int)((pCd.coord.xmax-pCd.coord.xmin+2.*kd.aperx)/kd.dxo + 0.9999);
		ns = (int)((pCd.coord.xmax-pCd.coord.xmin+2.*kd.aperx)/kd.ds + 0.9999);
		nzo = (int)((pCd.coord.zmax-pCd.coord.zmin)/vel.dz + 0.9999);
		if(kd.aperx<kd.dxo) kd.aperx = kd.dxo;

		exo = fxo+(nxo-1)*kd.dxo*1000.f;
		fzo = (float)pCd.coord.zmin*1000.f;
		ezo = (float)(fzo+(nzo-1)*vel.dz*1000.);

		//be careful to get raytracing wide enough to cover all output areas.
		fxv = fxo;
		nxv = (int)((exo-fxv)/kd.dxv/1000.f + 2.f); //this should come last.
		fzv = 0.f; 	//Found that raytracing requires fzv<=0 
		dzv = 1000.f*kd.dzv;	//depth increment for vel model.
		nzv = (int)((ezo-fzv)/kd.dzv/1000.f+2.f);


		CFile file;
		if (!file.Open(draw.timeSecName, CFile::modeRead | CFile::typeBinary)) {
			return;
		}
		UINT bytesRead = file.Read(head.ascHead, 3200L);
		if(bytesRead < 3200) 
			AfxMessageBox(_T("Ascii section header read wrong"));

		segy tr;
		short *i2buf;
		i2buf = (short *) &tr;
		float *trcdat;
		trcdat = (float *) &i2buf[120];

		bytesRead = file.Read(i2buf, 400L);
		if(bytesRead < 400) 
			AfxMessageBox(_T("Binary section header read wrong"));
		file.Close();
		int numsamp = (unsigned short)i2buf[10];
		int len;
		if(i2buf[12]!=3)  
			len = numsamp*4 + 240;
		else
			len = numsamp*2 + 240;
		int tpp = (unsigned short)i2buf[8];
		dt = (float)(((double) tpp)/(double)MIL);

		rmax = exo;
		rmax = (float)MIN(rmax,0.5*kd.offmax*1000.f+kd.aperx*1000.f);
		nr = 2+(int)(rmax/kd.dxo/1000.f);
		// Finish initializing local parameters.

		//	kd.migLog = velMod.velSecName + _T(".MigData.Log";
		kd.migLog = GetFileNameAppendExt(velMod.velSecName, _T(".MigData.Log"), _T("txt"));
		jpfile = kd.migLog.GetBuffer(kd.migLog.GetLength());
		_tfopen_s(&jpfp, jpfile,_T("w"));
		kd.migLog.ReleaseBuffer();

		_ftprintf_s(jpfp,_T("\n"));
		_ftprintf_s(jpfp,_T(" Migration parameters\n"));
		_ftprintf_s(jpfp,_T(" ================\n"));
		_ftprintf_s(jpfp,_T(" nzo=%d fzo=%g dzo=%d\n"),nzo,fzo,(int)(vel.dz*1000.f));
		_ftprintf_s(jpfp,_T(" nxo=%d fxo=%g dxo=%d\n"),nxo,fxo,(int)(kd.dxo*1000.f));
		_ftprintf_s(jpfp,_T(" \n"));
		_ftprintf_s(jpfp,_T(" offmax=%d\n"),(int)(kd.offmax*1000.f));
		_ftprintf_s(jpfp,_T(" aperx=%d \n"),(int)(kd.aperx*1000.f));
		_ftprintf_s(jpfp,_T(" ================\n"));
		fflush(jpfp);

		//Determine space allocation for holding migration output data.
		// Each output segy sample occupies 4 bytes,
		// plus 2 time tables since a raytracing table is calculated for each (X,Z) sample.
		// major 2D arrays:
		// v, vxx, vxz, vzz: nvx*nvz.
		// t, ov2, s, tt, tsum, mig: nxo*nzo.
		// tb, pb, cs0b, angb: nzo*nr.
		int nnv = 4*4*nxv*nzv;
		int nno = 7*4*nxo*nzo;
		int nnr = 4*4*nr*nzo;
		_ftprintf_s(jpfp,_T(" Required memory is made up by 4*nvx*nvz floats: %d bytes,\n"), nnv);
		_ftprintf_s(jpfp,_T("   7*nxo*nzo floats: %d bytes, \n"), nno);
		_ftprintf_s(jpfp,_T("   and 4*nr*nzo floats: %d bytes, where nr=MIN(ext, 0.5*offmax+aperx)/dxo = %d.\n"), nnr, nr);
		temp = (float)((nnv+nno+nnr)/(double)MIL);
		_ftprintf_s(jpfp,_T("   Therefore, this operation requires a total memory of %d mb.\n"), (int)temp);
		if(kd.memMax < temp)
		{
			tempStr.Format(_T("Total memory required to migrate the section at once is %d mb, which is greater than specified %d mb. Divide into smaller sections?"), (int)temp, (int)kd.memMax);
			if(AfxMessageBox(tempStr, MB_YESNO|MB_ICONQUESTION)!=IDYES)
			{
				fclose(jpfp);
				showFileInNotePad(kd.migLog);
				return;
			}
		}

		//	int nxoR = (int)(kd.memMax*MIL/(float)(4.*nzo));
		/*
		"    	[7*nxo*nzo+4*nr*nzt+npa*7*nxo*nzo]*4 bytes				",
		"    where nr = 1+min(nxt*dxt,0.5*offmax+aperx)/dxo. 			",
		*/

		fxo = xmin = (float)pCd.coord.xmin;
		xmax = (float)pCd.coord.xmax;
		nxo = (int)((kd.memMax*MIL - nnv - nnr) / (7.*4.*nzo));
		int nzt = (int)((pCd.coord.zmax-pCd.coord.zmin)/kd.dzt + 0.9999);
		int nxt = (int)((pCd.coord.xmax-pCd.coord.xmin+2.*kd.aperx)/kd.dxt + 0.9999);

		double dwFreeSpace = getFreeSpace(velMod.velSecName);

		//check free disk space for raytracing
		double bytesNeededRay = (double)((double)ns*(double)nzt*(double)nxt*sizeof(float)/(double)MIL);
		double bytesNeededOutput = (double)((double)nzo*(double)nxo*sizeof(float)/(double)MIL);
		double bytesTotal = bytesNeededRay+bytesNeededOutput+50.;

		_ftprintf_s(jpfp,_T("\n For disk space\n  Space needed to hold raytracing results (mb)=%d \n"),(long)bytesNeededRay);
		_ftprintf_s(jpfp,_T("  Free space in the current working drive (mb):%d\n"),(long)dwFreeSpace);
		_ftprintf_s(jpfp,_T("  MBytes Needed for storing output file=%d \n"),(long)bytesNeededOutput);

		_ftprintf_s(jpfp,_T("     Space needed for raytracing is calculated from:\n"));
		_ftprintf_s(jpfp,_T("       ns:%d; nxt:%d; nzt:%d\n"),ns, nxt, nzt);

		tempStr.Format(_T("Raytracing results will occupy %d mb temporary space. Continue?"), (int)bytesTotal);
		if(AfxMessageBox(tempStr, MB_YESNO|MB_ICONQUESTION)!=IDYES)
		{
			fclose(jpfp);
			showFileInNotePad(kd.migLog);
			return;
		}

		CFile file2;
		if (!file2.Open(draw.depthSecName, CFile::modeCreate|CFile::modeWrite|CFile::typeBinary)) {
			fclose(jpfp);
			return;
		}


		// BOOL CSeisWideDoc::KdmigGeneral(jpfp, file2, useExist, preStack, appendOutput)
		// (3) if useExist is true, skip raytracing. If preStack is true, a pre-stack case.
		// (4) if appendOutput=TRUE, output data will be appended to existing one: for  
		//	   migration of several sections, this is useful.
		while (fxo<xmax)
		{
			pCd.coord.xmin = fxo;
			pCd.coord.xmax = fxo + (nxo-1)*kd.dxo;
			if (pCd.coord.xmax > xmax) pCd.coord.xmax = xmax;
			KdmigGeneral(jpfp, &file2, useExist, TRUE, appendOutput);
			useExist = FALSE;
			appendOutput = TRUE; // next time will append output segy file.
			fxo = (float)pCd.coord.xmax;
		}

		pCd.coord.xmin = xmin;
		pCd.coord.xmax = xmax;
		file2.Close();
		fclose(jpfp);

		//Auto change mode to display both.
		draw.modeOld = draw.mode;
		draw.mode = 3;	//Both velocity color and depth sections will be drawn.
		draw.depthSecOld = _T("");	//recalculate gain.

		draw.isSameDataDisplay = FALSE; //indicate display has been changed and will re-load all data in OnDraw().
		SetModifiedFlag();
		UpdateAllViews(NULL);
		NotifyChanged();

	}

#include "dlgKdmigPost.h"
	void CSeisWideDoc::OnProcessingKdmigpost() 
	{
		int 	nxv,nzv,nzo,nxo,nr, ns;
		float   fxv,fzv,fzo,fxo,dzv,ezo,exo, rmax,temp, xmin, xmax;
		TCHAR *jpfile;
		BOOL useExist, appendOutput=FALSE;
		FILE *jpfp;
		CString tempStr;

		CdlgKDMigPost dlg;
		dlg.m_timeSecName = draw.timeSecName;
		dlg.m_velSecName  = velMod.velSecName;
		dlg.m_depthSecName = draw.depthSecName;
		dlg.m_ek = kd.ek;
		dlg.m_amax = kd.amax;
		dlg.m_amin = kd.amin;
		dlg.m_angmax = kd.angmax;
		dlg.m_da = kd.da;
		dlg.m_dt = kd.dt;	//dt for raytracing, not for output mig
		dlg.m_dxt = (kd.dxt<kd.dxo)?kd.dxo*4.f:kd.dxt;
		dlg.m_dzt = (float)((kd.dzt<vel.dz)?vel.dz*4.f:kd.dzt);

		dlg.m_dxv = kd.dxv = (float)((pCd.coord.xmax-pCd.coord.xmin)*0.01);
		dlg.m_dzv = kd.dzv = (float)((pCd.coord.zmax-pCd.coord.zmin)*0.01); //dzv is depth increment for model gridding.
		dlg.m_dvz = kd.dvz;	//dvz is vertical gradient.
		dlg.m_dxo = kd.dxo;
		dlg.m_dxs = (kd.ds<0.00001f)?(kd.dxo*2.f):kd.ds;
		dlg.m_dzo = (float)vel.dz; //use existing vel.dz
		dlg.m_fa = kd.fa;
		dlg.m_fac = kd.fac;
		dlg.m_fxo = (float)pCd.coord.xmin;	//equals to pCd.coord.xmin
		dlg.m_xmax = (float)pCd.coord.xmax;
		dlg.m_fzo = (float)pCd.coord.zmin;
		dlg.m_zmax = (float)pCd.coord.zmax;
		dlg.m_na = kd.na;
		dlg.m_tmaxRay = kd.tmaxRay;
		dlg.m_v0 = kd.v0;
		dlg.m_fmax = kd.fmax;
		dlg.m_ls = kd.ls;
		dlg.m_aperx = kd.aperx;
		dlg.m_memMax = kd.memMax;

		if(dlg.DoModal() == IDOK)
		{
			draw.timeSecName = dlg.m_timeSecName.Trim();
			velMod.velSecName = dlg.m_velSecName.Trim();

			dlg.m_depthSecName = mySetFileExtension(dlg.m_depthSecName, _T("sgy"));

			draw.depthSecName = dlg.m_depthSecName;
			kd.ek = dlg.m_ek;  //ek does not exist in this routine, instead kd.ek is used.
			kd.amax = dlg.m_amax;
			kd.amin = dlg.m_amin ;
			kd.angmax = dlg.m_angmax;
			kd.da = dlg.m_da;
			kd.fa = dlg.m_fa;
			kd.na = dlg.m_na;
			kd.fac = dlg.m_fac ;
			kd.aperx = dlg.m_aperx;
			kd.ds = dlg.m_dxs;

			pCd.coord.xmin = dlg.m_fxo;
			kd.dxo = dlg.m_dxo;
			pCd.coord.xmax = dlg.m_xmax;
			pCd.coord.zmin = dlg.m_fzo;
			vel.dz = dlg.m_dzo;
			pCd.coord.zmax = dlg.m_zmax;
			kd.v0 = dlg.m_v0;
			kd.dvz = dlg.m_dvz;
			kd.fmax = dlg.m_fmax;
			kd.ls = dlg.m_ls;
			kd.memMax = dlg.m_memMax;

			kd.tmaxRay = dlg.m_tmaxRay;
			kd.dt = dlg.m_dt;	//kd.dt, dtRay are for raytracing, not for output mig
			kd.dxt = dlg.m_dxt;
			kd.dzt = dlg.m_dzt;

			kd.dxv= dlg.m_dxv;
			kd.dzv= dlg.m_dzv;

			useExist = dlg.m_useExist;
		}
		else 
		{
			return;
		}

		kd.off0 = 0.f;	//not really used in post-stack.
		kd.doff = 999999.f;	//not really used in post-stack
		kd.offmax = 0.f;	//not really used in post-stack.
		kd.dxm = kd.dxo;
		if(kd.dt<0.0000001f)kd.dt=0.008f;

		kd.sourceDepth = 0.f;  // for the water depth of source/receivers in meters
		kd.fs = (float)pCd.coord.xmin;

		if(!CheckTime(200))
		{
			return;
		}
		if(velMod.velSecName.IsEmpty())
		{
			AfxMessageBox(_T("Please specify a velocity name in .BIN format"));
			return;
		}
		//if(velMod.velSecOld != velMod.velSecName)
		//{
		//	if(!velMod.velSecName.IsEmpty())
		//	{
		//		if(!MyInitVel()) return;
		//		else velMod.velSecOld = velMod.velSecName;
		//	}
		//}
		OnToolbarSavev(); //save velocity file first, in case people ...

		if(draw.timeSecName.IsEmpty() || draw.depthSecName.IsEmpty()) 
		{
			AfxMessageBox(_T("Please specify an input/output file name"));
			return;
		}

		//All parameters are entered in km, but this routine only uses m.
		fxo = (float)pCd.coord.xmin*1000.f - kd.aperx*1000.f;
		nxo = (int)((pCd.coord.xmax-pCd.coord.xmin+2.*kd.aperx)/kd.dxo + 0.9999);
		ns = (int)((pCd.coord.xmax-pCd.coord.xmin+2.*kd.aperx)/kd.ds + 0.9999);
		nzo = (int)((pCd.coord.zmax-pCd.coord.zmin)/vel.dz + 0.9999);
		if(kd.aperx<kd.dxo) kd.aperx = kd.dxo;

		exo = fxo+(nxo-1)*kd.dxo*1000.f;
		fzo = (float)pCd.coord.zmin*1000.f;
		ezo = (float)(fzo+(nzo-1)*vel.dz*1000.);

		//be careful to get raytracing wide enough to cover all output areas.
		fxv = fxo;
		nxv = (int)((exo-fxv)/kd.dxv/1000.f + 2.f); //this should come last.
		fzv = 0.f; 	//Found that raytracing requires fzv<=0 
		dzv = 1000.f*kd.dzv;	//depth increment for vel model.
		nzv = (int)((ezo-fzv)/kd.dzv/1000.f+2.f);

		CFile file;
		if (!file.Open(draw.timeSecName, CFile::modeRead | CFile::typeBinary)) {
			return;
		}
		UINT bytesRead = file.Read(head.ascHead, 3200L);
		if(bytesRead < 3200) 
			AfxMessageBox(_T("Ascii section header read wrong"));

		segy tr;
		short *i2buf;
		i2buf = (short *) &tr;
		float *trcdat;
		trcdat = (float *) &i2buf[120];

		bytesRead = file.Read(i2buf, 400L);
		if(bytesRead < 400) 
			AfxMessageBox(_T("Binary section header read wrong"));
		file.Close();
		int numsamp = (unsigned short)i2buf[10];
		int len;
		if(i2buf[12]!=3)  
			len = numsamp*4 + 240;
		else
			len = numsamp*2 + 240;
		int tpp = (unsigned short)i2buf[8];
		float dt = (float)(((double) tpp)/(double)MIL);

		rmax = exo;
		rmax = (float)MIN(rmax, kd.aperx*1000.f);
		nr = 2+(int)(rmax/kd.dxo/1000.f);
		// Finish initializing local parameters.

		//	kd.migLog = velMod.velSecName + _T(".MigData.Log";
		kd.migLog = GetFileNameAppendExt(velMod.velSecName, _T(".MigData.Log"), _T("txt"));
		jpfile = kd.migLog.GetBuffer(kd.migLog.GetLength());
		_tfopen_s(&jpfp, jpfile,_T("w"));
		kd.migLog.ReleaseBuffer();

		_ftprintf_s(jpfp,_T("\n"));
		_ftprintf_s(jpfp,_T(" Migration parameters\n"));
		_ftprintf_s(jpfp,_T(" ================\n"));
		_ftprintf_s(jpfp,_T(" nzo=%d fzo=%g dzo=%d\n"),nzo,fzo,(int)(vel.dz*1000.f));
		_ftprintf_s(jpfp,_T(" nxo=%d fxo=%g dxo=%d\n"),nxo,fxo,(int)(kd.dxo*1000.f));
		_ftprintf_s(jpfp,_T(" \n"));
		_ftprintf_s(jpfp,_T(" aperx=%d \n"),(int)(kd.aperx*1000.f));
		_ftprintf_s(jpfp,_T(" ================\n"));
		fflush(jpfp);

		//Determine space allocation for holding migration output data.
		// Each output segy sample occupies 4 bytes,
		// plus 2 time tables since a raytracing table is calculated for each (X,Z) sample.
		// major 2D arrays:
		// v, vxx, vxz, vzz: nvx*nvz.
		// t, ov2, s, tt, tsum, mig: nxo*nzo.
		// tb, pb, cs0b, angb: nzo*nr.
		int nnv = 4*4*nxv*nzv;
		int nno = 7*4*nxo*nzo;
		int nnr = 4*4*nr*nzo;
		_ftprintf_s(jpfp,_T(" Required memory is made up by 4*nvx*nvz floats: %d bytes,\n"), nnv);
		_ftprintf_s(jpfp,_T("   7*nxo*nzo floats: %d bytes, \n"), nno);
		_ftprintf_s(jpfp,_T("   and 4*nr*nzo floats: %d bytes, where nr=MIN(ext, aperx)/dxo = %d.\n"), nnr, nr);
		temp = (float)((double)(nnv+nno+nnr)/(double)MIL);
		_ftprintf_s(jpfp,_T("   Therefore, this operation requires a total memory of %d mb.\n"), (int)temp);
		if(kd.memMax < temp)
		{
			fclose(jpfp);
			CString tempStr;
			tempStr.Format(_T("Total memory required to migrate the section at once is %d mb, which is greater than specified %d mb. Divide into smaller sections?"), (int)temp, (int)kd.memMax);
			if(AfxMessageBox(tempStr, MB_YESNO|MB_ICONQUESTION)!=IDYES)
			{
				showFileInNotePad(kd.migLog);
				return;
			}
		}

		//	int nxoR = (int)(kd.memMax*MIL/(float)(4.*nzo));
		/*
		"    	[7*nxo*nzo+4*nr*nzt+npa*7*nxo*nzo]*4 bytes				",
		"    where nr = 1+min(nxt*dxt,0.5*offmax+aperx)/dxo. 			",
		*/

		fxo = xmin = (float)pCd.coord.xmin;
		xmax = (float)pCd.coord.xmax;
		nxo = (int)((kd.memMax*MIL - nnv - nnr) / (7.*4.*nzo));
		int nzt = (int)((pCd.coord.zmax-pCd.coord.zmin)/kd.dzt + 0.9999);
		int nxt = (int)((pCd.coord.xmax-pCd.coord.xmin+2.*kd.aperx)/kd.dxt + 0.9999);

		// handle the drive free space label
		//	char szBuffer[ 250 ];

		double dwFreeSpace = getFreeSpace(velMod.velSecName);

		//check free disk space for raytracing
		double bytesNeededRay = (double)((double)ns*(double)nzt*(double)nxt*sizeof(float)/(double)MIL);
		double bytesNeededOutput = (double)((double)nzo*(double)nxo*sizeof(float)/(double)MIL);
		double bytesTotal = bytesNeededRay+bytesNeededOutput+50.;

		_ftprintf_s(jpfp,_T("\n For disk space\n  Space needed to hold raytracing results (mb)=%d \n"),(long)bytesNeededRay);
		_ftprintf_s(jpfp,_T("  Free space in the current working drive (mb):%d\n"),(long)dwFreeSpace);
		_ftprintf_s(jpfp,_T("  MBytes Needed for storing output file=%d \n"),(long)bytesNeededOutput);

		_ftprintf_s(jpfp,_T("     Space needed for raytracing is calculated from:\n"));
		_ftprintf_s(jpfp,_T("       ns:%d; nxt:%d; nzt:%d\n"),ns, nxt, nzt);

		if(bytesTotal > dwFreeSpace)
		{
			tempStr.Format(_T("Raytracing results will occupy %d mb temporary space. Please free %d mbytes more disk space for storing raytracing and migration results in the directory where the velocity model resides; otherwise, increase  dxs or dxo, or decrease memMax."), (int)bytesTotal, (int)(bytesTotal-dwFreeSpace));
			AfxMessageBox(tempStr);
			fclose(jpfp);
			showFileInNotePad(kd.migLog);
			return;
		}
		else
		{
			tempStr.Format(_T("Raytracing results will occupy %d mb temporary space. Continue?"), (int)bytesTotal);
			if(AfxMessageBox(tempStr, MB_YESNO|MB_ICONQUESTION)!=IDYES)
			{
				fclose(jpfp);
				showFileInNotePad(kd.migLog);
				return;
			}
		}

		CFile file2;
		if (!file2.Open(draw.depthSecName, CFile::modeCreate|CFile::modeWrite|CFile::typeBinary)) {
			fclose(jpfp);
			return;
		}


		// BOOL CSeisWideDoc::KdmigGeneral(jpfp, file2, useExist, preStack, appendOutput)
		// (3) if useExist is true, skip raytracing. If preStack is true, a pre-stack case.
		// (4) if appendOutput=TRUE, output data will be appended to existing one: for  
		//	   migration of several sections, this is useful.
		while (fxo<xmax)
		{
			pCd.coord.xmin = fxo;
			pCd.coord.xmax = fxo + (nxo-1)*kd.dxo;
			if (pCd.coord.xmax > xmax) pCd.coord.xmax = xmax;
			KdmigGeneral(jpfp, &file2, useExist, FALSE, appendOutput);
			useExist = FALSE;
			appendOutput = TRUE; // next time will append output segy file.
			fxo = (float)pCd.coord.xmax;
		}

		pCd.coord.xmin = xmin;
		pCd.coord.xmax = xmax;
		file2.Close();
		fclose(jpfp);

		//Auto change mode to display both.
		draw.modeOld = draw.mode;
		draw.mode = 3;	//Both velocity color and depth sections will be drawn.
		draw.depthSecOld = _T("");	//recalculate gain.

		draw.isSameDataDisplay = FALSE; //indicate display has been changed and will re-load all data in OnDraw().
		SetModifiedFlag();
		UpdateAllViews(NULL);
		NotifyChanged();

	}


	void CSeisWideDoc::OnSonobuoyLinearKm() 
	{
		if( (draw.mode!=0 && draw.mode!=6 && draw.mode!=7) || !draw.isDigitizing || para.isDistanceDisplay)
		{
			AfxMessageBox(_T(" To assign offsets for sonobuoy data, please display a time section with trace or offset(km) or NMO, and digitize 1 segment only for the water wave, and then 'Associate km to Sonobuoy Traces' to obtain the distance"));
			return;
		}
		if (dig.nPoint[0]<2)
		{
			AfxMessageBox(_T(" Please select >1 points on the water wave to obtain distance"));
			return;
		}


		int i;

		BOOL isUnix = false;
		bhed bh;
		segy tr;
		//short *i2buf;
		//i2buf = (short *) &tr;
		// float *trcdat;
		float xOfTrace,range;

		// static float VavgWater=1.44f; // typical for Arctic area
		// static float buoyDepth = 0.12192f; // this value is the one USGS used, in km
		static float buoyDepth = 0.06f; // this value is the one GSCA used, in km
		static float srcDepth = 0.011f;
		static float gunDelay = 0.00f; // these values are the ones GSCA used, in km, sec


		//	short i2buf[40000];
		//	trcdat = (float *) &i2buf[120];
		CdlgSonobouy dlg;
		dlg.m_vred = para.waterVelocityAboveObs;
		dlg.m_buoydepth = buoyDepth;
		dlg.m_srcDepth = srcDepth;
		dlg.m_gunDelay = gunDelay;
		if (dlg.DoModal() == IDOK)
		{
			para.waterVelocityAboveObs = dlg.m_vred;
			buoyDepth = dlg.m_buoydepth;
			srcDepth = dlg.m_srcDepth;
			gunDelay = dlg.m_gunDelay;
		}
		else return;

		//	dig.nPoint[0] = dig.iPoint;	//only one curve digitized.
		CString tStr;


		CFile file;
		if (!file.Open(draw.timeSecName, CFile::modeReadWrite | CFile::typeBinary)) {
			return;
		}

		ULONGLONG bytesRead = file.Seek(3200L, CFile::begin);
		if(bytesRead < 3200L) 
		{
			file.Close();
			AfxMessageBox(_T("Ascii section header read wrong"));
			return;
		}


		bytesRead = file.Read(&bh, 400L);
		if (isUnix = IsUnix(bh.format)) SwapTapeHeader(&bh);
		if(isUnix) {
			AfxMessageBox(_T("Please convert to PC format first."));
			file.Close();
			return;
		}
		if(bytesRead < 400 || !IsFormatValid(bh.format)) {
			AfxMessageBox(_T("Binary section header read wrong"));
			file.Close();
			return;
		}

		// get some parameters from the tape header
		int len = (bh.format==3) ? (2*bh.hns) :  4*bh.hns;
		len += 240;
		int numsamp = bh.hns;

		//For progress control, need to know the last bytes no.
		ULONGLONG curBytesRead, totBytesRead = file.GetLength();
		file.Seek(3600, CFile::begin);

		//Begin progress control.
		CMainFrame* pFrame = 
			(CMainFrame*)AfxGetMainWnd();
		ASSERT(pFrame);
		ASSERT_KINDOF(CMainFrame, pFrame);
		pFrame->BeginProgress();

		pCd.coord.xmin = MIL;
		pCd.coord.xmax = -MIL;

		while (file.Read(&tr,240) == 240)
		{
			curBytesRead = file.Seek(0, CFile::current);
			int iPos = (int)((double)curBytesRead/(double)totBytesRead*100.);
			if(iPos<0)iPos=0;
			if(iPos>100)iPos=100;
			pFrame->SetProgress(iPos);

			if(tr.trid == 2) //dead traces.
			{
				file.Seek(len-240, CFile::current);
				continue ;
			}

			xOfTrace = (draw.mode==6)  ?  (float)tr.tracl  :  getOffset(&tr);

			//note: //range is time in sec first
			//		dig.x[][0] is actually digitized shot number
			//		dig.t[][0] is digitized time in sec.
			if(xOfTrace<dig.x[0][0])
				range = dig.t[0][0] +(dig.t[1][0]-dig.t[0][0])
				/(dig.x[1][0]-dig.x[0][0])*(xOfTrace-dig.x[0][0]);
			else if(xOfTrace>dig.x[dig.nPoint[0]-1][0])
				range = dig.t[dig.nPoint[0]-2][0] +(dig.t[dig.nPoint[0]-1][0]-dig.t[dig.nPoint[0]-2][0])
				/(dig.x[dig.nPoint[0]-1][0]-dig.x[dig.nPoint[0]-2][0])*(xOfTrace-dig.x[dig.nPoint[0]-2][0]);
			else
			{
				for (i=0; i<dig.nPoint[0]-1; i++)
				{

					if(dig.x[i+1][0] < dig.x[i][0])
					{
						pFrame->EndProgress();
						file.Close();
						AfxMessageBox(_T("Error: digitized points must run from left to right monotonically with trace number"));
						return;
					}
					if(xOfTrace>=dig.x[i][0] && xOfTrace<=dig.x[i+1][0] )
					{
						if(dig.x[i][0]!=dig.x[i+1][0])
							range = dig.t[i][0]+(dig.t[i+1][0]-dig.t[i][0])
							/(dig.x[i+1][0]-dig.x[i][0])*(xOfTrace-dig.x[i][0]); 
						else
							range = dig.t[i][0];
						break;
					}
				}
			}

			// range is now the travel time (sec) of the direct water wave. We apply source delay time
			range -= gunDelay;

			//convert time to range in km.
			range *= para.waterVelocityAboveObs;

			double a = range*range - (buoyDepth-srcDepth)*(buoyDepth-srcDepth);
			if (a >0.) {
				range = (float)sqrt(a);
			}
			else {
				range = 0.0f;  // this can not happen here
			}

			if(pCd.coord.xmin > range) pCd.coord.xmin=range;
			if(pCd.coord.xmax < range) pCd.coord.xmax=range;

			setOffset(&tr, range);
			setTraceDelayF(&tr, getTraceDelay(&tr)-gunDelay );

			file.Seek(-240,CFile::current);
			file.Write(&tr,240);
			file.Seek(len-240,CFile::current);
		}
		file.Close();
		pFrame->EndProgress();

		draw.isDigitizing = FALSE;
		dig.digName = _T(""); // this remove the digitize info for the .SEI  project file only.

		//pCd.coord.xmin = (float)((int)(pCd.coord.xmin*0.1)*10.);
		//pCd.coord.xmax = (float)((int)(pCd.coord.xmax*0.1+0.99)*10.);
		//draw.modeOld = draw.mode;
		//draw.mode = 0;

		tStr.Format(_T("Offset information is assigned successfully. Last trace is assigned offset %f km"), range);
		// myCaption(_T("Offset information is assigned successfully. If you do raytracing, you need to assign source position and distance information (use Processing | Design Source/Receiver Distance)."));
		myCaption(tStr);


		draw.isSameDataDisplay = FALSE; //indicate display has been changed and will re-load all data in OnDraw().
		SetModifiedFlag();
		UpdateAllViews(NULL);
		NotifyChanged();
	}

	void CSeisWideDoc::extraSerialize()
	{
		vel.vminR = 0;
		vel.vminG = 0;
		vel.vminB = 255;
		vel.vmidR = 0;
		vel.vmidG = 200;
		vel.vmidB = 20;
		vel.vmaxR = 255;
		vel.vmaxG = 0;
		vel.vmaxB = 51;

		vel.cxExt = 8.;
		vel.cxPos = 2.;
		vel.cyExt = .5;
		vel.cyPos = 2.;
		vel.vmid2 = 5.;
		vel.vmid3 = 6.5;
		vel.vmid4 = 7.7;
		vel.vmidB2 = 0;
		vel.vmidB3 = 100;
		vel.vmidB4 = 50;
		vel.vmidG2 = 255;
		vel.vmidG3 = 200;
		vel.vmidG4 = 50;
		vel.vmidR2 = 255;
		vel.vmidR3 = 200;
		vel.vmidR4 = 200;
		vel.dv1 = .1;

	}

	// not used
	//void CSeisWideDoc::mySetOBSPosition(float xshot)
	//{
	//	//check and/or modify segy.
	//	segy tr;
	//	short *i2buf;
	//	i2buf = (short *) &tr;
	//	float *trcdat;
	//
	//	trcdat = (float *) &i2buf[120];
	//	if (!isFileExistNotDirectory(draw.timeSecName)) return;
	//	CFile file;
	//	if (!file.Open(draw.timeSecName, CFile::modeReadWrite | CFile::typeBinary)) {
	//		return;
	//	}
	//
	//	//For progress control, need to know the last bytes no.
	//	 ULONGLONG curBytesRead, len;
	//	ULONGLONG totBytesRead = file.GetLength();
	//	 file.Seek(0, CFile::begin);
	//	//Begin progress control.
	//     CMainFrame* pFrame = 
	//        (CMainFrame*)AfxGetMainWnd();
	//     ASSERT(pFrame);
	//     ASSERT_KINDOF(CMainFrame, pFrame);
	//     pFrame->BeginProgress();
	//
	//	ULONGLONG bytesRead = file.Seek(3200L, CFile::begin);
	//	if(bytesRead < 3200) {
	//		file.Close();
	//		return;
	//	}
	//	bytesRead = file.Read(i2buf, 400);
	//	if(bytesRead < 400) {
	//		file.Close();
	//		return;
	//	}
	//	if(i2buf[12]!=3)  
	//		len = i2buf[10]*4;
	//	else if(i2buf[12]<0 || i2buf[12]>5) {
	//		file.Close();
	//		return;
	//	}
	//	else
	//		len = i2buf[10]*2;
	//
	//	while (file.Read(i2buf, 240) == 240)
	//	{
	//		curBytesRead = file.Seek(0, CFile::current);
	//		int iPos = (int)((double)curBytesRead/(double)totBytesRead*100.);
	//		if(iPos<0)iPos=0;
	//		if(iPos>100)iPos=100;
	//		pFrame->SetProgress(iPos);
	//
	//		ssmic.iv = (int)myRound((double)xshot*1000.);
	//		if(tr.sx == ssmic.iv) 
	//		{
	//			file.Close();
	//			pFrame->EndProgress();
	//			return; //this means the data is  already correct.
	//		}
	//		tr.sx = ssmic.iv;
	//		tr.gx = tr.offset + tr.sx;
	//		setDistance(&tr, tr.gx );
	//
	//		// i2buf[54] += -i2buf[52];  //in version 3.2, static shift is in i2buf[54], as opposed to [52] in previous version .
	//		// i2buf[52] = 0;
	//		tr.counit = 1;  //meters used.
	//		file.Seek(-240, CFile::current);
	//		file.Write(i2buf, 240);
	//		file.Seek((long)len, CFile::current);
	//	}
	//	
	//	file.Close();
	//	pFrame->EndProgress();
	//}

	void CSeisWideDoc::OnToolbarRefresh() 
	{
		draw.isNodeChanged = TRUE;
		if (this->draw.isShiftPressed) this->getRaycodeColor(0, TRUE);  // this will clear the already calculated color array
		//	draw.isSameDataDisplay = FALSE;
		//	if(velMod.ncont >= 2) OnToolbarSavev() ;
		//	velMod.velSecOld = _T("");	//this line is added to re-initialize vel model, in case the model is changed by other docs.
		if (draw.mode == 2 || draw.mode == 4) {
			// in velocity colormap or contour mode, the screen does not refresh the model, so we need to force it.
			// but in moode=3, it is handled separately.
			//draw.isSameDataDisplay = FALSE;
		}

		// must delete some transient files before closing 
		CString aName = getFileNameSubdir(draw.timeSecName, _T("rms"), _T("RmsHyperbolas.txt"), FALSE);
		if (!aName.IsEmpty()) {
			if (dig.digName == aName && isFileExistNotDirectory(aName)) {
				freeDigAll();
				if (!DeleteFile(aName)) {
					myCaption(_T("Failed to clean up a temporary file"));
				}
			}
		}

		draw.dxdyDrawn = 0.0f; // this value should now be set to zero

		// try to refresh the previous window
		// this->myUpdatePrevFrame();

		UpdateAllViews(NULL);
		NotifyChanged();
	}

	void CSeisWideDoc::OnToolbarRefreshAll() 
	{
		draw.isNodeChanged = TRUE;
		draw.isSameDataDisplay = FALSE;

		//if (isModelDisplayed()) 
		//	velMod.velSecOld = _T("");  // re-calc velocity model since other windows may have changed it

		//draw.timeSecOld = _T(""); // will clear up the cache
		if (this->draw.isShiftPressed) this->getRaycodeColor(0, TRUE);  // this will clear the already calculated color array

		CMainFrame* pFrame = 
			(CMainFrame*)AfxGetMainWnd();
		ASSERT(pFrame);
		ASSERT_KINDOF(CMainFrame, pFrame);
		// pFrame->gIsDisplayFreeze = FALSE;

		// must delete some transient files before closing 
		CString aName = getFileNameSubdir(draw.timeSecName, _T("rms"), _T("RmsHyperbolas.txt"), FALSE);
		if (!aName.IsEmpty()) {
			if (dig.digName == aName && isFileExistNotDirectory(aName)) {
				freeDigAll();
				if (!DeleteFile(aName)) {
					myCaption(_T("Failed to clean up a temporary file"));
				}
			}
		}

		dig.digNameOld = draw.digMarker.digNameOld = _T("");  // this will make them to reload the disk files.

		// try to refresh the previous window
		this->myUpdatePrevFrame();

		// we must save the model changes before Refresh All, otherwise, it may load the model again from disk and we lose any editing changes
		//if (isModelDisplayed())
		//	myModelSaveAs(velMod.velSecName);

		UpdateAllViews(NULL);
		NotifyChanged();

		// TESTING follows:
		//this->SetTitle(this->GetPathName() + _T(" - ") + draw.timeSecName);
	}

	void CSeisWideDoc::OnProcessingLatlongtodistance() 
	{
		static float aDist = ERRORVAL;
		static CString aLatlong;
		static BOOL isLonglat = false;
		static BOOL isOutputlatlong = true;
		CdlgLatLong dlg;
		dlg.m_latLongMulti = aLatlong;
		dlg.m_isLonglat = isLonglat;
		dlg.m_isOutputLatlong = isOutputlatlong;

		if(dlg.DoModal() == IDOK)
		{
			aLatlong = dlg.m_latLongMulti;
			isLonglat = dlg.m_isLonglat;
			isOutputlatlong = dlg.m_isOutputLatlong;
		}
		else
		{
			delete dlg;
			return;
		}


		//******************
		/*
		// this is the old spherical calculation, not acurate enough
		double  DEGTORAD=57.29578;
		double  EARTHRAD=6371.;
		double dist;

		// Find the colatitudes and calculate the solid angles
		double  ALPHA= fabs(para.long2-para.long1)/DEGTORAD;
		double  COLAT1=(90.-para.lat2)/DEGTORAD;
		double  COLAT2=(90.-para.lat1)/DEGTORAD;

		double  ANG1=cos(COLAT2)*cos(COLAT1);
		double  ANG2=sin(COLAT2)*sin(COLAT1)*cos(ALPHA);
		ALPHA=ANG1+ANG2;
		if(ALPHA >= 1.) dist = 0.;
		else dist=acos(ALPHA)*EARTHRAD;
		*/
		//******************
		//	aDist = (float)calcDist(para.long1, para.lat1, para.long2, para.lat2);

		int pos = 0;
		int count = 0;
		int i = 0;
		CString comments;
		CStringArray latLongArray, outArray;


		aLatlong.TrimLeft();
		aLatlong.TrimRight();
		CString a, t;
		double long1;
		double lat1;
		double flong;
		double flat;
		if (aLatlong.GetLength() > 2) {
			SplitString(aLatlong, _T("\n"), latLongArray);

			for (i=0; i<latLongArray.GetSize(); i++) {
				a = latLongArray.ElementAt(i);
				a.TrimLeft();
				a.TrimRight();
				if (a.GetLength() > 1) {
					// if here, the data is valid
					pos = a.FindOneOf(_T(" \t"));
					t = a.Left(pos);
					flat = _tstof(t);

					t = a.Mid(pos+1);  // include any third or fourth collumns
					t.TrimLeft();	// t may still contain extra spaces
					t.TrimRight();
					pos = t.FindOneOf(_T(" \t"));
					if (pos<0) {
						flong = _tstof(t);
						comments = _T("");
					}
					else {
						// we will ignore any strings in the third or fourth collumns
						flong = _tstof(t.Left(pos));
						comments = t.Mid(pos);
					}

					if (isLonglat) {
						// swap
						register double f = flong;
						flong = flat;
						flat = f;
					}


					if (i==0) {
						long1 = flong;
						lat1 = flat;
					}

					aDist = (float)calcDist(long1, lat1, flong, flat);
					if (isOutputlatlong)
						t.Format(_T("%8.5f  %8.5f  %8.5f%s"), (float)flat, (float)flong, (float)aDist, comments);
					else
						t.Format(_T("%8.5f  %s"), (float)aDist, comments);
					outArray.Add(t);
				}
			}


			isLonglat = FALSE;
			aLatlong = _T("");
			for (i=0; i<outArray.GetSize(); i++) {
				aLatlong += outArray.ElementAt(i) + _T("\r\n");
			}
			// dlg.m_latLongMulti = aLatlong;
		}


		latLongArray.RemoveAll();
		outArray.RemoveAll();
		OnProcessingLatlongtodistance();
		//	draw.isSameNodeDisplay = TRUE;

	}

	BOOL CSeisWideDoc::checkModelError(CString name)
	{
		//Autoly check if any errors exist in the velocity model.

		//name: input velocity file name in .bin format
		//parameters used: papa.xmin, pCd.coord.xmax, vel.dxV.
		// if(!MyInitVel(name)) return FALSE;

		if (!isFileExistNotDirectory(name)) {
			AfxMessageBox(_T("No model to check!"));
			return FALSE;
		}

		int icont, ix, nx, j;
		//FILE *stream;
		//float range;
		double range,depth[MOD_LAYER_MAX][500];
		//	BOOL errFound = FALSE, first=TRUE;

		nx=(int)((pCd.coord.xmax- pCd.coord.xmin)/vel.dxVDesired + 1.5);
		if(nx>500) {
			nx=500;
			vel.dxVDesired = (pCd.coord.xmax- pCd.coord.xmin) / 499.;
		}
		if (vel.dxVDesired < 0.) vel.dxVDesired = 0.1;

		if(velMod.ncont > 40)
		{
			AfxMessageBox(_T(">40 layers are not allowed for raytracing"));
			return FALSE;
		}

		for (ix=0; ix<nx; ix++)
		{
			if(ix==(nx-1)) range=pCd.coord.xmax;
			else range = pCd.coord.xmin + vel.dxVDesired*(double)ix;
			for (icont=0; icont<velMod.ncont; icont++)
			{
				for (j=1; j<velMod.nzed[icont]; j++)
				{
					if(range>=velMod.xm[j-1][icont] && range<=velMod.xm[j][icont])
					{
						if (fabs(velMod.xm[j][icont]-velMod.xm[j-1][icont]) < 0.00001f)
							depth[icont][ix] = velMod.zm[j][icont];
						else
							depth[icont][ix] = velMod.zm[j-1][icont] + (range-velMod.xm[j-1][icont])*
							(velMod.zm[j][icont]-velMod.zm[j-1][icont])/(velMod.xm[j][icont]-velMod.xm[j-1][icont]);
						break;
					}
				}
			}
		}

		CStringArray *strArr = new CStringArray();
		CString tStr;
		for (ix=0; ix<nx; ix++)
		{
			for (icont=1; icont<velMod.ncont; icont++)
			{
				if(depth[icont][ix]<depth[icont-1][ix]) 
				{
					if(ix==(nx-1)) range=pCd.coord.xmax;
					else range = pCd.coord.xmin + vel.dxVDesired*(double)ix;
					tStr.Format(_T("Error due to boundary overlap detected during velocity interpolation \n   at boundary no.: %2d, distance: %10.4f, with depth of %10.4f < the above boundary which is at %10.4f"), icont+1,range,depth[icont][ix],depth[icont-1][ix]);
					strArr->Add(tStr);
				}
			}
		} 
		//End of checking vel errors.
		if (strArr->GetCount() > 0)
		{
			CString newName = name + _T(".tempErrInfo.txt");
			if (saveStringArrayToFile(strArr, newName))
				showFileInNotePad(newName);
			strArr->RemoveAll();
			delete strArr;
			return FALSE;
		}

		delete strArr;
		return TRUE;
	}


	void CSeisWideDoc::OnProcessingRawtosegy() 
	{
		// simulate raw DOBS data to output segy. Left-over code from old work. Now it is disabled, until you want it.

		short i2buf[400], chan=2, n,nf=0;
		long i,j, tsiz, nSize, sampIndex=0;
		BOOL firstTrc=TRUE, fileEnd=FALSE;
		CString inFile = _T(""), outFile=_T(""), inFiles[999], newName, newName0, t;
		char ascHead[415];
		datafile binHead;
		// segy tro,tro2,tro3,tro4;
		segydynamic trDyn,trDyn2,trDyn3,trDyn4;
		trDyn.data = NULL;
		trDyn2.data = NULL;
		trDyn3.data = NULL;
		trDyn4.data = NULL;
		double deltaT;


		int nYear,nMonth,nDay,nHour,nMin,nSec;
		WORD trcIndex=0;
		short nbyts[4];  //used for 3-4 byte conversion.
		// short fbyts[4];
		unsigned short m1=4095,m2=255;        /* bit masks for use in bit manipulation */
		unsigned short m3=15,m5=61440,m6=2048; 
		/* m1=0000 1111 1111 1111
		m2=0000 0000 1111 1111
		m3=0000 0000 0000 1111
		m5=1111 0000 0000 0000
		m6=0000 1000 0000 0000
		*/


		//open a temporary text file for notepad.
		TCHAR lpszSystemInfo[MAX_PATH];   // buffer for concat'd. str.
		nSize = GetTempPath(MAX_PATH, lpszSystemInfo);
		FILE *stream;
		newName = CString(lpszSystemInfo) + _T(".tempAsciiHeader.txt");
		if( _tfopen_s(&stream, newName, _T("w") ) != 0 )
		{
			AfxMessageBox( _T("Can not open a temporaty file to hold the ascii header") );
			return;
		}

		//Open file dialog.
		CFileDialog dlg( TRUE,_T(""),_T("*.*"),
			OFN_HIDEREADONLY|OFN_OVERWRITEPROMPT|OFN_ALLOWMULTISELECT|OFN_EXPLORER,
			_T("Input Data Files (*.*)|*.*|"));
		TCHAR* buff=new TCHAR[65535];
		buff[0]='\0';
		dlg.m_ofn.lpstrTitle = _T("Select as many DOBS raw data files as you want to convert");
		dlg.m_ofn.lpstrFile=buff;
		dlg.m_ofn.nMaxFile = 65535;//sizeof(buff);


		POSITION Position;
		CTime timeRec0, timeRec;

		if(dlg.DoModal()==IDOK)
		{

			Position=dlg.GetStartPosition();
			while(Position)
			{
				inFile = dlg.GetNextPathName(Position);
				if(!inFile.IsEmpty()) {
					inFiles[nf] = inFile;
					nf++; }
			}
		} //end dlg.DoModal function.
		else {
			fclose(stream);
			delete [] buff;
			return;
		}
		delete [] buff;

		//now reorganize these files sequentially.
		if(nf>999)
		{
			fclose(stream);
			AfxMessageBox(_T("How come there are >999 files selected???"));
			return;
		}
		short indexF[999];
		for (n=0; n<nf; n++)
		{
			TCHAR s[3];
			t = inFiles[n].Right(3);
			for (i=0; i<3; i++) s[i] = t.GetAt(i);
			indexF[n] = _tstoi(&s[0]);
		}
		for (n=0; n<nf-1; n++)
		{
			for (i=n+1; i<nf; i++)
			{
				if(indexF[n]>indexF[i]) 
				{
					t = inFiles[i];				j=indexF[i];
					inFiles[i] = inFiles[n];	indexF[i]=indexF[n];
					inFiles[n] = t;				indexF[n]=(short)j;
				}
			}
		}


		//new file dialog.
		CFileDialog dlgOut( FALSE,_T(""),_T("*.sgy"),
			OFN_HIDEREADONLY|OFN_OVERWRITEPROMPT|OFN_EXPLORER,
			_T("Output Data Files (*.sgy)|*.sgy|"));
		dlgOut.m_ofn.lpstrTitle = _T("Select the output segy file");
		if(dlgOut.DoModal()==IDOK)
			newName0 = dlgOut.GetPathName();
		else {
			fclose(stream);
			return;
		}

		CFile fileOut1(getFileNameAppend(newName0, _T("ch1")), CFile::modeCreate|CFile::modeWrite|CFile::typeBinary);
		CFile fileOut2(getFileNameAppend(newName0, _T("ch2")), CFile::modeCreate|CFile::modeWrite|CFile::typeBinary);
		CFile fileOut3(getFileNameAppend(newName0, _T("ch3")), CFile::modeCreate|CFile::modeWrite|CFile::typeBinary);
		CFile fileOut4(getFileNameAppend(newName0, _T("ch4")), CFile::modeCreate|CFile::modeWrite|CFile::typeBinary);

		for (n=0; n<nf; n++)
		{
			CFile file;
			if (!file.Open(inFiles[n], CFile::modeRead | CFile::typeBinary)) {
				continue;
			}

			tsiz   = sizeof(binHead);
			UINT bytesRead = file.Read(&binHead, 97);
			if(bytesRead < 97) 
			{
				fclose(stream);
				fileOut1.Close();
				fileOut2.Close();
				fileOut3.Close();
				fileOut4.Close();
				AfxMessageBox(_T("File ") + inFile + _T(" binary section header read wrong"));
				return ;
			}
			//	binHead.freq *= (float)(4./3.);  //actual sampling rate is greater by 4/3.
			bytesRead = file.Read(ascHead, 415);
			if(bytesRead < 415) 
			{
				fclose(stream);
				fileOut1.Close();
				fileOut2.Close();
				fileOut3.Close();
				fileOut4.Close();
				AfxMessageBox(_T("File ") + inFile + _T(" ascii section header read wrong"));
				return ;
			}
			_ftprintf_s(stream, _T("\n\nDump of the ascii header for file %s"),inFiles[n]);
			_ftprintf_s(stream, _T("\n This data file will write traces starting from #%d \n"), trcIndex+1);
			for (i=0; i<415; i++)
				_ftprintf_s(stream, _T("%c"), ascHead[i]);

			//need to decode the begining time of this datafile.xxx .
			//date info starts at ascHead[96-].
			nDay = atoi(&ascHead[96]);
			t.Format(_T("%.3s"), &ascHead[99]);
			nYear = atoi(&ascHead[103]) + 1900;
			nHour = atoi(&ascHead[106]);
			nMin = atoi(&ascHead[109]);
			nSec = atoi(&ascHead[112]);
			if		(t == _T("Jan")) nMonth = 1;
			else if (t == _T("Feb")) nMonth = 2;
			else if (t == _T("Mar")) nMonth = 3;
			else if (t == _T("Apr")) nMonth = 4;
			else if (t == _T("May")) nMonth = 5;
			else if (t == _T("Jun")) nMonth = 6;
			else if (t == _T("Jul")) nMonth = 7;
			else if (t == _T("Aug")) nMonth = 8;
			else if (t == _T("Sep")) nMonth = 9;
			else if (t == _T("Oct")) nMonth = 10;
			else if (t == _T("Nov")) nMonth = 11;
			else if (t == _T("Dec")) nMonth = 12;
			else {AfxMessageBox(_T("Month not recognizable"));
			fclose(stream);
			fileOut1.Close();
			fileOut2.Close();
			fileOut3.Close();
			fileOut4.Close();
			return;
			}
			CTime timeRec(nYear, nMonth, nDay, nHour, nMin, nSec, 0);
			//this is the start recording time for this current file.

			if(firstTrc)
			{
				fileOut1.Write(ascHead, 415);
				fileOut2.Write(ascHead, 415);
				fileOut3.Write(ascHead, 415);
				fileOut4.Write(ascHead, 415);

				fileOut1.Seek(3200L, CFile::begin);
				fileOut2.Seek(3200L, CFile::begin);
				fileOut3.Seek(3200L, CFile::begin);
				fileOut4.Seek(3200L, CFile::begin);
				//assign section headers.
				memset((void *) &i2buf, (int) '\0', sizeof(i2buf));
				memset((void *) &trDyn, (int) '\0', sizeof(segydynamic));

				i2buf[10] = (unsigned short) (60.*binHead.freq+1); // numsamp;
				i2buf[11] = i2buf[10];
				i2buf[12] = 1;
				i2buf[8] = (unsigned short)(MIL/binHead.freq);	//Sampling rate;
				i2buf[9] = i2buf[8];
				fileOut1.Write(i2buf, 400L);
				fileOut2.Write(i2buf, 400L);
				fileOut3.Write(i2buf, 400L);
				fileOut4.Write(i2buf, 400L);

				trDyn.dt = i2buf[8];
				trDyn.ns = i2buf[10];
				trDyn.d1 = (float)(MIL/binHead.freq);
				trDyn.delrt = 0;
				trDyn.t1 = 0;  // delay recording time.
				trDyn.trid = 1;
				trDyn.data = (float *)malloc(sizeof(float)*trDyn.ns);
				trDyn2.data = (float *)malloc(sizeof(float)*trDyn.ns);
				trDyn3.data = (float *)malloc(sizeof(float)*trDyn.ns);
				trDyn4.data = (float *)malloc(sizeof(float)*trDyn.ns);

				timeRec0 = timeRec;
			}

			/* what's the time difference in sec at sampIndex (the last dat file)*/
			if( firstTrc ) {deltaT=0.f; firstTrc = FALSE; }
			else
			{
				CTimeSpan timeSpan1 = timeRec - timeRec0;
				deltaT = (float)timeSpan1.GetTotalSeconds();
				deltaT -= (trcIndex*trDyn.ns + sampIndex -1)/binHead.freq;
				if(deltaT<0) {
					//	AfxMessageBox(_T("Problems ");
					if (deltaT>0) _ftprintf_s(stream, _T("\n Problem of recording time with datafile.%3d"), n);
					continue;
				}
			}
			//now fill up the rest of tro.dat.data buffer.
			if (deltaT>0) _ftprintf_s(stream, _T("\n Data gap is %f long"), deltaT);
			_ftprintf_s(stream, _T("\n Sampling frequency is %f Hz"), binHead.freq);
			while (deltaT > 0)
			{
				if (deltaT*binHead.freq<=trDyn.ns-sampIndex)
				{ //the gap is now smaller and should fill in this trace only.
					while (deltaT > 0)
					{
						trDyn.data[sampIndex] = 0.f;
						sampIndex ++;
						deltaT -= 1.f/binHead.freq;
					}
					break;
				}
				else 
				{ //the gap is long enough to cover the whole trace.
					while (sampIndex < trDyn.ns)
					{
						trDyn.data[sampIndex] = 0.f;
						sampIndex ++;
						deltaT -= 1.f/binHead.freq;
					}
					//mark dead trace.
					trDyn.trid = 2;
					trDyn.tracr = trDyn.tracl = trcIndex;
					trDyn.offset = trcIndex*150 - 150000;

					// output as IBM float by default
					float_to_ibm((int *) &trDyn.data[0], (int *) &trDyn.data[0], (int)trDyn.ns);

					fileOut1.Write(&trDyn, trDyn.ns*4+240);
					fileOut2.Write(&trDyn, trDyn.ns*4+240);
					fileOut3.Write(&trDyn, trDyn.ns*4+240);
					fileOut4.Write(&trDyn, trDyn.ns*4+240);
					fileOut1.Flush();
					fileOut2.Flush();
					fileOut3.Flush();
					fileOut4.Flush();
					sampIndex=0;
					trDyn.trid = 1;
					trcIndex++;
				}
			}


			//now construct segy traces: I want 300 km, 150 m apart, 60 sec length for 
			//each trace, total 2000 traces, simulate an airgun experiment.
			while (file.Read(nbyts, 8) == 8)
			{
				trDyn.data[sampIndex] = (float)(nbyts[0]-2048);
				trDyn2.data[sampIndex] = (float)(nbyts[1]-2048);
				trDyn3.data[sampIndex] = (float)(nbyts[2]-2048);
				trDyn4.data[sampIndex] = (float)(nbyts[3]-2048);
				sampIndex++;

				if(sampIndex==trDyn.ns)
				{  //here means a trace is finished, advance to next trace.
					//the last few bits as just read in need to wrap.

					//but what's the time for the next trace? exactly 60 sec after.
					trDyn.tracr = trDyn.tracl = trcIndex;
					trDyn.offset = trcIndex*150 - 150000;
					fileOut1.Write(&trDyn, trDyn.ns*4+240);
					fileOut2.Write(&trDyn, 240); fileOut2.Write(&trDyn2.data, trDyn.ns*4);
					fileOut3.Write(&trDyn, 240); fileOut3.Write(&trDyn3.data, trDyn.ns*4);
					fileOut4.Write(&trDyn, 240); fileOut4.Write(&trDyn4.data, trDyn.ns*4);
					fileOut1.Flush();
					fileOut2.Flush();
					fileOut3.Flush();
					fileOut4.Flush();
					sampIndex = 0;
					trcIndex ++;
				}
			}  //end while loop for fileEnd.
		} //end the while file loop.

		fclose( stream );
		fileOut1.Seek(3212L, CFile::begin);
		fileOut2.Seek(3212L, CFile::begin);
		fileOut3.Seek(3212L, CFile::begin);
		fileOut4.Seek(3212L, CFile::begin);
		fileOut1.Write(&trcIndex, 2);
		fileOut2.Write(&trcIndex, 2);
		fileOut3.Write(&trcIndex, 2);
		fileOut4.Write(&trcIndex, 2);
		fileOut1.Close();
		fileOut2.Close();
		fileOut3.Close();
		fileOut4.Close();
		if (trDyn.data != NULL) free(trDyn.data);
		if (trDyn2.data != NULL) free(trDyn2.data);
		if (trDyn3.data != NULL) free(trDyn3.data);
		if (trDyn4.data != NULL) free(trDyn4.data);

		showFileInNotePad(newName);


	}

	void CSeisWideDoc::OnViewTraceanalysis() 
	{

		CString theString(  _T("SeisGraf.exe "));
		if(!myProcessSimple(theString)) 
			AfxMessageBox(_T("Not able to load SeisGraf.exe"));

	}


	int CSeisWideDoc::totDays(int nYear,int nDay,CString t)
	{

		int tot_days, temp=((nYear-1992)%4)!=0?28:29;
		if(nYear<1000) nYear+=1900;
		if(t == _T("Jan")) tot_days = nDay;
		else if (t == _T("Feb")) tot_days = 31+nDay;
		else if (t == _T("Mar")) tot_days = 31+temp+nDay;
		else if (t == _T("Apr")) tot_days = 31*2+temp+nDay;
		else if (t == _T("May")) tot_days = 31*2+30+temp+nDay;
		else if (t == _T("Jun")) tot_days = 31*3+30+temp+nDay;
		else if (t == _T("Jul")) tot_days = 31*3+30*2+temp+nDay;
		else if (t == _T("Aug")) tot_days = 31*4+30*2+temp+nDay;
		else if (t == _T("Sep")) tot_days = 31*5+30*2+temp+nDay;
		else if (t == _T("Oct")) tot_days = 31*5+30*3+temp+nDay;
		else if (t == _T("Nov")) tot_days = 31*6+30*3+temp+nDay;
		else if (t == _T("Dec")) tot_days = 31*6+30*4+temp+nDay;
		else return -1;

		return tot_days;
	}

	void CSeisWideDoc::OnProcessingDumpdistance() 
	{
		AfxMessageBox(_T("This routine will dump ascii numbers from the current segy file on screen. You put all your desired FFIDs (or shot points) in a text file and let the program compute the corresdponding CDPs for you. Assume CDPs increase monotonically with trace numbers, and input FFIDs ordered the same way as the segy file. Useful for gravity and magnetic modeling."));

		if (draw.mode != 0) 
		{
			AfxMessageBox(_T("Please display the time section first"));
			return;
		}

		CString name;
		segy tr;
		bhed hd;
		FILE *ifh1, *stream;  /* file handles */
		TCHAR line[MAXLINE];
		long len, FFID, ffidOld;
		ULONGLONG len1;  // to hold seek position
		float out,distOld;

		//new file dialog.
		CFileDialog dlg( TRUE,_T(""),_T("*.*"),
			OFN_HIDEREADONLY|OFN_EXPLORER,
			_T("Ascii Input FFID File (*.*)|*.*|"));
		dlg.m_ofn.lpstrTitle = _T("Each shot number in one line please");
		if(dlg.DoModal()==IDOK)
			name = dlg.GetPathName();
		else
			return;

		//now start this routine.

		CFile file;
		if (!file.Open(draw.timeSecName, CFile::modeRead | CFile::typeBinary)) {
			return;
		}
		file.Seek(3200L, CFile::begin);
		file.Read(&hd, 400L);
		if(hd.format != 3)
			len = hd.hns*4 + 240;
		else 
			len = hd.hns*2 + 240;

		if (_tfopen_s(&ifh1, name,_T("r")) != 0) 
		{
			AfxMessageBox(_T("Error opening input table")); 
			return; 
		}

		if( _tfopen_s( &stream, name+_T(".output.txt"), _T("w") ) != 0 )
		{
			AfxMessageBox(_T("New file cannot be opened") );
			return;
		}
		_ftprintf_s(stream,_T(" Ascii Dump of segy info\n FFIDs and Distance in km\n"));

		long i = 0;
		file.Read(&tr, 240);
		ffidOld = tr.fldr;
		distOld = getDistance(&tr);
		file.Seek(-240, CFile::current);
		while (_fgetts(line,MAXLINE,ifh1)!=NULL)
		{
			if (_tcslen(line) < 2) continue;
			if (line[0] == '#') continue; // we do not need comment lines
			_stscanf_s(line,_T("%d"),&FFID);

			//now look in segy file for proper trace that has this FFID or tr.fldr  .
			while (file.Read(&tr, 240) != NULL)
			{
				len1 = file.Seek(len-240, CFile::current);
				if(tr.trid == 2) continue; //dead traces.
				if (tr.fldr>=9980) i = 9980;
				if (i == 9980)
				{
					long ii = i;
				}
				if (tr.fldr < FFID)
				{
					ffidOld = tr.fldr;
					distOld = getDistance(&tr);
					continue;
				}
				else if(tr.fldr > FFID)
				{
					//I should interpolate betrwwn FFIDs.
					if (FFID < ffidOld)
					{
						// here the FFIDs gets smaller than previous, odd, fix!
						while (file.Read(&tr, 240) != NULL)
						{
							file.Seek(len-240, CFile::current);
							if (tr.fldr == FFID) break;
						}
						if (tr.fldr != FFID)
						{ //if no suitable FFID found, go back.
							file.Seek(len1-len, CFile::begin);
							file.Read(&tr, 240);
							file.Seek(len-240, CFile::current);
							out = -9999999.;
						}
						else if (tr.fldr==ffidOld) out=(float)distOld;
						else {
							out=(float)(distOld+(getDistance(&tr)-distOld)*(FFID-ffidOld)/(double)(tr.fldr-ffidOld));
						}
					}
					else
						if (tr.fldr==ffidOld) out=(float)distOld;
						else {
							out=(float)(distOld+(getDistance(&tr)-distOld)*(FFID-ffidOld)/(double)(tr.fldr-ffidOld));
						}
				}
				else
					out=getDistance(&tr);

				_ftprintf_s(stream,_T(" %d %f\n"),FFID, out*0.001f);
				ffidOld = tr.fldr;
				distOld = getDistance(&tr);
				break;
			}
		}

		file.Close();
		fclose( ifh1 );
		fclose( stream );

		AfxMessageBox(_T("Ascii dumping has been completed. Check the output file carefully for possible errors. Fix any numbers like -9999." ));

		showFileInNotePad(name+_T(".output.txt"));
	}




	void CSeisWideDoc::OnModelingDenblocks() 
	{
		long icont,j, jj;

		if (vel.dz<0.004) vel.dz=0.004;  //make sure it doesn't overflow.
		long nzmax = (long)myRound (pCd.coord.zmax / vel.dz);  //note: y is time in sec. nzmax is max num of pnts in depth.
		double x1,x2,z1,z2,z3,z4, v1,v2,v3,v4, x, rho, velRef[9], denRef[9], weightAtX, weightAtXAbs, depthCorr;
		float xmin, xmax;

		if (!isModelDisplayed())  {
			AfxMessageBox(_T("Please show a velocity model before converting to density outputs"));
			return;
		}


		FILE *fp;


		int pathLen = velMod.velSecName.ReverseFind( '\\' );
		if(pathLen>(-1)) SetCurrentDirectory(velMod.velSecName.Left(pathLen));
		CFileStatus status;
		BOOL initFileStatus = CFile::GetStatus(  _T("vel2den.txt"), status ); // static function
		if(!initFileStatus) {
			CdlgVel2Den dlg;
			if (dlg.DoModal() == IDOK)
			{
				velRef[0] = dlg.m_v1;  denRef[0]=dlg.m_d1;
				velRef[1] = dlg.m_v2;  denRef[1]=dlg.m_d2;
				velRef[2] = dlg.m_v3;  denRef[2]=dlg.m_d3;
				velRef[3] = dlg.m_v4;  denRef[3]=dlg.m_d4;
				velRef[4] = dlg.m_v5;  denRef[4]=dlg.m_d5;
				velRef[5] = dlg.m_v6;  denRef[5]=dlg.m_d6;
				velRef[6] = dlg.m_v7;  denRef[6]=dlg.m_d7;
				velRef[7] = dlg.m_v8;  denRef[7]=dlg.m_d8;
				velRef[8] = dlg.m_v9;  denRef[8]=dlg.m_d9;
			}
			else return;
			delete dlg;
			if (_tfopen_s(&fp, _T("vel2den.txt"), _T("w")) != 0) return;
		}
		else {  //read in the numbers in the file.
			if (_tfopen_s(&fp, _T("vel2den.txt"), _T("r+")) != 0) return;
			CdlgVel2Den1 dlg;
			_ftscanf_s( fp, _T("%f %f"), &dlg.m_v1,&dlg.m_d1);
			_ftscanf_s( fp, _T("%f %f"), &dlg.m_v2,&dlg.m_d2);
			_ftscanf_s( fp, _T("%f %f"), &dlg.m_v3,&dlg.m_d3);
			_ftscanf_s( fp, _T("%f %f"), &dlg.m_v4,&dlg.m_d4);
			_ftscanf_s( fp, _T("%f %f"), &dlg.m_v5,&dlg.m_d5);
			_ftscanf_s( fp, _T("%f %f"), &dlg.m_v6,&dlg.m_d6);
			_ftscanf_s( fp, _T("%f %f"), &dlg.m_v7,&dlg.m_d7);
			_ftscanf_s( fp, _T("%f %f"), &dlg.m_v8,&dlg.m_d8);
			_ftscanf_s( fp, _T("%f %f"), &dlg.m_v9,&dlg.m_d9);
			if (dlg.DoModal() == IDOK)
			{
				velRef[0] = dlg.m_v1;  denRef[0]=dlg.m_d1;
				velRef[1] = dlg.m_v2;  denRef[1]=dlg.m_d2;
				velRef[2] = dlg.m_v3;  denRef[2]=dlg.m_d3;
				velRef[3] = dlg.m_v4;  denRef[3]=dlg.m_d4;
				velRef[4] = dlg.m_v5;  denRef[4]=dlg.m_d5;
				velRef[5] = dlg.m_v6;  denRef[5]=dlg.m_d6;
				velRef[6] = dlg.m_v7;  denRef[6]=dlg.m_d7;
				velRef[7] = dlg.m_v8;  denRef[7]=dlg.m_d8;
				velRef[8] = dlg.m_v9;  denRef[8]=dlg.m_d9;
			}
			else  {
				fclose(fp);  //must close before return.
				return;
			}
			delete dlg;
			rewind (fp);
		}

		for (j=0; j<9; j++) _ftprintf_s( fp, _T("%8.3f %8.3f\n"), velRef[j], denRef[j]);
		fclose(fp);



		CString tStr;

		CStringArray *sArray = new CStringArray();

		xmin = (float)velMod.xmin;
		xmax = (float)velMod.xmax;
		sArray->Add(_T("#This file contains extra model parameters calculated for alternative plots of gravity blocks, and is not needed for gravity modeling program."));
		sArray->Add(_T("#Fourth collumn is isostatic depth (in km) corrected for sediment loading if you selected a boundary (z) for datum beforhand"));
		sArray->Add(_T("#       assuming densities are 3.25 and 1.03 for asthenosphere (Ra) and water (Rw)"));
		sArray->Add(_T("#       The formula is [Ra*z-Sum(den*dz)] / (Ra-Rw). Useful for obtaining subsidence history."));
		sArray->Add(_T("#       You can narrow down the display xmin and xmax for a finer calculation grid."));
		sArray->Add(_T("#       The units for weights are density multiplied by depth in km, for a depth collumn of the whole model. \n"));
		sArray->Add(_T("#DISTANCE(km)  WEIGHT(relative)  WEIGHT(absolute)  DEPTH(isostatically corrected) "));
		//calculate for isostacy at a number of x points.
		x = xmin;
		while (x<=xmax) {
			depthCorr = -9999.;
			weightAtX = 0.;
			weightAtXAbs = 0.;
			for (icont=0; icont<velMod.ncont-1; icont++) {	
				v1 = v2 = -9999.0;
				for (j=0; j<velMod.nvel[icont][0]-1; j++) {
					x1 = velMod.xvel[j][icont][0];
					if(x>=x1 && x<= velMod.xvel[j+1][icont][0]) {
						v1 = velMod.vf[j][icont][0] + (velMod.vf[j+1][icont][0]-velMod.vf[j][icont][0])*
							(x-x1)/(velMod.xvel[j+1][icont][0]-x1);
						break;
					}
					else continue;
				}
				for (j=0; j<velMod.nvel[icont][1]-1; j++) {
					x1 = velMod.xvel[j][icont][1];
					if(x>=x1 && x<= velMod.xvel[j+1][icont][1]) {
						v2 = velMod.vf[j][icont][1] + (velMod.vf[j+1][icont][1]-velMod.vf[j][icont][1])*
							(x-x1)/(velMod.xvel[j+1][icont][1]-x1);
						break;
					}
					else continue;
				}
				if (fabs(v1+9999.0)<0.1 || fabs(v2+9999.0)<0.1) {
					myCaption(_T("Cannot get a correct velocity for isostacy balancing"));
					continue;
				}
				rho = v2rho((v1+v2)/2., velRef, denRef); //average density computed.

				z1 = z2 = -9999.0;
				for (j=0; j<velMod.nzed[icont]-1; j++) {
					x1 = velMod.xm[j][icont];
					if(x>=x1 && x<= velMod.xm[j+1][icont]) {
						z1 = velMod.zm[j][icont] + (velMod.zm[j+1][icont]-velMod.zm[j][icont])*
							(x-x1)/(velMod.xm[j+1][icont]-x1);
						break;
					}
					else continue;
				}
				for (j=0; j<velMod.nzed[icont+1]-1; j++) {
					x1 = velMod.xm[j][icont+1];
					if(x>=x1 && x<= velMod.xm[j+1][icont+1]) {
						z2 = velMod.zm[j][icont+1] + (velMod.zm[j+1][icont+1]-velMod.zm[j][icont+1])*
							(x-x1)/(velMod.xm[j+1][icont+1]-x1);
						break;
					}
					else continue;
				}
				if (fabs(z1+9999.0)<0.1 || fabs(z2+9999.0)<0.1) {
					myCaption(_T("Cannot get a correct depth for isostacy balancing"));
					break;
				}
				if (z1>z2) {
					myCaption(_T("boundary problem for isostacy balancing"));
					break;
				}
				weightAtX += (rho-3.0)*(z2-z1);
				weightAtXAbs += rho*(z2-z1);

				//compute for sediment isostasy correction
				if (draw.nodes==1 && icont==draw.iLayerFocus-1) //boundary mode.
					depthCorr = (3.25*z2-weightAtXAbs)/(3.25-1.03);
				else if (draw.nodes==2 && icont==draw.iLayerFocus) //velocity mode.
					depthCorr = (3.25*z2-weightAtXAbs)/(3.25-1.03);

			} //end of isostacy calcualation for one x
			tStr.Format(_T("%7.2f %7.2f %7.2f %7.3f"), x, weightAtX, weightAtXAbs, depthCorr);
			sArray->Add(tStr); 
			x = x+(xmax-xmin)*0.02;
		}
		//end of isostacy section.


		CVelMod vm;
		CStringArray *gModArray = new CStringArray();

		sArray->Add(_T("#DENSITY  DISTANCE(km)  DEPTH(km)"));
		for (icont=0; icont<velMod.ncont-1; icont++) {
			//create layer-extension to the left.
			v1=velMod.vf[0][icont][0];
			v2=velMod.vf[1][icont][0];
			v3=velMod.vf[0][icont][1];
			v4=velMod.vf[1][icont][1];
			rho = v2rho((v1+v2+v3+v4)/4., velRef, denRef);

			tStr.Format(_T("%9.3f %9.3f %9.3f"), rho, -9999.f, velMod.zm[0][icont]);
			sArray->Add(tStr);
			tStr.Format(_T("%9.3f %9.3f %9.3f"), rho, xmin, velMod.zm[0][icont]);
			sArray->Add(tStr);
			tStr.Format(_T("%9.3f %9.3f %9.3f"), rho, xmin, velMod.zm[0][icont+1]);
			sArray->Add(tStr);
			tStr.Format(_T("%9.3f %9.3f %9.3f"), rho, -9999.f, velMod.zm[0][icont+1]);
			sArray->Add(tStr);

			tStr.Format(_T("%2d%3d%7.4f%7.4f"), icont+1,4,rho,rho);
			gModArray->Add(tStr);
			tStr.Format(_T("%9.3f%9.3f%9.3f%9.3f%9.3f%9.3f%9.3f%9.3f"), -999.f, velMod.zm[0][icont],
				xmin, velMod.zm[0][icont], 
				xmin, velMod.zm[0][icont+1],
				-999.f, velMod.zm[0][icont+1]);
			gModArray->Add(tStr);

			x1 = x2 = xmin;
			CString tStr2;
			//create the polygons for each layer.
			//*****x1***********x2******* with range at depth[icont]
			//**********range************
			//***************************
			//**x3*********************x4 with range at depth[icont+1]
			do
			{
				//first, find a block boundary for x2.
				for (j=1; j<velMod.nvel[icont][0]; j++) {
					x = velMod.xvel[j][icont][0];
					if (x2 > x) continue;
					else if (fabs(x2 - velMod.xvel[j][icont][0]) < 0.00001) continue;
					else break;
				} //now x is the next candidate for block boundary.
				for (j=1; j<velMod.nvel[icont][1]; j++) {
					if (x2 > velMod.xvel[j][icont][1]) continue;
					else if (fabs(x2 - velMod.xvel[j][icont][1]) < 0.00001) continue;

					//now velMod.xvel[j][1] is the another candidate for block boundary.
					// we need to choose one.
					x1 = x2;
					x2 = MIN(x, velMod.xvel[j][icont][1]);
					break;
				} 

				double vAvg = vm.getAvgVelAtDistRange(&velMod, x1, x2, icont);
				rho = v2rho(vAvg, velRef, denRef);

				//depths of the 4 corners?
				for (j=0; j<velMod.nzed[icont]-1; j++) {
					x = velMod.xm[j][icont];
					if(x1>=x && x1<= velMod.xm[j+1][icont]) {
						z1 = velMod.zm[j][icont] + (velMod.zm[j+1][icont]-velMod.zm[j][icont])*
							(x1-x)/(velMod.xm[j+1][icont]-x);
						break;
					}
					else continue;
				}
				for (j=0; j<velMod.nzed[icont]-1; j++) {
					x = velMod.xm[j][icont];
					if(x2>=x && x2<= velMod.xm[j+1][icont]) {
						z2 = velMod.zm[j][icont] + (velMod.zm[j+1][icont]-velMod.zm[j][icont])*
							(x2-x)/(velMod.xm[j+1][icont]-x);
						break;
					}
					else continue;
				}

				for (j=0; j<velMod.nzed[icont+1]-1; j++) {
					x = velMod.xm[j][icont+1];
					if(x2>=x && x2<= velMod.xm[j+1][icont+1]) {
						z3 = velMod.zm[j][icont+1] + (velMod.zm[j+1][icont+1]-velMod.zm[j][icont+1])*
							(x2-x)/(velMod.xm[j+1][icont+1]-x);
						break;
					}
					else continue;
				}

				for (j=0; j<velMod.nzed[icont+1]-1; j++) {
					x = velMod.xm[j][icont+1];
					if(x1>=x && x1<=velMod.xm[j+1][icont+1]) {
						z4 = velMod.zm[j][icont+1] + 
							(velMod.zm[j+1][icont+1]-velMod.zm[j][icont+1])*
							(x1-x)/(velMod.xm[j+1][icont+1]-x);
						break;
					}
					else continue;
				}

				//find out how many points, not writing now.
				long nn = 0;
				for (j=0; j<velMod.nzed[icont]; j++) {
					x = velMod.xm[j][icont];
					if (x<=x1) continue;
					if (x>=x2) break;
					nn++;
				}
				for (j=velMod.nzed[icont+1]-1; j>=0; j--) {
					x = velMod.xm[j][icont+1];
					if (x<=x1 || x>=x2) continue;
					nn++;
				}
				nn += 4;  //4 extra points.


				float *xx = ealloc1float(nn);
				float *zz = ealloc1float(nn);
				int count = 0;
				xx[count] = (float)x1;
				zz[count] = (float)z1;
				count++;
				for (j=0; j<velMod.nzed[icont]; j++) {
					x = velMod.xm[j][icont];
					if (x<=x1) continue;
					if (x>=x2) break;
					xx[count] = velMod.xm[j][icont];
					zz[count] = velMod.zm[j][icont];
					count++;
				}
				xx[count] = (float)x2;
				zz[count] = (float)z2;
				count++;
				xx[count] = (float)x2;
				zz[count] = (float)z3;
				count++;
				for (j=velMod.nzed[icont+1]-1; j>=0; j--) {
					x = velMod.xm[j][icont+1];
					if (x<=x1 || x>=x2) continue;
					xx[count] = velMod.xm[j][icont+1];
					zz[count] = velMod.zm[j][icont+1];
					count++;
				}
				xx[count] = (float)x1;
				zz[count] = (float)z4;
				count++;
				// NOTE: by now, count must be equal to nn, otherwise we have a problem

				if (count == nn) {
					for (j=0; j<count; j++) {
						tStr.Format(_T("%9.3f %9.3f %9.3f"), rho, xx[j], zz[j]);
						sArray->Add(tStr);
					}
				}
				free1float (xx);
				free1float (zz);


				tStr.Format(_T("%2d%3d%7.4f%7.4f"), icont+1,nn,rho,rho);
				gModArray->Add(tStr);

				tStr.Format(_T("%9.3f%9.3f"), x1, z1);
				jj = 1;  //now 1 point is written to tStr.
				for (j=0; j<velMod.nzed[icont]; j++) {
					x = velMod.xm[j][icont];
					if (x<=x1) continue;
					if (x>=x2) break;
					tStr2.Format(_T("%9.3f%9.3f"), velMod.xm[j][icont], velMod.zm[j][icont]);
					tStr += tStr2;
					if (jj == 4) {
						jj = 0;
						gModArray->Add(tStr);
						tStr.Format(_T(""));  // reset it
					}
					else  {
						jj++;
					}
				} // for
				tStr2.Format(_T("%9.3f%9.3f"), x2, z2);
				tStr += tStr2;
				if (jj == 4) {
					jj = 0;
					gModArray->Add(tStr);
					tStr.Format(_T(""));
				}
				else {
					jj++;
				}

				tStr2.Format(_T("%9.3f%9.3f"), x2, z3);
				tStr += tStr2;
				if (jj == 4) {
					jj = 0;
					gModArray->Add(tStr);
					tStr.Format(_T(""));
				}
				else {
					jj++;
				}

				for (j=velMod.nzed[icont+1]-1; j>=0; j--)
				{
					x = velMod.xm[j][icont+1];
					if (x<=x1 || x>=x2) continue;
					tStr2.Format(_T("%9.3f%9.3f"), velMod.xm[j][icont+1], velMod.zm[j][icont+1]);
					tStr += tStr2;
					if (jj == 4) {
						jj = 0;
						gModArray->Add(tStr);
						tStr.Format(_T(""));
					}
					else {
						jj ++;
					}
				}

				// last point
				tStr2.Format(_T("%9.3f%9.3f"), x1, z4);
				tStr += tStr2;
				gModArray->Add(tStr);
			} while ((x2-xmax) < -0.00001);

			//create layer extension to the right.
			v1=velMod.vf[velMod.nvel[icont][0]-2][icont][0];
			v2=velMod.vf[velMod.nvel[icont][0]-1][icont][0];
			v3=velMod.vf[velMod.nvel[icont][1]-1][icont][1];
			v4=velMod.vf[velMod.nvel[icont][1]-2][icont][1];
			rho = v2rho((v1+v2+v3+v4)/4., velRef, denRef);


			tStr.Format(_T("%9.3f %9.3f %9.3f"), rho, xmax, velMod.zm[velMod.nzed[icont]-1][icont]);
			sArray->Add(tStr);
			tStr.Format(_T("%9.3f %9.3f %9.3f"), rho, 9999.f, velMod.zm[velMod.nzed[icont]-1][icont]);
			sArray->Add(tStr);
			tStr.Format(_T("%9.3f %9.3f %9.3f"), rho, 9999.f,  velMod.zm[velMod.nzed[icont+1]-1][icont+1]);
			sArray->Add(tStr);
			tStr.Format(_T("%9.3f %9.3f %9.3f"), rho, xmax,  velMod.zm[velMod.nzed[icont+1]-1][icont+1]);
			sArray->Add(tStr);

			tStr.Format(_T("%2d%3d%7.4f%7.4f"), icont+1,4,rho,rho);
			gModArray->Add(tStr);
			tStr.Format(_T("%9.3f%9.3f%9.3f%9.3f%9.3f%9.3f%9.3f%9.3f"), xmax, velMod.zm[velMod.nzed[icont]-1][icont],
				999.f, velMod.zm[velMod.nzed[icont]-1][icont],
				999.f, velMod.zm[velMod.nzed[icont+1]-1][icont+1],
				xmax,   velMod.zm[velMod.nzed[icont+1]-1][icont+1]);
			gModArray->Add(tStr);
		}



		bool isTrue;

		CString progPath = getGravmodPath();
		CString workPathSlash = getWorkingPathSlash();
		SetCurrentDirectory(workPathSlash);


		CString strGmodExtra = workPathSlash + _T("g.mod.extra");
		saveStringArrayToFile(sArray, strGmodExtra);
		sArray->RemoveAll();
		sArray = NULL;

		tStr = workPathSlash + _T("\\g.mod");
		isTrue = saveStringArrayToFile(gModArray, tStr);
		gModArray->RemoveAll();
		gModArray = NULL;


		CDigitize pDg;
		dig.digName = draw.markerName;
		if (isFileExistNotDirectory(draw.markerName) && 
			isEndWith(draw.markerName, _T("g.obs")) &&
			pDg.myDigitizingLoadTXTUnix2(&dig, FALSE, FALSE) && 
			dig.totCurve==1 ) {
				// if this marker is correct, we try to generate r.in, run gravmod.exe, and extrat calculated gravity from g.out and put results to  dig.digName 

				CStringArray *sArray3 = new CStringArray();
				sArray3 = new CStringArray();
				sArray3->Add(_T("  &pltpar"));
				sArray3->Add(_T("          icol=1, iseg=0, imod=2, igrav=1, isigma0=0,"));
				sArray3->Add(_T("          irmdc=1, idata=1, ilab=2, idump=0, "));
				sArray3->Add(_T("          nsmth=0, nevery=2,"));
				sArray3->Add(_T("          xsdata=0., dsmax=.2,"));
				sArray3->Add(_T("          symht=1., numht=2.0, isymb=2,"));
				sArray3->Add(_T("  &end"));
				sArray3->Add(_T("  &axepar "));
				tStr.Format(_T("          xmin=%f, xmax=%f, xmm=200., ntickx=25, "), velMod.xmin, velMod.xmax);
				sArray3->Add(tStr);
				tStr.Format(_T("          xtmin=%f, xtmax=%f, xmm=200.,"), velMod.xmin, velMod.xmax);
				sArray3->Add(tStr);
				tStr.Format(_T("          zmin=0.0, zmax=%f, zmm=100.,"), pCd.coord.zmax);
				sArray3->Add(tStr);
				tStr.Format(_T("          gmin=-50.0, gmax=50, gmm=35., ntickg=1,"));
				sArray3->Add(tStr);
				sArray3->Add(_T("          albht=3., xorig=15., yorig=15.,"));
				sArray3->Add(_T("  &end"));
				sArray3->Add(_T("  &grvpar"));
				sArray3->Add(_T("          polys=500, den0=3.1,"));
				tStr.Format(_T("          first=%f, last=%f, spacng=4.,"), velMod.xmin-200., velMod.xmax+200.);
				sArray3->Add(tStr);
				sArray3->Add(_T("          pincl=-1, pomit=-1,"));
				sArray3->Add(_T("  &end"));

				tStr = workPathSlash + _T("g.in");
				isTrue = saveStringArrayToFile(sArray3, tStr);
				sArray3->RemoveAll();
				sArray3 = NULL;

				if (isTrue) {
					// now we want to run the gravMod program
					// SetCurrentDirectory(progPath);
					//myProcessSimple(progPath+ _T("\\gravMod.exe"));
					CString txPath = getWorkingPathSlash();
					CString progPath = getSeisWidePath() + _T("\\others\\psGravmod\\gravExample\\gravMod.exe");
					CString exeNameQuoted = addQuotes(progPath);
					if (!isFileExistNotDirectory(exeNameQuoted)) {
						AfxMessageBox(_T("Failed to locate gravMod.exe program."));
					}
					else {
						PROCESS_INFORMATION proc_i = myProcess(exeNameQuoted, txPath, FALSE);  // info returned from CreateProcess
						if(WaitForSingleObject(proc_i.hProcess, INFINITE) == WAIT_TIMEOUT) {
							AfxMessageBox(_T("Failed due to time-out")) ;
						} // else	
						CloseHandle(proc_i.hProcess);
						CloseHandle(proc_i.hThread);
					}


					tStr = _T("After gravMod finished, Skip auto adjustments for vertical scales to accomodate the observed gravity points? (No=Adjust; Cancel=Adjust negative axis limit only.)");
					int isTrue2 = AfxMessageBox(tStr, MB_YESNOCANCEL|MB_ICONINFORMATION);
					dig.digName = workPathSlash+ _T("g.out");
					pDg.myDigitizingLoadTXTUnix2(&dig, FALSE, FALSE, TRUE);
					tStr = workPathSlash+ _T("g.out.calc.txt");
					if (myDigSaveAs(tStr)) {
						dig.digName = tStr;
					}

					float amin = pDg.getDigYMin(&dig);
					float amax = pDg.getDigYMax(&dig);
					if (myFloat2(pCd.coord.vred) == 0.0f) {
						amin *= draw.markerYMultFactor;
						amin += draw.markerYShift;
						amax *= draw.markerYMultFactor;
						amax += draw.markerYShift;
					}
					amin = getMinRounded(amin, amax, 10);
					amax = getMaxRounded(amin, amax, 10);
					if (draw.markerIsRevYAxis) {
						x =   -amax;
						amax = -amin;
						amin = (float)x;
					}

					if (isTrue2==IDNO) {
						if (isTimeDomain()) {
							if (pCd.coord.tmin > amin) pCd.coord.tmin = amin;
							if (pCd.coord.tmax < amax) pCd.coord.tmax = amax;
						}
						else {
							if (pCd.coord.zmin > amin) pCd.coord.zmin = amin;
							if (pCd.coord.zmax < amax) pCd.coord.zmax = amax;
						}
					}
					else if (isTrue2==IDCANCEL) {
						if (isTimeDomain()) {
							if (pCd.coord.tmin > amin) pCd.coord.tmin = amin;
						}
						else {
							if (pCd.coord.zmin > amin) pCd.coord.zmin = amin;
						}
					}

					UpdateAllViews(NULL);
					NotifyChanged();
					return;
				}
		}

		showFileInNotePad(strGmodExtra);

		tStr = _T("Velocity model is succesfully converted to density blocks in file g.mod. To use it in GRAVMOD, \n1. Create/Edit a file named 'g.obs' with observed distance-gravity pairs (X Y free format) in:\n");
		tStr += workPathSlash;
		tStr += _T("\n2. Select this file as marker. \n3. Re-run this routine. For your convenience, a Windows Explorer will show you the directory after this.");

		//AfxMessageBox(_T("Converted density blocks of the model is succesfully saved to g.mod. To use it in GRAVMOD program, \n1. Edit 'g.obs' with observed distance-gravity pairs in 'Digitize format'.\n2. Modify parameter file 'g.in'.\n3. Run 'GravMod.exe' in DOS window.\n4. Run gravMod.exe to result in a 2-page 'g.ps' file."));
		AfxMessageBox(tStr);
		ShellExecute(NULL, _T("explore"), workPathSlash, NULL, NULL, SW_SHOWDEFAULT);

	}

	void CSeisWideDoc::OnModelingSubsidence() 
	{
		CString tStr;
		tStr.Format(_T("Perform isostatic depth correction for stripping sediment loading.\n First, digitize 1 segment z(x). All sediments above it will be stripped.\n Assume densities 3.25 and 1.03 for asthenosphere (Ra) and water (Rw),\n final depth deduction is [Sum(den*dz) - Rw*z]/(Ra-Rw)."));
		AfxMessageBox(tStr);

		if (!draw.isDigitizing || dig.nPoint[0]<2) {
			// the user is not digitizing. 
			tStr.Format(_T("Pleaser digitize 1 segment with >= 2 points."));
			AfxMessageBox(tStr);
			return;
		}
		if (!isModelDisplayed() && isTimeDomain()) 
		{
			AfxMessageBox(_T("Please show a velocity model in depth domain before converting to density outputs"));
			return;
		}

		long icont,icont2,j,j2;

		if (vel.dz<0.004) vel.dz=0.004;  //make sure it doesn't overflow.
		long nzmax = (long)myRound (pCd.coord.zmax / vel.dz);  //note: y is time in sec. nzmax is max num of pnts in depth.
		double z1,z2,v1,v2, x, rho, velRef[9], denRef[9], weightDig, dz;



		FILE *fp;
		setCurrentPathSameAs(velMod.velSecName);
		//CFileStatus status;
		//BOOL initFileStatus = CFile::GetStatus( _T("vel2den.txt"), status ); // static function
		if(!isFileExistNotDirectory(_T("vel2den.txt"))) {
			CdlgVel2Den dlg;
			if (dlg.DoModal() == IDOK)
			{
				velRef[0] = dlg.m_v1;  denRef[0]=dlg.m_d1;
				velRef[1] = dlg.m_v2;  denRef[1]=dlg.m_d2;
				velRef[2] = dlg.m_v3;  denRef[2]=dlg.m_d3;
				velRef[3] = dlg.m_v4;  denRef[3]=dlg.m_d4;
				velRef[4] = dlg.m_v5;  denRef[4]=dlg.m_d5;
				velRef[5] = dlg.m_v6;  denRef[5]=dlg.m_d6;
				velRef[6] = dlg.m_v7;  denRef[6]=dlg.m_d7;
				velRef[7] = dlg.m_v8;  denRef[7]=dlg.m_d8;
				velRef[8] = dlg.m_v9;  denRef[8]=dlg.m_d9;
			}
			else return;
			delete dlg;
			if (_tfopen_s(&fp, _T("vel2den.txt"), _T("w")) != 0) return;
		} else {
			//read in the numbers in the file.
			if (_tfopen_s(&fp, _T("vel2den.txt"), _T("r+")) != 0) return;
			CdlgVel2Den1 dlg;
			_ftscanf_s( fp, _T("%f %f"), &dlg.m_v1,&dlg.m_d1);
			_ftscanf_s( fp, _T("%f %f"), &dlg.m_v2,&dlg.m_d2);
			_ftscanf_s( fp, _T("%f %f"), &dlg.m_v3,&dlg.m_d3);
			_ftscanf_s( fp, _T("%f %f"), &dlg.m_v4,&dlg.m_d4);
			_ftscanf_s( fp, _T("%f %f"), &dlg.m_v5,&dlg.m_d5);
			_ftscanf_s( fp, _T("%f %f"), &dlg.m_v6,&dlg.m_d6);
			_ftscanf_s( fp, _T("%f %f"), &dlg.m_v7,&dlg.m_d7);
			_ftscanf_s( fp, _T("%f %f"), &dlg.m_v8,&dlg.m_d8);
			_ftscanf_s( fp, _T("%f %f"), &dlg.m_v9,&dlg.m_d9);
			if (dlg.DoModal() == IDOK) {
				velRef[0] = dlg.m_v1;  denRef[0]=dlg.m_d1;
				velRef[1] = dlg.m_v2;  denRef[1]=dlg.m_d2;
				velRef[2] = dlg.m_v3;  denRef[2]=dlg.m_d3;
				velRef[3] = dlg.m_v4;  denRef[3]=dlg.m_d4;
				velRef[4] = dlg.m_v5;  denRef[4]=dlg.m_d5;
				velRef[5] = dlg.m_v6;  denRef[5]=dlg.m_d6;
				velRef[6] = dlg.m_v7;  denRef[6]=dlg.m_d7;
				velRef[7] = dlg.m_v8;  denRef[7]=dlg.m_d8;
				velRef[8] = dlg.m_v9;  denRef[8]=dlg.m_d9;
			} else  {
				fclose(fp);  //must close before return.
				return;
			}
			delete dlg;
			rewind (fp);
		}

		for (j=0; j<9; j++) _ftprintf_s( fp, _T("%8.3f %8.3f\n"), velRef[j], denRef[j]);
		fclose(fp);



		/*
		float xmin, xmax;
		double weightAtX;
		FILE *stream;
		CString newName = _T("g_mod.txt";
		if( _tfopen_s(&stream, newName, _T("w") ) != 0 )
		{
		AfxMessageBox( _T("Can not open a file to hold the output" );
		return;
		}
		xmin = (float)pCd.coord.xmin;
		xmax = (float)pCd.coord.xmax;
		_ftprintf_s(stream, "First three collumns are Distance (km), relative [thickness*(den-3)], total [thickness*den] weights (in 100kg/cm^2) \n");
		_ftprintf_s(stream, "Fourth collumn is isostatic depth (in km) corrected for sediment loading for a selected boundary (at depth z)\n");
		_ftprintf_s(stream, "       assuming densities are 3.25 and 1.03 for asthenosphere (Ra) and water (Rw)\n");
		_ftprintf_s(stream, "       The formula is [Ra*z-Sum(den*dz)] / (Ra-Rw). Useful for obtaining subsidence history. \n");
		_ftprintf_s(stream, "       You can narrow down the display xmin and xmax for a finer calculation grid. \n");

		//calculate for isostacy at a number of x points.
		x = xmin;
		while (x<=xmax)
		{
		getVZCurveAtDist((float)x, &depth[0], &vTop[0], &vBot[0], true);  // apply anisotropy automatically as long as it exists for the layer!
		depthCorr = -99999.;
		weightAtX = 0.;
		weightAtXAbs = 0.;
		for (icont=0; icont<velMod.nlayer; icont++)
		{	
		v1 = vTop[icont]; v2 = vBot[icont];
		rho = v2rho((v1+v2)/2., velRef, denRef); //average density computed.
		z1 = depth[icont]; z2 = depth[icont+1];
		weightAtX += (rho-3.0)*(z2-z1);
		weightAtXAbs += rho*(z2-z1);

		//compute for sediment isostasy correction
		if (icont==draw.iLayerFocus-1) //boundary mode.
		depthCorr = (3.25*z2-weightAtXAbs)/(3.25-1.03);
		//else if (draw.nodes==2 && icont==draw.iLayerFocus) //velocity mode.
		//	depthCorr = (3.25*z2-weightAtXAbs)/(3.25-1.03);

		} //end of isostacy calcualation for one x
		_ftprintf_s(stream, _T("%7.2f %7.2f %7.2f %7.3f\n", x, weightAtX, weightAtXAbs, depthCorr); 
		x = x+(xmax-xmin)*0.01;
		}
		//end of isostacy section.
		fclose( stream );

		draw.isSameNodeDisplay = FALSE;
		//	AfxMessageBox(_T("This model is succesfully converted to density \nWith density blocks bordered by vertical boundaries only at velocity nodes of layers. \nYou should modify the density of each block to fit observed gravity.");
		showFileInNotePad(newName);
		*/



		//calculate for isostacy for all model boundaries below draw.iLayerFocus.
		CVelMod vm;
		CVelMod::VELMOD modNew;
		vm.velModSetArrays(&modNew);

		CVelMod::VELMOD_X modX;

		int boundaryCut = 0;

		double zDig;
		CDigitize pDg;
		pDg.myDigSort(&dig, TRUE, FALSE, pCd.coord.xmin, pCd.coord.xmax);
		int np = dig.nPoint[0];
		for (icont2=velMod.ncont-1; icont2>=0; icont2--) {
			bool isBoundaryUseful = false;
			for (j2=0; j2<velMod.nzed[icont2]; j2++) {
				x = velMod.xm[j2][icont2];
				modX.dist = x;
				vm.initModX(&velMod, &modX, isTimeDomain() == TRUE, true, true, vel.dz);
				// apply anisotropy automatically as long as it exists for the layer!

				// need to get the zDig (the digitized curve depth) at x
				zDig = -99999.;
				if (x <= dig.x[0][0]) zDig = dig.t[0][0];
				else if (x >= dig.x[np-1][0]) zDig = dig.t[np-1][0];
				else {
					for (int i=0; i<np-1; i++) {
						if (x > dig.x[i][0]  && x<=dig.x[i+1][0]) {
							zDig = (dig.x[i+1][0] - dig.x[i][0]) == 0.f  ?  dig.t[i][0]  :
								dig.t[i][0] + (dig.t[i+1][0] - dig.t[i][0]) * (x-dig.x[i][0]) / (dig.x[i+1][0] - dig.x[i][0]);
							break;
						} 
					} // for
				}


				dz = -99999.;  // the amount of depth correction
				weightDig = 0.;  // total weight at depth on the digitized curve 
				for (icont=0; icont<velMod.ncont; icont++) {	
					z1 = modX.depthMod[icont];
					z2 = modX.depthMod[icont + 1];
					if (z1 >= zDig) {
						break;
					}

					v1 = modX.vTop[icont];
					v2 = modX.vBot[icont];
					rho = v2rho((v1+v2)/2., velRef, denRef); //average density computed.
					if (z2 > zDig) z2 = zDig;
					weightDig += rho*(z2-z1);
				} //end of weight calcualation for one point.


				//compute for sediment isostasy correction
				// note: the following 2 formulas are all correct!
				// dz = zDig - (3.25*zDig-weightDig)/(3.25-1.03);  
				dz = (weightDig - 1.03 * zDig) /(3.25-1.03);

				modNew.zm[j2][icont2] = velMod.zm[j2][icont2] - (float)dz;

				// now, the digitized depth should be adjusted to 
				zDig -= dz;
				if (modNew.zm[j2][icont2] <= zDig ) {
					modNew.zm[j2][icont2] = (float)zDig;
				}
				else 
					isBoundaryUseful = true;
			} // for j2
			if (!isBoundaryUseful) {
				boundaryCut = icont2;
				break;
			}
		} // for icont2

		// do not update the first boundary which is sea surface
		for (int icontNew=1; icontNew<velMod.ncont-boundaryCut+1; icontNew++) {
			// icont is the new boundary number
			int icontOld = icontNew+boundaryCut-1;  // icontOld is the previous boundary number 
			for (j=0; j<velMod.nzed[icontOld]; j++) {
				velMod.xm[j][icontNew] = velMod.xm[j][icontOld];
				velMod.zm[j][icontNew] = modNew.zm[j][icontOld];
			}
			velMod.nzed[icontNew] = velMod.nzed[icontOld];
			for (int k=0; k<2; k++) {
				// k==0 means at the top of layer; k==1 means bottom of layer
				for (j=0; j<velMod.nvel[icontOld][k]; j++) {
					velMod.xvel[j][icontNew][k] = velMod.xvel[j][icontOld][k];
					velMod.vf[j][icontNew][k] = velMod.vf[j][icontOld][k];
				}
				velMod.nvel[icontNew][k] = velMod.nvel[icontOld][k];
			}
		}
		velMod.ncont -= boundaryCut-1;
		draw.iLayerFocus = boundaryCut;

		vm.velModFreeArrays(&modNew);

		velMod.velSecName = getFileNameAppend(velMod.velSecName, _T("isoCorr"));
		AfxMessageBox(_T("All boundaries at and below the selected boundary are succesfully isostatically corrected for sediment loading."));

		OnToolbarSaveasv();
		//velMod.velSecOld = _T("");	//refresh velocity.
		SetModifiedFlag();
		UpdateAllViews(NULL);
		NotifyChanged();
	}

	//void CSeisWideDoc::DrawControls(CDC *pDC, CRect rectDeviceClient, CRect rect)
	void CSeisWideDoc::DrawControls(CDC *pDC)
	{

		//return;

		//this routine is shared and  called by two OnDraw().
		//rect is where the X-Y axes are drawn.
		//rectDeviceClient is supplied in pixels, used only during the SeisWide's decision in traces that are to be skipped (so the program runs faster).
		// onDraw() of VIew class only call this routine when draw.isSameDataDisplay is FALSE

		// when !draw.isSameNodeDisplay, stops loading seismic going further to avoid crash!

		// NOTE: DrawControls() does not draw travel-time curves, digitized points and
		//		 line-drawings. However, it tries to do some fix up on these points 
		//		 when some problem occurs.
		//	TCHAR s[80];
		//	_stprintf(s, _T(" file not properly opened; assign path to file name for a fix!");

		if (!isTimeDomainUtil(draw.mode))
			para.isDistanceDisplay = TRUE;  // this can avoid problems.

		if (!bmp24.bmp24Name.IsEmpty()) {
			DrawBitmap(draw.gDC);
			return;
		}


		CString tStr = _T(" file was not properly opened.");
		CString tStr2 = _T("");
		BOOL isTrueBackup;
		switch (draw.mode) 
		{
		case 0:
			if(!DrawTimeArr(pDC)) {
				tStr2.Format(_T("%s%s"), draw.timeSecName, tStr);
			}
			break;
		case 1:
			// show only the seismic section in depth
			pCd.coord.isFaceUp = 0;
			if(!DrawSectionArr(pDC, draw.depthSecName, pCd.coord.zmin, pCd.coord.zmax)) {
				tStr2.Format(_T("%s%s"), draw.depthSecName, tStr);
			}
			break;
		case 2:
			// show only the velocity color map in depth
			pCd.coord.isFaceUp = 0;
			if(!DrawVel(pDC)) {
				myCaption(tStr);
			}
			break;
		case 3:
			// show both the velocity color map and depth section
			// This is not used in the onDraw() of CSeisWideDraw class
			// since I want to separate DC when the seismic and velocity model are all displayed.
			// but it's used for other classes
			pCd.coord.isFaceUp = 0;
			isTrueBackup = draw.isNoBoundary; // backup first
			draw.isNoBoundary = TRUE;
			if(!DrawVel(pDC))	{
				AfxMessageBox(tStr);
			}
			if(!DrawSectionArr(pDC, draw.depthSecName, pCd.coord.zmin, pCd.coord.zmax)) {
				tStr2.Format(_T("%s%s"), draw.depthSecName, tStr);
			}

			// no only draw boundaries if needed. We want to draw these after the seismic section displayed
			draw.isNoBoundary = isTrueBackup;
			if (!draw.isNoBoundary)
				DrawVel(pDC, TRUE);
			break;
		case 4:
			// show only the velocity contours
			pCd.coord.isFaceUp = 0;
			if(!DrawCont(pDC)) {
				myCaption(tStr);
			}
			break;
		case 6:
			if(!DrawSectionTrcArr(pDC, draw.timeSecName, para.trace1, para.trace2)) {
				tStr2.Format(_T("%s%s"), draw.timeSecName, tStr);
			}
			break;
		case 7:
			// if(!DrawHydroTime(pDC)) {
			if(!DrawTimeArr(pDC)) {
				tStr2.Format(_T("%s%s"), draw.timeSecName, tStr);
			}

			// if(para.traveltime) myShowTravelTimeInGDC(pDC, TRUE);

			break;
		case 8:
			if(!DrawStackVelocity(pDC)) {
				tStr2.Format(_T("Failed drawing stacking velocity!"));
			}
			break;
		case 9:
			if (isFileExistNotDirectory(draw.timeSecName)) {
				// para.traveltime = FALSE;  // do not show travel time curves while showing velocity model in TWTT mode
				para.isDistanceDisplay = TRUE;  
				// in this mode, only distance display is meaningful. But sometimes the user does not have it right. So we reset it here.
				DrawTimeArr(pDC);
			}
			break;
		case 10:
			if(!DrawTimeArr(pDC)) {
				tStr2.Format(_T("%s%s"), draw.timeSecName, tStr);
			}
			break;
		}

		if (tStr2.GetLength() > 0)
			myCaption(tStr2);

		//	if(!draw.isNoOBSPos && draw.mode>0 && draw.mode<6) DrawSymbolPos(pDC);
		//DrawSymbolPos(pDC);

	}

	void CSeisWideDoc::DrawBitmap(CDC *pDC)
	{
		//this routine is called after OnFileImportbitmap() which loads bitmap parameters,
		//and LoadBitmapInDC(pDC) which loads bitmap file into a memory DC: bmp24.bmpDC.
		//This routine maps the bitmap in bmp24.bmpDC into world coords, and draws 
		//onto the screen in pDC, called by OnDraw() before DrawControls().
		//rect is the rectangle of axes to be displayed.
		//	note:	pCd.coord.ix1,iy1,ix2,iy2; //device coords.
		//			pCd.coord.axisX1,y1,x2,y2; //These are limits zoomed up by user.
		//			pCd.coord.xmin,xmax,zmin,zmax;  //xmin and xmax are limits in actutal vel data.
		//	faceDown==1: time axis is upward.

		//	if (!draw.isSameNodeDisplay) return;

		int nrow, ncol;
		CPoint p1, p2;
		//	CPoint pSrc1, pSrc2;
		double y1,y2; //these are bounds for a valid display area.


		if(bmp24.isNeedInitialize) {
			if (! bmp24.dib.LoadBMP(bmp24.bmp24Name, &bmp24.biForm, &ncol, &nrow) ) {
				myCaption(_T("Could not load the bitmap file"));
				return;
			}
			bmp24.isNeedInitialize = FALSE;
		}

		bool isTime = isTimeDomain() == TRUE;
		if(isTime) {
			y1 = pCd.coord.tmin;
			y2 = pCd.coord.tmax;
		} else {
			y1 = pCd.coord.zmin;
			y2 = pCd.coord.zmax;
		}

		// destination client coord
		p1 = pCd.mm_coord(pCd.coord.xmin, y1, isTime);
		p2 = pCd.mm_coord(pCd.coord.xmax, y2, isTime);

		// source client coord

		//pDC->SetStretchBltMode(HALFTONE);


		//if (! bmp24.dib.Draw( pDC, 
		//	p1.x, 
		//	p1.y, 
		//	p2.x-p1.x, 
		//	p2.y-p1.y) )
		//{
		//	myCaption(_T("Could not draw the bitmap file"));
		//}




		int col1,col2, row1,row2;
		//CPoint bb1, bb2, delt;
		//CSize siz1, siz2;
		double a1,a2;

		//the bitmap, defined by (bmp24.dib.m_pBIH->biWidth, bmp24.dib.m_pBIH->biHeight) pixels in bmp24.dib should be mapped 
		//to a rectangle defined by (col1,row1) and (col2,row2) in screen pixels in pDC.
		a1 = bmp24.dib.m_pBIH->biWidth/(bmp24.xmax-bmp24.xmin);
		a2 = bmp24.dib.m_pBIH->biHeight/(bmp24.ymax-bmp24.ymin);
		col1 = (int)myRound((pCd.coord.xmin - bmp24.xmin)*a1);
		row1 = (int)myRound((y1 - bmp24.ymin)*a2);
		col2 = (int)myRound((pCd.coord.xmax - bmp24.xmin)*a1);
		row2 = (int)myRound((y2 - bmp24.ymin)*a2);


		if (! bmp24.dib.DrawEx( pDC, 
			col1, // these are the bitmap pixels, not considering any client coords
			row1, 
			col2, 
			row2,


			p1.x, // these are client coords
			p1.y, 
			p2.x-p1.x, 
			p2.y-p1.y) 
			)
		{
			myCaption(_T("Could not draw the bitmap file"));
		}



		// now draw a faint rectangle to make the border visible
		CPoint plt[5];
		plt[0] = p1;
		plt[1] = CPoint(p2.x, p1.y);
		plt[2] = p2;
		plt[3] = CPoint(p1.x, p2.y);
		plt[4] = p1;

		CPen greenPen(PS_SOLID, 1, RGB(230,255,230));
		// oldPen = pDC->SelectObject(&greenPen);
		//CBrush brush(RGB(255,255,255));
		int nSaved = pDC->SaveDC();
		pDC->SelectStockObject(NULL_BRUSH); // No Area Filling
		CPen* oldPen = pDC->SelectObject(&greenPen);
		pDC->Polyline(plt, 5); // If I use 5, it may fill the whole box when printed to PS file.
		//pDC->SelectObject(oldBrush);
		//pDC->SelectObject(oldPen);
		pDC->RestoreDC(nSaved);
	}

	void CSeisWideDoc::OnFileResizebitmap() 
	{
		if (!isFileExistNotDirectory(bmp24.bmp24Name)) {
			OnFileImportbitmap();
			return;
		}
		CdlgImportbitmap dlg;
		dlg.m_name = bmp24.bmp24Name;
		dlg.m_X1 = bmp24.xmin;
		dlg.m_Z1 = bmp24.ymin;
		dlg.m_X2 = bmp24.xmax;
		dlg.m_Z2 = bmp24.ymax;
		dlg.m_isDepth = bmp24.isDepth;
		//dlg.isLoading = FALSE; //if false, it will disable two boxes in the dlg.

		if (dlg.DoModal() == IDOK)
		{
			bmp24.xmin = dlg.m_X1;
			bmp24.ymin = dlg.m_Z1;
			bmp24.xmax = dlg.m_X2;
			bmp24.ymax = dlg.m_Z2;
			bmp24.isDepth = dlg.m_isDepth;
		}
		else return;

		draw.isSameDataDisplay = FALSE; //indicate display has been changed and will re-load all data.
		SetModifiedFlag();
		UpdateAllViews(NULL);
		NotifyChanged();
	}

	void CSeisWideDoc::OnFileImportbitmap() 
	{
		CdlgImportbitmap dlg;
		dlg.m_name = bmp24.bmp24Name;
		dlg.m_X1 = bmp24.xmin;
		dlg.m_Z1 = bmp24.ymin;
		dlg.m_X2 = bmp24.xmax;
		dlg.m_Z2 = bmp24.ymax;
		dlg.m_isDepth = !isTimeDomain(); //if TRUE, a time section, otherwise a depth section.
		if (dlg.DoModal() == IDOK) {
			bmp24.bmp24Name = dlg.m_name;
			bmp24.xmin = dlg.m_X1;
			bmp24.ymin = dlg.m_Z1;
			bmp24.xmax = dlg.m_X2;
			bmp24.ymax = dlg.m_Z2;
			bmp24.isDepth = dlg.m_isDepth; //if TRUE, a time section, otherwise a depth section.
		}
		else return;

		if (!isFileExistNotDirectory(bmp24.bmp24Name)) {
			bmp24.bmpDC.DeleteDC();
			bmp24.isNeedInitialize = TRUE; //when update screen, initialize the bitmap file and DC etc.
		} else {
			if(isTimeDomain()) {//current display is in time.
				if (bmp24.isDepth) {
					AfxMessageBox(_T("Bitmap data is not in the time domain and will not load"));
					// bmp24.bmp24Name = _T("");
					return;
				}
			} else { //current display is in depth.
				if (!bmp24.isDepth) {
					AfxMessageBox(_T("Bitmap data is not in the depth domain and will not load"));
					return;
				}
			}
			bmp24.isNeedInitialize = TRUE; //when update screen, initialize the bitmap file and DC etc.
		}

		draw.isSameDataDisplay = FALSE; //indicate display has been changed and will re-load all data.
		SetModifiedFlag();
		UpdateAllViews(NULL);
		NotifyChanged();

	}

	BOOL CSeisWideDoc::LoadBitmapInDC(CDC *pDC)
	{
		//this routine will load a bmp24 file into a memory device context *pDC: bmp24.bmpDC, 
		// with no coord transformation. *pDC is input, a major DC used by OnDraw(). 
		// Another DC will be generated to hold the bitmap DC, transformed into a world coordinate, 
		// and bitblt() into current DC.
		// this routine loads any uncompressed bitmap format.
		CDib m_Dib;
		int nrow,ncol;
		if (! m_Dib.LoadBMP(bmp24.bmp24Name, &bmp24.biForm, &ncol, &nrow) ) {
			myCaption(_T("Could not load the bitmap file"));
			return FALSE;
		}

		//bmp24.bmpDC.DeleteDC(); //if bmpDC is still there then delete it before we create it.

		//CBitmap m_bmp; //deleted every time a routine has finished using it.
		//BOOL trueFalse = bmp24.bmpDC.CreateCompatibleDC(pDC);
		//if (bmp24.biForm == 1)
		//	m_bmp.CreateBitmap(ncol, nrow, 1, 1, NULL); //only for monochrome.
		//else
		//	m_bmp.CreateCompatibleBitmap(pDC, ncol, nrow);
		//bmp24.bmpDC.SelectObject(&m_bmp);
		//bmp24.bmpDC.SetMapMode(MM_ANISOTROPIC);
		//bmp24.bmpDC.SetViewportExt(ncol, nrow);
		//bmp24.bmpDC.SetWindowExt(ncol, nrow);	 //for rect, logical, himetric coords.
		//bmp24.bmpDC.SetBkMode(TRANSPARENT); //to avoid texts overlap each other.
		//m_bmp.DeleteObject();

		m_Dib.SetPalette(  &bmp24.bmpDC );
		if (! m_Dib.Draw( &bmp24.bmpDC, 0, 0, ncol, nrow) ) {
			myCaption(_T("Could not draw the bitmap file"));
			return FALSE;
		}


		return TRUE;
	}


	void CSeisWideDoc::OnProcessingDataresample() 
	{

		ULONGLONG Byte;
		long i,totShot=0, rate, rate2;
		long outLen2;
		float *rData;
		CString outFile = _T(""), inFile=_T("");
		static int numsampNew = 0;

		CdlgResample dlg;
		dlg.m_in = draw.timeSecName;
		dlg.m_out = getFileNameAppend(draw.timeSecName, _T("Resamp"));
		dlg.m_tmax = 0;
		dlg.m_tmin = 0;
		dlg.m_vRed = 0;
		dlg.m_numsampNew = numsampNew;
		if (dlg.DoModal() == IDOK) {
			inFile = dlg.m_in;
			outFile = dlg.m_out;
			rate = dlg.m_rate;
			rate2 = dlg.m_rate2;
			numsampNew = dlg.m_numsampNew;
		} else 
			return;


		if (!isFileExistNotDirectory(inFile)) return;
		if(outFile==_T("")) return;


		// sometimes the user accidentally specified a stupid mistake in output sampling rate.
		if (rate2 < 10 || rate2 > 30000 || (float)rate2/(float)rate < 0.1f || (float)rate2/(float)rate > 10.f) {
			CString tmp;
			tmp.Format(_T("You desired sampling rate %d microsec is quite different from the existing %d microsec. Re-enter?"), rate2, rate);
			if(AfxMessageBox(tmp, MB_YESNO|MB_ICONINFORMATION) == IDYES) return;
		}




		outFile = mySetFileExtension(outFile, _T("sgy"));

		segy tr, tr2;
		bhed bh, bh2;
		CFile file;
		if (!file.Open(inFile, CFile::modeRead | CFile::typeBinary)) {
			return;
		}

		//For progress control, need to know the last bytes no.
		ULONGLONG curBytesRead, totBytesRead = file.GetLength();
		file.Seek(0, CFile::begin);
		ULONGLONG bytesRead = file.Read(head.ascHead, 3200L);
		if(bytesRead < 3200) {
			AfxMessageBox(_T("Ascii section header read wrong"));
			file.Close();
			return;
		}
		file.Read(&bh, 400L);

		int numsamp = bh.hns;
		int format = bh.format;
		int len = (bh.format != 3) ? numsamp*4 + 240   :   numsamp*2 + 240;
		int tpp = bh.hdt;

		float dt = (float)bh.hdt / (float)MIL;

		outLen2 = (int)myRound((double)bh.hns * (double)rate / (double)rate2); 
		if (outLen2 > SU_NFLTS) outLen2 = SU_NFLTS;
		if(outLen2<2) 
		{
			file.Close();
			AfxMessageBox(_T("trace length too short"));
			return;
		}
		if (numsampNew > 0) outLen2 = numsampNew;

		// we make a convention: bh will store section header info for output. 
		// while  head struct store input file


		CFile file2;
		if (!file2.Open(outFile, CFile::modeWrite|CFile::modeCreate|CFile::typeBinary)) {
			file.Close();
			return;
		}



		// now modify the section header for output
		memcpy( (void *) &bh2, (const void *) &bh, 400);
		bh2.hdt = (unsigned short)rate2;
		bh2.format = 1;  // we always want to output in floating point
		bh2.hns = (unsigned short)outLen2;
		file2.Write(head.ascHead, 3200L);
		file2.Write(&bh2, 400);
		float dt2 = (float)bh2.hdt / (float)MIL;

		rData = (float *)malloc((size_t)(numsamp*sizeof(float)));
		if( rData == NULL)
		{
			file.Close();
			file2.Close();
			AfxMessageBox( _T("Insufficient memory available") );
			return;
		}

		//Begin progress control.
		CMainFrame* pFrame = 
			(CMainFrame*)AfxGetMainWnd();
		ASSERT(pFrame);
		ASSERT_KINDOF(CMainFrame, pFrame);
		pFrame->BeginProgress();

		while (file.Read(&tr, len) == (UINT)len)
		{
			curBytesRead = file.Seek(0, CFile::current);
			Byte = curBytesRead + len-240;	//point to next trace.
			int iPos = (int)((double)curBytesRead/(double)totBytesRead*100.);
			if(iPos<0)iPos=0;
			if(iPos>100)iPos=100;
			pFrame->SetProgress(iPos);

			if(format == 1) 
			{ // float
				ibm_to_float((int *) tr.dat.data, (int *) tr.dat.data, (int)numsamp);
				for (i=0; i<numsamp; i++) {
					rData[i] = tr.dat.data[i];
				} // for i
			}
			else if(format == 2) 
			{ // int
				for (i=0; i<numsamp; i++) {
					rData[i] = (float)tr.dat.dataint[i];
				} // for i
			}
			else if(format == 3) 
			{ // short int
				for (i=0; i<numsamp; i++) {
					rData[i] = (float)tr.dat.datashort[i];
				} // for i
			}
			else if(format == 5) 
			{ // float
				for (i=0; i<numsamp; i++) {
					rData[i] = tr.dat.data[i];
				} // for i
			}
			else break;

			for (i=0; i<numsamp; i++)
			{
				if(_isnan(rData[i])) rData[i] = 0.f;
			}

			// tr2.dat.data[] now represents the desired time sample in sec
			for (i=0; i<outLen2; i++) {
				tr2.dat.data[i] = getTraceDelay(&tr) + (float)i*dt2;
			} // for i

			ints8r((int)numsamp, // ntin
				dt,   // dtin
				getTraceDelay(&tr),   // ftin
				&rData[0], // yin[t=ntin], with yin[0] = y(fxin)
				0.f,  // yinl    value used to extrapolate yin values to left of yin[0]
				0.f,  // yinr	 value used to extrapolate yin values to right of yin[ntin-1]
				outLen2,   // nxout
				(float *)&tr2.dat.data[0],  // ntout
				(float *)&tr.dat.data[0]);    // tout
			tr.dt = (unsigned short)rate2;
			tr.ns = (unsigned short)outLen2;
			float_to_ibm((int *) tr.dat.data, (int *) tr.dat.data, (int)tr.ns);
			file2.Write(&tr, (long)(240+outLen2*4));
		} // while

		pFrame->EndProgress();
		file.Close();
		file2.Close();

		free(rData);
		AfxMessageBox( _T("Success. Please check output file in the same directory.") );
		//draw.timeSecOld = _T("");
		//draw.timeSecName = outFile;
	}


	int CSeisWideDoc::ptdraw(int pick, int remove, int move, int add)
	{
		// this routine converts the 4 states into a variable for easy handling.
		if (pick==1) return 0;
		else if (remove==1) return 1;
		else if (move==1) return 2;
		else if (add==1) return 3;
		else return -1;
	}





	void CSeisWideDoc::OnProcessingDebias() 
	{
		long i;
		CString inFile = _T(""), outFile=_T("");
		static int trace1 = 0;
		static int trace2 = 99999;

		segy tr;
		segy tr2;
		bhed bh;

		/*
		unsigned short *i2buf;
		i2buf = (unsigned short *) &tr;

		float *trcdat;
		trcdat = (float *) &i2buf[120];

		unsigned short *i2short;
		i2short = (unsigned short *) &i2buf[120];
		long *i2int;
		i2int = (long *) &i2buf[60];
		*/

		CdlgInOut dlg;
		dlg.m_inFile = draw.timeSecName;	
		dlg.m_trace1 = trace1;
		dlg.m_trace2 = trace2;
		if (dlg.DoModal() == IDOK)
		{
			inFile = dlg.m_inFile;
			outFile = dlg.m_outFile;
			trace1 = dlg.m_trace1;
			trace2 = dlg.m_trace2;
			if (trace2 == trace1) {
				trace1 = 0;
				trace2 = 99999;
			}
		}
		else 
		{
			return;
		}

		//	inFile = draw.timeSecName;
		//	outFile = inFile + _T(".UNIX");
		if (!isFileExistNotDirectory(inFile)) return;
		if(outFile==_T("")) return;
		if(outFile == inFile) {
			AfxMessageBox(_T("Output file name is the same as the input file name!"));
			return;
		}
		outFile = mySetFileExtension(outFile, _T("sgy"));

		//put the path onto file2 if it doesn't have it.
		int pathLen = outFile.ReverseFind( '\\' );
		if(pathLen==(-1))
		{
			TCHAR curDir[_MAX_PATH];
			GetCurrentDirectory(_MAX_PATH, curDir);
			// outFile = (CString)curDir + _T("\\" + outFile;
			outFile.Format(_T("%s\\%s"), (CString)curDir, outFile );
		}

		CFile file;
		if (!file.Open(inFile, CFile::modeRead | CFile::typeBinary)) {
			return;
		}

		//For progress control, need to know the last bytes no.
		ULONGLONG curBytesRead, totBytesRead = file.GetLength();
		file.Seek(0, CFile::begin);
		//Begin progress control.
		CMainFrame* pFrame = 
			(CMainFrame*)AfxGetMainWnd();
		ASSERT(pFrame);
		ASSERT_KINDOF(CMainFrame, pFrame);
		pFrame->BeginProgress();


		UINT bytesRead = file.Read(head.ascHead, 3200L);
		if(bytesRead < 3200) 
			AfxMessageBox(_T("Ascii section header read wrong"));
		bytesRead=file.Read(&bh, 400L);
		if(bytesRead < 400) 
			AfxMessageBox(_T("Binary section header read wrong"));
		//The following numbers have to be recalculated everytime,
		//because plotting the depth section will change these numbers.
		int numsamp = bh.hns; // (unsigned short)i2buf[10];
		int len;

		BOOL dataInt;
		if(bh.format !=3)  
		{
			dataInt = FALSE;
			len = numsamp*4 + 240;
		}
		else 
		{
			dataInt = TRUE;
			len = numsamp*2 + 240;
		}
		long headLenOut = numsamp*4 + 240;  // output in floating point only


		CFile file2;
		if (!file2.Open(outFile, CFile::modeWrite|CFile::modeCreate|CFile::typeBinary)) {
			file.Close();
			return;
		}

		file2.Write(head.ascHead, 3200L);
		int formatIn = bh.format;
		// bh.format = 1;  // always output in floating format
		bh.format = pFrame->gIsIBMFloatSegy2  ?  1  :  5; // only floating is adopted for output
		file2.Write(&bh, 400L);

		ULONGLONG byteFileEnd = file.SeekToEnd();
		file.Seek(3600L, CFile::begin);

		while (file.Read(&tr, len) == (UINT)len)
		{
			if (tr.tracl < trace1 || tr.tracl > trace2) continue;

			tr.ns = numsamp; // this is for safer

			double sum=0.0;
			double mean=0.0;

			if(formatIn == 1 ) {	
				// float data
				ibm_to_float((int *) tr.dat.data, (int *) tr.dat.data, (int)numsamp);

				for (i=0; i<numsamp; i++)
					sum += (double)tr.dat.data[i];

				mean=sum/(double)numsamp;
				for (i=0; i<numsamp; i++)
				{
					tr2.dat.data[i]=(float)(tr.dat.data[i]-mean); 
				}

			} else if(formatIn  == 2) {
				for (i=0; i<numsamp; i++)
					sum += (double)(tr.dat.dataint[i]);

				mean=(double)sum/(double)numsamp;
				for (i=0; i<numsamp; i++)
				{
					tr2.dat.data[i] = (float)(tr.dat.dataint[i]-mean);
				}

			} else if(formatIn  == 3) {	
				// short int data
				for (i=0; i<numsamp; i++)
					sum=sum+(double)(tr.dat.datashort[i]);

				mean=(double)sum/(double)numsamp;
				for (i=0; i<numsamp; i++)
				{					 
					tr2.dat.data[i]=(float)(tr.dat.datashort[i]-mean); 
				}
			} else if(formatIn == 4) {
				AfxMessageBox(_T("Data is Fixed Point w/ Gain Code, not supported"));
				return;
			}
			else if(formatIn == 5 ) {	
				for (i=0; i<numsamp; i++)
					sum += (double)tr.dat.data[i];

				mean=sum/(double)numsamp;
				for (i=0; i<numsamp; i++) {
					tr2.dat.data[i]=(float)(tr.dat.data[i]-mean); 
				}
			}
			else
			{
				AfxMessageBox(_T("Unknown Data format"));
				return;
			}


			if ( bh.format==1 ) {
				float_to_ibm((int *) tr2.dat.data, (int *) tr2.dat.data, numsamp);
			}
			file2.Write(&tr, 240);
			file2.Write(&tr2.dat.data[0], numsamp*4); // will output floating point format only!

			// progress control. Do not change
			curBytesRead = file.Seek(0, CFile::current);
			int iPos = (int)((double)curBytesRead/(double)totBytesRead*100.);
			if(iPos<0)iPos=0;
			if(iPos>100)iPos=100;
			pFrame->SetProgress(iPos);
		}	// while


		if (file) file.Close();
		if (file2) file2.Close();
		if (pFrame) { 
			pFrame->EndProgress();
		}
	}




	void CSeisWideDoc::OnProcessingWiener() 
	{
		if (draw.mode != 0 && draw.mode != 6 && draw.mode != 7) return;
		CString inFile = _T(""), outFile=_T("");
		CString tStr;
		static float minLag = 0.03f;

		segy tr,out_tr;
		bhed bh;

		CdlgWienerFilter dlg;

		dlg.m_pnoise = 0.01f;
		dlg.m_maxcorr = dlg.m_tmax = (float)pCd.coord.tmax;
		dlg.m_mincorr = dlg.m_tmin = (float)pCd.coord.tmin;

		dlg.m_minlag = minLag;
		dlg.m_maxlag=(dlg.m_tmax-dlg.m_tmin)/20.0f;

		dlg.m_nameIn = draw.timeSecName;	
		dlg.m_nameOut = getFileNameAppend(draw.timeSecName, _T("_decon"));


		if (dlg.DoModal() == IDOK)
		{
			inFile = dlg.m_nameIn;
			outFile = dlg.m_nameOut;
			minLag = dlg.m_minlag;
		} else  {
			return;
		}

		if(outFile==_T("")) return;
		if(outFile == inFile) {
			AfxMessageBox(_T("Output file name is the same as the input file name!"));
			return;
		}

		float pnoise = dlg.m_pnoise;
		// now will use a few other variables: dlg.m_maxcorr, dlg.m_mincorr, dlg.m_maxlag

		CFile file;
		if (!file.Open(inFile, CFile::modeRead | CFile::typeBinary)) {
			return;
		}

		CMainFrame* pFrame =  (CMainFrame*)AfxGetMainWnd();
		UINT bytesRead = file.Read(head.ascHead, 3200L);

		if(bytesRead < 3200) 
			AfxMessageBox(_T("Ascii section header read wrong"));

		bytesRead=file.Read(&bh, 400L);
		BOOL isUnix = false;
		if (isUnix = IsUnix(bh.format)) SwapTapeHeader(&bh);
		if(bytesRead < 400) 
			AfxMessageBox(_T("Binary section header read wrong"));

		if(bh.format != 1 && bh.format != 5) {
			file.Close();
			AfxMessageBox(_T("Sorry, only floating points are supported for this decon. Please convert first."));
			return;
		}

		int formatIn = bh.format;
		bh.format = pFrame->gIsIBMFloatSegy2  ?  1  :  5; // only floating is adopted for output

		int numsamp= bh.hns;
		int len = (bh.format !=3)  ?  numsamp*4 + 240 :  numsamp*2 + 240;

		//The following numbers have to be recalculated everytime,
		//because plotting the depth section will change these numbers.
		// numsamp = bh.hns; // (unsigned short)i2buf[10];

		ULONGLONG byteFileEnd = file.SeekToEnd();
		file.Seek(3600L, CFile::begin);
		float dt=(float)((float)bh.hdt/(float)1000000.0);
		double odt = MIL / (double)bh.hdt;

		CFile file2;
		if (!file2.Open(outFile, CFile::modeWrite|CFile::modeCreate|CFile::typeBinary)) {
			file.Close();
			return;
		}

		file2.Write(head.ascHead, 3200L);
		file2.Write(&bh, 400L);


		float *wiener = ealloc1float(numsamp);
		float *spiker = ealloc1float(numsamp);
		float *autocorr = ealloc1float(numsamp);

		int i;
		int j;
		float omax = (head.maxAmp > 0.f)  ?  (float)(1.0/head.maxAmp)  :  0.f;

		CString labelMinlags = _T("");

		file.Seek(3600, CFile::begin);
		while (file.Read(&tr, len) == (UINT)len)
		{
			if (isUnix) {
				SwapTraceHeader(&tr);
				SwapN(&tr, bh.format);
			}
			if (formatIn==1)
				ibm_to_float((int *) tr.dat.data, (int *) tr.dat.data, (int)numsamp);
			if ((int)(tr.tracl /10) * 10 == tr.tracl) { 
				tStr.Format(_T("Decon Trc %d"), tr.tracl);
				myCaption(tStr);
			}

			tr.ns = (unsigned short)numsamp; // just to be safe

			// calculate lags
			int iminlag=(int)myRound(minLag*odt);
			if(iminlag<1) iminlag=1;
			int imaxlag=(int)myRound(dlg.m_maxlag *odt);
			if(imaxlag>numsamp) imaxlag=(int)myRound(0.05*numsamp);
			if(imaxlag<-numsamp) imaxlag=-(int)myRound(0.05*numsamp);
			int nlag=abs(imaxlag)-iminlag+1;


			// now calculate corr window
			float reducedTime = (float)this->getReduceTime( getOffset(&tr) , pCd.coord.vred);
			float mincorrAbs = dlg.m_mincorr+reducedTime;
			float maxcorrAbs = dlg.m_maxcorr+reducedTime;


			// for digitize curves, we can use them for calc decon factor window
			if(draw.isDigitizing 
				&& !dig.isZeltFormat2  // line-drawing format
				&& dig.totCurve > 0) {

					float dist = (para.isDistanceDisplay) ?  getDistance(&tr) : getOffset(&tr);
					float aintopol = -1.f;;
					for (int i=0; i<dig.nPoint[0]-1; i++)
					{
						if(dist>=dig.x[i][0] && dist<=dig.x[i+1][0] )
						{
							if(dig.x[i][0]!=dig.x[i+1][0])
								aintopol = dig.t[i][0]+(dig.t[i+1][0]-dig.t[i][0])
								/(dig.x[i+1][0]-dig.x[i][0])*(dist-dig.x[i][0]); 
							else
								aintopol = dig.t[i][0];
							break;
						}
					} // for int i
					if (aintopol >= 0)
						mincorrAbs = aintopol;

					if (dig.totCurve > 1) {
						aintopol = -1.f;;
						for (int i=0; i<dig.nPoint[1]-1; i++)
						{
							if(dist>=dig.x[i][1] && dist<=dig.x[i+1][1] )
							{
								if(dig.x[i][1]!=dig.x[i+1][1])
									aintopol = dig.t[i][1]+(dig.t[i+1][1]-dig.t[i][1])
									/(dig.x[i+1][1]-dig.x[i][1])*(dist-dig.x[i][1]); 
								else
									aintopol = dig.t[i][1];
								break;
							}
						} // for int i

						if (aintopol > mincorrAbs)
							maxcorrAbs = aintopol;
					} // else if totCurve>1
					if (mincorrAbs >= maxcorrAbs) {
						// for some reason, after adjusting the corr window, we have mincorr >= maxcorr. we need to correct this
						mincorrAbs = dlg.m_mincorr+reducedTime;
						maxcorrAbs = dlg.m_maxcorr+reducedTime;
					}
			} // if draw.isDigitizing

			// before calculating index, we need to minus the trace delay from absolute time
			mincorrAbs -= getTraceDelay(&tr);
			maxcorrAbs -= getTraceDelay(&tr);

			// calc the start and end time for auto correlation window
			int imincorr=(int)myRound( mincorrAbs *odt );
			if(imincorr<0) imincorr=0;
			if(imincorr>numsamp) imincorr=numsamp;

			int imaxcorr=(int)myRound( maxcorrAbs *odt );
			if(imaxcorr<0) imaxcorr=0;
			if(imaxcorr>numsamp) imaxcorr=numsamp;

			// now the window can be zero length. So we have to get around this  dlg.m_maxcorr, dlg.m_mincorr
			int iwindowCorrLength = (int)myRound((dlg.m_maxcorr - dlg.m_mincorr)*odt);
			if (imincorr > imaxcorr - iwindowCorrLength) {
				imincorr = imaxcorr - iwindowCorrLength;
			}
			int ncorr=imaxcorr-imincorr+1;

			// auto correlation starts
			for (i=0; i<numsamp; i++) {
				tr.dat.data[i] *= omax;
			}

			/*****************************************************************************
			void xcor (int lx, int ifx, float *x,
			int ly, int ify, float *y, 
			int lz, int ifz, float *z)
			Compute z = x cross-correlated with y; i.e.,

			ifx+lx-1
			z[i] =   sum    x[j]*y[i+j]  ;  i = ifz,...,ifz+lz-1
			j=ifx
			******************************************************************************
			Input:
			lx		length of x array
			ifx		sample index of first x
			x		array[lx] to be cross-correlated with y
			ly		length of y array
			ify		sample index of first y
			y		array[ly] with which x is to be cross-correlated
			lz		length of z array
			ifz		sample index of first z

			Output:
			z		array[lz] containing x cross-correlated with y
			*****************************************************************************/
			int itr=0;
			++itr;
			xcor(ncorr,imincorr,tr.dat.data,
				ncorr,imincorr,tr.dat.data,
				abs(imaxlag),0,autocorr);
			if(autocorr[0]==0.0)
			{
				if ( bh.format==1) {
					float_to_ibm((int *) tr.dat.data, (int *) tr.dat.data, (int)numsamp);
				}
				file2.Write(&tr, len);
				continue;
			}

			// Whiten
			autocorr[0]*=1.0f+pnoise;

			// Get inverse filter by Wiener-Levison
			/*****************************************************************************
			void stoepf (int n, float r[], float g[], float f[], float a[])
			Solve a symmetric Toeplitz linear system of equations Rf=g for f
			(float version) 
			******************************************************************************
			Input:
			n		dimension of system
			r		array[n] of top row of Toeplitz matrix
			g		array[n] of right-hand-side column vector

			Output:
			f		array[n] of solution (left-hand-side) column vector
			a		array[n] of solution to Ra=v (Claerbout, FGDP, p. 57)
			******************************************************************************
			Notes:
			This routine does NOT solve the case when the main diagonal is zero, it
			just silently returns.

			The left column of the Toeplitz matrix is assumed to be equal to the top
			row (as specified in r); i.e., the Toeplitz matrix is assumed symmetric.
			******************************************************************************
			Author:  Dave Hale, Colorado School of Mines, 06/02/89
			*****************************************************************************/
			//float *crosscorr = autocorr + iminlag; // Set pointer to "cross" correlation
			//stoepf(nlag,autocorr,crosscorr,wiener,spiker);
			stoepf(nlag,autocorr,&autocorr[iminlag],wiener,spiker);


			/* Convolve pefilter with trace - don't do zero multiplies */
			float sum;
			int n;
			for (i = 0; i < numsamp; ++i) 
			{
				n = MIN(i, imaxlag); 
				sum = tr.dat.data[i];
				for (j = iminlag; j < n; ++j)
					sum -= wiener[j-iminlag] * tr.dat.data[i-j];
				out_tr.dat.data[i] = sum;
			}

			/* Output filtered trace */
			if ( bh.format==1) {
				float_to_ibm((int *) out_tr.dat.data, (int *) out_tr.dat.data, (int)numsamp);
			}
			memcpy( (void *) &out_tr, (const void *) &tr, 240);
			//memcpy((void *)&out_tr.unass,(const void *) &tr.unass,30);
			file2.Write(&out_tr, len);
		} // while file.Read

		// must free the dynamic arrays
		free1float (wiener);
		free1float (spiker);
		free1float (autocorr);
		// &crosscorr  is just a pointer, not an array itself, so cannot free it
		//  free1float (crosscorr);

		file.Close();
		file2.Close();

		tStr.Format(_T("Finished decon"));
		myCaption(tStr);

		draw.timeSecName = outFile;
		// draw.timeSecOld = _T("");
		OnToolbarRefreshAll();


	}

	void CSeisWideDoc::OnDigitizingResizeSegments() 
	{
		// resize digitized line-drawings horizontally. Not very useful.

		// TODO: Add your command handler code here
		if (!draw.isDigitizing) {
			AfxMessageBox(_T("Line drawings can only be modified in Digitizing mode."));
			return;
		}
		if (dig.isZeltFormat2) {
			AfxMessageBox(_T("Only line drawing segments can be horizontally widened here."));
			return;
		}

		float ratio=2.f;
		CdlgDigResize dlg;
		long i,j;
		if (dlg.DoModal() == IDOK) 
		{
			ratio = dlg.m_ratioResize;
		}
		else return;

		//	if (ratio< 1.f) {
		//		AfxMessageBox(_T("Ratio must be >= 1");
		//		return;
		//	}
		//
		dig.totCurve = dig.iCurveSel+1;
		for (i=0; i<dig.totCurve; i++)
		{
			// first calculate the center x point
			float xmean = 0.f;
			for (j=0; j<dig.nPoint[i]; j++)
			{
				xmean += dig.x[j][i];
			}
			if (dig.nPoint[i]>0) {
				xmean /= dig.nPoint[i];
				for (j=0; j<dig.nPoint[i]; j++)
				{
					dig.x[j][i] += (dig.x[j][i]-xmean)*(ratio-1.f);
				}
			}
		}
		CDigitize pDg;
		pDg.myDigSaveAs(&dig, dig.isSorted, dig.isSortedY, tx.xShot); 
		draw.isSameDataDisplay = FALSE;
		UpdateAllViews(NULL);
		NotifyChanged();


	}
	void CSeisWideDoc::freeDigAll() 
	{
		CDigitize pDg;
		pDg.freeDigAll(&dig);
	}



	void CSeisWideDoc::freeRaypathsAll()
	{
		freeRaypathsAll(&raypaths);
		freeRaypathsAll(&this->raypathsTwtt);
	}

	void CSeisWideDoc::freeRaypathsAll(RAYPATHS *raypaths2)
	{
		if (raypaths2 && raypaths2->totCurve>0) {
			if (raypaths2->npts != NULL) free1int(raypaths2->npts);
			if (raypaths2->irrcol != NULL) free1int(raypaths2->irrcol);
			if (raypaths2->xr != NULL) free2float(raypaths2->xr);
			if (raypaths2->zr != NULL) free2float(raypaths2->zr);
			//if (raypaths2->xrClipCached != NULL) free2double(raypaths2->xrClipCached);
			//if (raypaths2->zrClipCached != NULL) free2double(raypaths2->zrClipCached);
		}

		raypaths2->npts = NULL;
		raypaths2->irrcol = NULL;
		raypaths2->xr = NULL;
		raypaths2->zr = NULL;
		//raypaths2->xrClipCached = NULL;
		//raypaths2->zrClipCached = NULL;

	}

	void CSeisWideDoc::freeModelArrayEx()
	{
		// this is for extra information inside the VELMOD struct
		free1int (velMod.npArray);
		free2float (velMod.xArray);
		free2float (velMod.tArray);

		velMod.npArray = NULL;
		velMod.xArray = NULL;
		velMod.tArray = NULL;
	}

	void CSeisWideDoc::velModSetArrays() {
		if (!isVelModValid()) {
			CVelMod vm;
			vm.velModSetArrays(&velMod);
		}
	}










	BOOL CSeisWideDoc::initAmpColorArray(int num)
	{
		freeAmpColorArray(); // free whatever arrays if they exist
		ampColorDyn.r = (int *)ealloc1int(num);
		ampColorDyn.g = (int *)ealloc1int(num);
		ampColorDyn.b = (int *)ealloc1int(num);
		ampColorDyn.percentAmp = (float *)ealloc1int(num);

		return TRUE;
	}
	void CSeisWideDoc::freeAmpColorArray()
	{
		if (ampColorDyn.r != NULL) free1int(ampColorDyn.r);
		if (ampColorDyn.g != NULL) free1int(ampColorDyn.g);
		if (ampColorDyn.b != NULL) free1int(ampColorDyn.b);
		if (ampColorDyn.percentAmp != NULL) free1float(ampColorDyn.percentAmp);
		ampColorDyn.r = NULL;
		ampColorDyn.g = NULL;
		ampColorDyn.b = NULL;
		ampColorDyn.percentAmp = NULL;
	}


	BOOL CSeisWideDoc::getLineColorArray()
	{
		CString tStr;
		if (!isFileExistNotDirectory(dig.digName)) return FALSE;

		if (lineColors.NUM_LINECOLORS != 11) {
			// this would be a case against my convention here. So we just set to constant green
			for (int i = 0; i<lineColors.NUM_LINECOLORS ; i++) {
				lineColors.r[i] = 0;
				lineColors.g[i] = 255;
				lineColors.b[i] = 0;
			}
			return TRUE;
		}


		CString lineColFileName = GetPathFromFileSlash(dig.digName) + _T("linePalette.txt");
		if (!isFileExistNotDirectory(lineColFileName)) {

			// the color index must be lineColors.NUM_LINECOLORS == 11
			//static const int col_r[11] = {255,255, 255, 127,   0,   0,   0,   0,   0, 127, 255};
			//static const int col_g[11] = {000,127, 255, 255, 255, 255, 255, 127,   0,   0,   0};
			//static const int col_b[11] = {000,  0,   0,   0,   0, 127, 255, 255, 255, 255, 255};

			// since we have too many lines in red, so we want to make the first line to be green
			static const int col_r[11] = {0,   127, 255, 255,   200, 127, 255,  0,   0, 127, 255};
			static const int col_g[11] = {255, 255, 255, 127,   10,  255, 255, 127,  0,   0,   0};
			static const int col_b[11] = {000,  0,   0,   0,    10,  127, 255, 255, 255, 255, 255};
			memcpy(lineColors.r, col_r, sizeof(int)*11);
			memcpy(lineColors.g, col_g, sizeof(int)*11);
			memcpy(lineColors.b, col_b, sizeof(int)*11);

			// now save
			CStringArray 	*arr = new CStringArray();
			tStr.Format(_T("#Color index file applied to the same directory as line drawings file."));	
			arr->Add(tStr);
			tStr.Format(_T("#If more lines exist than colors, repeat colors will be used."));
			arr->Add(tStr);
			tStr.Format(_T("#r      g     b    (You may manually edit these texts.)"));
			arr->Add(tStr);

			for (int i = 0; i<11; i++) {
				tStr.Format(_T("%3d  %3d  %3d"), lineColors.r[i], lineColors.g[i], lineColors.b[i]);
				arr->Add(tStr);
			}
			BOOL isTrue = saveStringArrayToFile(arr, lineColFileName);
			arr->RemoveAll();
			delete arr;

			static CString strPrompt = _T("linePalette.txt not existing in dir; use default");
			myCaption(strPrompt);
			strPrompt = _T("");
			return TRUE;
		}

		CStringArray *arr = getLinesFromFile(lineColFileName);
		int j;
		if (arr != NULL && arr->GetSize() > 0) {
			for (int i = 0; i<lineColors.NUM_LINECOLORS ; i++) {
				j = i;
				while (j >= arr->GetSize())  
					j -= arr->GetSize();
				if (j<0) break;  // this cannot happen
				_stscanf_s(arr->ElementAt(j).Trim(),_T("%d%d%d"),&lineColors.r[i], &lineColors.g[i], &lineColors.b[i]);
				if (lineColors.r[i]==255 && lineColors.g[i]==0 && lineColors.b[i]==0) {
					// since red color is reserved for mouse selection, we do not want any pure red line here
					lineColors.r[i] = 200;
					lineColors.g[i] = 0;
					lineColors.b[i] = 0;
				}
			}
		} else {
			// if here, the file does not exist, we just set the defaults
			for (int i = 0; i<lineColors.NUM_LINECOLORS ; i++) {
				lineColors.r[i] = 0;
				lineColors.g[i] = 255;
				lineColors.b[i] = 0;
			}
		}
		arr->RemoveAll();
		delete arr;
		arr = NULL;
		return TRUE;
	}

	// this is the only function that connects to CdlgSegyColor2 to get the user selected color pallete
	BOOL CSeisWideDoc::getAmpColorArray(CString colFileName, double amax)
	{
		CdlgSegyColor2 color2;
		if (!color2.getAmpColorArray2(colFileName)) return FALSE;

		if (ampColorDyn.num == 0) ampColorDyn.num = 11;
		if (!initAmpColorArray(ampColorDyn.num)) return FALSE;

		//ampColorDyn.num = NUM_SEGY_COLOR;
		for (int i = 0; i<ampColorDyn.num; i++) {
			ampColorDyn.r[i] = color2.ampColorDyn.r[i];
			ampColorDyn.g[i] = color2.ampColorDyn.g[i];
			ampColorDyn.b[i] = color2.ampColorDyn.b[i];
		}

		double fac = ampColorDyn.logScaleThreshold * 0.01;
		double logAmpCut =  fac*logScalingPure(amax);  // if amax=10,000 , logScalingPure(amax)=4
		double ampCut = logScalingInvPure(logAmpCut);  // this way, the ampThreshald can be 100 when amax=10,000

		amax = logScalingPure(amax);
		if (colFileName.GetLength() > 3 &&  colFileName.Find(_T("rms")) < 0) {
			// now convert ampColorDyn.percent[i]  to   real amplitude levels
			ampColorDyn.percentAmp[0] = -(float)amax;
			double rate = amax / (color2.ampColorDyn.percent[5] - color2.ampColorDyn.percent[0]);
			ampColorDyn.percentAmp[1] = -(float)amax + (color2.ampColorDyn.percent[1] - color2.ampColorDyn.percent[0])*(float)rate;
			ampColorDyn.percentAmp[2] = -(float)amax + (color2.ampColorDyn.percent[2] - color2.ampColorDyn.percent[0])*(float)rate;
			ampColorDyn.percentAmp[3] = -(float)amax + (color2.ampColorDyn.percent[3] - color2.ampColorDyn.percent[0])*(float)rate;
			ampColorDyn.percentAmp[4] = -(float)amax + (color2.ampColorDyn.percent[4] - color2.ampColorDyn.percent[0])*(float)rate;
			ampColorDyn.percentAmp[5] = 0.f;

			rate = amax / (color2.ampColorDyn.percent[10] - color2.ampColorDyn.percent[5]);
			ampColorDyn.percentAmp[6] = 0.f + (color2.ampColorDyn.percent[6] - color2.ampColorDyn.percent[5])*(float)rate;
			ampColorDyn.percentAmp[7] = 0.f + (color2.ampColorDyn.percent[7] - color2.ampColorDyn.percent[5])*(float)rate;
			ampColorDyn.percentAmp[8] = 0.f + (color2.ampColorDyn.percent[8] - color2.ampColorDyn.percent[5])*(float)rate;
			ampColorDyn.percentAmp[9] = 0.f + (color2.ampColorDyn.percent[9] - color2.ampColorDyn.percent[5])*(float)rate;
			ampColorDyn.percentAmp[10] = (float)amax;
		} // if
		else {
			for (int i=0; i<ampColorDyn.num; i++) {
				ampColorDyn.percentAmp[i] = (color2.ampColorDyn.percent[i] - color2.ampColorDyn.percent[0]) / 
					(color2.ampColorDyn.percent[ampColorDyn.num-1] -  color2.ampColorDyn.percent[0])* (float)amax;
			} // for i
		}

		for (int i=0; i<ampColorDyn.num; i++) {
			double x = fabs(ampColorDyn.percentAmp[i]);
			if (x < logAmpCut) {
				// use linear 
				ampColorDyn.percentAmp[i] = (float)(  sgn(ampColorDyn.percentAmp[i]) * ampCut * x / logAmpCut  );
			} else {
				ampColorDyn.percentAmp[i] = (float)logScalingInvPure(ampColorDyn.percentAmp[i]);
			}
		} // for i




		delete color2;



		return TRUE;
	}

	BOOL CSeisWideDoc::getAmpColorArray()
	{
		double amax = draw.isAvgEnergy ?  
			head.maxAmp*head.maxAmp  :  head.maxAmp;
		return this->getAmpColorArray(ampColorDyn.colFileName, amax);
	}




	BOOL CSeisWideDoc::initRaypathsArray(int npoint, int ncurve)
	{
		return initRaypathsArray(&raypaths, npoint, ncurve);
	}

	BOOL CSeisWideDoc::initRaypathsArray(RAYPATHS *raypaths2, int npoint, int ncurve)
	{
		if (raypaths2->totCurve > 0) freeRaypathsAll(raypaths2); // this is important for avoiding memory leaks.

		if (ncurve > 10000 || npoint > MIL) return FALSE;  // too much memory is needed curves

		// alocate enough space to work with
		ncurve += 30;
		npoint += 100;
		raypaths2->npts = (int *)ealloc1int(npoint);
		raypaths2->irrcol = (int *)ealloc1int(ncurve);
		raypaths2->xr = (float **)ealloc2float(npoint, ncurve);
		raypaths2->zr = (float **)ealloc2float(npoint, ncurve);
		raypaths2->npts_max = npoint;
		raypaths2->totCurve = ncurve;
		//raypaths2->xrClipCached = (double **)ealloc2double(npoint*2, ncurve);
		//raypaths2->zrClipCached = (double **)ealloc2double(npoint*2, ncurve);
		return TRUE;
	}


	BOOL CSeisWideDoc::initDigitizeArray(int npoint, int ncurve)
	{
		freeDigAll(); // before initialize, we need destroy whatever in there first
		CDigitize pDg;
		return pDg.initDigitizeArray(&dig, npoint, ncurve);
	}






	void CSeisWideDoc::DrawAxes(CDC* pDC, CRect rect)
	{
		// NOTE: leave rect to be non-global, since we may want to draw axes multiple locations in the same window
		CPen* oldPen;
		//int i = (int)myRound((rect.right-rect.left)*0.0004);
		//if (i<2) i=2;
		CPen whitekPen(PS_SOLID, 1, RGB(222,222,221));
		CPen blackPen(PS_SOLID, 1, RGB(0,0,0));

		// Use white border only if seismic is shown in the clipboard
		bool isSeismicShown = 
			(this->isTimeDomain() && !draw.timeSecName.IsEmpty())
			||
			(!this->isTimeDomain() && !draw.depthSecName.IsEmpty())
			;
		if (isSeismicShown && draw.isCopying)
			oldPen = pDC->SelectObject(&whitekPen);  // the background of a segy display is white. If we the border is black, it does not look good. But we do not want to use a white color as well.
		else
			oldPen = pDC->SelectObject(&blackPen);
		CPoint p[5];
		p[0] = CPoint(rect.left, rect.top);
		p[1] = CPoint(rect.right, rect.top);
		p[2] = CPoint(rect.right, rect.bottom);
		p[3] = CPoint(rect.left, rect.bottom);
		p[4] = p[0];
		pDC->Polyline(p, 5);
		pDC->SelectObject(oldPen); 

	}

	//
	//void CSeisWideDoc::WipeDrawingsAll(CDC* pDC, CRect rect)
	//{
	//
	//	// 
	//	pDC->FillSolidRect(rect, RGB(255, 255, 255)); 
	//
	//}

	void CSeisWideDoc::OnEditUndo() 
	{
		CDigitize pDg;

		if (draw.mode==2 || draw.mode==3 || draw.mode==4) {
			// onscreen display of model. Let's undo the editing
			CVelMod vm;
			if (vm.myModelBackup2(&velMod, draw.restoreLevelMax, vel.dz, isTimeDomain()) )

				if (this->myModelRestore()) {
					UpdateAllViews(NULL);
				}
		}
		else if (draw.isDigitizing && dig.nPoint!=NULL) {
			if(dig.iCurveSel>=0 && dig.nPoint[dig.iCurveSel]>0) 
			{
				dig.nPoint[dig.iCurveSel] --;
				myCaption(_T(" Your lastly-digitized point has been removed; Refresh screen to show the removal"));
				pDg.myDigSaveAs(&dig, dig.isSorted, dig.isSortedY, tx.xShot); 
			}
			else if(dig.iCurveSel>0)
			{
				if(AfxMessageBox(_T(" This will delete the last point in the previous curve; Stop? "), MB_YESNO |MB_ICONINFORMATION) == IDNO)
				{
					dig.iCurveSel--;
					dig.totCurve--;
					dig.nPoint[dig.iCurveSel]--;
					pDg.myDigSaveAs(&dig, dig.isSorted, dig.isSortedY, tx.xShot); 
				}
			}
			else myCaption(_T(" No points to undo"));
			draw.isSameDataDisplay = TRUE; //indicate display has been changed and will re-load all data in OnDraw().
		}


	}

	void CSeisWideDoc::OnEditRedo()
	{
		if (draw.mode==2 || draw.mode==3 || draw.mode==4) {
			// onscreen display of model. Let's undo the editing
			//myModelBackup();
			CVelMod vm;
			vm.myModelBackup2(&velMod, draw.restoreLevelMax, vel.dz, isTimeDomain());

			if (this->myModelRestore(FALSE)) {
				UpdateAllViews(NULL);
			}
		}
	}


	BOOL CSeisWideDoc::myModelRestore(BOOL isBackward)
	{
		// this is to restore model for undo. It'll deal with 9 versions. testing
		// not working yet
		CString tStr, aFile;
		//	int i;


		if (isBackward) {
			// draw.restoreLevelCurrent not saved. initialize with -1. 
			// If -1, restore the most recent velocity backup (say level 7), and this number will be 7.
			// the next time of restore (Cntl+Z), it will restore level 6, and the level index will be reduced to 6. 
			if (draw.restoreLevelCurrent < 0) {
				int fBackupIndex=0;
				for (int i=0; i<draw.restoreLevelMax*2; i++) {
					tStr.Format(_T("~%dbin~"), i); 
					aFile = getFileNameTemp(velMod.velSecName, tStr);
					if (!isFileExistNotDirectory(aFile)) {
						fBackupIndex=i;
						// now fBackupIndex is the maximum backup index that is not used. 
						break;
					}
				}
				draw.restoreLevelCurrent = fBackupIndex - 1;
			}
			// now draw.restoreLevelCurrent  should be the restore level for this round.


			tStr.Format(_T("~%dbin~"), draw.restoreLevelCurrent);  
			tStr = getFileNameTemp(velMod.velSecName, tStr);
			if (isFileExistNotDirectory(tStr)) {
				if (CopyFile(tStr, velMod.velSecName, FALSE)) {
					//velMod.velSecOld = _T(""); // this will ask program to reload the model file
					tStr.Format(_T("Restore level %d successful."), draw.restoreLevelCurrent);  
					myCaption(tStr);
					draw.restoreLevelCurrent --;
					return TRUE;
				} // if CopyFile
			} // if
		}
		else {
			if (draw.restoreLevelCurrent >= 0) {
				tStr.Format(_T("~%dbin~"), draw.restoreLevelCurrent+1);  
				tStr = getFileNameTemp(velMod.velSecName, tStr);
				if (isFileExistNotDirectory(tStr)) {
					if (CopyFile(tStr, velMod.velSecName, FALSE)) {
						//velMod.velSecOld = _T(""); // this will ask program to reload the model file
						tStr.Format(_T("Restore level %d successful."), draw.restoreLevelCurrent+1);
						draw.restoreLevelCurrent++;
						myCaption(tStr);
						return TRUE;
					} // if CopyFile
				} // if
			} // if
		} // else

		myCaption(_T("Failed to restore model."));
		return FALSE;
	}



	BOOL CSeisWideDoc::isTimeDomain()
	{
		//if true then in time domain.
		return isTimeDomainUtil(draw.mode);
	}


	// return true if the model is displayed,even if it is not visible
	BOOL CSeisWideDoc::isModelDisplayed()
	{
		//if true then a valid model is displayed on screen, either in depth or time domains.
		// note*******  special case:   draw.mode==9 shows model on scrren but it is in time domain. Any problem with this?
		return (draw.mode==2 || draw.mode==3 || draw.mode==4 || draw.mode == 9) && velMod.ncont>0; 
	}

	BOOL CSeisWideDoc::isModelVisible(CVelMod::VELMOD *velm, double xShift) {
		//if(xShift+velm->xmin >= pCd.coord.xmax || xShift+velm->xmax <= pCd.coord.xmin ||
		//	velm->zmin > pCd.coord.axisY2 || velm->zmax <= pCd.coord.axisY1) return(FALSE);
		if(xShift+velm->xmin >= pCd.coord.xmax || xShift+velm->xmax <= pCd.coord.xmin) return(FALSE);

		return(TRUE);

	}

	void CSeisWideDoc::OnProcessingChangereducevelocityforbmp() 
	{
		return; 

		// This routine converts bitmapped segy data from 1 velocity to another.
		//the bitmap must be properly displayed on screen before continue.
		//	int j;
		int row1,nrow,nrow1, col1,ncol,ncol1;
		BYTE  r, g, b;
		FILE* fou;
		TCHAR * name;
		unsigned char* bmpline;
		float tempf, vredIn, vredOut;
		CString newName;

		if(!CheckTime(100)) {
			return;
		}

		if (draw.mode != 0) {
			AfxMessageBox(_T("This function works in the Distance-Time domain only."));
			return;
		}

		if (bmp24.bmp24Name.IsEmpty()) {
			AfxMessageBox(_T("Please import a bitmap file first."));
			return;
		}
		if (bmp24.isDepth) {
			AfxMessageBox(_T("Please import a bitmap file that is in two-way travel-time."));
			return;
		}

		if (pCd.coord.isFaceUp==1) {
			tempf = bmp24.ymin;
			bmp24.ymin = bmp24.ymax;
			bmp24.ymax = tempf;
		}

		CSize siz = bmp24.bmpDC.GetWindowExt();
		ncol = siz.cx;
		nrow = siz.cy;

		//	CdlgTimDepthBMP dlg;
		CdlgChangeReducingBMP dlg;
		dlg.m_bmpIn = bmp24.bmp24Name;
		dlg.m_bmpOut = bmp24.bmp24Name + _T("Out.bmp");
		dlg.m_col = ncol;
		dlg.m_row = nrow;
		dlg.m_velIn = (float)pCd.coord.vred;
		dlg.m_velOut = 0.f;
		dlg.m_bitSize = (bmp24.biForm == 1)?0:1;
		dlg.m_sourceKm = (float)tx.xShot;
		if(dlg.DoModal() == IDOK)
		{
			bmp24.bmp24Name = dlg.m_bmpIn;
			newName = dlg.m_bmpOut;
			ncol1 = dlg.m_col;
			nrow1 = dlg.m_row;
			vredIn = dlg.m_velOut;
			vredOut = dlg.m_velOut;
			bmp24.biForm = (dlg.m_bitSize==0)? 1:24 ;
			tx.xShot = dlg.m_sourceKm;
		}
		else return;

		delete dlg;

		//now in output, pCd.coord.zmin to pCd.coord.zmax would cover nrow1 pixels.
		//so 1 pixel is (pCd.coord.zmax-pCd.coord.zmin)/(nrow1-1) km.
		double dx = (pCd.coord.xmax-pCd.coord.xmin)/(ncol1-1.0);
		double dz = (pCd.coord.zmax-pCd.coord.zmin)/(nrow1-1.0);
		long nzmin = (int)myRound (pCd.coord.zmin / dz);
		long nzmax = (int)myRound (pCd.coord.zmax / dz);
		COLORREF *colArray; //32-bit color values.

		//Prepare to formulate velocity traces.
		//	long iz;
		colArray = (COLORREF *)malloc(nrow1*ncol1*sizeof(COLORREF));
		if (colArray == NULL)
		{
			AfxMessageBox(_T("Can not allocate memory for bitmap"));
			return;
		}


		//Begin progress control.
		CMainFrame* pFrame = 
			(CMainFrame*)AfxGetMainWnd();
		ASSERT(pFrame);
		ASSERT_KINDOF(CMainFrame, pFrame);
		pFrame->BeginProgress();


		//start writing to file.
		newName = mySetFileExtension(newName, _T("bmp"));

		//generate a new file for holding output bitmap.
		name = newName.GetBuffer(newName.GetLength());
		if (0==(fou = BMP24CreateWriteStream(name, ncol1, nrow1, bmp24.biForm)) ) 
		{
			AfxMessageBox(_T("Unable to generate a new file for output\n"));
			free (colArray);
			return;
		}
		newName.ReleaseBuffer();
		if (0==(bmpline=BMP24CreateLineBuffer(ncol1, bmp24.biForm)) )
		{
			AfxMessageBox(_T("Unable to allocate memory for holding bitmap data"));
			free (colArray);
			return;
		}

		for (row1=0; row1<nrow1; row1++)
		{
			int iPos = (int)((float)row1/(float)nrow1*100.0);
			if(iPos<0)iPos=0;
			if(iPos>100)iPos=100;
			pFrame->SetProgress(iPos);

			for(col1=0; col1<ncol1; col1++)
			{
				if(colArray[row1*ncol1+col1] < 0)
					r=g=b=255;
				else
				{
					r   = (int)GetRValue(colArray[row1*ncol1+col1]);
					g   = (int)GetGValue(colArray[row1*ncol1+col1]);
					b   = (int)GetBValue(colArray[row1*ncol1+col1]);
				}
				BMP24SetRow(bmpline, col1, r, g, b, bmp24.biForm);
			}
			BMP24WriteRow(bmpline, ncol1, fou, bmp24.biForm);
			//	_ftprintf_s(stdout, _T("%s: %d rows total. %3d rows remaining        \r", fnou, nrow, nrow-1-row);
			// fflush(stdout);
		}

		//close bitmap file.
		fclose(fou);
		pFrame->EndProgress();
		free(bmpline);
		free (colArray);
		bmp24.bmp24Name  = newName;
		bmp24.isNeedInitialize = TRUE;
		bmp24.isDepth = TRUE;
		bmp24.xmax = (float)pCd.coord.xmax;
		bmp24.xmin = (float)pCd.coord.xmin;
		bmp24.ymax = (float)pCd.coord.zmax;
		bmp24.ymin = (float)pCd.coord.zmin;

		//Auto change mode to display both.
		//	draw.mode = 3;	//Both velocity contours and depth sections will be drawn.
		//	draw.isNoColorMap = TRUE; //don't let color map overlay bitmap.
		draw.isSameDataDisplay = FALSE; //indicate display has been changed and will re-load all data in OnDraw().

		SetModifiedFlag();
		UpdateAllViews(NULL);
		NotifyChanged();


	}

	double CSeisWideDoc::getXPosAll() {
		double out = ERRORVAL;

		if (isFileExistNotDirectory(draw.timeSecName) )  {
			// if here, the current segy display has a requirement to display only its own xshot
			out = getXShotInSegy(draw.timeSecName);
		}


		if (isXShotDefined((float)out) )  {
			return out;
		}

		if (isFileExistNotDirectory(draw.timeSecName) )  {
			// the segy exists but no valid xshot detected, we should not display any TX curves
			return out;
		}

		// Now the segy does not exist, we just need to take the first available xshot from tx.out 
		CString txPath = getWorkingPathSlash();
		if (!isDirectoryExist(txPath))
			txPath = _T("tx.out");
		else
			txPath += _T("tx.out");
		CString tStr = getLineFirst(txPath).Trim();
		int j = tStr.Find(_T(" "));
		if (j>0) {
			CString tStr2 = tStr.Left(j);
			if (IsNumeric(tStr2)) {
				out = StringToFloat(tStr2);
			}
		}

		// here, if we still failed to get a valid xShot from a segy, we do not want get from rayName file otherwise it is confusing to the user

		return out;
	}

	// SHOULD remove this function??? I think we should!
	//float CSeisWideDoc::getFirstXShotFromTxFile(CString fileTx)
	//{
	//	// this function calc the OBS position from a given ray parameter file.
	//	// it does not use any global variables
	//	// returns the position accurate up to 3 decimal points.
	//	float out = ERRORVAL;
	//	if (isFileExistNotDirectory(fileTx)) {
	//		// we use the xShot parameter as the first choice if it exist
	//		//CStringArray *sArr = new CStringArray();
	//		//if (loadParam(draw.rayName, _T("xshot"), sArr)) {
	//		//	if (sArr->GetCount() > 0) {
	//		//		out = (float)_tstof(sArr->GetAt(0));
	//		//	}
	//		//} // if loadParam
	//		//sArr->RemoveAll();
	//		//delete sArr;
	//	} // if
	//
	//	return out;
	//}


	void CSeisWideDoc::DrawControlsEx(CDC *pDC)
	{
		//return; // testing

		// draws everything else except already drawn by DrawControls() and Tick(), and DrawBitmap()
		// Sometimes, some customzation is required for some small step, then you cannot call this routine.
		CString tStr;
		CString tStr2 = _T("");
		
		setCurrentDirectoryAs(getWorkingPathSlash());
		
		DrawMarkers(pDC);
		showDigLineDraw(pDC);

		if (!bmp24.bmp24Name.IsEmpty()) {
			DrawBitmap(pDC);
		}

		if (draw.mode == 9) {
			DrawRayPathTwtt(pDC);
			DrawVelocityTwtt(pDC);
		} else if (isTimeDomain()) {
			myShowTravelTime(pDC, NULL);
		} else {
			// depth domain
			if (!bmp24.bmp24Name.IsEmpty()) DrawVel(pDC, TRUE); // this redraw is for boundary only after BMP overlay
			myShowFloatReflectors(pDC);
			DrawRayPath(pDC); // it will return if not showing raypath


			DrawVelocityLabelDepth(pDC, &velMod, tx.xShot);
			DrawVelocityTheoreticalDepth(pDC, &velMod);
			if (draw.velSecNamesEx.GetLength()>0) {
				draw.velSecNamesEx.Replace(_T(",\n"), _T("\r\n"));
				draw.velSecNamesEx.Replace(_T(",\r\n"), _T("\r\n"));
				draw.velSecNamesEx.Replace(_T(","), _T("\r\n"));
				CStringArray arr;
				int nElementCount = SplitString(draw.velSecNamesEx, _T("\r\n"), arr);

				CPen greenPen(PS_SOLID, 0, RGB(0,0,255));
				CVelMod::VELMOD velm;
				CVelMod vm;
				for (int i=0; i<arr.GetCount()-1; i++) {
					// example:  80, 115, G:\arcticSBs\sb2007\sb21\model0721New.bin
					double xShift = 0.;
					double xpos = -99999.;
					if (IsNumeric(arr.ElementAt(i).Trim())) {
						xShift = StringToFloat(arr.ElementAt(i).Trim());
						i++;
					}
					if (IsNumeric(arr.ElementAt(i).Trim())) {
						xpos = StringToFloat(arr.ElementAt(i).Trim());
						i++;
					}
					
					tStr = arr.ElementAt(i).Trim();
					if (!IsNumeric(tStr) && isFileExistNotDirectory(tStr) && GetBaseFileName(tStr)!=GetBaseFileName(velMod.velSecName)) {
						// this is a vel model
						vm.velModSetArrays(&velm);
						velm.velSecName = tStr;
						if (vm.loadInitVel(&velm, velm.velSecName, vel.dz)) {
							DrawVelocityDepth(pDC, &velm, TRUE, TRUE, xShift, &greenPen);
							DrawVelocityLabelDepth(pDC, &velm, xpos, xShift);
						}
						vm.velModFreeArrays(&velm);
					}
				}

				arr.RemoveAll();
			} // if (draw.velSecNamesEx.GetLength()>0
		}

	}


	BOOL CSeisWideDoc::myCreateTempDC(CDC *pDCfrom, CDC *pDCto, CRect rectPixel, CRect rectLogical)
	{
		// note: rectPixel is in the pixels
		// rectLogical is the user coords to be mapped into rect1 pixels. Not in km/sec but int only

		BOOL trueFalse = pDCto->CreateCompatibleDC(pDCfrom);
		if (!trueFalse) return FALSE;

		CBitmap m_bmp; //deleted every time a routine has finished using it.
		trueFalse = m_bmp.CreateCompatibleBitmap(pDCfrom, rectPixel.right, rectPixel.bottom);
		pDCto->SelectObject(&m_bmp);
		pDCto->SetMapMode(MM_ANISOTROPIC);
		pDCto->SetViewportExt(rectPixel.right, rectPixel.bottom);
		pDCto->SetWindowExt(rectLogical.right, rectLogical.bottom);	 //for rectClient, logical, himetric coords.
		pDCto->SetBkMode(TRANSPARENT); //to avoid texts overlap each other.
		CBrush brBackground(::GetSysColor(COLOR_WINDOW));
		pDCto->FillRect(rectLogical, &brBackground);
		m_bmp.DeleteObject();
		return TRUE;
	}


	int                                /*   1=inside, 0=outside                */
		inpoly(                            /* is target point inside a 2D polygon? */
		//	   unsigned int poly[][2],            /*   polygon points, [0]=x, [1]=y       */
		float **digx,				/* dig.x[][0] is the x points in polygon */
		float **digt,				/* dig.t[][0] is the y points in polygon */
		int npoints,                       /*   number of points in polygon        */
		float xt,                   /*   x (horizontal) of target point     */
		float yt)                   /*   y (vertical) of target point       */
	{
		float xnew,ynew;
		float xold,yold;
		float x1,y1;
		float x2,y2;
		int i;
		int inside=0;

		if (npoints < 3) {
			return(0);
		}
		xold=digx[npoints-1][0];
		yold=digt[npoints-1][0];
		for (i=0 ; i < npoints ; i++) {
			xnew=digx[i][0];
			ynew=digt[i][0];
			if (xnew > xold) {
				x1=xold;
				x2=xnew;
				y1=yold;
				y2=ynew;
			}
			else {
				x1=xnew;
				x2=xold;
				y1=ynew;
				y2=yold;
			}
			if ((xnew < xt) == (xt <= xold)          /* edge "open" at one end */
				&& (yt-y1)*(x2-x1) < (y2-y1)*(xt-x1)) {
					inside=!inside;
			}
			xold=xnew;
			yold=ynew;
		}
		return(inside);
	}

	void CSeisWideDoc::OnProcessingChopdata() 
	{
		// added by Deping on Oct 26, 2004
		//	if(draw.mode != 0 && draw.mode != 7)
		if (!isTimeDomain())
		{
			AfxMessageBox(_T("This function will chop time domain segy data based on digitized polygon."));
			return;
		}
		if(dig.digName.IsEmpty())
		{
			AfxMessageBox(_T("Please digitize with 1-2 segments forming a closed polygon, and try again to chop the segy data."));
			return;
		}


		CString outFile=_T("");

		// we need to determine which segy file to use for chopping
		CString inFile = (isTimeDomain() && draw.mode==10)  ?   draw.depthSecName  :   draw.timeSecName;
		outFile = getFileNameAppend(inFile, _T("_Chop"));

		CdlgInOut dlg;
		dlg.m_inFile = inFile;
		dlg.m_outFile = outFile; 
		if (dlg.DoModal() == IDOK)
		{
			inFile = dlg.m_inFile;
			outFile = dlg.m_outFile;
		}
		else 
		{
			return;
		}

		if (!isFileExistNotDirectory(inFile)) return;
		if(outFile==_T("")) return;
		if(outFile == inFile)
		{
			AfxMessageBox(_T("Output file name is the same as the input file name!"));
			return;
		}


		bool iKeepBelow = true;
		if (dig.totCurve == 1) {
			if(AfxMessageBox(_T("Do you want to chop above the curve? Click No for chopping below the curve instead."), MB_YESNO|MB_ICONQUESTION)!=IDYES) {
				iKeepBelow = false;
			}
		}
		else if (dig.totCurve == 2) {
			if(AfxMessageBox(_T("Will chop any points outside the area defined by the 2 digitized curves. Continue?"), MB_YESNO|MB_ICONQUESTION)!=IDYES) {
				return;
			}
		}
		else return;




		//put the path onto file2 if it doesn't have it.
		int pathLen = outFile.ReverseFind( '\\' );
		if(pathLen==(-1))
		{
			TCHAR curDir[_MAX_PATH];
			GetCurrentDirectory(_MAX_PATH, curDir);
			// outFile = (CString)curDir + _T("\\" + outFile;
			outFile.Format(_T("%s\\%s"), (CString)curDir, outFile);
		}

		// Now start chopping seismic data
		// output segy file: outFile
		// area to retain after chop: 
		CFile file;
		if (!file.Open(inFile, CFile::modeRead | CFile::typeBinary)) {
			return;
		}

		segy tr, tr2;
		bhed bh;
		int i, j;

		//unsigned short *i2buf;
		//i2buf = (unsigned short *) &tr;
		//float *trcdat;
		//trcdat = (float *) &i2buf[120];

		//unsigned short *i2short;
		//i2short = (unsigned short *) &i2buf[120];
		//int *i2int;
		//i2int = (int *) &i2buf[60];



		//For progress control, need to know the last bytes no.
		ULONGLONG curBytesRead, totBytesRead = file.GetLength();
		file.Seek(0, CFile::begin);
		//Begin progress control.
		CMainFrame* pFrame = 
			(CMainFrame*)AfxGetMainWnd();
		ASSERT(pFrame);
		ASSERT_KINDOF(CMainFrame, pFrame);
		pFrame->BeginProgress();


		UINT bytesRead = file.Read(head.ascHead, 3200L);
		if(bytesRead < 3200) 
			AfxMessageBox(_T("Ascii section header read wrong"));
		bytesRead=file.Read(&bh, 400L);
		if(bytesRead < 400) 
			AfxMessageBox(_T("Binary section header read wrong"));

		//if(bh.format!=1 && bh.format>3 ) {
		// AfxMessageBox(_T("Data is Fixed Point w/ Gain Code, not supported, or unknown format."));
		// if (file) file.Close();
		// return;
		//}
		int numsamp = bh.hns; // (unsigned short)i2buf[10];
		int len;
		if(bh.format !=3)  {
			len = numsamp*4 + 240;
		} else  {
			len = numsamp*2 + 240;
		}


		CFile file2;
		if (!file2.Open(outFile, CFile::modeWrite|CFile::modeCreate|CFile::typeBinary)) {
			file.Close();
			return;
		}

		file2.Write(head.ascHead, 3200L); 
		int formatIn = bh.format;
		// bh.format = 1;  // always output in floating format
		bh.format = pFrame->gIsIBMFloatSegy2  ?  1  :  5; // only floating is adopted for output
		file2.Write(&bh, 400L); 

		ULONGLONG byteFileEnd = file.SeekToEnd();
		file.Seek(3600L, CFile::begin);


		double aratio = (double) bh.hdt /(double)MIL;
		while (file.Read(&tr, len) == (UINT)len)
		{
			if(formatIn == 1 ) {	
				// float data
				ibm_to_float((int *) tr.dat.data, (int *) tr.dat.data, (int)numsamp);
				for (i=0; i<numsamp; i++){
					tr2.dat.data[i]=(float)(tr.dat.data[i]); 
				}
			} else if(formatIn  == 2) {
				for (i=0; i<numsamp; i++) {
					// tr2.dat.data[i] = (float)(i2int[i]);
					tr2.dat.data[i] = (float)(tr.dat.dataint[i]);
				}
			} else if(formatIn  == 3) {	
				// short int data
				for (i=0; i<numsamp; i++) {					 
					tr2.dat.data[i]=(float)(tr.dat.datashort[i]); 
				}
			} else if(formatIn == 5 ) {	
				// float data
				for (i=0; i<numsamp; i++){
					tr2.dat.data[i]=(float)(tr.dat.data[i]); 
				}
			}

			// ****************now do the chopping
			float xpos = (draw.mode == 6) ?  tr.tracl  :  getDistance(&tr);
			float tShift = getTraceDelay(&tr);

			for (i=0; i<numsamp; i++)
			{
				float ypos = (float)(i*aratio + tShift);
				// now need to decide if the point (xpos, ypos) is inside the area defined by struct dig
				// if outside, then set tr2.dat.data[] to zero.
				//if (inpoly(dig.x, dig.t, dig.nPoint[0], (float)xpos, (float)ypos) != iKeepInside) 
				// tr2.dat.data[i] = 0.0;

				// ypos += this->getReduceTime( getOffset(&tr) );	   //Apply reduction velocity.
				//      do not apply reducing velocity, because the data itself do not have that!!!


				float tTop = -1.f;
				int iCurve = 0;  // top curve
				if (xpos >= dig.x[0][iCurve] && xpos <= dig.x[ dig.nPoint[0]-1 ][iCurve]) {
					for (j=0; j<dig.nPoint[iCurve]-1; j++) {
						if (xpos >= dig.x[j][iCurve] && xpos <= dig.x[j+1][iCurve]) {
							float dx = dig.x[j+1][iCurve] - dig.x[j][iCurve];
							tTop = (dx > 0.00001f) ?  (dig.t[j][iCurve] + (dig.t[j+1][iCurve] - dig.t[j][iCurve])/dx * (xpos - dig.x[j][iCurve]))   :   dig.t[j][iCurve];
							break;
						} // if
					} // for j
				} // if


				// note: tTop is absolute time without reducing
				if (tTop>= 0.f) {
					if (iKeepBelow && ypos<tTop) {
						tr2.dat.data[i] = 0.0f;
						continue;
					}
					else if (!iKeepBelow && ypos>tTop) {
						tr2.dat.data[i] = 0.0f;
						continue;
					}
				}
				else {
					tr2.dat.data[i] = 0.0f;
					continue;
				}

				if (dig.totCurve < 2) continue;  // only 1 curve

				float tBot = -1.f;
				iCurve = 1;  // bottom curve
				if (xpos >= dig.x[0][iCurve] && xpos <= dig.x[ dig.nPoint[iCurve]-1 ][iCurve]) {
					for (j=0; j<dig.nPoint[iCurve]-1; j++) {
						if (xpos >= dig.x[j][iCurve] && xpos <= dig.x[j+1][iCurve]) {
							float dx = dig.x[j+1][iCurve] - dig.x[j][iCurve];
							tBot = (dx > 0.00001f) ?  (dig.t[j][iCurve] + (dig.t[j+1][iCurve] - dig.t[j][iCurve])/dx * (xpos - dig.x[j][iCurve]))   :   dig.t[j][iCurve];
							break;
						} // if
					} // for j
				} // if


				if (tBot<0 || (tBot>=0 && ypos>tBot) ) {
					tr2.dat.data[i] = 0.0f;
				}
			} // for i



			// ****************end of chopping

			tr.ns = numsamp;
			if ( bh.format==1 ) {
				float_to_ibm((int *) tr2.dat.data, (int *) tr2.dat.data, (int)tr.ns);
			}
			file2.Write(&tr, 240);
			file2.Write(&tr2.dat.data, numsamp*4);

			// progress control. Do not change
			curBytesRead = file.Seek(0, CFile::current);
			int iPos = (int)((double)curBytesRead/(double)totBytesRead*100.);
			if(iPos<0)iPos=0;
			if(iPos>100)iPos=100;
			pFrame->SetProgress(iPos);
		}	// while


		if (file) file.Close();
		if (file2) file2.Close();
		if (pFrame) pFrame->EndProgress();

		// draw.timeSecName = outFile;

		AfxMessageBox(_T("Chopped file is output as ") + outFile);

		//draw.isSameDataDisplay = FALSE;
		//UpdateAllViews(NULL);
		//NotifyChanged();

	}


#include "CSpreadSheet.h"

	int CSeisWideDoc::setShotsFromCoherency(CStringArray *sarray, 
		int *filej, 
		int *shotk, float *shotDist, 
		int numShotIn, int numShotOut, 
		int iwin1, int iwin2, 
		int itauHalf, int itauInc, 
		float freq1, float freq2, 
		float distMaxPreferred)
	{
		// this routine has not considered IBM floating point issue?????!!!!!

		// now we have too (~100) many traces: numShotIn traces as indicated in the arrays filej[] and shotk[].
		// we need to reduce it to numShotOut traces to stack, based on the maximum coherent traces
		// in a small time window [iwin1, iwin2]
		// the results will be stored in the first numShotOut values in the arrays sarray[], filej[], shotk[]

		// the actual number of traces will be returned!
		if (numShotIn<1) return 0;
		if (numShotIn<=numShotOut) numShotOut = numShotIn;
		if (numShotOut==1) return 1; // no need to bother with 1 trace only to process
		if (iwin1<0) iwin1=0;
		int lenWin = iwin2 - iwin1 + 1;
		float **trSegy = (float **)ealloc2float(lenWin,numShotIn); 
		memset((void *)trSegy[0],(int) '\0',sizeof(float)*lenWin*numShotIn); 
		float *trEnergy = (float *)ealloc1float(numShotIn); 

		// now loop through the same loops
		int aj, ii, i, j, k;
		for(aj = 0; aj < numShotIn; aj++)
		{
			j = filej[aj];
			k = shotk[aj];

			// found a trace to sum for trace i. 
			CString aName = sarray->GetAt(j);
			aName.Replace(_T(".xls"), _T(".SG0")); // aName is now the segy file to sum
			if (!isFileExistNotDirectory(aName)) continue;

			// segy file exist and we need to grab its related trace
			CFile file;
			if (!file.Open(aName, CFile::modeRead | CFile::typeBinary)) {
				continue;
			}
			file.Seek(3200L, CFile::begin);
			bhed bh;
			file.Read(&bh, 400);
			int tpp = bh.hdt;
			int sampByte = (bh.format != 3) ?  4  :  2;
			int lenByte = bh.hns*sampByte;


			// now search for trace number k for segy aName 
			if (file.Seek(k*lenByte+3600L+iwin1*sizeof(float), CFile::begin) < 0) continue;


			// now trace number k is found
			if (file.Read(&trSegy[aj][0], lenWin*sizeof(float)) == (UINT)lenWin*sizeof(float)) {
				// first, convert from big endian to small endian
				for (ii=0; ii<lenWin; ii++)
					Swap((float *)&trSegy[aj][ii]);


				filterTimeDomain(&trSegy[aj][0], lenWin, freq1, freq2, tpp);


				// always normalize to a median of 1.0 for proper calculation
				double aMedian = getMedianAbsolute(&trSegy[aj][0], lenWin);
				if (aMedian>MINAMP) {
					aMedian = (1./aMedian);
					for (ii=0; ii<lenWin; ii++) {
						trSegy[aj][ii] *= (float)aMedian;
					}
				}
			} // if (file.Read(&tr

			file.Close();

			trEnergy[aj] = 0.f;
			for (ii=0; ii<lenWin; ii++) {
				trEnergy[aj] += trSegy[aj][ii] * trSegy[aj][ii];
			}
		} // for aj

		// now start calc semblence
		float **semb = (float **)ealloc2float(numShotIn,numShotIn); 
		for(i = 0; i < numShotIn; i++) {
			semb[i][i] = 2.f;  // center value in the matrix shall not be used
			for (j=0; j<i; j++) {
				semb[i][j] = semb[j][i];
			}
			for (j=i+1; j<numShotIn; j++) {
				// given trace i, and need to computer its maximum semblence with trace j --> semb[i][j]
				//    note that we allow a static shift itau that ranges in a small window [iwin1, iwin2]
				semb[i][j] = 0.f;

				// nom = (a1+b1)**2 + (a2+b2)**2 + (a3+b3)**2 + (a4+b4)**2;
				// denom = (a1**2+b1**2 + a2**2+b2**2 + a3**2+b3**2 + a4**2+b4**2) / 2;
				double denom = trEnergy[i] + trEnergy[j];
				if (denom>MINAMP) {
					// loop through the itau
					double sumMax = 0.;
					for (int itau=-itauHalf; itau<=itauHalf; itau++) {
						double nom = 0.;
						for (int iwin=0; iwin<lenWin; iwin++) {
							int jwin = itau+iwin;
							if (jwin>=0 && jwin<lenWin) {
								double a = trSegy[i][iwin] + trSegy[j][jwin];
								nom += a*a;
							}
						}
						if (sumMax < nom) sumMax = nom;
						itau += (itauInc -1);
					} // itau
					semb[i][j] = (float)(sumMax / denom);
				} // if denom
			} // for j
		} // for i
		free2float (trSegy );
		free1float (trEnergy);


		// now, from numShotIn traces, we need to sort out only numShotOut traces, 
		// and put them into the first numShotOut elements in the 3 input arrays

		// first find out "popularity" of each trace relative to all its nabours
		float *semb2 = (float *)ealloc1float(numShotIn);
		for(i = 0; i <numShotIn; i++)
		{
			semb2[i] = 0.f;
			for (j=0; j<numShotIn; j++) {
				if (j!=i)
					semb2[i] += semb[i][j];
			}
		}
		free2float (semb); // 2D array semb is no use any more

		// search for only numShotOut maximum semblence and store the indice in index2[]
		int *index2 = (int *)ealloc1int(numShotOut);
		int *filej2 = (int *)ealloc1int(numShotOut);
		int *shotk2 = (int *)ealloc1int(numShotOut);
		float *shotDist2 = (float *)ealloc1float(numShotOut);



		// note: numShotOut only if there are more than 1 traces matching, we select the traces
		//  with a maximum distance of distMaxPreferred. Another limit is <=numShotOut traces are needed


		// first, determine how many maximum traces to output
		// note: shotDist[]  is already distance in meters squared
		distMaxPreferred *= distMaxPreferred;
		int numOfPreferred = 0;
		for(i = 0; i <numShotIn; i++) {
			if (shotDist[i] <= distMaxPreferred) {
				numOfPreferred++;
			}
		}
		if (numOfPreferred<numShotOut) numShotOut = numOfPreferred;
		if (numShotOut<1) numShotOut = 1;


		// now do the assigning
		for(i = 0; i <numShotOut; i++) {
			index2[i] = i;
		}
		for(i = numShotOut; i <numShotIn; i++) {
			for (int ii=0; ii<numShotOut; ii++) {
				int index4Out = index2[ii];
				// weight the semblence according to distance
				// double a = (shotDist[index4Out]+1.)/(shotDist[i]+1.);
				if (shotDist[index4Out]*semb2[i] > shotDist[i]*semb2[index4Out]) {
					index2[ii] = i;
					break;
				}
			}
		}

		for(i = 0; i <numShotOut; i++) {
			filej2[i] = filej[ index2[i] ];
			shotk2[i] = shotk[ index2[i] ];
			shotDist2[i] = shotDist[ index2[i] ];
		}

		for(i = 0; i <numShotOut; i++) {
			filej[i] = filej2[i];
			shotk[i] = shotk2[i];
			shotDist[i] = shotDist2[i];
		}

		free1int(filej2);
		free1int(shotk2);
		free1float(shotDist2);
		free1int(index2);
		free1float (semb2);

		return numShotOut;
	}

	BOOL CSeisWideDoc::DrawStackVelocity(CDC* pDC)
	{
		// this function is just for testing any codes.
		draw.modeOld = draw.mode;
		draw.mode = -1;












		// first define the desired seismic line
		CIniReader iniReader(_T("F:\\data\\cook\\Logger.ini"));
		CString szName = iniReader.ReadString(_T("Setting"), _T("Name"), _T(""));   
		int iAge = iniReader.ReadInteger(_T("Setting"), _T("Age"), 25); 
		float fltHieght = iniReader.ReadFloat(_T("Setting"), _T("Height"), 1.80f); 
		bool bMarriage = iniReader.ReadBoolean(_T("Setting"), _T("Marriage"), true); 
		delete [] szName;  

		const int MAX_SUM = iniReader.ReadInteger(_T("Setting"), _T("MAX_SUM"), 1);
		CString outDir = iniReader.ReadString(_T("Setting"), _T("outDir"), _T("F:\\data\\cook"));
		CString outName = iniReader.ReadString(_T("Setting"), _T("outName"), _T("out1.sgy"));
		const int numShotStack= iniReader.ReadInteger(_T("Setting"), _T("numShotStack"), 12);
		const float distMaxPreferred=iniReader.ReadFloat(_T("Setting"), _T("distMaxPreferred"), 0.4f);

		const float winCoh1=iniReader.ReadFloat(_T("Setting"), _T("winCoh1"), 0.3f);
		const float winCoh2=iniReader.ReadFloat(_T("Setting"), _T("winCoh2"), 1.3f);

		const float twmin=iniReader.ReadFloat(_T("Setting"), _T("twmin"), 2.6f);  // small window for the limeline
		const float twmax=iniReader.ReadFloat(_T("Setting"), _T("twmax"), 2.9f);

		const float tauMax=iniReader.ReadFloat(_T("Setting"), _T("tauMax"), 0.15f); // max window for computing cohency of traces for static shift

		const float freq1=iniReader.ReadFloat(_T("Setting"), _T("freq1"), 10.0f);
		const float freq2=iniReader.ReadFloat(_T("Setting"), _T("freq2"), 90.0f);

		const bool isCoherency = iniReader.ReadBoolean(_T("Setting"), _T("isCoherency"), false);
		const bool isRemoveTimeline = iniReader.ReadBoolean(_T("Setting"), _T("isRemoveTimeline"), false);
		const double distInc = iniReader.ReadFloat(_T("Setting"), _T("distInc"), 100.f);  // every 100 meters we want a trace
		const double distSum = iniReader.ReadFloat(_T("Setting"), _T("distSum"), 2000.f);  // any trace that falls in a 1000 meter circle will be summed

		// hard code the 4 corners
		const double lon1 = iniReader.ReadFloat(_T("Setting"), _T("lon1"), -85.25f);
		const double lon2 = iniReader.ReadFloat(_T("Setting"), _T("lon2"), -79.1985935f);
		const double lat1 = iniReader.ReadFloat(_T("Setting"), _T("lat1"), 83.367f);
		const double lat2 = iniReader.ReadFloat(_T("Setting"), _T("lat2"), 83.7579465f);


		/*
		// my first successful line: shorter, southern part
		double lon1 = -82.6293;
		double lon2 = -79.1985935;
		double lat1 = 83.5314185;
		double lat2 = 83.7579465;
		cart1[0] = -277360.;
		cart2[0] = -228729.; 
		cart1[1] = -665357.;
		cart2[1] = -656874.;
		which is at: 
		(-82.6293, 83.5314185)
		(-79.1985935, 83.7579465)
		*/



		//***********************************************//
		CString newName = outDir + outName;
		newName.Replace(_T(".sgy"), _T("_Nav.txt"));
		FILE *stream;
		if( _tfopen_s(&stream, newName, _T("w") ) != 0 )
		{
			AfxMessageBox( _T("The new file was not opened") );
			return FALSE;
		}

		newName = outDir + outName;
		newName.Replace(_T(".sgy"), _T("_Nav2.txt")); 
		FILE *stream2;
		if( _tfopen_s(&stream2, newName, _T("w") ) != 0 ) return FALSE;

		double *cart1 = convLatlon2XY(lon1,  lat1);
		double *cart2 = convLatlon2XY(lon2,  lat2);
		double distSum2 = distSum*distSum;

		double x1 = cart1[0];
		double x2 = cart2[0]; 
		double y1 = cart1[1];
		double y2 = cart2[1];

		// pre-calculate
		double distTotal = sqrt((x1-x2)*(x1-x2) + (y1-y2)*(y1-y2));
		double dx = distInc / distTotal * (x2 - x1);
		double dy = distInc / distTotal * (y2 - y1);
		int numTotal = (int)((distTotal / distInc) + 1.5);  // 1813 traces


		// calculate an area for stacking, for outputting a rectangle only, no other use
		double dxxPlot = distSum * (y1-y2)/distTotal;
		double dyyPlot = distSum * (x2-x1)/distTotal;


		// put all related file path names in CStringArray
		CStringArray *sarrayRaw = getAllPathArray(outDir);
		CStringArray 	*sarray = new CStringArray();			
		sarray->RemoveAll();		// Not really necessary - Just habit
		int j;
		for(j = 0; j < sarrayRaw->GetSize(); j++) {
			CString aNameExcel = sarrayRaw->GetAt(j);
			aNameExcel.MakeLower();
			if (aNameExcel.Right(4)==_T(".xls")) {
				CString aName = aNameExcel;
				aName.Replace(_T(".xls"), _T(".SG0")); // aName is now the segy file 
				if (isFileExistNotDirectory(aName)) {
					sarray->Add(aNameExcel);
					_ftprintf_s(stream, _T("%s\n"), aNameExcel);
				}
			}

		}
		sarrayRaw->RemoveAll();
		delete sarrayRaw;

		_ftprintf_s(stream, _T("\n\nThe follow lists all existing control points in Cartesion coordinates:\n"));

		// first count how many Excel files
		int numExcel = (int)sarray->GetSize();

		// now convert the lat long inside Segy/XLS files into double arrays.
		// note: there are numExcel files, with each file containing a few coordinates
		int *nShotSegy = (int *)ealloc1int(numExcel);

		// assuming a maximum of MAXSHOT shots in each segy file
		static int MAXSHOT = 1200;
		float **xxSegy = (float **)ealloc2float(MAXSHOT,numExcel); 
		float **yySegy = (float **)ealloc2float(MAXSHOT,numExcel);

		// loop through all files to locate related shots
		CStringArray colTrace;
		CStringArray colLat;
		CStringArray colLon;
		for(j = 0; j < numExcel; j++)
		{
			CString aNameExcel = sarray->GetAt(j);
			// now let's read the XLS file
			CSpreadSheet *SS = new CSpreadSheet(aNameExcel, _T("Sheet1"));
			SS->ReadColumn(colTrace, 1);
			SS->ReadColumn(colLat, 6);
			SS->ReadColumn(colLon, 7);
			delete SS;

			int nShotInExcel = 0; 
			int aNum = (int)colTrace.GetSize();
			int k;
			nShotSegy[j] = -1;
			// the first row is header in Excel
			for(k = 1; k < aNum; k++) {
				if (colTrace.GetAt(k)==_T("")) {
					nShotInExcel = k-1;
					nShotSegy[j] =  _tstoi(colTrace.GetAt(k-1)); // total number of shot for a segy
					break;
				}
			}
			if (nShotSegy[j] < 0) {
				// this means that the Excel collumn does not contain extra blank cells
				nShotSegy[j] = _tstoi(colTrace.GetAt(aNum-1));
				nShotInExcel = aNum-1;
			}
			if (nShotSegy[j] > MAXSHOT) {
				CString tmp;
				tmp.Format(_T("Shot number is large: %d in Excel File: %s"), nShotSegy[j], aNameExcel);
				AfxMessageBox(tmp);
			}

			// local arrays
			int *trcInExcel = (int *)ealloc1int(nShotInExcel);
			float *xxInExcel = (float *)ealloc1float(nShotInExcel);
			float *yyInExcel = (float *)ealloc1float(nShotInExcel);

			for(k = 0; k < nShotInExcel; k++) {
				// CString trc = colTrace.GetAt(k);
				trcInExcel[k] = _tstoi(colTrace.GetAt(k+1));
			}
			// Trace number collumn always has 1 more value (i.e. the last shot number)
			for(k = 0; k < nShotInExcel-1; k++) {
				CString tmp = colLon.GetAt(k+1);
				//	yySegy[j][k-1] = (float)_tstof(colLat.GetAt(k+1));
				double *a = convLatlon2XY(_tstof(colLon.GetAt(k+1)),  _tstof(colLat.GetAt(k+1)));
				xxInExcel[k] = (float)a[0];
				yyInExcel[k] = (float)a[1];
				free(a);
				//	_ftprintf_s(stream, _T("%f %f\n", xxInExcel[k], yyInExcel[k]);
				//	_ftprintf_s(stream2, _T("%s %s\n", colLon.GetAt(k+1), colLat.GetAt(k+1));
			}
			// _ftprintf_s(stream2, _T(">\n");
			if (nShotInExcel < 3) {
				_ftprintf_s(stream, _T("    %s has too little navigation information for a usccessful interpolation\n"), aNameExcel);
			}

			// construct segy trace sequence for the current Excel file, 
			// loop thru each segy trace, starting with 1, increment by 1
			int s;
			for (s=1; s<=nShotSegy[j]; s++) {
				// for each segy trace s, search  where it belongs to a shot in Excel file
				// s exactly corresponds to the actual shot number starting with 1

				if (nShotInExcel < 3) {
					/*
					// note: if k2=nShotInExcel-1, then only trcInExcel[k2] has value, but xxInExcel[k2] will not
					trace	LAT. (DEG)	LONG. (DEG)
					72	    83.615	-81.281
					178						

					for this, nShotInExcel=2
					*/
					xxSegy[j][s-1] = (float)(xxInExcel[0] + 100. *(s - trcInExcel[0]));  // 100 is kind of arbitrary
					yySegy[j][s-1] = (float)(yyInExcel[0] + 100. *(s - trcInExcel[0]));  // 100 is kind of arbitrary
				}
				else {
					/*
					trace	LAT. (DEG)	LONG. (DEG)
					109	    83.451	-84.347				row=0
					253	    83.45	-84.352				row=1
					397		83.45	-84.357				row=2
					541		83.45	-84.35				row=4
					542									row=5
					*/
					int row1 = -1;
					int row2 = 99999;
					if (s==nShotSegy[j]) {
						int aaa = 1;
					}
					for(int row = 0; row < nShotInExcel; row++) {
						if (s<=trcInExcel[row]) {
							if (row==0) {
								row1 = row;
								row2 = row+1;
								// since we have at least 2 rows, row+1 must exist already
							}
							else if (row==nShotInExcel-1) {
								// last row is different
								row1 = row-2;
								row2 = row-1;
							}
							else {
								row1 = row-1;
								row2 = row;
							}
							break;
						}
					}
					if (row1>=0) {
						// found coordinates to interpolate. Note that trace numbers are integers
						// need to cast to double before division
						double avalue = (double)(s - trcInExcel[row1]) /(double)(trcInExcel[row2] - trcInExcel[row1]);
						xxSegy[j][s-1] = (float)(xxInExcel[row1] + avalue*(xxInExcel[row2]-xxInExcel[row1]));
						yySegy[j][s-1] = (float)(yyInExcel[row1] + avalue*(yyInExcel[row2]-yyInExcel[row1]));
					}
				} // else
			} // for s

			// fix since I have found all segy file j has its first and last trace swapped
			int n = nShotSegy[j];
			for (s=0; s<n/2; s++) {
				int s2 = n-s-1;
				float a = xxSegy[j][s];
				xxSegy[j][s] = xxSegy[j][s2];
				xxSegy[j][s2] = a;
				a = yySegy[j][s];
				yySegy[j][s] = yySegy[j][s2];
				yySegy[j][s2] = a;
			} // for s

			free1int(trcInExcel);
			free1float(xxInExcel);
			free1float(yyInExcel);

			// now print out the line positions in the excel file
			_ftprintf_s(stream, _T("%f %f\n"), xxSegy[j][0], yySegy[j][0]);
			_ftprintf_s(stream, _T("%f %f\n"), xxSegy[j][nShotSegy[j]-1], yySegy[j][nShotSegy[j]-1]);


			bool isACloser2FirstShot = true;
			double *c = convLatlon2XY(_tstof(colLon.GetAt(1)),  _tstof(colLat.GetAt(1)));
			double *d = convLatlon2XY(_tstof(colLon.GetAt(nShotInExcel-1)),  _tstof(colLat.GetAt(nShotInExcel-1)));
			if ( (pow(xxSegy[j][0]-c[0], 2)+pow(yySegy[j][0]-c[1], 2)) > (pow(xxSegy[j][0]-d[0], 2)+pow(yySegy[j][0]-d[1], 2))  ) isACloser2FirstShot = false;
			/*
			if (colLon.GetAt(1) == _T("-83.851") {
			int yyyyyy = 1;
			}
			*/
			double *a = convXY2Latlon(xxSegy[j][0],  yySegy[j][0]);
			double *b = convXY2Latlon(xxSegy[j][nShotSegy[j]-1],  yySegy[j][nShotSegy[j]-1]);
			if (isACloser2FirstShot)
				_ftprintf_s(stream2, _T("%f %f %d %s\n"), a[0], a[1], 1, sarray->GetAt(j));
			else
				_ftprintf_s(stream2, _T("%f %f %d %s\n"), b[0], b[1], 1, sarray->GetAt(j));

			for(k = 0; k < nShotInExcel-1; k++) {
				_ftprintf_s(stream2, _T("%s %s\n"), colLon.GetAt(k+1), colLat.GetAt(k+1));
			}

			double ax = xxSegy[j][0] - xxSegy[j][nShotSegy[j]-1];
			double ay = yySegy[j][0] - yySegy[j][nShotSegy[j]-1];
			if (isACloser2FirstShot)
				_ftprintf_s(stream2, _T("%f %f %d %f\n"), b[0], b[1], nShotSegy[j], (float)sqrt(ax*ax+ay*ay)*0.001);
			else
				_ftprintf_s(stream2, _T("%f %f %d %f\n"), a[0], a[1], nShotSegy[j], (float)sqrt(ax*ax+ay*ay)*0.001);
			free(a);
			free(b);
			free(c);
			free(d);
			_ftprintf_s(stream2, _T(">\n"));
			// end print out the line positions in the excel file
		} // j
		colTrace.RemoveAll();
		colLat.RemoveAll();
		colLon.RemoveAll();

		// write the last few lines for the output files
		//	_ftprintf_s(stream, _T("%f %f\n", x1, y1);
		//	_ftprintf_s(stream, _T("%f %f\n", x2, y2);
		//	_ftprintf_s(stream, _T(">\n");
		_ftprintf_s(stream, _T("%f %f\n"), x1+dxxPlot, y1+dyyPlot);
		_ftprintf_s(stream, _T("%f %f\n"), x2+dxxPlot, y2+dyyPlot);
		_ftprintf_s(stream, _T("%f %f\n"), x2-dxxPlot, y2-dyyPlot);
		_ftprintf_s(stream, _T("%f %f\n"), x1-dxxPlot, y1-dyyPlot);
		_ftprintf_s(stream, _T("%f %f\n"), dxxPlot, dyyPlot);
		_ftprintf_s(stream, _T("%f %f\n"), x1+dxxPlot, y1+dyyPlot);
		fclose(stream);
		/*
		double *a = convXY2Latlon(x1,  y1);
		_ftprintf_s(stream2, _T("%f %f\n", a[0], a[1]);
		a = convXY2Latlon(x2,  y2);
		_ftprintf_s(stream2, _T("%f %f\n", a[0], a[1]);
		_ftprintf_s(stream2, _T(">\n");
		*/
		double *a = convXY2Latlon(x1+dxxPlot,  y1+dyyPlot);
		_ftprintf_s(stream2, _T("%f %f\n"), a[0], a[1]);
		a = convXY2Latlon(x2+dxxPlot,  y2+dyyPlot);
		_ftprintf_s(stream2, _T("%f %f\n"), a[0], a[1]);
		free(a);
		a = convXY2Latlon(x2-dxxPlot,  y2-dyyPlot);
		_ftprintf_s(stream2, _T("%f %f\n"), a[0], a[1]);
		free(a);
		a = convXY2Latlon(x1-dxxPlot,  y1-dyyPlot);
		_ftprintf_s(stream2, _T("%f %f\n"), a[0], a[1]);
		free(a);
		a = convXY2Latlon(x1+dxxPlot,  y1+dyyPlot);
		_ftprintf_s(stream2, _T("%f %f\n"), a[0], a[1]);
		free(a);
		_ftprintf_s(stream2, _T(">\n"));


		// now compute the desired shot locations; we use meters as unit
		double *xxOut = (double *)malloc(numTotal*sizeof(double));
		double *yyOut = (double *)malloc(numTotal*sizeof(double));
		xxOut[0] = x1;
		yyOut[0] = y1;

		// define some segy structs
		segy tr, tr2;  // tr2 is for output trace with timeline removed
		// segy tr2Ref, tr2Semb;  // tr2Ref is a reference output trace containing the timeline; 
		// this timeline is useful for calculating static shifts
		bhed bh;
		//short *i2buf, *i2short;
		//int *i2int, *i4int;
		//float *trcdat;
		//i2buf = (short *) &tr;
		//i2short = (short *) &i2buf[120];
		//i2int = (int *) &i2buf[0];
		//i4int = (int *) &i2buf[120];
		//trcdat = (float *) &i2buf[120];

		// for generating an output segy, we grab the section headers from the first input segy
		CString aNameSegyRef = sarray->GetAt(0);
		aNameSegyRef.Replace(_T(".xls"), _T(".SG0")); 
		CFile fileRef(aNameSegyRef, CFile::modeRead|CFile::typeBinary);
		fileRef.Read(head.ascHead, 3200L);
		fileRef.Read(&bh, 400L);
		fileRef.Close();

		// convert from unix format to PC format
		BOOL isUnix;
		if (isUnix = IsUnix(bh.format)) SwapTapeHeader(&bh);
		int numsamp = bh.hns;
		int len = numsamp*sizeof(float) + 240;
		int tpp = bh.hdt; // in micro sec


		// file2 is the output file handler. It must already have existed.
		// This is because we cannot guarantee that the first trace of the output is not blank
		CFile file2;
		if (!file2.Open(outDir + outName, CFile::modeWrite|CFile::modeCreate|CFile::typeBinary)) {
			return FALSE;
		}

		ebc2asc(head.ascHead, 3200);
		file2.Write(head.ascHead, 3200L);
		file2.Write(&bh, 400L);

		// file2.Seek(3600L, CFile::begin);

		//Begin progress control.
		CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
		ASSERT(pFrame);
		ASSERT_KINDOF(CMainFrame, pFrame);
		pFrame->BeginProgress();

		// define a small time window to cut the scale line. The timeline occurs only between
		// 2.5-2.9 sec, slightly floated. The final cut-off width is twdt=0.08  sec
		int itauMax = (int)(tauMax * MIL / tpp  + 0.5);  // maximum static shift, used for coherency mixing window
		int itauMaxHalf = itauMax/2;
		itauMax = itauMaxHalf * 2 +1; // must be an even number
		int itauInc = 2;  // to save CPU time, we do not calculate cohenrncy for every delay
		int itwdt = (int)(0.12 * MIL / tpp  + 0.5); // a small time window to cut the scale line
		int itwmin = (int)(twmin * MIL / tpp  + 0.5);

		int iwinCoh1 = (int)(winCoh1 * MIL / tpp  + 0.5);
		int iwinCoh2 = (int)(winCoh2 * MIL / tpp  + 0.5);


		int itwmax = (int)(twmax * MIL / tpp  + 0.5);
		double ax, ay, adist2, totxweight;
		float *trsqrt = (float *)ealloc1float(numsamp);
		float *tr2sqrt = (float *)ealloc1float(numsamp);
		float **trcorr = (float **)ealloc2float(numsamp, itauMax);


		// store a maximum of 24 shots number as k. Each shot has a excel file numbered as j
		int *filej = (int *)ealloc1int(MAX_SUM);
		int *shotk = (int *)ealloc1int(MAX_SUM);
		float *shotDist = (float *)ealloc1float(MAX_SUM);

		// now loop thru all desired shot points
		CTime time0 = CTime::GetCurrentTime();
		for (int i=1; i<numTotal; i++) {
			// the output trace reset to 0
			_ftprintf_s(stream2, _T("\nTrace %d"), i);
			CTime TimeStart = CTime::GetCurrentTime();
			memset((void *)&tr2,(int) '\0',len); 
			//	memset((void *)&tr2Ref,(int) '\0',len); 
			totxweight = 0.;
			int numSum = 0;

			xxOut[i] = xxOut[i-1] + dx;
			yyOut[i] = yyOut[i-1] + dy;

			// precalculate the arrays
			int numShot2Sum = 0;
			for(int jb = 0; jb < numExcel; jb++)
			{
				// For each Excel file jb, we have a number of shots kb to process
				// look for related traces in a circle of  distSum  to sum up
				// from point (xx[i], yy[i])   to   (xxSegy[j][k], yySegy[j][k])
				for (int kb=0; kb<nShotSegy[jb]-1; kb++) {
					ax = xxOut[i] - xxSegy[jb][kb];
					ay = yyOut[i] - yySegy[jb][kb];
					adist2 = ax*ax+ay*ay;
					if (adist2 < distSum2) {
						// found a trace to sum for trace i. 
						if (numShot2Sum>=MAX_SUM) {
							// now, more than 24 traces fit, but we only need 24 traces to stack.
							// so we choose the closest traces
							setShotsFromDist(&filej[0], &shotk[0], &shotDist[0], numShot2Sum, jb, kb, (float)adist2);
							// after coming to here, numShot2Sum will not increase any more!!!
						}
						else {
							filej[numShot2Sum] = jb;
							shotk[numShot2Sum] = kb;
							shotDist[numShot2Sum] = (float)adist2;
							numShot2Sum++;
						}
					}
				} // k
			} // jb

			if (numShot2Sum>0) {
				// print out the nav
				_ftprintf_s(stream2, _T("\n   Trace %d : total of %d nearby traces:"), i, numShot2Sum);
				for(int cj = 0; cj < numShot2Sum; cj++)
				{
					int j = filej[cj];
					int k = shotk[cj];
					CString aName = sarray->GetAt(j);
					aName.Replace(_T(".xls"), _T(".SG0")); // aName is now the segy file to sum
					if (!isFileExistNotDirectory(aName)) continue;
					a = convXY2Latlon(xxSegy[j][k],  yySegy[j][k]);
					_ftprintf_s(stream2, _T("\n   %f %f "), a[0], a[1]);
					free(a);
					_ftprintf_s(stream2, _T(" %d %d %f %s"), i, k, (float)sqrt(shotDist[cj]), aName);
				}


				// now we have too (~100) many traces: numShot2Sum traces as indicated in the arrays filej[] and shotk[].
				// we need to reduce it to ~12 traces to stack, based on the maximum coherent traces
				int numReturned = setShotsFromCoherency(sarray, &filej[0], &shotk[0], &shotDist[0], numShot2Sum, numShotStack, iwinCoh1, iwinCoh2, itauMaxHalf, itauInc, freq1, freq2, distMaxPreferred);


				// now loop through the same loops
				_ftprintf_s(stream2, _T("\n Trace %d : total of %d stacked traces (Long Lat Trc TrcExcel DistInMeter NameSgyRaw):"), i, numReturned);
				for(int aj = 0; aj < numReturned; aj++)
				{
					int j = filej[aj];
					int k = shotk[aj];

					// found a trace to sum for trace i. 
					CString aName = sarray->GetAt(j);
					aName.Replace(_T(".xls"), _T(".SG0")); // aName is now the segy file to sum
					if (!isFileExistNotDirectory(aName)) continue;

					// print out the nav
					a = convXY2Latlon(xxSegy[j][k],  yySegy[j][k]);
					_ftprintf_s(stream2, _T("\n %f %f "), a[0], a[1]);
					free(a);
					_ftprintf_s(stream2, _T(" %d %d %f %s"), i, k, (float)sqrt(shotDist[aj]), aName);

					// segy file exist and we need to grab its related trace
					CFile file;
					if (!file.Open(aName, CFile::modeRead | CFile::typeBinary)) {
						continue;
					}

					// now search for trace number k for segy aName 
					if (file.Seek(k*len+3600L, CFile::begin) > 0) {
						// now trace number k is found
						if (file.Read(&tr, len) == (UINT)len) {
							// first, convert from big endian to small endian

							if (isUnix) {
								SwapTraceHeader(&tr);
								SwapN(&tr, bh.format);
							}
							if (bh.format==1)
								ibm_to_float((int *) tr.dat.data, (int *) tr.dat.data, (int)numsamp);
							filterTimeDomain(&tr.dat.data[0], numsamp, freq1, freq2, tpp);


							// now we need to calculate remove the timeline within a small windows of twdt=0.08 sec 
							// this actual window should be between  itwmin and itwmax
							//	double sum2 = 0.;
							if (isRemoveTimeline) {
								removeTimeLine(&tr.dat.data[0], itwmin, itwmax, itwdt);
							} // if isRemoveTimeline

							if (aj==0) {
								// first trace, no need to mix anything
								for (int ii=0; ii<numsamp; ii++) {
									tr2.dat.data[ii] = tr.dat.data[ii];
								}
							}
							else {
								// first, we should normalize the tr.dat to balance with tr2.dat
								double temp2 = getMedianAbsolute(&tr2.dat.data[0], numsamp);
								double temp = getMedianAbsolute(&tr.dat.data[0], numsamp);

								double aMedian = 0.; // the desired output median to use
								if (temp > MINAMP && temp2 > MINAMP)
									aMedian = (temp + temp2)*0.5;
								else if (temp2 > MINAMP) 
									aMedian = temp2;
								else
									aMedian = temp;

								temp = (temp>MINAMP)? (aMedian/temp) : 1.;  
								if (temp != 1. ) {
									for (int ii=0; ii<numsamp; ii++) {
										tr.dat.data[ii] *= (float)temp;
									}
								}

								temp2 = (temp2>MINAMP)? (aMedian/temp2) : 1.;  
								if (temp2 != 1. ) {
									for (int ii=0; ii<numsamp; ii++) {
										tr2.dat.data[ii] *= (float)temp2;
									}
								}

								// first prepare a few arrays data. This is because the multiplication
								// takes much longer CPU time
								// tr2 is the reference trace
								int ii;
								for (ii=itwmin-itauMaxHalf; ii<=itwmax+itauMaxHalf; ii++) {
									// I know that ii will not exceed the limits of the arrays, so it's ok
									trsqrt[ii] = tr.dat.data[ii] * tr.dat.data[ii];
									tr2sqrt[ii] = tr2.dat.data[ii] * tr2.dat.data[ii];
								}

								int itau;
								for (itau=-itauMaxHalf; itau<=itauMaxHalf; itau++) {
									// indexTau is actual index in the array for tau
									// itau is the actual delay in number of samples
									int indexTau = itau+itauMaxHalf; 
									for (ii=itwmin-itauMaxHalf; ii<=itwmax+itauMaxHalf; ii++) {
										// for each ii, there is a range of itauMax tau values
										float a = tr2.dat.data[ii];
										int jj = ii+itau;
										if (jj>=0 && jj<numsamp) {
											a += tr.dat.data[jj];
										}
										trcorr[indexTau][ii] = a*a;
									}
								}



								// now we need to coherency mixing for applying sttaic shift
								// we base it on the timeline within a small windows of itauMax (~33 samples) 
								// we only consider 2 traces: tr2.dat.data[]  and tr.dat.data[]
								// Window of cohenrency: itwmin, itwmax, in between (i.e. 2.6-2.9 sec) there is a strong timeline
								int itauChosen = 0;  // this default means no delay
								double cohChosen = 0.;
								double cohChosenNoWeight = 0.;
								for (itau=-itauMaxHalf; itau<=itauMaxHalf; itau++) {
									// nom = (a1+b1)**2 + (a2+b2)**2 + (a3+b3)**2 + (a4+b4)**2;
									// denom = (a1**2+b1**2 + a2**2+b2**2 + a3**2+b3**2 + a4**2+b4**2) / 2;
									double nom = 0.;
									double denom = 0.;
									int indexTau = itau+itauMaxHalf; 
									for (int iwin=itwmin; iwin<=itwmax; iwin++) {
										nom += trcorr[indexTau][iwin]; // trcorr[] index must start from 0
										denom += tr2sqrt[iwin] + trsqrt[iwin + itau];
									}

									if (denom > MINAMP) {
										double cohNoWeightThis = nom / denom * 2.;
										double tweight = (1.-fabs((double)itau) / (float)itauMaxHalf);
										double cohThis = cohNoWeightThis*tweight*tweight;
										// note: this weighting is very important for proper results

										// if sum3==2, it means one of the 2 traces is all zero
										// if sum3==4, the 2 traces are exactly equal
										// if sum3==0, the 2 traces are reversed polarity
										if (fabs(cohThis-2.)>MINAMP && cohThis > cohChosen) {
											cohChosen = cohThis;
											cohChosenNoWeight = cohNoWeightThis;
											itauChosen = itau; 
										}
									}
								} // itau
								// tr2Ref.dat.data[ii] = (float)itauChosen; // this is actually the time shifts in number of samples
								// tr2Semb.dat.data[ii] = (float)sum2;

								// do the final mixing
								// itauChosen = 0;  // testing
								for (ii=0; ii<numsamp; ii++) {
									int jj = itauChosen + ii;
									if (jj>=0 && jj<numsamp) {
										// tr2.dat.data[ii] = (tr2.dat.data[ii] + tr.dat.data[jj]) * 0.5f;
										tr2.dat.data[ii] += tr.dat.data[jj];
										//	tr2.dat.data[ii] *= 0.5f; // no need since we will normalize it later
									}
									else {
										// do nothing
										//	tr2.dat.data[ii] = 0.f;
									}

									// multiple by the semblence
									if (isCoherency) {
										if (cohChosen > MINAMP)
											tr2.dat.data[ii] *= (float)cohChosenNoWeight;
									}
								}

								// rescale the amplitude to fix the desired amplitude level
								temp = getMedianAbsolute(&tr2.dat.data[0], numsamp);
								if (temp > MINAMP) {
									float a = (float)(aMedian / temp);
									for (ii=0; ii<numsamp; ii++) {
										tr2.dat.data[ii] *= a;
									}

									// to avoid instability of amplitudes, cut the maximum amplitude for output
									float ampMax = (float)(aMedian*10.);
									for (ii=0; ii<numsamp; ii++) {
										if (fabs(tr2.dat.data[ii]) > ampMax)
											tr2.dat.data[ii] = ampMax;
									}
								} // if (temp > 
							}	// if (aj==0)


							numSum++;
						} // if (file.Read(&tr
					} // if (file.Seek(k*len+3600L
					file.Close();
				} // for aj
			} // if (numShot2Sum>0


			// process a few trace headers
			tr2.tracl = i;

			ax = xxOut[i] - xxOut[0];
			ay = yyOut[i] - yyOut[0];
			setDistance(&tr2,  (int)(sqrt(ax*ax+ay*ay) + 0.5));  // directly in meters
			tr2.cdpbak = i;

			tr2.ep = i;
			tr2.dt = (unsigned short)tpp;
			tr2.ns = (unsigned short)numSum;


			if ( bh.format==1 ) {
				tr2.idistopt = 8;
				float_to_ibm((int *) tr2.dat.data, (int *) tr2.dat.data, (int)tr2.ns);
			}
			file2.Write(&tr2, len);

			int iPos = (int)((double)i/(double)numTotal*100.);
			if(iPos<0)iPos=0;
			if(iPos>100)iPos=100;
			pFrame->SetProgress(iPos);

			// write info for viewing
			CTime TimeEnd = CTime::GetCurrentTime();
			CTimeSpan timeSpan = TimeEnd - TimeStart;
			_ftprintf_s(stream2, _T("\n Trace %d took %d seconds with %d traces stacked"), i, timeSpan.GetSeconds(), numSum);
			fflush(stream2);
		} // for i shot points
		pFrame->EndProgress();

		CTime time1 = CTime::GetCurrentTime();
		CTimeSpan timeSpan = time1 - time0;
		_ftprintf_s(stream2, _T("Total %d min spent\n"), timeSpan.GetMinutes());
		fclose(stream2);

		// close the array
		free1float(trsqrt);
		free1float(tr2sqrt);
		free2float(trcorr);

		free1int(filej);
		free1int(shotk);
		free1float(shotDist);

		free(xxOut);
		free(yyOut);
		sarray->RemoveAll();
		free1int(nShotSegy);
		free2float (xxSegy);
		free2float (yySegy);

		file2.Seek(3200L, CFile::begin);
		file2.Read(&bh, 400L);
		bh.ntrpr = (unsigned short)numTotal;
		file2.Seek(3200L, CFile::begin);
		file2.Write(&bh, 400L);
		file2.Close();

		showFileInNotePad(newName);

		/*
		_ftprintf_s(stream, _T("Original: %f %f\r\n", -78.507, 83.848);
		double *a = convLatlon2XY(-78.507,  83.848);
		_ftprintf_s(stream, _T("XY: %f %f\r\n", a[0], a[1]);
		double *b = convXY2Latlon(a[0], a[1]);
		_ftprintf_s(stream, _T("Output degrees: %f %f\r\n", b[0], b[1]);
		// alon = -78.507;
		// alat = 83.848;


		// Create a new Excel spreadsheet, filename is test.xls, sheetname is Sheet1
		CSpreadSheet SS("F:\\data\\cook\\p181\\feb19-20-74\\feb19-20-74.xls", _T("Sheet1");
		CStringArray Rows, Column;
		CString tempString;

		// Print out entire spreadsheet
		for (int i = 1; i <= SS.GetTotalRows(); i++)
		{
		// Read row
		SS.ReadRow(Rows, i);
		for (int j = 1; j <= Rows.GetSize(); j++)
		{
		if (j != Rows.GetSize())
		{
		_ftprintf_s(stream, _T("%s\t", Rows.GetAt(j-1));
		}
		else
		{
		_ftprintf_s(stream, _T("%s\r\n", Rows.GetAt(j-1));
		}
		}
		}

		// print out total number of columns
		_ftprintf_s(stream, _T("\nTotal number of columns = %d\r\n\r\n", SS.GetTotalColumns()); 

		// Read and print out contents of second column of spreadsheet
		SS.ReadColumn(Column, 2);
		for (i = 0; i < Column.GetSize(); i++)
		{
		_ftprintf_s(stream, _T("Column 2 row %d: %s\r\n", i+1, Column.GetAt(i));
		}

		// Read in and print out the cell value at column 3, row 3 of spreadsheet
		if (SS.ReadCell(tempString, 3, 3))
		{
		_ftprintf_s(stream, _T("\nCell value at (3,3): %s\r\n", tempString);
		}
		else
		{
		// print out error message if cell value cannot be read
		_ftprintf_s(stream, _T("Error: %s\r\n", SS.GetLastError); 
		}

		*/






		/*
		// the following code sucessfully traverse all subdirectories and 
		// print out all directories and files
		char s[1000];
		CString newName = _T("F:\\a\\aTempName.txt";
		FILE *stream;
		if( _tfopen_s(&stream, newName, _T("w" ) != 0 )
		{
		AfxMessageBox( _T("The new file was not opened" );
		return FALSE;
		}


		static const TCHAR szFileToFind[] = _T("F:\\data\\cook\\*.*");

		CFileFind finder;
		BOOL bResult = finder.FindFile(szFileToFind);

		_ftprintf_s(stream, _T("Searched results for %s:\r\n", szFileToFind);
		while (bResult)
		{
		bResult = finder.FindNextFile();
		CString aName = (LPCTSTR) finder.GetFileName();
		if (aName == _T("." || aName == _T("..") continue;
		CString aPath = (LPCTSTR) finder.GetFilePath();

		_ftprintf_s(stream, _T("Path|Name is %s|%s\r\n", aPath, aName);
		if (!isFileExistNotDirectory(aName)) {
		CFileFind finder2;
		BOOL bResult2 = finder2.FindFile(aPath + _T("\\*.*");
		while (bResult2)
		{
		bResult2 = finder2.FindNextFile();
		CString aName2 = (LPCTSTR) finder2.GetFileName();
		if (aName2 == _T("." || aName2 == _T("..") continue;
		CString aPath2 = (LPCTSTR) finder2.GetFilePath();

		_ftprintf_s(stream, _T("    Path2|Name2 is %s|%s\r\n", aPath2, aName2);
		if (!isFileExistNotDirectory(aName2)) {
		CFileFind finder3;
		BOOL bResult3 = finder3.FindFile(aPath2 + _T("\\*.*");
		while (bResult3)
		{
		bResult3 = finder3.FindNextFile();
		CString aName3 = (LPCTSTR) finder3.GetFileName();
		if (aName3 == _T("." || aName3 == _T("..") continue;
		CString aPath3 = (LPCTSTR) finder3.GetFilePath();

		_ftprintf_s(stream, _T("      Path3|Name3 is %s|%s\r\n", aPath3, aName3);

		// now the files are found here. do calculation here
		//
		//
		}
		finder3.Close();
		}

		}
		finder2.Close();
		}
		_ftprintf_s(stream, _T("  Root is %s\r\n", (LPCTSTR) finder.GetRoot());

		_ftprintf_s(stream, _T("  Title is %s\r\n", (LPCTSTR) finder.GetFileTitle());
		_ftprintf_s(stream, _T("  Path is %s\r\n", aPath);
		_ftprintf_s(stream, _T("  URL is %s\r\n", (LPCTSTR) finder.GetFileURL());

		}
		finder.Close();

		_ftprintf_s(stream, _T("Original: %f %f\r\n", -78.507, 83.848);
		double *a = convLatlon2XY(-78.507,  83.848);
		_ftprintf_s(stream, _T("XY: %f %f\r\n", a[0], a[1]);
		double *b = convXY2Latlon(a[0], a[1]);
		_ftprintf_s(stream, _T("Output degrees: %f %f\r\n", b[0], b[1]);
		// alon = -78.507;
		// alat = 83.848;

		fclose(stream);
		showFileInNotePad(newName);

		*/





		/*
		CString aName = (LPCTSTR) finder.GetFileName();
		_ftprintf_s(stream, _T("  Root is %s\r\n", (LPCTSTR) finder.GetRoot());
		_ftprintf_s(stream, _T("  Title is %s\r\n", (LPCTSTR) finder.GetFileTitle());
		_ftprintf_s(stream, _T("  Path is %s\r\n", (LPCTSTR) finder.GetFilePath());
		_ftprintf_s(stream, _T("  URL is %s\r\n", (LPCTSTR) finder.GetFileURL());
		Searched results for F:\data\cook\*.*:
		Name is p181
		Directory
		Root is F:\data\cook
		Title is p181
		Path is F:\data\cook\p181
		URL is file://F:\data\cook\p181
		Name is p182
		Directory
		Root is F:\data\cook
		Title is p182
		Path is F:\data\cook\p182
		URL is file://F:\data\cook\p182
		*
		*
		*/
		return true;



		/*
		// this part is for working with Sonya. It works very well.

		TCHAR s[80];
		CString nameOffset;
		//	FILE *ifh1;  

		bhed bh;
		segy tr, tr2;
		short *i2buf;
		i2buf = (short *) &tr;
		float *trcdat;
		trcdat = (float *) &i2buf[120];

		CString nameTab = _T("F:\\a\\intvel_johnPC.sgy";
		if (!isFileExistNotDirectory(nameTab)) return false;

		CFile file(nameTab, CFile::modeReadWrite | CFile::typeBinary);
		int bytesRead = file.Seek(3200L, CFile::begin);

		bytesRead = file.Read(&bh, 400);
		int sampRate = bh.hdt; // in micros sec
		int ns = bh.hns;
		int iformat = bh.format;
		long nbytePerTrc = 0;
		if(iformat!=3)  
		nbytePerTrc = ns*4 + 240;
		else
		nbytePerTrc = ns*2 + 240;

		int numProcessed = 0;
		float dz = bh.hdt * 0.001f; // meter
		//	int ttt  = sizeof(long);
		while (file.Read(&tr, nbytePerTrc) == (unsigned long)nbytePerTrc)
		{
		tr2.dat.data[0] = 0;
		if (tr.dat.data[0]<0.001f) tr.dat.data[0] = 1500.f;
		for (int i=1; i<ns; i++) {
		if (tr.dat.data[i]<0.00001) tr.dat.data[i] = tr.dat.data[i-1];
		tr2.dat.data[i] = tr2.dat.data[i-1] + 2.f*dz/tr.dat.data[i];
		}
		for (i=0; i<ns; i++) {
		tr.dat.data[i] = tr2.dat.data[i];
		}
		file.Seek(-nbytePerTrc, CFile::current);  // variable nbytePerTrc cannot be unsigned
		file.Write(&tr, nbytePerTrc);
		numProcessed++;

		}
		_stprintf(s, _T("%d trace procesed",numProcessed);
		AfxMessageBox(s, MB_OK |MB_ICONINFORMATION);
		//	fclose(ifh1);
		file.Close();

		return true;

		*/	
















		// testing ******************************
		/*
		PROFILE deping1->1           TYPE 1 29                                          2d_ci7m_gf.ifdf  m  ms
		SNAPPING PARAMETERS 2    19 1
		1.13814000E+06  4.97529221E+06  1 14  3283.08   5366.33  16099.00 5071 3.4028235E+38 2 1205-100                                                      
		1.13815252E+06  4.97529322E+06  1 14  3280.97   5366.67  16100.00 5072 3.4028235E+38 2 1205-100                                                      
		easting         northern       No.    TWTT      FFID              

		5120   -->   0.661km


		5366.330 -->  
		5883.330
		*/



		/* The following code works very well: it takes NOPAK velocity data, and convert into 
		*  velocity file for Claritas software to use
		*/
		/*
		CString nameTab = _T("F:\\data2\\Hud2004-030\\stacking_velocities\\TGS-notpak.txt";
		FILE *ifh1;

		if (_tfopen_s(&ifh1, nameTab,_T("r")) != 0) 
		{AfxMessageBox(_T("Error opening file: "+ nameTab); return FALSE; }

		CString nameOut = _T("F:\\data2\\Hud2004-030\\stacking_velocities\\TGS-notpak-dig.txt";
		FILE *ifh2;
		_tfopen_s(&ifh2, nameOut,_T("w"));

		CString tmp;
		TCHAR line[MAXLINE];
		float a,b;
		int i;
		double rate = 0.037494915;
		while (_fgetts(line,MAXLINE,ifh1)) {
		if (_tcslen(line) < 2) continue;
		if (line[0] == '#') continue; // we do not need comment lines
		CString cs = CString(line);
		if (cs.Compare(_T(""))==0) continue;
		if (cs.Left(3).Compare("EOD")==0) continue;
		if (cs.Left(7).Compare("PROFILE")==0) continue;
		if (cs.Left(8).Compare("SNAPPING")==0) continue;

		i = _tstoi(cs.Mid(33, 3));  // curve number
		a = (float)_tstof(cs.Mid(50, 8));  // FFID
		b = (float)_tstof(cs.Mid(40, 8));  // TWTT
		tmp.Format(_T("%8.3f %8.3f %8d\n", (float)(0.661+(a-5120.)*rate), (float)(b*0.001), i);
		_fputts(tmp,ifh2); 
		}
		fclose(ifh1);
		fclose(ifh2);
		*/
		/* end of code for convert velocity data for Claritas */





		/*
		int nxMax=200, nzMax = 500;
		int *nzed;
		float **xv, **zv, **vf;
		nzed = (int *) ealloc1int(nxMax);
		xv = (float **) ealloc2float(nzMax,nxMax);
		zv = (float **) ealloc2float(nzMax,nxMax);
		vf = (float **) ealloc2float(nzMax,nxMax);
		if (xv==NULL || zv==NULL || vf==NULL) return FALSE;

		// initialize parameters
		float xstart = 0.661f;
		float xinc = 0.037495f;
		float xstartReadin = ERRORVAL;   // this will be read in from the first line of file

		FILE *ifh1;  
		CString nameTab = _T("F:\\data2\\Hud2004-030\\stacking_velocities\\stk_vel_1205.lst";
		if (_tfopen_s(&ifh1, nameTab,_T("r")) != 0) 
		{AfxMessageBox(_T("Error opening file: "+ nameTab); return FALSE; }
		CString startChar;
		CString ss = _T("VELMIG";
		int i = -1;
		int j = -1;
		TCHAR line[MAXLINE];
		CString tmp;
		while (_fgetts(line,MAXLINE,ifh1)) 
		{
		if (_tcslen(line) < 2) continue;
		if (line[0] == '#') continue; // we do not need comment lines
		_stscanf_s(line,"%6s",startChar);
		int ia = ss.CompareNoCase(startChar.Left(6));
		if (ia==0) {
		// this means it is the first line for a given shot.
		// AfxMessageBox(line);
		i++;
		if (i>nxMax-1) {
		tmp.Format(_T("ix=%d Out of bounds: %s", i, line);
		AfxMessageBox(tmp); 
		break;
		}
		xv[i][0] = (float)_tstoi(CString(line).Right(5));
		if (i==0) {
		//save the first shot for calculating distance
		xstartReadin = xv[i][0];
		}
		//		xv[i][0] = (xv[i][0]-xstartReadin)*xinc + xstart;
		j=0;
		nzed[i] = 0;
		continue;
		}

		CString cs = CString(line);
		for (int k = 0; k<5; k++) {
		zv[i][j+k] = _tstoi(cs.Mid(k*12, 6));
		vf[i][j+k] = _tstoi(cs.Mid(k*12+6, 6));
		if (vf[i][j+k] == 0) continue;
		nzed[i]++;
		}

		j+=5;
		if (j<0 || j+4>nzMax-1) {
		tmp.Format(_T("iz=%d Out of bounds at this line: %s", j, line);
		AfxMessageBox(tmp);
		break;
		}

		}
		fclose(ifh1);

		CString nameOut = _T("F:\\data2\\Hud2004-030\\stacking_velocities\\stk_vel_1205.nmo";
		FILE *ifh2;
		_tfopen_s(&ifh2, nameOut,_T("w"));
		tmp = _T("NMO\n";
		_fputts(tmp,ifh2); 
		tmp = _T("PRIMARY KEY : SHOT\n";
		_fputts(tmp,ifh2);
		_fputts("SECONDARY KEY : ???\n",ifh2);
		_fputts("INTERPOLATION KEY : Interpolate/End\n",ifh2);
		_fputts("Initial Spherical Divergence Velocity\n",ifh2);
		_fputts("|KEYVAL|{T1     |V1}     |{T2     |V2}     |{T3     |V3}     |{T4     |V4}...  |\n",ifh2);


		// now write the actual data points to file
		int nxv = i+1; // total number of records read in
		int ix, iz;
		for (ix=0; ix<nxv; ix++)
		{
		tmp.Format(_T("%7d ", (int)xv[ix][0]);
		_fputts(tmp,ifh2);
		for (iz=0; iz<nzed[ix]; iz+=4)
		{
		tmp = _T("");
		for (int k=0; k<4; k++) {
		if (iz+k < nzed[ix])
		tmp.Format(tmp+"%8d %8d ", (int)zv[ix][iz+k], (int)vf[ix][iz+k]);
		}
		_fputts(tmp,ifh2);
		_fputts("\n        ",ifh2);
		}

		// since the last output line for ix should not have the 8 spaces, 
		// we need to backspace for 8 spaces
		fseek(ifh2, -8L, SEEK_CUR);
		}

		fclose(ifh2);

		free2float(xv);
		free2float(zv);
		free2float(vf);
		free1int(nzed);
		*/

		/*
		// now we have read in the complete velocity file
		//Generate velocity contours
		short ix, iz, iv;
		double vminLayer=1.5f, vmaxLayer=7.;
		double range, depth;
		double a,b,x1,x2,y1,y2, v,dv;
		CPoint p,p1,plta[1000],pltb[1000];

		//Start plotting velocity color map.
		CPen whitePen(PS_NULL, 0, RGB(255,255,255));
		CPen whiteLinePen(PS_SOLID, 0, RGB(255,255,255));
		CPen blackPen(PS_SOLID, 0, RGB(0,0,0));
		CPen redPen(PS_SOLID, (int)(pCd.coord.logicalAxes.Height()/400), RGB(255,0,0));
		CPen greenPen(PS_SOLID, (int)(pCd.coord.logicalAxes.Height()/400), RGB(0,255,0));
		CPen thickPen(PS_SOLID, (int)(min(pCd.coord.logicalAxes.Width(),pCd.coord.logicalAxes.Height())/600), RGB(0,0,0));
		CPen thinPen(PS_SOLID, 0, RGB(0,100,0));
		CBrush blackBrush(RGB(0,0,0));
		CBrush redBrush(RGB(255,0,0));
		CBrush greenBrush(RGB(0,255,0));
		CBrush blueBrush(RGB(0,0,255));

		if(vminLayer<=vel.vmin) dv = vel.dv1;
		else if(vminLayer<=vel.vmid) dv = vel.dv1;
		else if (vminLayer<=vel.vmid2) dv = vel.dv2;
		else if (vminLayer<=vel.vmid3) dv = vel.dv3;
		else if (vminLayer<=vel.vmid4) dv = vel.dv4;
		else dv = vel.dv5;

		//vminLayer should be rounded to a multiple of dv.
		vminLayer = (int)(vminLayer/dv) * dv;

		int nv = (int)((vmaxLayer-vminLayer)/dv + .5);
		if(nv<2)  nv=2;
		if(nv>=500) {
		dv = (vmaxLayer-vminLayer)/499;
		nv = 500;
		}	//Make sure plt[] array do not exceed 500.

		//Loop through colors for this layer.
		for (iv=0; iv<nv-1; iv++)
		{
		v = vminLayer + iv*dv;
		if(v>vmaxLayer) break;

		//Search by interpolation for the curve for v.
		for (ix=0; ix<nxv; ix++)
		{
		// first, for this ix, search for the velocity contour between v and (v+dv)
		for (iz=0; iz<nzed[ix]-1; iz++)
		{
		float v1 = vf[ix][iz];
		if (v1>=v && v1<(v+dv)) {
		// found a v
		range = xv[ix][iz];
		depth = zv[ix][iz];
		double dzm = zv[ix][iz+1]-depth;
		double dvm=vf[ix][iz+1]-v1;
		if(dzm<0.) 
		{
		// should not happen -- next node shallower
		a = depth;
		}
		else if(fabs(dvm)<0.001)
		{
		//const vel
		if(fabs(v-v1) <= dv ) a=depth;
		else a=zv[ix][iz+1];
		}
		else
		{
		a =depth+dzm*(v-v1)/dvm;
		}

		if(a<depth) a=depth;
		if(a<pCd.coord.zmin) a=pCd.coord.zmin;
		if(a>pCd.coord.zmax) a=pCd.coord.zmax;
		plta[ix] = pCd.mm_coord(range, a);
		// plt[2*nx-ix-1] = pCd.mm_coord(range, b);
		} // end of if v
		} // end of for iz

		} //End of loop ix.

		// start the final plot
		COLORREF colThis = getVelocityColor((float)v, vel);
		oldPen = pDC->SelectObject(&blackPen);
		CBrush brush;
		brush.CreateSolidBrush(colThis);
		oldBrush = pDC->SelectObject(&brush);
		pDC->Polygon(plt, 2*nx);
		pDC->SelectObject(oldBrush);
		pDC->SelectObject(oldPen);
		} //End of loop iv.

		//	double xx[500],zz[500];
		*/
		return(TRUE);
	}



	double CSeisWideDoc::getFreeSpace(CString f)
	{
		int pathLen = f.ReverseFind( '\\' );
		if(pathLen>(-1)) SetCurrentDirectory(f.Left(pathLen));

		ULARGE_INTEGER iwFreeSpace, iwTotalBytes; 
		BOOL truefalse = GetDiskFreeSpaceEx(NULL, &iwFreeSpace, &iwTotalBytes, NULL);

		double dwFreeSpace = (DOUBLE)iwFreeSpace.LowPart;
		dwFreeSpace += ((DOUBLE)iwFreeSpace.HighPart)*ULONG_MAX;
		dwFreeSpace /= MIL;

		return dwFreeSpace;
	}

	COLORREF CSeisWideDoc::getRayColor(int irayCol)
	{
		// 0 for black, 1 for red TT curves; 2 for white, 3 for blue, 4 for random colors.

		if (irayCol==0)
			return RGB(90,90,90);
		else if (irayCol==1)
			return RGB(255,20,20);
		else if (irayCol==2)
			return RGB(235,235,235);
		else if (irayCol==3)
			return RGB(0,0,225);
		else {
			double r = rand()/(double)RAND_MAX * 220 + 30; // always <= 1.0;
			double g = rand()/(double)RAND_MAX * 200 + 40;
			double b = rand()/(double)RAND_MAX * 200 + 30;

			// avoid too white rays
			if (r + g + b > 580.) {
				r = 1.;
				g = 255.;
				b = 1;
			}
			return RGB((int)r, (int)g, (int)b);
		}
	}

	void CSeisWideDoc::OnToolbarBiggerAmp() 
	{
		draw.isSameDataDisplay = FALSE;
		if (para.wiggle == 4) {
			// here, we just reduce the color scale to reveal smaller amps
			CdlgSegyColor2 color2;
			if (!color2.getAmpColorArray2(ampColorDyn.colFileName)) return;
			if (color2.ampColorLower())
				color2.saveAmpColorToFile(ampColorDyn.colFileName);
		}
		else
			para.gain *= 1.2;
		UpdateAllViews(NULL);
		NotifyChanged();

	}

	void CSeisWideDoc::OnToolbarLessAmp() 
	{
		draw.isSameDataDisplay = FALSE;
		//if (para.wiggle == 5) {
		//	// this is Pixel based color display, and we can only use clip to gain things
		//	para.clip /= 1.2;
		//}
		//else
		if (para.wiggle == 4) {
			// here, we just reduce the color scale to reveal smaller amps
			CdlgSegyColor2 color2;
			if (!color2.getAmpColorArray2(ampColorDyn.colFileName)) return;
			if (color2.ampColorHigher())
				color2.saveAmpColorToFile(ampColorDyn.colFileName);
		}
		else
			para.gain /= 1.2;
		UpdateAllViews(NULL);
		NotifyChanged();

	}



	void CSeisWideDoc::OnProcessingAppendmanysegyfiles() 
	{
		short nf = 0;
		CString inFileName,inFileName2, inFileNames[999], logFileName, gmtFileName ;

		AfxMessageBox(_T("Note: each segy must have the sample rate and length. This is not checked for. If not sure, append one file at a time."));

		//Open file dialog.
		CFileDialog dlg( TRUE,_T("sgy; SEG"),_T("*.sgy"),
			OFN_HIDEREADONLY|OFN_OVERWRITEPROMPT|OFN_ALLOWMULTISELECT|OFN_EXPLORER,
			_T("Input Segy Files (*.sgy)|*.sgy|"));
		TCHAR* buff=new TCHAR[65535];
		buff[0]='\0';
		dlg.m_ofn.lpstrTitle = _T("Select all segy files for appending at alphabetical order, regardless of whatever in display. ");
		dlg.m_ofn.lpstrFile=buff;
		dlg.m_ofn.nMaxFile = 65535;//sizeof(buff);


		POSITION Position;

		bool isCanceled = false;
		if(dlg.DoModal()==IDOK)
		{

			Position=dlg.GetStartPosition();
			while(Position)
			{
				inFileName = dlg.GetNextPathName(Position);
				if(!inFileName.IsEmpty()) {
					inFileNames[nf] = inFileName;
					nf++; }
			}
			delete dlg;

		} //end dlg.DoModal function.
		else {
			delete dlg;
			isCanceled = true;
		}

		delete[] buff;
		if (isCanceled) return;

		// If data numbers exceed max, just change this number
		int MAX_FILES=999;
		if(nf>MAX_FILES)
		{
			AfxMessageBox(_T("Maximum number of files selected is exceeded."));
			return;
		}

		//now reorganize these files sequentially, alphabetically.
		int n;
		CString t;
		for (n=0; n<nf-1; n++)
		{
			for (int i=n+1; i<nf; i++)
			{
				if(inFileNames[n]>inFileNames[i]) 
				{
					t = inFileNames[i];			
					inFileNames[i] = inFileNames[n];
					inFileNames[n] = t;			
				}
			}
		}




		int totShot;
		bhed bh;
		segy tr, tr2;

		ULONGLONG curBytesRead,bytesRead;
		int iPos;
		BOOL isUnix = false;

		CString tStr;

		//###############initilize output file pointer###################
		CFile file2;
		CFile gmtFile2;
		inFileName2 = inFileNames[0];
		if ((n = inFileNames[0].GetLength()) > 4) {
			inFileName2 = GetFileNameAppendExt(inFileNames[0], _T("Merged"), _T("sgy"));
			logFileName = GetFileNameAppendExt(inFileNames[0], _T("Merged"), _T("log"));
			gmtFileName = GetFileNameAppendExt(inFileNames[0], _T("MergedGmt"), _T("log"));
			tStr = GetPathFromFileSlash(inFileNames[0]);
			if(isDirectoryExist(tStr))
				SetCurrentDirectory(tStr);
		}
		else {
			inFileName2 = _T("outMerged.sgy");
			logFileName = _T("outMerged.log");
			gmtFileName = _T("outMergedGmt.log");
		}

		if (!file2.Open(inFileName2, CFile::modeCreate|CFile::modeReadWrite|CFile::typeBinary)) {
			return;
		}

		FILE *log, *logGmt;


		if (_tfopen_s(&log, logFileName, _T("w")) != 0) {
			AfxMessageBox(_T("Cannot open log file to write."));
			file2.Close();
			return;
		}
		_tfopen_s(&logGmt, gmtFileName, _T("w"));
		//###############end initilize output file pointer###################


		//Begin progress control.
		CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
		pFrame->BeginProgress();


		//###############loop thru the input files ###################
		totShot = 0;
		int i;
		int outLen = 0;
		int outRate = 0;
		bool isProb = false;
		for (n=0; n<nf; n++) {
			curBytesRead = file2.Seek(0, CFile::current);
			iPos = (int)((double)n/(double)nf*100.);
			if(iPos<0)iPos=0;
			if(iPos>100)iPos=100;
			pFrame->SetProgress(iPos);


			if (!isFileExistNotDirectory(inFileNames[n])) continue;
			CFile file;
			if (!file.Open(inFileNames[n], CFile::modeRead | CFile::typeBinary)) {
				continue;
			}

			// first, we processs the tape headers
			bytesRead = file.Read(head.ascHead, 3200L);
			if(bytesRead < 3200) {
				AfxMessageBox(_T("Ascii section header for 2nd file read wrong"));
				file.Close();
				file2.Close();
				return;
			}
			// ebc2asc(head.ascHead, 3200);
			_ftprintf_s(log, _T("\n--------------------\nSEGY NAME:\n%s\n"), inFileNames[n]);
			_ftprintf_s(logGmt, _T(">%s\n"), inFileNames[n]);

			for (i=0; i<260; i++) 
				_ftprintf_s(log, _T("%c"), head.ascHead[i]);
			_ftprintf_s(log, _T("\n\n"));


			bytesRead = file.Read(&bh, 400L);
			if (isUnix = IsUnix(bh.format)) SwapTapeHeader(&bh);
			if(bytesRead < 400 || !IsFormatValid(bh.format)) {
				AfxMessageBox(_T("Binary section header read wrong"));
				file.Close();
				file2.Close();
				continue;
			}

			// get some parameters from the tape header
			int len = (bh.format==3) ? (2*bh.hns) :  4*bh.hns;
			len += 240;

			if (outLen == 0) {
				file2.Write(head.ascHead, 3200L);
				file2.Write(&bh, 400L);
				_ftprintf_s(log, _T("Trace, Long, Lat, CDP, CDPBak, TimeRec\n"));
				outLen = bh.hns;
				outRate = bh.hdt;
			}
			//	int iii = sizeof(bh);

			//	int yyyy = sizeof(tr);

			// we now process the data
			if (bh.hdt == outRate && bh.hns==outLen) {
				while (file.Read(&tr, len) == (UINT)len) {
					if (isUnix) {
						SwapTraceHeader(&tr);
						SwapN(&tr, bh.format);
					}
					if (bh.format==1) {
						// floating
						ibm_to_float((int *) tr.dat.data, (int *) tr.dat.data, (int)bh.hns);
					}
					else if (bh.format==2) {
						// we want to convert fixed point to float for easier processing
						for (i=0; i<bh.hns; i++) 
							tr.dat.data[i] = (float)tr.dat.dataint[i];
					}
					else if(bh.format == 3) {
						// short int for input
						for (i=0; i<bh.hns; i++) 
							tr2.dat.data[i] = (float)tr.dat.datashort[i];
						for (i=0; i<bh.hns; i++) 
							tr.dat.data[i] = (float)tr2.dat.data[i];
					}
					tr.tracl = totShot + 1;

					if (bh.hns < outLen) {
						for (i=bh.hns; i<outLen; i++)
							tr.dat.data[i] = 0.f;
					}
					tr.ns = outLen;
					if ( bh.format==1) {
						float_to_ibm((int *) tr.dat.data, (int *) tr.dat.data, (int)tr.ns);
					}
					file2.Write(&tr, 240+outLen*sizeof(float));

					_ftprintf_s(log, _T("%d %8.5f %8.5f %d %d %d:%d:%d:%d\n"), tr.tracl,(float)(0.0001f*tr.gx), (float)(0.0001f*tr.gy), tr.cdp,tr.cdpbak,tr.year,tr.hour,tr.minute,tr.sec);
					// _ftprintf_s(logGmt, _T("%8.5f %8.5f %d:%d:%d:%d\n", (float)(0.0001f*tr.gx), (float)(0.0001f*tr.gy),tr.year,tr.hour,tr.minute,tr.sec);
					_ftprintf_s(logGmt, _T("%8.5f %8.5f 6 0 8 LM \\040\n"), (float)(0.0001f*tr.gx), (float)(0.0001f*tr.gy));
					totShot++;
				} // while file.Read
			} // if
			else {
				_ftprintf_s(log, _T("  *** this file is not merged: \n  **** sampling rate/num samples changed from: %d/%d to %d/%d.Resampe it first!\n"), outRate, outLen, bh.hdt, bh.hns);
				isProb = true;
			}
			file.Close();
			file2.Flush();
		} // for n
		pFrame->EndProgress();

		if(totShot>0) {
			file2.Seek(3200L, CFile::begin);
			file2.Read(&bh, 400L);
			bh.format = 1;
			bh.ntrpr = (unsigned short)totShot;
			file2.Seek(3200L, CFile::begin);
			file2.Write(&bh, 400L);

			if (isProb)
				tStr.Format(_T("Problem entered. Check log. However, succesfully Mixing the datain the temp directory! A total of %d traces processed."), totShot);
			else
				tStr.Format(_T("Succesfully Mixing the data in the temp directory! A total of %d traces processed."), totShot);
		}
		else
			tStr.Format(_T("Not even one trace appended!"));
		AfxMessageBox(tStr);

		file2.Close();
		fclose(log);
		fclose(logGmt);


		showFileInNotePad(logFileName);
	}



	// this function calculates color for an amplitude
	// it uses global variables of  seisBiColor, draw.ampMax
	COLORREF CSeisWideDoc::getAmpRgb(CPoint *pint, int numfa, int xFull, int xZero)
	{
		// depreciated
		if (ampColorDyn.r == NULL && !getAmpColorArray()) return RGB(0,0,0);
		if (ampColorDyn.num == 0) return RGB(0,0,0);
		int ampMax;
		double scale;
		//	return RGB(ampBiColor.rhi[ii], ampBiColor.ghi[ii], ampBiColor.bhi[ii]);
		/*
		-5	0	0	255	-4	51	51	255
		-4	51	51	255	-3	102	102	255
		-3	102	102	255	-2	153	153	255
		-2	153	153	255	-1	204	204	255
		-1	204	204	255	0	255	255	255
		0	255	255	255	1	255	204	204
		1	255	204	204	2	255	153	153
		2	255	153	153	3	255	102	102
		3	255	102	102	4	255	51	51
		4	255	51	51	5	255	0	0
		*/

		if (xFull == xZero) {
			scale = 0.5;
		}
		else if (xFull > xZero) {
			ampMax = -(int)MIL;
			for (int i=0; i<numfa; i++) {
				if (ampMax < pint[i].x) ampMax = pint[i].x;
			}
			scale = (float)(ampMax - xZero) /(float)(xFull-xZero);
		}
		else {
			// fill the left half
			ampMax = (int)MIL;
			for (int i=0; i<numfa; i++) {
				if (ampMax > pint[i].x) ampMax = pint[i].x;
			}
			scale = - (float)(ampMax - xZero) /(float)(xFull-xZero);
		}

		int ii = (int)myRound(5.0 * scale);
		if (ii<-5) ii = -5;
		else if (ii>5) ii=5;

		ii += 5;

		//if (ampColorDyn.r[ii] > 200 && ampColorDyn.g[ii] > 200 && ampColorDyn.b[ii] > 200) {
		//	int sdfsd = 1;
		//}

		return RGB(ampColorDyn.r[ii], ampColorDyn.g[ii], ampColorDyn.b[ii]);

	}
	COLORREF CSeisWideDoc::getAmpRgbSimple(int fullAmpR, int fullAmpG, int fullAmpB)
	{
		return RGB(fullAmpR,fullAmpG,fullAmpB);
	}




	COLORREF CSeisWideDoc::getAmpRgb(float amp)
	{
		// and then we use amp, head.maxAmp, draw.avgAmp to determine the color
		//return getAmpRgbPixel(amp, -(float)head.maxAmp,(float)head.maxAmp);
		//int ii = (amp < 0.f)  ?  0  :  10;
		//return RGB(ampColorDyn.r[ii], ampColorDyn.g[ii], ampColorDyn.b[ii]);


		if (ampColorDyn.r == NULL && !getAmpColorArray()) return RGB(0,0,0);
		if (ampColorDyn.num == 0) return RGB(0,0,0);

		int num = ampColorDyn.num;

		//float ampPercent = ampColorDyn.percent[0] + 
		//	(ampColorDyn.percent[num-1] - ampColorDyn.percent[0]) *
		//	(float)(amp + head.maxAmp) / (float)(2.*head.maxAmp);

		if (amp <= ampColorDyn.percentAmp[0])
			return RGB(ampColorDyn.r[0], ampColorDyn.g[0], ampColorDyn.b[0]);
		else if (amp >= ampColorDyn.percentAmp[num-1]) {
			return RGB(ampColorDyn.r[num-1], ampColorDyn.g[num-1], ampColorDyn.b[num-1]);
		}


		for (int i = 0; i<num; i++) {
			if (amp == ampColorDyn.percentAmp[i]) {
				return RGB(
					ampColorDyn.r[i],
					ampColorDyn.g[i],
					ampColorDyn.b[i]
				);
			}
		}

		for (int i = 1; i<num; i++) {
			if (amp >= ampColorDyn.percentAmp[i-1] && amp <= ampColorDyn.percentAmp[i]) {
				return RGB(
					(ampColorDyn.r[i-1]+ampColorDyn.r[i])/2,
					(ampColorDyn.g[i-1]+ampColorDyn.g[i])/2,
					(ampColorDyn.b[i-1]+ampColorDyn.b[i])/2
					);
			}
		}

		// now the rate is not covered. This cannot happen unless program erros
		return RGB(ampColorDyn.r[num], ampColorDyn.g[num], ampColorDyn.b[num]);
	}

	/*
	convert ampColorDyn.r[iai]  
	to  
	COLORREF *colArr     which is expanded to ~50 colors based on amp levels
	*/
	bool CSeisWideDoc::getExpandedColorTableDepreciated(COLORREF *colArr, float *percentAmpExpanded, int numExpanded) {
		if (!getAmpColorArray()) return true;  // we always read the color table from file whenever plotting starts

		if (colArr == NULL) return false;
		int num = ampColorDyn.num;
		if (num == numExpanded) {
			for (int i=0; i<numExpanded; i++) {
				colArr[i] = RGB(ampColorDyn.r[i], ampColorDyn.g[i], ampColorDyn.b[i]);
				percentAmpExpanded[i] = ampColorDyn.percentAmp[i];
			}
			return true;
		}



		int r,g,b;


		for (int i=0; i<numExpanded; i++) {
			float ai = (float)i / (float)numExpanded * (float)(num-1);

			// ai is for the original color table, must be inside [0, num-1]

			int iai = (int)ai;
			if (iai > num-1) {
				iai = num-1;
				ai = (float)iai;
			}

			if (iai == ai || iai+1 > num-1) {
				colArr[i] = RGB(
					ampColorDyn.r[iai], 
					ampColorDyn.g[iai], 
					ampColorDyn.b[iai]
				);
				percentAmpExpanded[i] = ampColorDyn.percentAmp[iai];
			}
			else {
				r = ampColorDyn.r[iai] + (int)myRound((ampColorDyn.r[iai+1]-ampColorDyn.r[iai])*(ai-iai)),
					g = ampColorDyn.g[iai] + (int)myRound((ampColorDyn.g[iai+1]-ampColorDyn.g[iai])*(ai-iai)),
					b = ampColorDyn.b[iai] + (int)myRound((ampColorDyn.b[iai+1]-ampColorDyn.b[iai])*(ai-iai));
				if (r > 255) r = 255;
				if (g > 255) g = 255;
				if (b > 255) b = 255;

				if (r < 0) r = 0;
				if (g < 0) g = 0;
				if (b < 0) b = 0;

				colArr[i] = RGB(r,g,b);
				percentAmpExpanded[i] = ampColorDyn.percentAmp[iai] + 
					(ampColorDyn.percentAmp[iai+1]-ampColorDyn.percentAmp[iai])*(float)(ai-iai);
			}

		} // for i
		return true;
	}


	int CSeisWideDoc::getColorIndex4AmpDepreciated(float *amp, float *percentAmpExpanded) {
		if (draw.numContours == 0) return 0;
		// int numContours = ampColorDyn.numContours;
		if (*amp <= percentAmpExpanded[0])
			return 0;
		else if (*amp >= percentAmpExpanded[draw.numContours-1]) {
			return draw.numContours-1;
		}

		for (int i = 1; i<draw.numContours; i++) {

			if (isInsideFloat(amp, &percentAmpExpanded[i-1], &percentAmpExpanded[i])) {
				// this function will be very deep in loop. So we want it to be as fast as possible!!! So we drop complicated calculation
				//if ( fabs(*amp-percentAmpExpanded[i-1]) < fabs(percentAmpExpanded[i]-*amp) ) return i-1;
				//else return i;
				return i-1;
			}
		}

		// now the rate is not covered. This cannot happen unless program erros
		//	myCaption(_T("Not covered"));
		return draw.numContours/2;
	}


	COLORREF CSeisWideDoc::getColorRef4Amp(double amp, int numColors, float *percentAmp, COLORREF *colArr) 
	{
		static COLORREF white = RGB(255, 255, 255);

		if (numColors == 0) return white;
		if (amp <= percentAmp[0]) return colArr[0];

		int iLast =  numColors-1;
		if (amp >= percentAmp[iLast]) return colArr[iLast];

		for (int i = 1; i<numColors; i++) {
			if (amp >= percentAmp[i-1] && amp <= percentAmp[i]) {
				// this function will be very deep in loop. So we want it to be as fast as possible!!! So we drop complicated calculation
				//if ( fabs(*amp-percentAmpExpanded[i-1]) < fabs(percentAmpExpanded[i]-*amp) ) return i-1;
				//else return i;
				register double delta = percentAmp[i] - percentAmp[i-1];
				register double f = (delta == 0.f)  ?  0.f  :  (amp - percentAmp[i-1])/delta;

				// testing
				//int r = (int)(GetRValue(colArr[i-1]) + (GetRValue(colArr[i]) - GetRValue(colArr[i-1])) * f);
				//int g = (int)(GetGValue(colArr[i-1]) + (GetGValue(colArr[i]) - GetGValue(colArr[i-1])) * f);
				//int b = (int)(GetBValue(colArr[i-1]) + (GetBValue(colArr[i]) - GetBValue(colArr[i-1])) * f);
				register BYTE r = GetRValue(colArr[i-1]);
				register BYTE g = GetGValue(colArr[i-1]);
				register BYTE b = GetBValue(colArr[i-1]);

				//double aaR = (r + (double)(GetRValue(colArr[i]) - r) * f);
				//double aaG = (g + (double)(GetGValue(colArr[i]) - g) * f);
				//double aaB = (b + (double)(GetBValue(colArr[i]) - b) * f);

				return RGB( (int)(r + (double)(GetRValue(colArr[i]) - r) * f),
					(int)(g + (double)(GetGValue(colArr[i]) - g) * f),
					(int)(b + (double)(GetBValue(colArr[i]) - b) * f) );
			}
		}

		// now the rate is not covered. This cannot happen unless program errors
		return white;
	}

	/*
	// This function just get an average color from the 4 surrounding points
	DWORD GetSubTexel( int x, int y )
	{
	const int h = (x & 0xff00) / 255;
	const int i = (y & 0xff00) / 255;

	x = x >> 16;
	y = y >> 16;

	const COLORREF cr1 = GetTexel( x + 0, y + 0 );
	const COLORREF cr2 = GetTexel( x + 1, y + 0 );
	const COLORREF cr3 = GetTexel( x + 1, y + 1 );
	const COLORREF cr4 = GetTexel( x + 0, y + 1 );

	const int a = (0x100 - h) * (0x100 - i);
	const int b = (0x000 + h) * (0x100 - i);
	const int c = (0x000 + h) * (0x000 + i);
	const int d = 65536 - a - b - c;

	const unsigned int R = 0x00ff0000 & (((cr1 >> 16)      * a) + ((cr2 >> 16)      * b) + ((cr3 >> 16)      * c) + ((cr4 >> 16)      * d));
	const unsigned int G = 0xff000000 & (((cr1 & 0x00ff00) * a) + ((cr2 & 0x00ff00) * b) + ((cr3 & 0x00ff00) * c) + ((cr4 & 0x00ff00) * d));
	const unsigned int B = 0x00ff0000 & (((cr1 & 0x0000ff) * a) + ((cr2 & 0x0000ff) * b) + ((cr3 & 0x0000ff) * c) + ((cr4 & 0x0000ff) * d));

	return R|((G|B)>>16);    
	}
	*/

	int CSeisWideDoc::getAmpRgbIndex(COLORREF col) {
		for (int i = 1; i<ampColorDyn.num; i++) {
			if ( RGB(ampColorDyn.r[i], ampColorDyn.g[i], ampColorDyn.b[i]) == col ) return i;
		}
		return ampColorDyn.num /2;
	}

	COLORREF CSeisWideDoc::getAmpRgbPixel(float amp, float amin, float amax)
	{
		return getAmpRgbPixel(amp);
		/*
		// will use global struct seisBiColor, global variable draw.ampMax
		if (amin==amax || (ampColorDyn.r == NULL && !getAmpColorArray()) ) return RGB(0,0,0);
		if (ampColorDyn.num == 0) return RGB(0,0,0);

		if (amax < MINAMP) amax = (float)head.maxAmp;
		if (amax < MINAMP) amax = 1.f; // invalid max amp. So we use 1.f only

		if (amp < amin) amp = amin;
		else if (amp > amax) amp = amax;

		float ampPercent = ampColorDyn.percent[0] + 
		(ampColorDyn.percent[ampColorDyn.num-1] - ampColorDyn.percent[0]) *
		(amp - amin) / (amax - amin);

		for (int i = 1; i<ampColorDyn.num; i++) {
		if (ampPercent >= ampColorDyn.percent[i-1] && ampPercent <= ampColorDyn.percent[i]) {
		double rate =  (ampColorDyn.percent[i] == ampColorDyn.percent[i-1])  ?
		0.0
		:
		(ampPercent - ampColorDyn.percent[i-1]) / (ampColorDyn.percent[i] - ampColorDyn.percent[i-1]);
		return RGB(
		myRound((double)ampColorDyn.r[i-1] + (double)(ampColorDyn.r[i] - ampColorDyn.r[i-1]) * rate),
		myRound((double)ampColorDyn.g[i-1] + (double)(ampColorDyn.g[i] - ampColorDyn.g[i-1]) * rate),
		myRound((double)ampColorDyn.b[i-1] + (double)(ampColorDyn.b[i] - ampColorDyn.b[i-1]) * rate)
		);
		}
		}

		// now the rate is not covered. This cannot happen unless program erros
		if (ampPercent > ampColorDyn.percent[0])
		return RGB(ampColorDyn.r[0], ampColorDyn.g[0], ampColorDyn.b[0]);
		else {
		int n = ampColorDyn.num - 1;
		return RGB(ampColorDyn.r[n], ampColorDyn.g[n], ampColorDyn.b[n]);
		}
		*/
	}

	COLORREF CSeisWideDoc::getAmpRgbPixel(float amp)
	{
		// will use global struct seisBiColor, global variable draw.ampMax
		if (ampColorDyn.r == NULL && !getAmpColorArray() ) return RGB(0,0,0);
		if (ampColorDyn.num == 0) return RGB(0,0,0);

		float p1 = ampColorDyn.percentAmp[0];
		float p2 = ampColorDyn.percentAmp[2];
		float p3 = ampColorDyn.percentAmp[8];
		float p4 = ampColorDyn.percentAmp[10];

		//float ampPercent = ampColorDyn.percent[0] + 
		//	(ampColorDyn.percent[ampColorDyn.num-1] - ampColorDyn.percent[0]) *
		//	(amp + head.maxAmp) / (head.maxAmp*0.5);

		int iSel = 0;
		//double ampPercent = ampColorDyn.percent[0] + 
		//	(ampColorDyn.percent[ampColorDyn.num-1] - ampColorDyn.percent[0]) *
		//	(amp + head.maxAmp) / (head.maxAmp*0.5);

		for (int i = 1; i<ampColorDyn.num; i++) {
			if (amp >= ampColorDyn.percentAmp[i-1] && amp <= ampColorDyn.percentAmp[i]) {
				double rate =  (ampColorDyn.percentAmp[i] == ampColorDyn.percentAmp[i-1])  ?
					0.0
					:
				(amp - ampColorDyn.percentAmp[i-1]) / (ampColorDyn.percentAmp[i] - ampColorDyn.percentAmp[i-1]);
				return RGB(
					myRound((double)ampColorDyn.r[i-1] + (double)(ampColorDyn.r[i] - ampColorDyn.r[i-1]) * rate),
					myRound((double)ampColorDyn.g[i-1] + (double)(ampColorDyn.g[i] - ampColorDyn.g[i-1]) * rate),
					myRound((double)ampColorDyn.b[i-1] + (double)(ampColorDyn.b[i] - ampColorDyn.b[i-1]) * rate)
					);
			}
		}

		// now the rate is not covered. This cannot happen unless program erros
		if (amp > ampColorDyn.percentAmp[0])
			return RGB(ampColorDyn.r[0], ampColorDyn.g[0], ampColorDyn.b[0]);
		else {
			int n = ampColorDyn.num - 1;
			return RGB(ampColorDyn.r[n], ampColorDyn.g[n], ampColorDyn.b[n]);
		}
	}

	void CSeisWideDoc::OnEditDisplaytuneupAdjustinglabelsizes() 
	{
		// TODO: Add your command handler code here
		CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
		ASSERT(pFrame);
		ASSERT_KINDOF(CMainFrame, pFrame);


		CdlgLabelSizes dlg;
		dlg.m_LabelNumberHeigth = pFrame->fLabelDistance3;
		dlg.m_LabelNumberWidth = pFrame->fLabelDistance3;
		dlg.m_LabelSize = pFrame->fLabelDistance3;
		if (dlg.DoModal() == IDOK)
		{
			pFrame->fLabelDistance3 = dlg.m_LabelSize;
		}
		else return;

		SetModifiedFlag();
		UpdateAllViews(NULL);
		NotifyChanged();
	}

	BOOL CSeisWideDoc::myDigSaveAs(CString aName)
	{
		// this means that the backup file is the same as target file. It'll just overwrite the file.
		CDigitize pDg;
		dig.digName = aName;
		return pDg.myDigSaveAs(&dig, dig.isSorted, dig.isSortedY, tx.xShot);
	}

	BOOL CSeisWideDoc::myDigSaveAs(CString aName, CString aNameOrig)
	{
		CDigitize pDg;
		dig.digName = aName;
		return pDg.myDigSaveAs(&dig, dig.isSorted, dig.isSortedY, tx.xShot);
	}








	BOOL CSeisWideDoc::myDigSaveAsWithZplot(CDigitize::DIGITIZE *dig2, CString aName, BOOL isSort, BOOL isSortY, CString strRemarkLine)
	{
		//	if(!dig2->isZeltFormat2) { //Here a plain text format is chosen.
		//		CString CSeisWideDoc::myDigSaveAsPlain(CDigitize::DIGITIZE *dig2, CString aName, CString aNameOrig, BOOL isSort, BOOL isSortY)

		if (dig2->isZeltFormat2) {
			isSort = TRUE;
			isSortY = FALSE;
		}

		// isSort=TRUE would mean it'll sort the data points before saving. Sometimes we do not want to sort the points however.
		if (aName.IsEmpty()) aName = GetFileNameAppendExt(draw.timeSecName, _T("_digiAuto"), _T("txt"));

		float t1,t2,t3;
		short n, k;
		int fileFormat=0;
		FILE *stream;
		long i,j;

		CString aNameBak;
		aNameBak = aName+".bak";
		if( _tfopen_s(&stream, aName, _T("w") ) != 0) {
			CString aExt;
			if(!dig2->isZeltFormat2) aExt = _T("txt");
			else aExt = _T("in");
			CFileDialog dlg( FALSE,aExt,dig2->digName,
				OFN_OVERWRITEPROMPT|OFN_EXPLORER,
				_T("File name for the digfitized points (*.")+aExt+")|*."+aExt+"|");
			//	dlg.m_ofn.lpstrTitle = _T("Each shot number in one line please";
			if(dlg.DoModal()==IDOK) {
				BOOL a = myDigSaveAs(dlg.GetPathName(), dig2->digName); 
				if (a) {
					dig2->digName = dlg.GetPathName();
				}
				return a;
				// dig2->digName = a;  // do not update the digName, otherwise it may crash
			}
		}
		// why do we need a backup file before overwriting ?
		// This is because our digitized array in memory only reads in for a 
		// particular source. When we save the digitized data, we do not want 
		// to overwrite data for a different shot.----- solved
		//


		FILE *streamZplot = NULL;
		//int countTrace = 0;
		//float *ptrace = NULL;
		//float *pdist = NULL;

		if (gIsZplotFormat && isFileExistNotDirectory(draw.timeSecName) ) {

			if( _tfopen_s( &streamZplot, aName+"Zplot.txt", _T("w+") ) != 0 ) {
				AfxMessageBox(_T("File could not be opened to write."));
				return FALSE;
			}

			// if segy file name exists, try to save trace numbers in addition to the distance km.
			//CFile file;
			//if (!file.Open(draw.timeSecName, CFile::modeRead | CFile::typeBinary)) {
			// if (streamZplot) fclose(streamZplot);
			// return FALSE;
			//}


			//file.Seek(3200, CFile::begin);
			//bhed bh;
			//segy tr;
			//if(file.Read(&bh, 400) < 400) {
			// fclose(stream);
			// file.Close();
			// return FALSE;
			//}

			//long len = 0;
			//if(bh.format!=3)  len = bh.hns*4 + 240;
			//else len = bh.hns*2 + 240;

			//while (file.Read(&tr, 4)==4) {
			// countTrace++;
			// file.Seek(len-4, CFile::current);
			//}

			//ptrace = (float *)ealloc1float(countTrace+1);  // must add 1 more point for work space
			//pdist = (float *)ealloc1float(countTrace+1);
			//int j = 0;
			//file.Seek(3600, CFile::begin);
			//while (file.Read(&tr, 24)==24) {
			// ptrace[j] = (float)tr.tracl;
			// pdist[j] = (para.isDistanceDisplay)  ?   getDistance(&tr)  :  getOffset(&tr);  // in km
			// j++;
			// file.Seek(len-24, CFile::current);
			// //  if (j>= countTrace) break;
			//}
			//countTrace = j;  // make sure it does not overflow.
			//file.Close();
			//sort2(countTrace, pdist, ptrace);
		} // if (!draw.timeSecName.IsEmpty())







		// there may be some points not in proper order. Let's correct for this
		CDigitize pDg;
		pDg.myDigSort(dig2, isSort, FALSE, pCd.coord.xmin, pCd.coord.xmax);

		if (!strRemarkLine.IsEmpty())
			_ftprintf_s(stream,_T("#%s\n"), strRemarkLine);

		CString tStr;

		if(!dig2->isZeltFormat2)
		{	//Here a plain text format is chosen.

			// first, we remove an irregularity
			for (i=0; i<dig2->totCurve; i++)
			{
				for (j=0; j<dig2->nPoint[i]; j++)
				{
					if (dig2->x[j][i] < -99999. && dig2->t[j][i] < -99999.) {
						pDg.myDigRemove(dig2, j, i); // this changes the num of points for this curve
						break;
					}
				}
			} // for


			for (i=0; i<dig2->totCurve; i++)
			{
				tStr = dig2->labelArr->ElementAt(i);
				for (j=0; j<dig2->nPoint[i]; j++)
				{
					t1 = dig2->x[j][i];
					t2 = dig2->t[j][i];
					_ftprintf_s(stream,_T(" %11.5f %11.5f %s"),t1,t2, tStr);
					if (head.dist!=NULL) {
						int kk = getClosestIndex(head.dist, head.numTraces, t1);
						if (kk>= 0) {
							_ftprintf_s(stream,_T("  %9d"), (UINT)head.traces[kk]);
							_ftprintf_s(streamZplot,_T("%6d %5d %5s %11.3f\n"),1,(UINT)head.traces[kk],tStr,t2);
						}
					}
					_ftprintf_s(stream,_T("\n"));

				}
			}


		}	//End for plain text format option.
		else {

			if (isFileExistNotDirectory(aNameBak) ) {

				// We first want to put all dig points that are not of the same source, and write as is.
				// We will EXCLUDE any dig points that have the same source as the active one.
				// This way, we can append the active data to the end of the file.
				FILE  *streamBak;

				if (_tfopen_s( &streamBak, aNameBak, _T("r") ) != 0) {
					TCHAR line[MAXLINE];
					BOOL firstTim=TRUE, textErr=FALSE ;
					while (_fgetts(line,MAXLINE,streamBak)!=NULL)
					{
						if (_tcslen(line) < 2) continue;
						if (line[0] == '#') continue; // we do not need comment lines
						if (_stscanf_s(line,_T("%f%f%f%d"),&t1, &t2, &t3, &k)==0)
						{
							textErr=TRUE; 
							continue;
						}
						else if(k==0 && fabs(t2) == 1.0f)
						{ // Start one side of the OBS.
							//if here then decide the shot location.
							if(!isXShotDefined(tx.xShot)) tx.xShot=t1;

							if(fabs(tx.xShot-t1)<=0.00001f)
							{
								// this shot needs to be excluded.
								while (_fgetts(line,MAXLINE,streamBak)!=NULL) {
									if (_tcslen(line) < 2) continue;
									if (line[0] == '#') continue; // we do not need comment lines
									if (_stscanf_s(line,_T("%f%f%f%d"),&t1, &t2, &t3, &k)==0) break;
									if(k==0 && (fabs(t2) == 1.0f) && 
										fabs(tx.xShot-t1)>0.00001f) {
											break;
									}
									else if((fabs(t2)-1.0f)<0.00001f && k== -1)
									{ //end of the file.
										break;
									}
								} // while
							}
							if(k>= 0) _ftprintf_s( stream, _T("%s"), line);
						}
						else if(k== -1)
						{ //end of the file; we do not want the last line
							// since it will be appended later
							continue;
						}
						else {
							// duplicate data except the end line
							_ftprintf_s( stream, _T("%s"), line);
						}
					}
					fclose(streamBak);

				} // if (streamBak 
			} // if (isFileExistNotDirectory(aName)


			_ftprintf_s( stream, _T(" %9.3f %9.3f %9.3f %9d\n"), tx.xShot,-1.f, 0.f, 0);
			n=0;
			for (i=0; i<dig2->totCurve; i++)
			{
				t3 = dig2->digResolution[i];
				BOOL newCurve = TRUE;
				for (j=0; j<dig2->nPoint[i]; j++)
				{
					t1 = dig2->x[j][i];
					if(!para.isDistanceDisplay) t1 += (float)tx.xShot;
					if(t1>tx.xShot) continue;
					if(newCurve) {n++; newCurve=FALSE;}
					t2 = dig2->t[j][i]; //reduction velocity is already accounted for.
					//   _ftprintf_s(stream," %9.3f %9.3f %9.3f %9d",t1,t2,t3,n);
					_ftprintf_s(stream,_T(" %9.3f %9.3f %9.3f %9d"),t1,t2,t3,dig2->ivray[i]);
					if (head.dist!=NULL && head.traces!=NULL) {
						int kk = getClosestIndex(head.dist, head.numTraces, t1);
						if (kk>= 0) {
							_ftprintf_s(stream,_T("  %9d"), (UINT)head.traces[kk]);
							// _ftprintf_s(streamZplot,"%6d %5d %5d %11.3f\n",1,(UINT)ptrace[kk],n,t2);
							_ftprintf_s(streamZplot,_T("%6d %5d %5d %11.3f\n"),1,(UINT)head.traces[kk],dig2->ivray[i],t2);
						}

					}
					_ftprintf_s(stream,_T("\n"));
				}
			}
			_ftprintf_s( stream, _T(" %9.3f %9.3f %9.3f %9d\n"), tx.xShot,1.f, 0.f, 0);
			n=0;
			for (i=0; i<dig2->totCurve; i++)
			{
				t3 = dig2->digResolution[i];
				BOOL newCurve = TRUE;
				for (j=0; j<dig2->nPoint[i]; j++)
				{
					t1 = dig2->x[j][i];
					if(!para.isDistanceDisplay) t1 += (float)tx.xShot;
					if(t1<tx.xShot) continue;
					if(newCurve) {n++; newCurve=FALSE;}
					t2 = dig2->t[j][i];
					//   _ftprintf_s(stream," %9.3f %9.3f %9.3f %9d",t1,t2,t3,n);
					_ftprintf_s(stream,_T(" %9.3f %9.3f %9.3f %9d"),t1,t2,t3,dig2->ivray[i]);
					if (head.dist!=NULL && head.traces!=NULL) {
						int kk = getClosestIndex(head.dist, head.numTraces, t1);
						if (kk>= 0) {
							_ftprintf_s(stream,_T("  %9d"), (UINT)head.traces[kk]);
							// _ftprintf_s(streamZplot,"%6d %5d %5d %11.3f\n",1,(UINT)ptrace[kk],n,t2);
							_ftprintf_s(streamZplot,_T("%6d %5d %5d %11.3f\n"),1,(UINT)head.traces[kk],dig2->ivray[i],t2);
						}
					}
					_ftprintf_s(stream,_T("\n"));
				}

			}
			_ftprintf_s( stream, _T(" %9.3f %9.3f %9.3f %9d\n"), 0.,0.,0.,-1 );

		}

		fclose( stream );

		//free1float (ptrace);
		//free1float (pdist);

		if (gIsZplotFormat) {
			fclose(streamZplot);
			showFileInNotePad(aName+"Zplot.txt");
		}

		return TRUE;
	}








	void CSeisWideDoc::OnDigitizingReviselinelabel() 
	{
		// this line is important to avoid crash
		if (!draw.isDigitizing || dig.iCurveSel < 0 || dig.iCurveSel > 99999) return;
		if (dig.isZeltFormat2) {
			myCaption(_T("Cannot change option for Zelt format"));
			return;
		}

		dlgDigOption DLG;
		DLG.m_label = dig.strComment;
		DLG.m_nCurve = dig.iCurveSel;
		DLG.m_isSort = dig.isSorted;
		DLG.m_isSortY = dig.isSortedY;

		if (DLG.DoModal() == IDOK) {
			dig.strComment = DLG.m_label;

			// I want to remove any spaces in dig.strComment
			// dig.strComment.Remove(_T(' '));

			dig.noPromptLabel = DLG.m_NotShow;
			dig.isSorted = DLG.m_isSort;
			dig.isSortedY = DLG.m_isSortY;
		}

		UpdateAllViews(NULL);
		NotifyChanged();
	}

	// private function
	//void CSeisWideDoc::myLineDrawingLabelDepreciated(CDC *pDC)
	//{
	//	// plot the labels for line drawngs, or during digitization. Can be either in time or depth domain
	//	//return; // now we do not plot the labels, otherwise it looks messy. When I got time, 
	//	//         I can improve the label display here!
	//
	//
	//	if (draw.isNoLabelInSide || !dig.isLabelShow) return;
	//	if (dig.nPoint==NULL) return;  // this avoids program crash
	//	long i, j;
	//	float xpos,ypos;
	//	int numRef = 7000; // cannot make this floating
	//
	////	char s[8];
	//     CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	//	LOGFONT logFontNum;
	//	pDC->GetCurrentFont()->GetLogFont(&logFontNum);
	//	float xyRatio = (float)logFontNum.lfWidth / (float)logFontNum.lfHeight;
	//	int numWidth = (LONG)myRound(pFrame->fLabelDistance3 * 150.);
	//	int numHeight = (LONG)(numWidth / xyRatio);
	//
	//	logFontNum.lfHeight = (int)numHeight;
	//	logFontNum.lfWidth = (int)numWidth;
	//	logFontNum.lfEscapement = 0;
	//	logFontNum.lfOrientation = 0;
	//	logFontNum.lfWeight = FW_NORMAL;
	//	logFontNum.lfWeight = FW_BOLD;
	//	logFontNum.lfItalic = 0;
	//	logFontNum.lfUnderline = 0;
	//	logFontNum.lfStrikeOut = 0;
	//	logFontNum.lfCharSet = ANSI_CHARSET;
	//	logFontNum.lfOutPrecision = OUT_DEFAULT_PRECIS;
	//	logFontNum.lfClipPrecision = CLIP_DEFAULT_PRECIS;
	//	logFontNum.lfQuality = DEFAULT_QUALITY;
	//	logFontNum.lfPitchAndFamily = FF_SWISS;
	//	_tcscpy_s(logFontNum.lfFaceName, _T("Arial"));
	//	CFont* fontN = new CFont(); 
	//	fontN->CreateFontIndirect(&logFontNum);
	//	CFont* oldFont = pDC->SelectObject(fontN);
	//	COLORREF oldColor = pDC->SetTextColor(RGB(10, 10, 10));
	//
	//	for (i=0; i<dig.totCurve; i++)
	//	{
	//		//CString ttt = dig.labelArr->ElementAt(i);
	//		if (_tcslen(dig.labelArr->ElementAt(i)) < 1) {
	//			continue;
	//		}
	//		// added Jan 2007 to plot labels for this curve
	//		// first, we get the center x
	//		//double xMin = 9999999.; 
	//		//double xMax = -9999999.; 
	//		//for (j=0; j<dig.nPoint[i]; j++)
	//		//{
	//		//	xpos = dig.x[j][i];
	//		//	if (xMin>=xpos) xMin = xpos;
	//		//	if (xMax<=xpos) xMax = xpos;
	//		//}
	//		//xpos = (float)(xMin + (xMax-xMin)*0.5);
	//		j = dig.nPoint[i]-1;
	//		if (j<1) continue;
	//		if ( fabs(dig.t[j][i] - dig.t[j-1][i]) < 0.1) {
	//			xpos = dig.x[j-1][i];
	//			ypos = dig.t[j-1][i];
	//		}
	//		else {
	//			xpos = dig.x[j][i];
	//			ypos = dig.t[j][i];
	//		}
	//		if (isTimeDomain() && draw.mode != 10){
	//			ypos -= (float)getReduceTime(getOffsetFromXVal(xpos), para.vred);
	//
	//		}
	//
	//			if (myFloat2(para.vred) == 0.0f) {
	//				xpos *= draw.markerXMultFactor;
	//				xpos += draw.markerXShift;
	//				if (draw.markerIsRevYAxis) ypos = -ypos;
	//				ypos *= draw.markerYMultFactor;
	//				ypos += draw.markerYShift;
	//			}
	//
	//		// now plot the labels for this curve i
	//		CPoint p = pCd.mm_coordz(xpos,ypos);
	//		pDC->TextOut((int)(p.x), (int)(p.y-numHeight*0.5), dig.labelArr->ElementAt(i));
	//	} // for i
	//
	//	pDC->SelectObject(oldFont);
	//	pDC->SetTextColor(oldColor);
	//	fontN->DeleteObject();
	//	delete fontN;
	//}

	void CSeisWideDoc::OnEditDisplaytuneupModelpropertiesLinedrawinglabel() 
	{
		draw.isNoLabelInSide = !draw.isNoLabelInSide;
		UpdateAllViews(NULL);
		NotifyChanged();

	}




	// Load xshot,zshot information from ray parameter file draw.rayName
	// it will output results into arrays:  tx.shots[k][0], tx.shots[k][1]
	// where k indexes to all xshot and zshot  listing
	int CSeisWideDoc::loadRayPara(void)
	{
		int i,k,m;
		CString cs, csDig;
		FILE *ifh = NULL;
		TCHAR line[255];
		k = tx.nShot = 0;
		if (isFileExistNotDirectory(draw.rayName)) {
			// now load the contents of this ray parameter file
			if (_tfopen_s(&ifh, draw.rayName, _T("r")) != 0) {
				tx.nShot = 0;
				return 0;
			}
			while (_fgetts(line, 255, ifh) != NULL) {
				cs.Format(_T("%s"), line);
				if (cs.GetLength() <= 0) continue;

				if (cs.Find(_T("&pltpar")) >= 0) {
					// we store colour codes here only, for plotting in the T-X curves.
					// the colour codes have to match the ones defined in the ray parameter file
					// since the raypath plotting uses this colour codes as done by Zelt's fortran program
					for (m=0; m<100; m++) {
						if ( (i=cs.Find(_T("colour"))) >= 0) {
							while ( (i = cs.Find(_T("colour"))) >= 0) {
								cs = cs.Mid(i+5);
								cs = cs.Mid(cs.Find('=')+1);
								k = 0;
								for (i=0; i<100; i++) {
									int iWordEnd = cs.FindOneOf(_T(", "));
									if (iWordEnd < 0) break;
									csDig = cs.Left(iWordEnd);
									csDig.Trim();
									if (csDig.GetLength() == 0) {
										cs = cs.Mid(1);
										continue;
									}
									tx.colour[k] = _tstoi(csDig);
									k++;
									tx.ncolour = k;
									cs = cs.Mid(iWordEnd+1);
								}
							} // while
							break;
						} // if
						if (_fgetts(line, 255, ifh) != NULL) {
							cs.Format(_T("%s"), line);
						}
					} // for k
				} // if

				if (cs.Find(_T("&end")) >= 0) {
					// we strip all codes in the array except the final comments
					tx.rayCodes->RemoveAll();
					continue;
				}
				else {
					// we store the readings into array
					tx.rayCodes->Add(cs);
				}

				// now find out the xshot,zshot pairs
				i = cs.Find(_T("xshot"));
				if (i>=0) {
					cs = cs.Mid(i+5);
					cs = cs.Mid(cs.Find('=')+1);
					k = 0;
					for (i=0; i<100; i++) {
						int iWordEnd = cs.FindOneOf(_T(", "));
						if (iWordEnd < 0) break;
						csDig = cs.Left(iWordEnd);

						csDig.Trim();
						if (csDig.GetLength() == 0) {
							cs = cs.Mid(1);
							continue;
						}
						tx.shots[k][0] = (float)_tstof(csDig);
						k++;
						cs = cs.Mid(iWordEnd+1);
					}
				} // if i

				i = cs.Find(_T("zshot"));
				if (i>=0) {
					cs = cs.Mid(i+5);
					cs = cs.Mid(cs.Find('=')+1);
					// cs = cs.Right('=');
					k = 0;
					for (i=0; i<100; i++) {
						int iWordEnd = cs.FindOneOf(_T(", "));
						if (iWordEnd < 0) break;
						csDig = cs.Left(iWordEnd);
						csDig.Trim();
						if (csDig.GetLength() == 0) {
							cs = cs.Mid(1);
							continue;
						}
						tx.shots[k][1] = (float)_tstof(csDig);
						k++;
						cs = cs.Mid(iWordEnd+1);
					}
				} // if i


				i = cs.Find(_T(" ray"));
				if (i>=0) {
					cs = cs.Mid(i+5);
					cs = cs.Mid(cs.Find('=')+1);
					// cs = cs.Right('=');
					k = 0;
					for (i=0; i<100; i++) {
						int iWordEnd = cs.FindOneOf(_T(", "));
						if (iWordEnd < 0) break;
						csDig = cs.Left(iWordEnd);
						csDig.Trim();
						if (csDig.GetLength() == 0) {
							cs = cs.Mid(1);
							continue;
						}

						tx.rayCodeIn[k] = (float)_tstof(csDig);
						k++;
						cs = cs.Mid(iWordEnd+1);
					}
				} // if i

				i = cs.Find(_T("ivray"));
				if (i>=0) {
					cs = cs.Mid(i+5);
					cs = cs.Mid(cs.Find('=')+1);
					// cs = cs.Right('=');
					k = 0;
					for (i=0; i<100; i++) {
						int iWordEnd = cs.FindOneOf(_T(", "));
						if (iWordEnd < 0) break;
						csDig = cs.Left(iWordEnd);
						csDig.Trim();
						if (csDig.GetLength() == 0) {
							cs = cs.Mid(1);
							continue;
						}

						tx.ivray[k] = _tstoi(csDig);
						k++;
						cs = cs.Mid(iWordEnd+1);
					}
				} // if i

			} // while
			fclose(ifh);
		} // if isFileExist
		else {
			// CString a;
			// a.Format(_T("Ray parameter file invalid: %s", draw.rayName);
			// this->myCaption(a);
		}
		tx.nShot = k;
		return k;
	}

	// Now, all calls for getting xShot info should come from here only!!!
	void CSeisWideDoc::setXShotAll(void) {
		if (!isXShotDefined(tx.xShot)) {
			// load xshot,zshot information from ray parameter file draw.rayName
			if ( loadRayPara()==0)
				tx.xShot = tx.shots[0][tx.iShot] = getXShotInSegy(draw.timeSecName);

			if ( !isXShotDefined(tx.xShot) && tx.nShot>0 ) {
				// when tx.xShotInSegy not defined, we use the one in tx.shots[tx.iShot][0]
				if (tx.iShot < 0) { 
					tx.iShot = 0;
					tx.xShot = tx.shots[0][0];
				}
				else if (tx.iShot< 100) {
					tx.xShot = tx.shots[tx.iShot][0];
				}
			}
		} // if !isXS
	}





	void CSeisWideDoc::OnDigitizingRaycodes()
	{
		// TODO: Add your command handler code here
		draw.isShowRaycode = !draw.isShowRaycode;
		UpdateAllViews(NULL);
		NotifyChanged();
	}

	void CSeisWideDoc::myCaption(CString text)
	{
		CMainFrame* pFrame = 
			(CMainFrame*)AfxGetMainWnd();
		ASSERT(pFrame);
		ASSERT_KINDOF(CMainFrame, pFrame);
		CString tStr;
		pFrame->GetWindowText(tStr);
		CString a = text.Left(50);
		CString b = tStr.Left(50);
		if (a != b) {
			a.Format(_T("%s ... %s"), text.GetString(), tStr);
			text = a.Left(255);
		}



		//if (pFrame->m_pWndCurrentChildOld) {
		// (CMDIChildWnd  *)pFrame->m_pWndCurrentChildOld->getact
		//}

		pFrame->SetMessageText(text);
		pFrame->m_wndStatusBar.Invalidate();
		pFrame->m_wndStatusBar.UpdateWindow();

	}

	// working path: important. Back slash at the end shall be returned as well.
	CString CSeisWideDoc::getWorkingPathSlash()
	{
		// first, try the current .SEI file, then try the velMod file, then try the draw.timeSecFile, 
		// if all failed, return the current directory
		//CString name = m_strPathName;
		//int nPathLength =  GetModuleFileName (NULL,name.GetBuffer(_MAX_PATH), _MAX_PATH );
		//name.ReleaseBuffer();

		CString aPath = GetPathFromFileSlash(this->GetPathName());
		if (isDirectoryExist(aPath)) return aPath;

		// now aPath does not exist
		aPath = GetPathFromFileSlash(velMod.velSecName);
		if (isDirectoryExist(aPath)) return aPath;

		// now aPath does not exist
		aPath = GetPathFromFileSlash(draw.timeSecName);
		if (isDirectoryExist(aPath)) return aPath;

		TCHAR curDir[_MAX_PATH];
		GetCurrentDirectory(_MAX_PATH, curDir);
		aPath = (CString)curDir;

		int pos = aPath.ReverseFind(_T('\\'));
		int len = aPath.GetLength();
		if(pos != len-1)
			aPath += _T('\\');

		return aPath;
	}


	// Get a color from a file for a given ray code. If not existing in the file, create the file. 
	COLORREF CSeisWideDoc::getRaycodeColor(int irrCol)
	{
		return getRaycodeColor(irrCol, FALSE);
	}

	COLORREF CSeisWideDoc::getRaycodeColor(float rayCode)
	{
		// we first calculate irrCol based on rayCode in tx struct
		int irrCol = 0;
		for (int i=0; i<100; i++) {
			if (tx.rayCodeIn[i] == rayCode) {
				irrCol = tx.ivray[i];
				break;
			}
		}

		return getRaycodeColor(irrCol, FALSE);
	}

	COLORREF CSeisWideDoc::getRaycodeColor(int irrCol, BOOL isColorRecalc)
	{
		if (irrCol == 0) return getRayColor(draw.TTCurveColor);

		CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
		if (irrCol >= RAYCODENUM) {
			irrCol -= (int)(irrCol/RAYCODENUM) * RAYCODENUM;
		}

		// by now, it is possible we have irrCol==0, in which case we would want to use it
		if (isColorRecalc || pFrame->gRayColor[irrCol] == 0) {
			// in selecting random colors, we want bright red, but if green and blue are full 255, we get pure white, which is not good.
			double r1 = rand()/(RAND_MAX + 1.0);
			double r2 = rand()/(RAND_MAX + 1.0);
			double r3 = rand()/(RAND_MAX + 1.0);
			//pFrame->gRayColor[irrCol] = RGB( (int)(220*r1)+34, (int)(200*r2)+54, (int)(200*r3)+54 );
			//pFrame->gRayColor[irrCol] = RGB( 
			// (int)(220*r1)+34, 
			// (int)(200*r2)+54, 
			// (int)(200*r3)+54 
			// );

			// the following line makes the colors very pure.
			int r = (int)(255* (int)(r1+0.5) );
			int g = (int)(255* (int)(r2+0.5) );
			int b = (int)(255* (int)(r3+0.5) );

			if (r>240 && g>240 && b>240) {
				// we do not want a pure white ray, since it may not be visible in some cases
				r = g = b = 240;
			}

			pFrame->gRayColor[irrCol] = RGB( r, g, b);
		}



		return pFrame->gRayColor[irrCol];
	}

	void CSeisWideDoc::OnDigitizingSavedigffid()
	{
		if (!draw.isDigitizing || dig.nPoint==NULL) return;
		CString a = dig.digName + _T(".tmpOut.txt");

		CDigitize pDg;
		dig.digName = a;
		if (pDg.myDigSaveWithFFID(&dig, head.numTraces, head.traces, head.dist, head.ffid, head.offsets)) 
			showFileInNotePad(a);
		else
			myCaption(_T("Failed to show digitize with FFID"));
	}



	// this function uses 2 global variables:
	// para.isDistanceDisplay      and      tx.xShotInSegy. 
	// NOTE: it may return negative offset when traces are on the left hand side of the source
	double CSeisWideDoc::getOffsetFromXVal(double x) {
		if (!isXShotDefined(tx.xShot)) {
			//CString txPath = getWorkingPathSlash();
			//if (!isDirectoryExist(txPath))
			//	txPath = _T("tx.out");
			//else
			//	txPath += _T("tx.out");
			tx.xShot = (float)getXPosAll();
		}
		if (!isXShotDefined(tx.xShot)) 
			return x;  // we give up after one try

		if (para.isDistanceDisplay) {
			// now x is in distance mode, how do we get offset?
			x -= tx.xShot;
		}


		return x;
	}

	// get reduced time in sec based on offset information. 
	//float CSeisWideDoc::getReduceTime(float offset) {
	//	return getReduceTime(offset, (float)para.vred);
	//}
	double CSeisWideDoc::getReduceTime(double offset, double vred)
	{
		if (!isTimeDomain()) return 0.f;
		return getReduceTimeEx(offset, draw.mode, (float)vred, para.waterVelocityAboveObs, para.waterVelocityAboveObs, para.obsDepth, para.gunDepth2);

		//// the following is disabledalthough they do work.
		//if (draw.mode == 6) return 0.f;  // this is trace display, without any reducing.
		//if (draw.mode == 10) return 0.f;  

		//// sometimes the refl time section does not show up. detailed debugging shows that it is 
		//// because the offset information is very wrong
		//// and the reduction velocity is not zero, causing delay time is be exceptionally high
		//if (draw.mode==0 && 
		//	para.isDistanceDisplay &&
		//	fabs(vred) > 0.001f &&
		//	fabs(offset) > 1000.0)
		//{
		//	// this condition implies a wrong reduction velocity. the reason for the complicated conditioning is
		//	// because I want the program to be versatile for any real situations
		//	myCaption(_T("Vred is forced 0 when offset >1000km in distance mode."));
		//	vred = 0.0f;
		//}

		//// double rvVred = (para.vred > 0.1 && para.vred < 10.0)  ?   1./para.vred  : 0.0;
		//double rvVred = !isFloatEqual(vred, 0.0f)  ?   1./vred  : 0.0;

		//double reducedTime = 0.0;
		//if (draw.mode==0) {
		//	reducedTime = rvVred * fabs(offset);	   //Apply reduction velocity.
		//} else {
		//	// if here then draw NMO mode.
		//	if (para.waterDepth<-10.f || para.waterDepth>15.f) {
		//		para.waterDepth = 0.f;
		//	}


		//	//		double adz = para.obsDepth - para.gunDepth;
		//	//		double adx = xpos-tx.xShotInSegy;
		//	//		reducedTime=para.rvVred*(sqrt(adz*adz+adx*adx)-adz);
		//	// if (!isFloatEqual(para.waterDepth, para.obsDepth)) {
		//	// note: this is the John Shilmald display for NMO
		//	// note: since para.waterDepth is new, it is not saved to .sei file. 
		//		// double tmpGun = para.waterDepth - para.gunDepth;
		//		//double tmpGun = para.waterDepth;
		//		double tmpOBS = para.waterDepth - para.obsDepth;
		//		//double tmpOffset2 = offset * 0.5; // half offset in km
		//		//tmpOffset2 *= tmpOffset2;  // half offset squared
		//		
		//		double halfOffset2 = offset * offset * 0.25; // half offset squared

		//		reducedTime=sqrt(halfOffset2+ para.waterDepth*para.waterDepth) + sqrt(halfOffset2 + tmpOBS*tmpOBS) - para.waterDepth*2.;
		//		// note: the above is the John Shilmald display for NMO
		//	// }
		//	//else {
		//	//	double tmpGun = para.waterDepth - para.gunDepth;
		//	//	double tmpOffset = offset; // offset in km
		//	//	reducedTime=sqrt(tmpGun*tmpGun+ tmpOffset*tmpOffset)-tmpGun;
		//	//		// note: the above is the gas hydrate display for NMO
		//	//}

		//	reducedTime*=rvVred;
		//}

		//return (float)reducedTime;
	}

	//float CSeisWideDoc::getVelocityMin(int icont)
	//{
	//	int j;
	//	float vmin = MIL;
	//	float v;
	//	for (j=0; j<velMod.nvel[icont][0]; j++)
	//	{
	//		v=velMod.vf[j][icont][0];
	//		if (v < vmin) vmin = v;
	//	}
	//
	//	return vmin;
	//}


	void CSeisWideDoc::OnTimeForwide()
	{
		// This routine converts wide-angle segy data from time to depth.
		if(!CheckTime(100))
		{
			return;
		}

		static float offsetMax = 20.f;
		static float stackWidth = 2.0f;
		static float stackWidth2 = 3.0f;
		static BOOL isRaytrace = TRUE;


		int j;
		int icont;
		CdlgWide2Depth dlg;
		dlg.m_xmax = (float)pCd.coord.xmax;
		dlg.m_xmin = (float)pCd.coord.xmin;

		// we have the issue of half offset after NMO
		if ( (dlg.m_xmax - dlg.m_xmin) < offsetMax) {
			// the user has already run this routine before, and the x bounds are too small
			//dlg.m_xmax += offsetMax*0.5f;
			//if (dlg.m_xmax > pCd.coord.xmax) dlg.m_xmax = (float)pCd.coord.xmax;
			//dlg.m_xmin = dlg.m_xmax - offsetMax;
		}

		if (draw.raymode < 0) draw.raymode = 0;

		dlg.m_depthSecName = (draw.depthSecName.IsEmpty())  ?  
			getFileNameAppend(draw.timeSecName, _T("_Depth")) : draw.depthSecName;


		dlg.m_dz = (float)vel.dz;
		dlg.m_zmax = (float)pCd.coord.zmax;
		dlg.m_zmin = (float)pCd.coord.zmin;
		dlg.m_timeSecName = draw.timeSecName;
		if(fabs(para.sphericOrder) > 100.f) para.sphericOrder = 0.f;
		dlg.m_sphericOrder = para.sphericOrder; //not saved in documents
		dlg.m_velSecName = velMod.velSecName;

		dlg.m_rayTracing = draw.rayName;
		dlg.m_floatName = velMod.floatName;
		dlg.m_rayMode = draw.raymode;
		dlg.m_offsetMax = offsetMax;

		dlg.m_isRaytrace = isRaytrace;
		dlg.m_tmin = (float)pCd.coord.tmin;
		dlg.m_tmax = (float)pCd.coord.tmax;
		dlg.m_stackWidth = stackWidth;
		dlg.m_stackWidth2 = stackWidth2;

		if (dlg.DoModal() == IDOK)
		{
			draw.rayName = dlg.m_rayTracing;
			velMod.floatName = dlg.m_floatName;
			offsetMax = dlg.m_offsetMax;
			draw.raymode = dlg.m_rayMode ;

			pCd.coord.xmax = dlg.m_xmax;
			pCd.coord.xmin = dlg.m_xmin;
			draw.depthSecName = dlg.m_depthSecName;
			vel.dz = dlg.m_dz;
			pCd.coord.zmax = dlg.m_zmax;
			pCd.coord.zmin = dlg.m_zmin;
			draw.timeSecName = dlg.m_timeSecName.Trim();
			para.sphericOrder = dlg.m_sphericOrder;	//not saved in documents
			velMod.velSecName = dlg.m_velSecName.Trim();

			isRaytrace = dlg.m_isRaytrace;
			pCd.coord.tmin = dlg.m_tmin;
			pCd.coord.tmax = dlg.m_tmax;
			stackWidth = dlg.m_stackWidth;
			stackWidth2 = dlg.m_stackWidth2;
		}
		else 
		{
			return;
		}
		if (!isFileExistNotDirectory(draw.timeSecName)) return;

		float stackWidthGradient = (stackWidth2 - stackWidth) / (float)(pCd.coord.zmax - pCd.coord.zmin);

		delete dlg;



		// fix up for dz, since it cannot be too big
		if (vel.dz*MIL > USHRT_MAX-1) vel.dz = (USHRT_MAX-1) / (double)MIL;


		draw.depthSecName = mySetFileExtension(draw.depthSecName, _T("sgy"));

		if(draw.depthSecName.IsEmpty()) return;


		//################### Prepare the raytracing
		if(!checkModelError(velMod.velSecName))
		{
			if(AfxMessageBox(_T("Current model has boundary overlaps; Raytracing may hang up if this model is used; Do you want to continue?"), MB_YESNO |MB_ICONINFORMATION) != IDYES)
			{
				return;
			}
		} 

		CString txoutName = _T("tx.outsemb");
		if (draw.raymode == 0) txoutName += _T("pp");
		else if (draw.raymode == 1) txoutName += _T("ps");
		else if (draw.raymode == 2) txoutName += _T("sp");

		CString astr;
		CString t;

		//make tx.out file in the same directory as velMod.velSecName.
		CString name = velMod.velSecName;
		int pathLen = name.ReverseFind( '\\' );
		t = name.Left(pathLen);
		t.MakeLower();
		if(pathLen<0) {
			TCHAR curDir[_MAX_PATH];
			GetCurrentDirectory(_MAX_PATH, curDir);
			t = (CString)curDir;
		}
		CString txPath;
		if (!isEndWith(t, _T("temp")))
			txPath.Format(_T("%s\\temp"), t);
		else
			txPath = t;



		if(!isDirectoryExist(txPath)) {
			// create the temp dir
			if (!CreateDirectory(txPath, NULL)) {
				astr.Format(_T("Cannot create a working directory: %s"), txPath);
				AfxMessageBox(astr);
				return;
			}
		}
		SetCurrentDirectory(txPath);


		// copy r.in. Note: allways apply anisotropy because we are only 2DNMO for near-offset
		t = txPath+"\\r.in";
		CString tempStr = draw.rayName;
		tempStr.MakeLower();
		if (tempStr != t &&  tempStr != _T("r.in")) {
			CopyFile(draw.rayName, t, FALSE);
		}

		// copy v.bin
		tempStr = velMod.velSecName;
		tempStr.MakeLower();
		t = txPath+"\\v.bin";
		if(tempStr != t && tempStr != _T("v.bin") ) {
			CopyFile(velMod.velSecName, _T("v.bin"), FALSE);
		} 

		if (pCd.coord.zmax < pCd.coord.zmin) pCd.coord.zmax = pCd.coord.zmax + 1.;
		int nz = (int)((pCd.coord.zmax - pCd.coord.zmin) / vel.dz + 1.0);
		if (nz > 6000) {
			nz = 6000;  // fortran program has this array limit to impose
			pCd.coord.zmax = pCd.coord.zmin + (nz-1)*vel.dz;
			AfxMessageBox(_T("Max depth adjusted due to array size limitation of 3000 points. Contact programer to increase size if needed."));
			OnTimeForwide();
			return;
		}


		//##################### now do the raytracing
		if ( !isXShotDefined(tx.xShot) ) {
			//CString txPath = getWorkingPathSlash();
			//if (!isDirectoryExist(txPath))
			//	txPath = _T("tx.out");
			//else
			//	txPath += _T("tx.out");
			tx.xShot = (float)getXPosAll();
		}
		//Do not refresh screen in any way until raytracing finished. Otherwise, 
		// it may refresh screen while raytracing is running!
		draw.isSameDataDisplay = TRUE; 
		CString fileContour = _T("");

		if (isRaytrace) {
			// generate f.insemb file
			fileContour = this->setContour4Raytrace(txPath+_T("\\f.insemb"), (float)tx.xShot, (float)vel.dz, (float)pCd.coord.zmin, &pCd.coord.zmax, 1.5f, 8.f, 0.1f);
			if (fileContour.IsEmpty()) {
				AfxMessageBox(_T("Failed to generate f.insemb file"));
				return;
			}
			astr.Format(_T("%s\\%s*"), txPath, txoutName);
			CShellFileOp sfo;
			BOOL         bAPICalled;
			int          nAPIReturnVal;
			sfo.AddSourceFile (astr);
			sfo.SetOperationFlags
				( FO_DELETE,         // the operation type (delete in this case)
				AfxGetMainWnd(), // pointer to parent window
				FALSE,           // flag - silent mode?
				FALSE,           // flag - allow undo?
				FALSE,           // flag - should wild cards affect files only?
				TRUE,            // flag - suppress confirmation messages?
				TRUE,            // flag - suppress confirmation messages 
				// when making directories?
				FALSE,           // flag - rename files when name collisions occur?
				FALSE );         // flag - simple progress dialog?
			if ( sfo.Go ( &bAPICalled, &nAPIReturnVal ) )
			{
				// The operation succeeded!
			}


			// start generating string for fortran batch procoessing
			name = m_strPathName;
			int nPathLength =  GetModuleFileName (NULL,name.GetBuffer(_MAX_PATH), _MAX_PATH );
			name.ReleaseBuffer();
			CString progPath = "\"" + name.Left(name.ReverseFind( '\\' )) + ("\\sembRayinvr.exe\"");
			// progPath += ("\\sembRayinvr.exe\"");


			CString str;
			str.Format(_T(" %3d %3d %6.3f"), 0, draw.raymode, 1.5f);
			progPath += str;
			myProcess(progPath, txPath);

			if(AfxMessageBox(_T("Please wait for the raytracing program to finish. Click YES when finished raytracing. Click NO to quit."), MB_YESNO |MB_ICONINFORMATION) == IDNO) {
				return;
			}
			isRaytrace = FALSE; // the next time it runs the same routine, it will be prompted as not raytracing again.
		}

		if (fileContour.IsEmpty()) fileContour = txPath+"\\myf.txt";

		float vPerturb = 1.5f;
		astr.Format(_T("%s\\%s%5.3f"), txPath, txoutName, vPerturb);
		CStringArray *txArray = getLinesFromFile(astr);
		if (txArray == NULL) {
			AfxMessageBox(_T("Failed to load the raytraced results."));
			return;
		}




		CStringArray *xzContourArray = getLinesFromFile(fileContour);
		int npoint = 0;
		int izOld = 0;
		int i,iz;
		float f1,f2,f7,f8;
		int np_max = 30;
		bool isProb = false;
		for (icont=0; icont<velMod.ncont; icont++)
		{
			if (npoint < velMod.nzed[icont]) npoint = velMod.nzed[icont];
		}
		float **xArray = (float **)ealloc2float(npoint*2, nz);
		float **zArray = (float **)ealloc2float(npoint*2, nz);    // data for the floating reflectors.
		int *nArray = (int *) ealloc1int(nz);
		i = 0;
		for (j=0; j<xzContourArray->GetSize(); j++) { 
			if ( _stscanf_s(xzContourArray->ElementAt(j).Trim(), _T("%f%f%d"),&f1, &f2, &iz) == 0) continue;
			if (iz >= nz) {
				// if here, the raytracing data does not exactly match the current paramaters. The user 
				// will have to raytrace again.
				isProb = true;
			}
			if (iz != izOld) {
				nArray[izOld] = i;
				i = 0;
				izOld = iz;
			}
			xArray[iz][i] = f1;
			zArray[iz][i] = f2;
			i++;
		} // if j
		nArray[iz] = i; // last line needs to assign
		xzContourArray->RemoveAll();
		xzContourArray = NULL;

		if (iz != nz-1) isProb = true;
		if (isProb) {
			free2float (xArray);
			free2float (zArray);
			free1int (nArray);
			astr = _T("Parameter in the raytracing mismatches. Please rerun this processing.");
			AfxMessageBox(astr);
			OnTimeForwide();
			return;
		}



		// ################### Use the raytracing results to form segy output
		segy tr;
		bhed bh;

		CFile file;
		if (!file.Open(draw.timeSecName, CFile::modeRead | CFile::typeBinary)) {
			return;
		}
		file.Seek(0, CFile::begin);
		UINT bytesRead = file.Read(head.ascHead, 3200L);
		if(bytesRead < 3200) 
			AfxMessageBox(_T("Ascii section header read wrong"));
		file.Read(&bh, sizeof(bhed));
		if(bytesRead < 400) 
			AfxMessageBox(_T("Binary section header read wrong"));
		//The following numbers have to be recalculated everytime,
		//because plotting the depth section will change these numbers.

		int numsamp = bh.hns; 
		int format = bh.format;
		// backup the original format since bh.format will be overwritten for output header
		int len = (format!=3) ? (numsamp*4 + 240) : (numsamp*2 + 240);
		int tpp = bh.hdt;

		long nzmin = (int)myRound (pCd.coord.zmin / vel.dz);
		long nzmax = nzmin + nz;
		float dtField = (float)((double)tpp / (double)MIL);

		//For progress control, need to know the last bytes no.
		ULONGLONG curBytesRead, totBytesRead = file.GetLength();
		file.Seek(3600, CFile::begin);

		//Begin progress control.
		CMainFrame* pFrame = 
			(CMainFrame*)AfxGetMainWnd();
		ASSERT(pFrame);
		ASSERT_KINDOF(CMainFrame, pFrame);
		pFrame->BeginProgress();

		int nxmax = 0;  // total number of traces in the input segy file
		while (file.Read(&tr, 4) == (UINT)4)
		{
			file.Seek(len-4, CFile::current);
			nxmax ++;
		}
		file.Seek(3600, CFile::begin);

		// allocate array big enough for storing all the input segy data in memory
		segydynamic *trArr = (segydynamic *)malloc( sizeof(segydynamic) * nxmax );
		if (ERROR == trArr) return;
		for (j=0; j<nxmax; j++) {
			//trArr[j].data = (float *)malloc(sizeof(float)*(numsamp));
			trArr[j].data = ealloc1float(numsamp);
			if (ERROR == trArr[j].data) {
				// clean up before return
				for (int jj=0; jj<j-1; jj++) {
					//free(trArr[jj].data); 
					free1float(trArr[jj].data);
					trArr[jj].data = NULL;
				}
				AfxMessageBox(_T("Sorry, failed to allocate memory for loading all traces into memory."));
				return;
			}
		} // for j


		int nxStore = 0;
		if (tx.xShot <= ERRORVAL) tx.xShot = 0.;  // a fix
		while (file.Read(&tr, len) == (UINT)len)
		{
			//Formulating velocity traces first.
			curBytesRead = file.Seek(0, CFile::current);
			int iPos = (int)((double)curBytesRead/(double)totBytesRead*100.);
			if(iPos<0)iPos=0;
			if(iPos>100)iPos=100;
			pFrame->SetProgress(iPos);

			if(tr.trid == 2) //dead traces.
			{
				file.Seek(len, CFile::current); 
				continue ;
			}


			// assign only the trace header to the trArr[]
			memcpy( (void *)&trArr[nxStore], (void *)&tr, 240L);

			// Note: format points to the original data in time, while bh.format  is already modified for output
			if(format==3)
				for (j=0; j<numsamp; j++) trArr[nxStore].data[j] = (float)tr.dat.datashort[j];
			else if (format==1) {
				ibm_to_float((int *) tr.dat.data, (int *) tr.dat.data, (int)numsamp);
				for (j=0; j<numsamp; j++) trArr[nxStore].data[j] = (float)tr.dat.data[j];
			}
			else if (format==2) 
				for (j=0; j<numsamp; j++) trArr[nxStore].data[j] = (float)tr.dat.dataint[j];
			else if (format==5) {
				for (j=0; j<numsamp; j++) trArr[nxStore].data[j] = (float)tr.dat.data[j];
			}
			else break;

			double aMedian = getMedianAbsolute(&trArr[nxStore].data[0], numsamp);	
			if (aMedian < MINAMP) continue;

			if(para.sphericOrder > 0.f)
			{
				double a = getTraceDelay(&tr);  // a is now the initial time in sec for this trace

				double aGain = pow(a + numsamp *  dtField,  (double)para.sphericOrder);  
				if (aGain > 0.) aGain = 1. / aGain;
				else aGain = 1.;

				double b;
				for (j=0; j<numsamp; j++) {
					b = a + j* (double)tpp / (double)MIL;      // b is now the actual time in sec for the inidex j
					if (para.sphericOrder == 2.f)
						trArr[nxStore].data[j] *= (float)(b*b*aGain);
					else
						trArr[nxStore].data[j] *= (float)(aGain* pow(b,(double)para.sphericOrder) );
				}  // for j
			} // if

			nxStore++;
		} // while file.Read
		file.Close();
		pFrame->EndProgress();



		// ####NOTE: nxmax is frequently smaller than originally planned!
		if (nxStore < nxmax) {
			for (j=nxStore; j<nxmax; j++) {
				free(trArr[j].data); trArr[j].data = NULL;
			}
			nxmax = nxStore;
		} // for 

		// finished loading all segy data into memory trArr[]
		astr.Format(_T("finished loading all segy data into memory"));
		pFrame->SetMessageText(astr);



		//################################################################################
		//############################ start loading X-T values for velocity perturbation#####
		//################################################################################

		// first, we need to calculate max number of points of (x,t) pair for a certain iz
		float **xwTraced = (float **)ealloc2float(np_max, nz);
		float **twTraced = (float **)ealloc2float(np_max, nz);
		int *numTraced = (int *)ealloc1int(nz);
		float *zTraced = (float *)ealloc1int(nz);  // not used at all
		memset( (void *)xwTraced[0], 0, sizeof(float)*np_max*nz );
		memset( (void *)twTraced[0], 0, sizeof(float)*np_max*nz );
		memset( (void *)numTraced, 0, sizeof(int)*nz );
		memset( (void *)zTraced, 0, sizeof(float)*nz );
		bool isTooMany = false;


		int izmaxTraced = -1; 
		isProb = false;

		for (j=0; j<txArray->GetSize(); j++) { 
			if ( _stscanf_s(txArray->ElementAt(j).Trim(),_T("%f%f%d%d%f%f"),&f1, &f2, &iz, &icont, &f7, &f8) == 0) continue;
			if ( iz == 0 && !isFloatEqual(f8, (float)pCd.coord.zmin) ) {
				isProb = true;
				pCd.coord.zmin = f8;
				break;
			}
			if (iz==-2 && !isFloatEqual(f8, (float)vel.dz) ) {
				// this is the last line of a raytracing file
				isProb = true;
				vel.dz = f8;
				break;
			}
			if (iz<=0 || icont==0 || iz>nz) continue;  // note: input file has  iz=1:nz.... from Fortran
			if ( (i=numTraced[iz-1]) < np_max) {
				xwTraced[iz-1][i] = f1;
				twTraced[iz-1][i] = f2;
				numTraced[iz-1]++;  // we want array index to be zero based
				zTraced[iz-1] = f8;  // not used at all
				// so we just ignore the user input
				if (izmaxTraced < iz) izmaxTraced = iz;
			}
			else {
				isTooMany = true;
			}
		} // if j
		txArray->RemoveAll();
		txArray = NULL;


		if (!isProb) {
			// since xw[][] may not be ordered monotonically with distance, we need to reorder it.
			for (iz=0; iz<nz; iz++) {
				for (j=0; j<numTraced[iz]-1; j++) {
					for (int k=j+1; k<numTraced[iz]; k++) {
						if (xwTraced[iz][j] > xwTraced[iz][k]) {
							// swap the 2 values
							f1 = xwTraced[iz][j];
							xwTraced[iz][j] = xwTraced[iz][k];
							xwTraced[iz][k] = f1;
							f1 = twTraced[iz][j];
							twTraced[iz][j] = twTraced[iz][k];
							twTraced[iz][k] = f1;
						} // if
					} // for k
				} // for j
			} // for iz

			astr.Format(_T("finished loading and parsing into memory the raytracing results"));
			pFrame->SetMessageText(astr);
		} // if


		// note: sei_zAll[nvPerturb][iz]  info is only for checking here, not used in later NMO calculation, as we all assume
		//       the depth indece are uniform.

		if (isTooMany) 
			AfxMessageBox(_T("Too many points found in the raytracing. Will truncate. You may limit number of points per ray <=30 ."));
		if (isProb) {
			free2float(xwTraced); xwTraced = NULL;
			free2float(twTraced); twTraced = NULL;
			free1int(numTraced); numTraced = NULL;
			free1float(zTraced); zTraced = NULL;
			for (j=0; j<nxmax; j++) {
				free(trArr[j].data); trArr[j].data = NULL;
			}
			free(trArr); trArr = NULL;

			astr = _T("Depth in the raytracing mismatches with desired zmin, zmax or dz that are now adjusted accordingly. Note that temporary raytracing results cannot be mixed for different running. Please rerun this processing.");
			AfxMessageBox(astr);
			OnTimeForwide();
			return;
		}







		CFile filez;
		if (!filez.Open(draw.depthSecName, CFile::modeCreate|CFile::modeReadWrite|CFile::typeBinary)) {
			return;
		}

		filez.Write(head.ascHead, 3200L);
		bh.hns = nz; // numsamp for output;
		bh.format = 1; // we always output in floating points
		bh.hdt = (unsigned short)myRound(vel.dz*MIL);	//Sampling rate;
		filez.Write(&bh, sizeof(bh));

		//Prepare to formulate velocity traces.
		WORD totShot=0;
		double oneodt = (double) (MIL/(double)tpp);

		astr.Format(_T("Start loop for 2D NMO correction. Please wait ..."));
		pFrame->SetMessageText(astr);
		segydynamic tTrcDepth;
		tTrcDepth.data = (float *)malloc(sizeof(float)*nz);
		segydynamic trcDepth;
		trcDepth.data = (float *)malloc(sizeof(float)*nz);
		// memset((void *)tTrcDepth.data, (int)'\0', sizeof(float)*nz);
		double t1,t2,x1, x2, t11, x11;
		for (nxStore=0; nxStore < nxmax; nxStore++) {
			memcpy((void *)&tr, (void *)&trArr[nxStore], 240L);
			// float offset = getOffset(&tr); // note: offset here can be negative!
			//	if (!isFloatEqual(0.f, offsetMax) &&  fabs(offset) > 2.f*offsetMax) continue;
			float dist = getDistance(&tr);

			for (iz=0; iz<nz; iz++) {
				// tTrcDepth.data[iz] = -1.f;
				tr.dat.data[iz] = 0.f;
				int n = numTraced[iz];
				if (n < 2) continue;
				// Be very careful here, as it affects the results drastically!

				// Now stack ~2km of data trArr[0:nxmax-1] around dist=getDistance(&trArr[nxStore]) along a hyperbola curve  
				// this curve is controled by indexTracedFound, m=numTraced[iz], xwTraced[iz][0:indexTracedFound:m], xwTraced[][], x1,x2,t1,t2,
				// put result into  tr.dat.data[iz].
				int countStacked = 0;
				float widthAtDepth = stackWidth + iz * (float)vel.dz * stackWidthGradient;
				for (int ix=0; ix < nxmax; ix++) {
					float x = getDistance(&trArr[ix]);
					if (x < dist - widthAtDepth*0.5f || x > dist + widthAtDepth*0.5f) continue;
					float offset = getOffset(&trArr[ix]); // note: offset here can be negative!

					// now we want to stack all the remaining traces along a given hyperbola which is already pre-calculated in the arrays
					// we just need to use linear interpolcations
					bool isFound = false;
					for (j=1; j<numTraced[iz]; j++) {
						if (x >= xwTraced[iz][j-1] && x < xwTraced[iz][j]) {
							x1 = xwTraced[iz][j-1] - tx.xShot; // we calculate using offset instead of dist here
							x2 = xwTraced[iz][j] - tx.xShot;
							t1 = twTraced[iz][j-1];
							t2 = twTraced[iz][j];

							if ( (x1 < 0) == (x2 < 0) ) {
								// now x1 and x2 are on the same side of the source
								isFound = true;
							}
							else {
								// now the 2 points are on diff sides of the source
								if ( (x1 < 0) == (offset < 0) ) {
									// x1 and xw[iz][j-1] is on the same side as source
									if (j>1) {
										x1 = xwTraced[iz][j-2] - tx.xShot;
										x2 = xwTraced[iz][j-1] - tx.xShot;
										t1 = twTraced[iz][j-2];
										t2 = twTraced[iz][j-1];
										isFound = true;
									}
								} // if x1
								else {
									// x2 and xw[iz][j] is on the same side as source
									if (j<numTraced[iz]-1) {
										x1 = xwTraced[iz][j] - tx.xShot;
										x2 = xwTraced[iz][j+1] - tx.xShot;
										t1 = twTraced[iz][j];
										t2 = twTraced[iz][j+1];
										isFound = true;
									}
								}
							} // if x1

							break;
						} // if dist
					} // for j
					if (!isFound) {
						// this part is important, since sometimes Zelt's raytracing cannot reach a certain distance
						// while the observed phases are strong there, such as the shallowest sediment reflections in
						// a complex 2D structure
						int jj = numTraced[iz]-1;
						if (x < xwTraced[iz][0]) {
							x1 = xwTraced[iz][0] - tx.xShot;
							x2 = xwTraced[iz][1] - tx.xShot;
							t1 = twTraced[iz][0];
							t2 = twTraced[iz][1];
							isFound = true;
						}
						else if (x > xwTraced[iz][jj]) {
							x1 = xwTraced[iz][jj-1] - tx.xShot;
							x2 = xwTraced[iz][jj] - tx.xShot;
							t1 = twTraced[iz][jj-1];
							t2 = twTraced[iz][jj];
							isFound = true;
						}
					}
					if (!isFound) continue;

					// **** we get:   x1,x2,t1,t2  for  trArr[ix]  ****
					float tInterpolated = -1.f;
					if ( fabs(t1 - t2) < 0.0001) {
						tInterpolated = (float)t1;
					}
					else {
						// first try hyperbola interpolation
						t11 = t1*t1;
						x11 = x1*x1;
						double x22 = x2*x2;
						double t22 = t2*t2;
						double vr2 = (x22 - x11) / (t22 - t11);
						if (fabs(vr2)>MINAMP) {
							// hyperbola interpolation
							double t00 = t11 + (offset*offset - x11) / vr2;
							if (t00 > 0.) {
								tInterpolated = (float)sqrt(t00);
							}
						}
						else {
							// testing shows this neven happened
							int ttt = 1;
						}
						if (tInterpolated < 0.f) {
							// since hyperbola interpolation fails, we do linear interpolation
							// continue;  // testing shows this neven happened
							if ( fabs(x2-x1) > 0.0001)
								tInterpolated = (float)(t1 + (offset - x1) / (x2-x1) * (t2-t1));
							else
								tInterpolated = (float)t1;
						}
					} // else

					// **** now we use: tInterpolated  for  trArr[ix] ****
					tr.dat.data[iz] += getTraceAmp(&trArr[ix], tInterpolated, dtField);
					countStacked++;
				} // for ix
				if (countStacked > 1) tr.dat.data[iz] /= (float)countStacked;


				// now tr.dat.data[iz=0:nz-1] has a wrong depth except at dist! we need to correct this using the contouring scheme
				// the desired distance should be at the reflecting point CMP
				double offsetOut = dist - tx.xShot; // note: offset here can be negative!
				double cmpOut = tx.xShot + offsetOut*0.5f; //**** Improtant */
				double ax;
				for (iz=0; iz<nz; iz++) {
					// we will put the real depth in km into array  tTrcDepth.data[iz]
					tTrcDepth.data[iz] = -1.f;
					for (j=0; j<nArray[iz]-1; j++) {
						if ( (cmpOut >= xArray[iz][j] && cmpOut <= xArray[iz][j+1])
							||
							(cmpOut >= xArray[iz][j+1] && cmpOut <= xArray[iz][j])
							) {
								// found the segment of contour
								ax = (xArray[iz][j+1] - xArray[iz][j]);
								if (fabs(ax) < 0.00001f) 
									tTrcDepth.data[iz] = zArray[iz][j];
								else
									tTrcDepth.data[iz] = (float)(zArray[iz][j] + (zArray[iz][j+1] - zArray[iz][j]) * (cmpOut - xArray[iz][j]) / ax);
								break;
						} // if
					} // for j
					if (tTrcDepth.data[iz] < 0.f) {
						int dasdas = 1; // never happened
					}
				} // for iz

				double az, bz;
				for (int izMig=0; izMig<nz; izMig++) {
					az = pCd.coord.zmin + (double)izMig * vel.dz;
					for (iz=0; iz<nz-1; iz++) {
						// look for the right index to grab the correct amp
						if (az >= tTrcDepth.data[iz] && az <= tTrcDepth.data[iz+1]) {
							// found it
							// trcDepth.data[izMig] = tr.dat.data[iz];
							bz = tTrcDepth.data[iz+1] - tTrcDepth.data[iz];
							trcDepth.data[izMig] = (fabs(bz) < 0.0001) ?
								tr.dat.data[iz]  
							:
							tr.dat.data[iz] + 
								(tr.dat.data[iz+1] - tr.dat.data[iz]) * (float)((az - tTrcDepth.data[iz]) / bz);
							break;
						}
					} // for j
				} // for izMig
				for (iz=0; iz<nz; iz++) {
					tr.dat.data[iz] = trcDepth.data[iz];
				}


				//	memcpy( (void *)tr.dat.data, (void *)&vTrc[nzmin], (nzmax-nzmin+1)*sizeof(float));
				tr.ns = (unsigned short)nz;
				tr.dt = (unsigned short)(vel.dz*MIL);
				setTraceDelayF(&tr, pCd.coord.zmin);
				//if (tr.tracl == 1642) {
				//	int terer = 1;
				//}

				setDistance(&tr, cmpOut); // make it to be CMP

				if ( format==1 ) {
					float_to_ibm((int *) tr.dat.data, (int *) tr.dat.data, (int)nz);
				}
				filez.Write(&tr, nz*sizeof(float)+240 );
			} // for nxStore


			draw.depthSecOld.Format(_T(""));  // ask the OnDraw() to reload the depth data


			CString digNameOut = GetFileNameAppendExt(dig.digName, _T("2dnmoDepth"), _T("txt"));
			if(draw.isDigitizing && dig.isZeltFormat2) {
				// Zelt format is in  dig struct. ******* this section needs revision******
				CDigitize pDg;
				CDigitize::DIGITIZE dig2;
				pDg.initDigitizeArray(&dig2, 2, dig.DIG_POINT_MAX*dig.totCurve);
				dig2.isZeltFormat2 = FALSE;
				dig2.totCurve = 0;  // we start from 0 here
				for (int ic=0; ic<dig.totCurve; ic++) {
					for (int jp=0; jp<dig.nPoint[ic]; jp++) {
						double dist = dig.x[jp][ic];
						double offset = dist - tx.xShot;
						dig2.nPoint[dig2.totCurve] = 0;
						// float tt = dig.t[jp][ic];

						for (iz=0; iz<nz; iz++) {
							tTrcDepth.data[iz] = -1.f;
							int n = numTraced[iz];
							if (n < 2) continue;
							// Be very careful here, as it affects the results drastically!
							if (dist < xwTraced[iz][0] - offsetMax) continue; // we excluse any traces left of min raytraced distance
							if (dist > xwTraced[iz][n-1] + offsetMax) continue;  // we excluse any traces right of max raytraced distance.

							double az = pCd.coord.zmin + (double)iz * vel.dz;
							bool isFound = false;
							for (j=1; j<numTraced[iz]; j++) {
								if (dist >= xwTraced[iz][j-1] && dist < xwTraced[iz][j]) {
									x1 = xwTraced[iz][j-1] - tx.xShot; // we calculate using offset instead of dist here
									x2 = xwTraced[iz][j] - tx.xShot;
									t1 = twTraced[iz][j-1];
									t2 = twTraced[iz][j];

									if ( (x1 < 0) == (x2 < 0) ) {
										// now x1 and x2 are on the same side of the source
										isFound = true;
									}
									else {
										// now the 2 points are on diff sides of the source
										if ( (x1 < 0) == (offset < 0) ) {
											// x1 and xw[iz][j-1] is on the same side as source
											if (j>1) {
												x1 = xwTraced[iz][j-2] - tx.xShot;
												x2 = xwTraced[iz][j-1] - tx.xShot;
												t1 = twTraced[iz][j-2];
												t2 = twTraced[iz][j-1];
												isFound = true;
											}
										} // if x1
										else {
											// x2 and xw[iz][j] is on the same side as source
											if (j<numTraced[iz]-1) {
												x1 = xwTraced[iz][j] - tx.xShot;
												x2 = xwTraced[iz][j+1] - tx.xShot;
												t1 = twTraced[iz][j];
												t2 = twTraced[iz][j+1];
												isFound = true;
											}
										}
									} // if x1

									break;
								} // if dist
							} // for j
							if (!isFound) {
								// this part is important, since sometimes Zelt's raytracing cannot reach a certain distance
								// while the observed phases are strong there, such as the shallowest sediment reflections in
								// a complex 2D structure
								int jj = numTraced[iz]-1;
								if (dist < xwTraced[iz][0]) {
									x1 = xwTraced[iz][0] - tx.xShot;
									x2 = xwTraced[iz][1] - tx.xShot;
									t1 = twTraced[iz][0];
									t2 = twTraced[iz][1];
									isFound = true;
								}
								else if (dist > xwTraced[iz][jj]) {
									x1 = xwTraced[iz][jj-1] - tx.xShot;
									x2 = xwTraced[iz][jj] - tx.xShot;
									t1 = twTraced[iz][jj-1];
									t2 = twTraced[iz][jj];
									isFound = true;
								}
							}
							if (!isFound) continue;

							// get the tTrcDepth.data[iz] for interpolation
							if ( fabs(t1 - t2) > 0.0001) {
								// testing shows here 0.0001  is better than MINAMP!!!
								bool isSuc = false;
								// first try hyperbola interpolation

								t11 = t1*t1;
								x11 = x1*x1;
								double vr2 = (x2*x2 - x11) / (t2*t2 - t11);
								if (fabs(vr2)>MINAMP) {
									// hyperbola interpolation
									double t00 = t11 + (offset*offset - x11) / vr2;
									if (t00 > 0.) {
										tTrcDepth.data[iz] = (float)sqrt(t00);
										isSuc = true;
									}
								}

								if (!isSuc) {
									// since hyperbola interpolation fails, we do linear interpolation
									// continue;  // testing
									if ( fabs(x2-x1) > 0.0001)
										tTrcDepth.data[iz] = (float)(t1 + (offset - x1) / (x2-x1) * (t2-t1));
									else
										tTrcDepth.data[iz] = (float)t1;
								}


							}
							else
								tTrcDepth.data[iz] = (float)t1;
						} // for iz

						// now for each dist, we get a complete array of tTrcDepth.data[iz], where iz=[0,nz). We now need to
						float zmin_bar = -1.f;
						float zmax_bar = -1.f;
						int iz2;
						for (iz=0; iz<nz; iz++) {
							if ( tTrcDepth.data[iz] < 0.f) continue;
							if ( tTrcDepth.data[iz] >= dig.t[jp][ic] - dig.digResolution[ic] * 0.5f) {
								// found the iz is the start of the error bar in the depth domain
								zmin_bar = (float)(pCd.coord.zmin + iz*vel.dz);
								// now try to find the maximum value
								for (iz2 = iz; iz2<nz; iz2++) {
									if ( tTrcDepth.data[iz2] < 0.f) {
										// if here, only 1 iz is detected 
										zmax_bar = zmin_bar;
										break; // out of loop for iz2
									}
									else if (iz2>0 && tTrcDepth.data[iz2] > dig.t[jp][ic] + dig.digResolution[ic] * 0.5f) {
										zmax_bar = (float)(pCd.coord.zmin + (iz2-1)*vel.dz);
										break; // out of loop for iz2
									}
								} // for iz2
								if (zmax_bar < 0.f) zmax_bar = (float)(pCd.coord.zmin + (nz-1)*vel.dz);
								break; // out of loop for iz
							} // if
						} // for iz

						if (zmin_bar > 0.f && zmax_bar > zmin_bar) {
							// now we need to add this point to dig2

							// estimated dz at the average depth
							//float dzHyperbola = dig.t[jp][ic] / (zmin_bar+zmax_bar) * dig.digResolution[ic] * (vmin+vmax) * 0.125f;
							//if (zmax_bar - zmin_bar > dzHyperbola * 5.f) {

							dig2.x[0][dig2.totCurve] = (float)(tx.xShot + offset*0.5);
							dig2.x[1][dig2.totCurve] = (float)(tx.xShot + offset*0.5);
							dig2.t[0][dig2.totCurve] = zmin_bar;
							dig2.t[1][dig2.totCurve] = zmax_bar;
							dig2.nPoint[dig2.totCurve] = 2;
							dig2.totCurve ++;
						} // if

					} // for jp
				} // for ic
				dig2.digName = digNameOut;
				pDg.myDigSaveAs(&dig2, FALSE, FALSE, tx.xShot);
				pDg.freeDigAll(&dig2);

				// now indicate to display the dig results in the depth domain
				//if (!isTimeDomain()) {
				//	dig.digName = digNameOut;
				//}
			} // if





			//################################################################################
			//############################ end loop for velocity perturbation###############
			//################################################################################

			//Free up space
			free2float(xwTraced); xwTraced = NULL;
			free2float(twTraced); twTraced = NULL;
			free1int(numTraced); numTraced = NULL;
			free1float(zTraced); zTraced = NULL;
			free(tTrcDepth.data);
			free(trcDepth.data);

			for (j=0; j<nxmax; j++) {
				free(trArr[j].data); trArr[j].data = NULL;
			}
			free(trArr); trArr = NULL;

			free2float (xArray);
			free2float (zArray);
			free1int (nArray);








			//#####################################################################################################
			//#####################################################################################################
			//#####################################################################################################
			//#####################################################################################################

			draw.modeOld = draw.mode;
			draw.mode = 10;	//show section in TWTT domain.

			astr.Format(_T("Start converting back from depth to TWTT domain ..."));
			pFrame->SetMessageText(astr);
			//UpdateAllViews(NULL);
			//NotifyChanged();

			draw.strXLabelOverwrite = _T("Distance");

			// we need to use vTop[] and vBot[] info at the OBS location, so we pre-calculate
			double val;
			int it;
			double frac;
			float atimeOutput;
			double **twtt2d = (double **)ealloc2double(nz, 1);
			// double depth[MOD_LAYER_MAX],vTop[MOD_LAYER_MAX],vBot[MOD_LAYER_MAX];

			CVelMod vm;
			CVelMod::VELMOD_X modX;


			//################################################################################
			//################################################################################
			//################################################################################
			segydynamic *trzArr = (segydynamic *)malloc( sizeof(segydynamic) * nxmax );
			segydynamic *trzArr2 = (segydynamic *)malloc( sizeof(segydynamic) * nxmax ); 
			filez.Seek(3600L, CFile::begin);
			for (nxStore=0; nxStore<nxmax; nxStore++) {
				trzArr[nxStore].data = (float *)malloc(sizeof(float)*nz);
				trzArr2[nxStore].data = (float *)malloc(sizeof(float)*numsamp);

				filez.Read(&trzArr[nxStore], 240L);
				if (format==1)
					ibm_to_float((int *) &trzArr[nxStore].data[0], (int *) &trzArr[nxStore].data[0], (int)nz);
				filez.Read(&trzArr[nxStore].data[0], nz*sizeof(float));

				memcpy((void *)&trzArr2[nxStore], (void *)&trzArr[nxStore], 240L); // just copy the segy trace header only
				memset((void *)&trzArr2[nxStore].data[0], 0, sizeof(float)*numsamp);
			}



			//*******************************************************************
			//********* display results in the TWTT domain***********************
			//*******************************************************************
			//****************Now twtt2d[nvPerturb][iz] complete with all TWTT info****************
			//****************Now trzArr[nvPerturb].data[iz] with all un-migrated data in depth domain****************
			//****************Now trzArr2[nvPerturb].data[it] space allocated to store data in TWTT domain****************
			// NOTE: for twtt[nvPerturb][iz], and trzArr[nvPerturb].data[iz], iz=0 is at pCd.coord.zmin !

			for (nxStore=0; nxStore<nxmax; nxStore++) {
				float dist = getDistance(&trzArr[nxStore]);
				if (dist<pCd.coord.xmin || dist > pCd.coord.xmax) continue;

				// pre-calculate twtt2d[0][] for the current trace with CMP distance
				modX.dist = dist;
				vm.initModX(&velMod, &modX, isTimeDomain() == TRUE, true, true, vel.dz);
				if (draw.raymode > 0) {
					// here, we only assume S waves
					CStringArray *csArr = new CStringArray();
					if (loadParam(draw.rayName, _T("pois"), csArr) ) {
						int poisCount = (int)csArr->GetCount();
						for (icont=0; icont<velMod.ncont-1; icont++)
						{
							float apois = (icont < poisCount)  ?  
								(float)_tstof(csArr->ElementAt(icont))  :  (float)_tstof(csArr->ElementAt(poisCount-1));
							float vsvp=(float)sqrt((1.-2.*apois)/(2.*(1.-apois)));
							if (vsvp > 0.f) {
								// if vsvp == 0.f, it means water, and we have to use vTop[] vBot[] without any conversion to S wave
								modX.vTop[icont] *= vsvp;
								modX.vBot[icont] *= vsvp;
							}
						}
					} // if loadParam
					csArr->RemoveAll();
					csArr = NULL;
				} // if raymode

				memset( (void *)twtt2d[0], 0, sizeof(double)*nz );
				vm.getTzFromZModGrad(&modX, nz, vel.dz, &twtt2d[0][0]);
				// note: this function will produce nz values in twtt2d[0][0:nz-1]

				// convert from depth to twtt domain
				for (atimeOutput=(float)pCd.coord.tmin, it=0; atimeOutput<=(float)pCd.coord.tmax; atimeOutput+=dtField, it++) {
					// now we need to find out the corresponding index in tTrcDepth.data[] for atime
					if (it >= numsamp) continue;

					for (iz=1; iz<nz; iz++) {
						if (atimeOutput <= twtt2d[0][iz]) {
							// now  atimeOutput is between  twtt2d[nvPerturb][iz-1]  and twtt2d[nvPerturb][iz]
							// NOTE: iz=0 is at pCd.coord.zmin !
							frac = twtt2d[0][iz] - twtt2d[0][iz-1];
							float zt = (fabs(frac) > 0.000001) ?  
								(float)(vel.dz * ( iz - 1 + (atimeOutput - twtt2d[0][iz-1]) / frac ) )
								:
							(float)(vel.dz * (iz-1));
							register double vt = vm.getVFromVz(&modX, zt + pCd.coord.zmin);
							val = (fabs(frac) > 0.000001) ? 
								trzArr[nxStore].data[iz-1] + (trzArr[nxStore].data[iz] - trzArr[nxStore].data[iz-1]) * (atimeOutput - twtt2d[0][iz-1]) / frac
								:
								trzArr[nxStore].data[iz-1];

							trzArr2[nxStore].data[it] = (float)val;
							break;  // finished for loop iz
						} // if atimeOutput, it
					} // for iz
				} // for atimeOutput
			} // for nxStore








			bh.hdt = (unsigned short)tpp;	//Sampling rate;
			bh.hns = numsamp;
			filez.Seek(3200L, CFile::begin);
			filez.Write(&bh, 400);
			for (nxStore=0; nxStore<nxmax; nxStore++) {
				// memcpy((void *)&tr, (void *)&trzArr2[nvPerturb], 240L);
				trzArr2[nxStore].ns = (unsigned short)numsamp;
				trzArr2[nxStore].dt = (unsigned short)tpp;
				setTraceDelayF(&trzArr2[nxStore], pCd.coord.tmin);

				if ( format==1 ) {
					float_to_ibm((int *) &trzArr2[nxStore].data[0], (int *) &trzArr2[nxStore].data[0], (int)numsamp);
				}

				filez.Write(&trzArr2[nxStore], 240L);  // note for simplicity, the segy headers in trzArr[nvPerturb]  is not directly assigned
				filez.Write(&trzArr2[nxStore].data[0], numsamp*sizeof(float));
				//showArrayInFile(trzArr[nvPerturb].data, numsamp);
			} // for nxStore

			free2double(twtt2d);
			//*******************************************************************
			//********* end display results in the TWTT domain***********************
			//*******************************************************************


			// free some last memory blocks
			for (j=0; j<nxmax; j++) {
				free(trzArr[j].data);
			}
			for (j=0; j<nxmax; j++) {
				free(trzArr2[j].data);
			}
			free(trzArr2);
			free(trzArr); 

			//para.vred = 0.;  // ***this is important, otherwise it may reduce in time
			para.isDistanceDisplay = TRUE;  // always display in distance


			//################################################################################
			//################################################################################
			//############################ end preparing for P-velocity display###############
			//################################################################################




			filez.Close();


			CDigitize pDg;
			pDg.freeDigAll(&dig);
			if(draw.isDigitizing && dig.isZeltFormat2) {
				t.Format(_T("Zelt's format points are 2DNMO corrected to depth domain and stored in %s"), digNameOut);
				dig.digName = digNameOut;
				dig.isZeltFormat2 = FALSE;
				AfxMessageBox(t);
			}

			draw.isDigitizing = FALSE;
			draw.isSameDataDisplay = FALSE; //indicate display has been changed and will re-load all data in OnDraw().
			draw.depthSecOld.Format(_T(""));	//recalculate gain.

			astr.Format(_T("Completed 2D NMO correction!"));
			pFrame->SetMessageText(astr);

			SetModifiedFlag();
			UpdateAllViews(NULL);
			NotifyChanged();
			//	AfxMessageBox(_T("Succesfully converting into depth domain");
		}
	}

	double CSeisWideDoc::getXp(double p, int nz, float dz, float vTrc[])
	{
		double result = 0.;
		double p2 = p*p;
		for (int i=0; i<nz; i++) {
			double t = 1. - p2 * vTrc[i] * vTrc[i];
			if (t > 0.) 
				result += dz*vTrc[i] / sqrt(t);
		}
		return result * 2. * p;
	}
	double CSeisWideDoc::setTp(double p, int nz, float dz, float vTrc[])
	{
		double result = 0.;
		double p2 = p*p;
		for (int i=0; i<nz; i++) {
			double t = 1. - p2 * vTrc[i] * vTrc[i];
			if (t > 0.) 
				result += dz / (vTrc[i] * sqrt(t));
		}
		return result * 2.;
	}

	//
	//int CSeisWideDoc::formatVelocityArray(float dvUniform, int ncont, double depth[], double vTop[], double vBot[])
	//{
	//	for (int i=0; i<ncont; i++) {  
	//		if (fabs(vBot[i] - vTop[i]) > dvUniform) {
	//			// if here, the velocity gradient is too great, we split the layer into smaller pieces 
	//			for (int icont = ncont-1; icont>i; icont--) {
	//				depth[icont+1] = depth[icont];
	//				vTop[icont+1] = vTop[icont]; // no meaning for vTop[ncont]
	//				vBot[icont+1] = vBot[icont];
	//			}
	//			depth[i+1] = depth[i] + dvUniform * (depth[i+1] - depth[i]) / (vBot[i] - vTop[i]);
	//			vTop[i+1] = vTop[i] + dvUniform;
	//			vBot[i+1] = vBot[i];
	//			vBot[i] = vTop[i+1];
	//			ncont ++;
	//			return formatVelocityArray(dvUniform, ncont, (double *)&depth[0], (double *)&vTop[0], (double *)&vBot[0]);
	//		}
	//	} // for i
	//	return ncont;
	//}

	/*
	dvUniform is the velocity increment that can be treated minimal for a uniform velocity layer
	*/
	double CSeisWideDoc::getXp2(float p, float z, int ncont, double depth[], double vTop[], double vBot[])
	{
		double result = 0.;
		double p2 = p*p;
		//for (int i=0; i<nz; i++) {
		//	double t = 1. - p2 * vTrc[i] * vTrc[i];
		//	if (t > 0.) 
		//		result += dz*vTrc[i] / sqrt(t);
		//}

		double t, v;
		for (int i=0; i<ncont-1; i++) {  // exclude the last layer for this loop
			if (z >= depth[i+1]) {
				v = (vBot[i] + vTop[i]) * 0.5; // average velocity in this layer
				t = 1. - p2 * v * v;
				if (t > 0.)
					result += (depth[i+1] - depth[i]) * v / sqrt(t);
				else 
					return 99999.;  // invalid ray encountered
			}
			else {
				// wil terminate here
				t= depth[i+1] - depth[i];
				if (t > 0.) {
					v = vTop[i] + (vBot[i] - vTop[i]) * (z - depth[i]) / t;
					t = 1. - p2 * v * v;
					if (t > 0.) 
						result += (z - depth[i]) * v / sqrt(t);
					else {
						// note: we only want the last layer to return 99999. when ray invalid
						return 99999.;
					}
				}
				break;
			}
		} // for i

		return result * 2. * p;
	}

	bool CSeisWideDoc::getXp3(float p, float z, int ncont, double depth[], double vTop[], double vBot[], double xt[])
	{
		// test
		//xt[0] = getXp2(p, (float)z, ncont, (double *)&depth[0], (double *)&vTop[0], (double *)&vBot[0]);
		//xt[1] = setTp2(p, (float)z, ncont, (double *)&depth[0], (double *)&vTop[0], (double *)&vBot[0]);
		//return (xt[0] != 99999.);



		xt[0] = 0.;
		xt[1] = 0.;
		double p2 = p*p;
		double oneov;
		double dz2;

		double tmp, v, dz, vz, x1,x2,x3,x4, t1,t2,t3,t4;
		double theta1, theta2, theta3, theta4;
		for (int i=0; i<ncont-1; i++) {  // exclude the last layer for this loop
			if (z >= depth[i+1]) {
				dz = (depth[i+1] - depth[i]);
				if (dz < 0.0001) continue;
				v = (vBot[i] + vTop[i]) * 0.5; // average velocity in this layer
				oneov = 1./v;
				vz = (vBot[i] - vTop[i]) / dz;  // constant for each layer
				tmp = p * vTop[i];
				if (tmp<= 1.0) {
					theta1 = asin(tmp);
					tmp = p * v;
					if (tmp > 1.0) 
						theta2 = theta3 = theta1;
					else
						theta2 = theta3 = asin(tmp);
					tmp = p * vBot[i];
					if (tmp > 1.0) 
						theta4 = theta1;
					else
						theta4 = asin(tmp);

					//theta2 = theta1 + 0.5 * dz * vz * oneov * tan(theta1);
					//theta3 = theta2 + 0.5 * dz * vz * oneov * tan(theta2);
					//theta4 = theta3 + dz * vz * oneov * tan(theta3);

					x1 = tan(theta1) * dz; // first order
					x2 = tan(theta2) * dz; // second order. here, v is the vel at half the interval
					x3 = tan(theta3) * dz; // third order
					x4 = tan(theta4) * dz; // fourth order
					xt[0] += (x1 + 2.*x2 + 2.*x3 + x4) / 6.;  // Runge-Kutta formula

					dz2 = dz*dz;
					t1 = sqrt(x1*x1 + dz2) / vTop[i];
					t2 = sqrt(x2*x2 + dz2) * oneov;
					t3 = sqrt(x3*x3 + dz2) * oneov;
					t4 = sqrt(x4*x4 + dz2) / vBot[i];

					xt[1] += (t1 + 2.*t2 + 2.*t3 + t4) / 6.;  // Runge-Kutta formula
				}
				else {
					xt[0] = 99999.;
					return false;  // invalid ray encountered
				}
			}
			else {
				// will terminate here
				dz = (z - depth[i]);
				if (dz < 0.0000001 || vBot[i] <= vTop[i]) {
					// this means there is no need to calculate any more. The result is already usable
					break;
				}
				double vmid = vTop[i] + dz / (depth[i+1] - depth[i]) * (vBot[i] - vTop[i]);
				v = (vmid + vTop[i]) * 0.5; // average velocity in this layer above z depth
				oneov = 1./v;
				vz = (vmid - vTop[i]) / dz;  // constant for each layer
				tmp = p * vTop[i];
				if (tmp<= 1.0) {
					theta1 = asin(tmp);
					tmp = p * v;
					if (tmp > 1.0) 
						theta2 = theta3 = theta1;
					else
						theta2 = theta3 = asin(tmp);
					tmp = p * vmid;
					if (tmp > 1.0) 
						theta4 = theta1;
					else
						theta4 = asin(tmp);
					//theta2 = theta1 + 0.5 * dz * vz * oneov * tan(theta1);
					//theta3 = theta2 + 0.5 * dz * vz * oneov * tan(theta2);
					//theta4 = theta3 + dz * vz * oneov * tan(theta3);

					x1 = dz * tan(theta1); // first order
					x2 = dz * tan(theta2); // second order
					x3 = dz * tan(theta3); // third order
					x4 = dz * tan(theta4); // fourth order
					xt[0] += (x1 + 2.*x2 + 2.*x3 + x4) / 6.;  // Runge-Kutta formula


					dz2 = dz*dz;
					t1 = sqrt(x1*x1 + dz2) / vTop[i];
					t2 = sqrt(x2*x2 + dz2) * oneov;
					t3 = sqrt(x3*x3 + dz2) * oneov;
					t4 = sqrt(x4*x4 + dz2) / vBot[i];

					xt[1] += (t1 + 2.*t2 + 2.*t3 + t4) / 6.;  // Runge-Kutta formula
				}
				else {
					xt[0] = 99999.;
					return false;  // invalid ray encountered
				}
				break;
			}
		} // for i

		xt[0] *= 2.;
		xt[1] *= 2.;
		return true;
	}

	double CSeisWideDoc::setTp2(float p, float z, int ncont, double depth[], double vTop[], double vBot[])
	{
		double result = 0.;
		double t, v;
		double p2 = p*p;
		for (int i=0; i<ncont-1; i++) {  // exclude the last layer for this loop
			if (fabs(depth[i+1] - depth[i]) > 0.) {
				if (z >= depth[i+1]) {
					v = (vBot[i] + vTop[i]) * 0.5; // average velocity in this layer
					t = 1. - p2 * v * v;
					if (t > 0.) 
						result += (depth[i+1] - depth[i]) / (v * sqrt(t));
					else 
						return 99999.;  // invalid ray encountered
				}
				else {
					// wil terminate here
					t= depth[i+1] - depth[i];
					if (t > 0.) {
						v = vTop[i] + (vBot[i] - vTop[i]) * (z - depth[i]) / t;
						t = 1. - p2 * v * v;
						if (t > 0.) 
							result += (z - depth[i]) / (v * sqrt(t));
						else 
							return 99999.;  // invalid ray encountered
					}
					break;
				} // if z>=
			} // if fabs(depth
		} // for i

		return result * 2.;
	}



	void CSeisWideDoc::DrawVelocityLabelDepth(CDC* pDC, CVelMod::VELMOD *velm, double xpos, double xShift)
	{
		// global variables used: draw, velMod, para
		if (this->isTimeDomain() || draw.isNoLableOutside || draw.isNoLabelInSide ||
			velm->ncont < 2) 
			return;
		if(!isFileExistNotDirectory(velm->velSecName) || !this->isModelVisible(velm, xShift)) return;
		if (xpos+xShift < pCd.coord.xmin || xpos+xShift > pCd.coord.xmax) return;

		CVelMod vm;
		//if (!vm.isVelModValid(velm) || xpos + xShift > pCd.coord.xmax || xpos + xShift < pCd.coord.xmin)
		//	return;

		CString tStr;

		// int numRef = 12000; // cannot make this floating

		CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();

		// Initialize a LOGFONT structure for the fonts.
		LOGFONT logFontNum;  // font for drawing numbers
		pDC->GetCurrentFont()->GetLogFont(&logFontNum);
		float xyRatio = (float)logFontNum.lfWidth / (float)logFontNum.lfHeight;
		int numXLogical = (int)myRound(pFrame->fLabelDistance3 * 150.);
		int numYLogical = (int)(numXLogical / xyRatio);

		logFontNum.lfHeight = numYLogical;
		logFontNum.lfWidth = numXLogical;
		logFontNum.lfEscapement = 0;
		logFontNum.lfOrientation = 0;
		logFontNum.lfWeight = FW_NORMAL;
		logFontNum.lfItalic = 0;
		logFontNum.lfUnderline = 0;
		logFontNum.lfStrikeOut = 0;
		logFontNum.lfCharSet = ANSI_CHARSET;
		logFontNum.lfOutPrecision = OUT_DEFAULT_PRECIS;
		logFontNum.lfClipPrecision = CLIP_DEFAULT_PRECIS;
		logFontNum.lfQuality = DEFAULT_QUALITY;
		logFontNum.lfPitchAndFamily = FF_SWISS;
		_tcscpy_s(logFontNum.lfFaceName, _T("Arial"));

		CFont fontSmall;
		fontSmall.CreateFontIndirect(&logFontNum);
		CFont* oldFont;
		oldFont = pDC->SelectObject(&fontSmall);

		// TWTT display of model: we need to show velocity labels at the rightmost side
		CVelMod::VELMOD_X modX;
		modX.dist = xpos;
		vm.initModX(velm, &modX, false, true, true, vel.dz);

		int oldBkMode=pDC->SetBkMode(OPAQUE);

		bool isMainModelShowing = 
			GetBaseFileName(velMod.velSecName) == GetBaseFileName(velm->velSecName);

		COLORREF cr;
		if (!isMainModelShowing) {
			double r1 = rand()/(RAND_MAX + 1.0);
			double r2 = rand()/(RAND_MAX + 1.0);
			double r3 = rand()/(RAND_MAX + 1.0);
			// the following line makes the colors very pure.
			int r = (int)(150* (int)(r1+0.5) );
			int g = (int)(255* (int)(r2+0.5) );
			int b = (int)(255* (int)(r3+0.5) );
			if (r>200 && g>200 && b>200) {
				// we do not want a pure white ray, since it may not be visible in some cases
				r = g = b = 200;
			}
			cr = RGB( r, g, b);
		}
		else cr = RGB(255, 0, 0);
		COLORREF oldColor = pDC->SetTextColor(cr);

		CPoint p1,p2;
		for (int i=0; i<velm->ncont-1; i++) {
			int n1 = velm->nzed[i];
			int n2 = velm->nzed[i+1];
			if (n1<1 || n2<1) continue;  // no points defined for this layer
			float z1 = (float)modX.depthMod[i];
			float z2 = (float)modX.depthMod[i + 1];
			if (z2 <= z1) continue;  // no points defined for this layer

			p1 = pCd.mm_coordz(xpos+xShift,z1);
			p2 = pCd.mm_coordz(xpos+xShift,z2);

			register double v;
			if (z1 >= pCd.coord.zmin && z1 <= pCd.coord.zmax) {
				v = modX.vTop[i];
				if (isFloat1(v, 4.1))
					tStr.Format(_T("%1.1f"), myFloat1(v));
				else
					tStr.Format(_T("%1.2f"), myFloat2(v));
				pDC->TextOut(p1.x+2, p1.y, tStr);
			} // if

			float zmid = (z1+z2)*0.5f;
			if (z1<pCd.coord.zmax && zmid>pCd.coord.zmax) zmid = (float)pCd.coord.zmax;
			else if (z2>pCd.coord.zmin && zmid<pCd.coord.zmin) zmid = (float)pCd.coord.zmin;

			if (isMainModelShowing && zmid>=pCd.coord.zmin && zmid<=pCd.coord.zmax) {
				p1 = pCd.mm_coordz(xpos,zmid);
				if (zmid==(float)pCd.coord.zmin)
					p1.y += 2;
				else if (zmid==(float)pCd.coord.zmax)
					p1.y -= logFontNum.lfHeight - 2;
				else
					p1.y -= (int)myRound(logFontNum.lfHeight/2.0);

				tStr.Format(_T("%d"), i+1);
				pDC->TextOut(p1.x-4*logFontNum.lfWidth, p1.y, tStr);
			}

			if (z2 >= pCd.coord.zmin && z2 <= pCd.coord.zmax) {
				v = modX.vBot[i];
				if (isFloat1(v, 4.1))
					tStr.Format(_T("%1.1f"), myFloat1(v));
				else
					tStr.Format(_T("%1.2f"), myFloat2(v));
				if (p2.y - p1.y >= logFontNum.lfHeight*2) {
					// pDC->TextOut(rect.right-logFontNum.lfWidth*tStr.GetLength()-8 - lenRShiftBot, p2.y-logFontNum.lfHeight, tStr);
					pDC->TextOut(p2.x+2, p2.y-logFontNum.lfHeight+1, tStr);
				} // if
			} // if
		} // for i
		pDC->SetTextColor(oldColor);


		COLORREF cl = RGB(0,0,255);
		oldColor = pDC->SetTextColor(cl);
		int icont = draw.iLayerFocus;
		float xposThis;
		if (draw.nodes == 2 && icont>=0 && icont<velm->ncont-1) {
			for (int i=0; i<velm->nvel[icont][0]; i++) {
				xposThis = velm->xvel[i][icont][0];
				if (xposThis == xpos || (xposThis+xShift<pCd.coord.xmin || xposThis+xShift>pCd.coord.xmax)) continue; // xpos already plotted
				modX.dist = xposThis;
				vm.initModX(velm, &modX, false, true, false, vel.dz);
				p1 = pCd.mm_coordz(xposThis + xShift, (float)modX.depthMod[icont]);
				if (modX.depthMod[icont] >= pCd.coord.zmin && modX.depthMod[icont] <= pCd.coord.zmax) {
					tStr.Format(_T("%1.3f"), myFloat3(modX.vTop[icont]));
					pDC->TextOut(p1.x+10, p1.y, tStr);
				} // if
			}

			for (int i=0; i<velm->nvel[icont][1]; i++) {
				xposThis = velm->xvel[i][icont][1];
				if (xposThis == xpos || (xposThis+xShift<pCd.coord.xmin || xposThis+xShift>pCd.coord.xmax)) continue; // xpos already plotted
				modX.dist = xposThis;
				vm.initModX(velm, &modX, false, true, false, vel.dz);
				p1 = pCd.mm_coordz(xposThis + xShift, (float)modX.depthMod[icont]);
				p2 = pCd.mm_coordz(xposThis + xShift, (float)modX.depthMod[icont + 1]);
				if (modX.depthMod[icont + 1] >= pCd.coord.zmin && modX.depthMod[icont + 1] <= pCd.coord.zmax) {
					bool isOnTheSide = i==0  ||  i==velm->nvel[icont][1]-1;
					if (!isOnTheSide || (isOnTheSide && abs(p2.y-p1.y)>logFontNum.lfHeight+2)) {
						tStr.Format(_T("%1.3f"), myFloat3(modX.vBot[icont]));
						pDC->TextOut(p2.x+10, p2.y, tStr);
					}
				} // if
			}
		} // if


		// draw label at the top of xpos
		if (!isMainModelShowing) {
			p1 = pCd.mm_coordz(xposThis + xShift, 0.);
			p1.y = pCd.coord.logicalAxes.top - logFontNum.lfHeight - 1;
			pDC->TextOut(p1.x, p1.y, GetBaseFileName(velm->velSecName));
		}

		pDC->SetTextColor(oldColor);
		pDC->SelectObject(oldFont);
		pDC->SetBkMode(oldBkMode);





	}

	void CSeisWideDoc::DrawTempPoint(CDC* pDC, SEI_POINT seip) 
	{
		if (!seip.isValid) return;
		CPoint plt;
		plt = pCd.mm_coord(seip.x, seip.y, isTimeDomain()==TRUE);
		CPen redPen(PS_SOLID, 1, RGB(255,0,0));
		CPen *oldPen = pDC->SelectObject(&redPen);
		pDC->Ellipse(plt.x-200, plt.y-200, plt.x+200, plt.y+200);
		pDC->SelectObject(oldPen);
		seip.isValid = false;
	}

	void CSeisWideDoc::DrawModelDashCurve(CDC* pDC, CVelMod::VELMOD *velm, int numWaterLayers, double h)
	{
		// this is called only by DrawVelocityTheoreticalDepth() since it calls many times
		if (numWaterLayers<1) return;
		int num = velm->nzed[numWaterLayers];
		if (num<2) return;

		double xpos, ypos;
		int ii = 0;
		CPoint *plt = (CPoint *)malloc(num*sizeof(CPoint));
		for (int j=0; j<num; j++) {
			xpos = velm->xm[j][numWaterLayers];
			ypos = velm->zm[j][numWaterLayers]+h;
			if (isVisibleOrNot(xpos, ypos)) {
				plt[ii] = pCd.mm_coord(xpos,ypos, isTimeDomain()==TRUE);
				ii++;
			}
		} // for
		if(ii>1)  pDC->Polyline(plt, ii);
		free (plt);
	}

	void CSeisWideDoc::DrawVelocityTheoreticalDepth(CDC* pDC, CVelMod::VELMOD *velm)
	{

		// global variables used: draw, velMod, para, psei
		if (this->isTimeDomain() || !draw.isShowTheoryModel || draw.isNoLabelInSide || velm->ncont < 2) 
			return;

		CString tStr;
		CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();

		// now show the reference curves
		if (pFrame->psei->regionalModelA > 0.0001 && pFrame->psei->regionalModelB > 0.0001 && pFrame->psei->regionalModelV0 != 0.0) {
			CPen* oldPen;
			int numWaterLayers = (velMod.vf[0][1][0]>1.55 || velMod.vf[0][1][1]>1.55) ?  1  :  2;

			CPen bluePen(PS_DASH, 1, RGB(255,0,255));
			oldPen = pDC->SelectObject(&bluePen);
			double beta = log(pFrame->psei->regionalModelVinf / pFrame->psei->regionalModelV0 - 1.);

			double a = (1./2. - pFrame->psei->regionalModelA) / pFrame->psei->regionalModelB;
			double h = (log(a) - beta) / pFrame->psei->regionalModelAlpha;
			DrawModelDashCurve(pDC, velm, numWaterLayers, h);
			a = (1./3. - pFrame->psei->regionalModelA) / pFrame->psei->regionalModelB;
			h = (log(a) - beta) / pFrame->psei->regionalModelAlpha;
			DrawModelDashCurve(pDC, velm, numWaterLayers, h);
			a = (1./4. - pFrame->psei->regionalModelA) / pFrame->psei->regionalModelB;
			h = (log(a) - beta) / pFrame->psei->regionalModelAlpha;
			DrawModelDashCurve(pDC, velm, numWaterLayers, h);
			pDC->SelectObject(oldPen);

		} // if pFrame
	}

	void CSeisWideDoc::OnViewVelocitycolortwtt()
	{
		// TODO: Add your command handler code here
		// AfxMessageBox(_T("ok");
		dlgVelocityTwtt2 dlg;
		dlg.m_timeSecTitle = draw.plotTitle;
		dlg.m_velSecName = velMod.velSecName;
		dlg.m_xmax = myFloat3(pCd.coord.xmax);
		dlg.m_xmin = myFloat3(pCd.coord.xmin);
		dlg.m_xTick = myFloat3(pCd.coord.xTick);
		dlg.m_tmax = myFloat3(pCd.coord.tmax);
		dlg.m_tmin = myFloat3(pCd.coord.tmin);
		dlg.m_tTick = myFloat3(pCd.coord.tTick);
		dlg.m_timeSecName = draw.timeSecName;

		dlg.m_gain = myFloat3(para.gain);
		dlg.m_clip = myFloat3(para.clip);

		// sometimes the clip is zero and it will not display well
		if (dlg.m_clip < 0.000001) dlg.m_clip = 1.9f;

		dlg.m_fillOff = myFloat3(para.fillOff);

		dlg.m_digName = dig.digName;
		dlg.m_markerName = draw.markerName; // addition on Nov. 14, 2003
		dlg.m_xMultFactor = draw.markerXMultFactor;
		dlg.m_xShift = draw.markerXShift;
		dlg.m_yMultFactor = draw.markerYMultFactor;
		dlg.m_yShift = draw.markerYShift;
		dlg.m_markerRevYAxis = draw.markerIsRevYAxis;
		dlg.m_vrmsTauName = draw.vrmsTauName;
		dlg.m_wiggle = para.wiggle;
		dlg.m_isAveEnergy = draw.isAvgEnergy;
		dlg.m_xshot = (float)tx.xShot;
		//	dlg.m_colPalette = GetPathFromFileSlash(draw.timeSecName) + _T("colPalette.txt");
		dlg.m_velModExtras = draw.velSecNamesEx;
		dlg.m_distShift = draw.distShift;
		dlg.m_logScaleThreshold = ampColorDyn.logScaleThreshold;
		// dlg.m_modelEx

		if (dlg.DoModal() == IDOK)
		{
			draw.plotTitle = dlg.m_timeSecTitle;
			velMod.velSecName = dlg.m_velSecName.Trim();
			draw.timeSecName = dlg.m_timeSecName.Trim();
			// dig.digName = dlg.m_digName;
			pCd.coord.xmax = (float)dlg.m_xmax;
			pCd.coord.xmin = (float)dlg.m_xmin;
			pCd.coord.xTick = (float)dlg.m_xTick;
			pCd.coord.tmax = dlg.m_tmax;
			pCd.coord.tmin = dlg.m_tmin;
			pCd.coord.tTick = dlg.m_tTick;

			para.gain = dlg.m_gain;
			para.clip = dlg.m_clip;
			para.fillOff = dlg.m_fillOff;

			dig.digName = dlg.m_digName;
			draw.markerName = dlg.m_markerName; // addition on Nov. 14, 2003
			draw.markerXMultFactor = dlg.m_xMultFactor;
			draw.markerXShift = dlg.m_xShift;
			draw.markerYMultFactor = dlg.m_yMultFactor;
			draw.markerYShift = dlg.m_yShift;
			draw.markerIsRevYAxis = dlg.m_markerRevYAxis;
			draw.vrmsTauName = dlg.m_vrmsTauName;
			para.wiggle = dlg.m_wiggle;
			draw.isAvgEnergy = dlg.m_isAveEnergy;
			tx.xShot = dlg.m_xshot;
			//	ampColorDyn.colFileName = dlg.m_colPalette;
			draw.velSecNamesEx = dlg.m_velModExtras;
			draw.distShift = dlg.m_distShift;
			ampColorDyn.logScaleThreshold = dlg.m_logScaleThreshold;
		}
		else
		{
			return;
		}

		draw.modeOld = draw.mode;  // setting this to -1 guarentees re-calc velMod.tm[] , otherwise if draw.modeOld==draw.mode it will not re-calc tm[]!!!
		draw.mode = 9;	//Velocity contours will be drawn in TWTT domain.
		draw.isSameDataDisplay = FALSE; //indicate display has been changed and will re-load all data in OnDraw().

		SetModifiedFlag();
		UpdateAllViews(NULL);
		NotifyChanged();

	}

	//void CSeisWideDoc::DrawVelocityLabelTwtt(CDC* pDC, double xpos)
	//{
	//	DrawVelocityLabelTwtt(pDC, &velMod, xpos);
	//}


	void CSeisWideDoc::DrawVelocityLabelTwtt(CDC* pDC, CVelMod::VELMOD *velm, double xpos, double xShift)
	{
		// global variables used: draw, velMod, para
		if (!this->isTimeDomain() || draw.isNoLableOutside || draw.isNoLabelInSide ||
			velm->ncont < 2) 
			return;
		setCurrentDirectoryAs(getWorkingPathSlash());
		if(!isFileExistNotDirectory(velm->velSecName) || !this->isModelVisible(velm, xShift)) return;
		if (xpos+xShift < pCd.coord.xmin || xpos+xShift > pCd.coord.xmax) return;

		int oldBkMode=pDC->SetBkMode(OPAQUE);

		CString tStr;
		// int numRef = 12000; // cannot make this floating

		CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();

		// Initialize a LOGFONT structure for the fonts.
		LOGFONT logFontNum;  // font for drawing numbers
		pDC->GetCurrentFont()->GetLogFont(&logFontNum);
		float xyRatio = (float)logFontNum.lfWidth / (float)logFontNum.lfHeight;
		int numXLogical = (int)myRound(pFrame->fLabelDistance3 * 150.);
		int numYLogical = (int)(numXLogical / xyRatio);
		logFontNum.lfHeight = numYLogical;
		logFontNum.lfWidth = numXLogical;
		logFontNum.lfEscapement = 0;
		logFontNum.lfOrientation = 0;
		logFontNum.lfWeight = FW_NORMAL;
		logFontNum.lfItalic = 0;
		logFontNum.lfUnderline = 0;
		logFontNum.lfStrikeOut = 0;
		logFontNum.lfCharSet = ANSI_CHARSET;
		logFontNum.lfOutPrecision = OUT_DEFAULT_PRECIS;
		logFontNum.lfClipPrecision = CLIP_DEFAULT_PRECIS;
		logFontNum.lfQuality = DEFAULT_QUALITY;
		logFontNum.lfPitchAndFamily = FF_SWISS;
		_tcscpy_s(logFontNum.lfFaceName, _T("Arial"));

		CFont fontSmall;
		fontSmall.CreateFontIndirect(&logFontNum);
		CFont* oldFont;
		oldFont = pDC->SelectObject(&fontSmall);


		CSize size = pDC->GetWindowExt(); 
		int xplot, yplot;

		bool isTime = isTimeDomain() == TRUE;
		// TWTT display of model: we need to show velocity labels at the rightmost side
		CVelMod vm;
		CVelMod::VELMOD_X modX;
		modX.dist = xpos;
		vm.initModX(velm, &modX, isTime, true, true, vel.dz);

		COLORREF cl = (velm->velSecName == velMod.velSecName) ?  RGB(255,0,0)  :  RGB(0,0,255);
		COLORREF oldColor = pDC->SetTextColor(cl);
		CPoint p1,p2;
		for (int i=0; i<velm->ncont-1; i++) {
			if (velm->nzed[i]<1 || velm->nzed[i+1]<1) continue;  // no points defined for this layer
			float z1 = (float)modX.timeMod[i];
			float z2 = (float)modX.timeMod[i + 1];
			if (z2 <= z1) continue;  // no points defined for this layer
			p1 = pCd.mm_coordt(xpos+xShift,z1);
			p2 = pCd.mm_coordt(xpos+xShift,z2);

			if (z1 > pCd.coord.tmin && z1 < pCd.coord.tmax) {
				tStr.Format(_T("%.3f   %.3f"), myFloat3(modX.timeMod[i]), myFloat3(modX.depthMod[i]));
				pDC->TextOut(p1.x-logFontNum.lfWidth*(tStr.GetLength()+1), (int)myRound(p1.y - (float)logFontNum.lfHeight/2.0), tStr);
			}

			float zavg = (z1 + z2) * 0.5f;
			if (zavg >= pCd.coord.tmin || zavg <= pCd.coord.tmax) {
				xplot = p2.x-2*logFontNum.lfWidth -1;  // why -1 pixel? because otherwise it will cut the border if x=0km
				yplot = (p1.y+p2.y)/2-logFontNum.lfHeight/2;
				if (yplot>0 && yplot<size.cy && xplot>=0 && xplot<size.cx) {
					tStr.Format(_T("%d"), i+1);
					pDC->TextOut(xplot, yplot, tStr);
				}
			} // if
		} // for i



		CPoint plt[MOD_LAYER_MAX*2];
		double deltax = (pCd.coord.axisX2 - pCd.coord.axisX1) / 30. / 7. * pFrame->fLabelDistance3;
		double aSign = ((xpos-pCd.coord.axisX1) > (pCd.coord.axisX2-xpos))  ?
			-1.  :  1.;
		deltax *= aSign;
		int count = 0;
		double v;
		for (int i=0; i<velm->ncont-1; i++) {
			if (velm->nzed[i]<1) continue;  // no points defined for this layer
			if (modX.timeMod[i] < pCd.coord.axisY1 && modX.timeMod[i + 1]>pCd.coord.axisY1) {
				// we need to insert a point and then continue the loop
				v = modX.vTop[i] + (modX.vBot[i] - modX.vTop[i])*
					(pCd.coord.axisY1 - modX.timeMod[i]) / (modX.timeMod[i + 1] - modX.timeMod[i]);
				plt[count++] = pCd.mm_coordt(xpos+xShift + deltax*(v-1.5), pCd.coord.axisY1);
				continue;
			}
			else if (modX.timeMod[i] < pCd.coord.axisY1)
				continue;
			plt[count++] = pCd.mm_coordt(xpos + xShift + deltax*(modX.vTop[i] - 1.5), modX.timeMod[i]);
			if (modX.timeMod[i + 1] < pCd.coord.axisY2)
				plt[count++] = pCd.mm_coordt(xpos + xShift + deltax*(modX.vBot[i] - 1.5), modX.timeMod[i + 1]);
			else {
				// deal with the last point
				double deltaTime = (modX.timeMod[i + 1] - modX.timeMod[i]);
				v = (deltaTime>0.) ? modX.vTop[i] + (modX.vBot[i] - modX.vTop[i])*(pCd.coord.axisY2 - modX.timeMod[i]) / deltaTime : modX.vTop[i];
				plt[count++] = pCd.mm_coordt(xpos+xShift + deltax*(v-1.5), pCd.coord.axisY2);
				break;
			}
		} // for i
		if (count > 1) {
			pDC->Polyline(plt, count);
		}


		// draw label at the top of xpos
		tStr.Format(_T("Twtt      km       km/s"));
		p1 = pCd.mm_coordt(xpos+xShift, (float)pCd.coord.tmin);
		pDC->TextOut(p1.x-logFontNum.lfWidth * 14, p1.y + logFontNum.lfHeight+1, tStr);
		p1.y = pCd.coord.logicalAxes.top - logFontNum.lfHeight - 1;
		pDC->TextOut(p1.x, p1.y, GetBaseFileName(velm->velSecName));
		//pDC->TextOut(p1.x-logFontNum.lfWidth * 14, p1.y, GetBaseFileName(velm->velSecName));


		for (int i=0; i<velm->ncont-1; i++) {
			if (velm->nzed[i]<1 || velm->nzed[i+1]<1) continue;  // no points defined for this layer
			float z1 = (float)modX.timeMod[i];
			float z2 = (float)modX.timeMod[i + 1];
			if (z2 <= z1) continue;  // no points defined for this layer
			p1 = pCd.mm_coordt(xpos+xShift,z1);
			p2 = pCd.mm_coordt(xpos+xShift,z2);

			register double v;
			if (z1 >= pCd.coord.tmin && z1 <= pCd.coord.tmax) {
				v = modX.vTop[i];
				if (isFloat1(v, 4.1))
					tStr.Format(_T("%1.1f"), myFloat1(v));
				else
					tStr.Format(_T("%1.2f"), myFloat2(v));
				pDC->TextOut(p1.x, p1.y, tStr);
			} // if
			if (z2 >= pCd.coord.tmin && z2 <= pCd.coord.tmax) {
				v = modX.vBot[i];
				if (isFloat1(v, 4.1))
					tStr.Format(_T("%1.1f"), myFloat1(v));
				else
					tStr.Format(_T("%1.2f"), myFloat2(v));
				if (p2.y - p1.y >= logFontNum.lfHeight*2) {
					pDC->TextOut(p2.x, p2.y-logFontNum.lfHeight+1, tStr);
				} // if
			} // if
		} // for i
		pDC->SetTextColor(oldColor);





		cl = RGB(0,0,255);
		oldColor = pDC->SetTextColor(cl);
		int icont = draw.iLayerFocus;
		double xposThis;
		if (draw.nodes == 2 && icont>=0 && icont<velm->ncont-1) {
			for (int i=0; i<velm->nvel[icont][0]; i++) {
				xposThis = velm->xvel[i][icont][0];
				if (xposThis == xpos || (xposThis+xShift<pCd.coord.xmin || xposThis+xShift>pCd.coord.xmax) ) continue; // xpos already plotted
				modX.dist = xposThis;
				vm.initModX(velm, &modX, isTime, true, true, vel.dz);
				p1 = pCd.mm_coordt(xposThis + xShift, (float)modX.timeMod[icont]);
				if (modX.timeMod[icont] >= pCd.coord.tmin && modX.timeMod[icont] <= pCd.coord.tmax) {
					tStr.Format(_T("%1.3f"), myFloat3(modX.vTop[icont]));
					pDC->TextOut(p1.x+10, p1.y, tStr);
				} // if
			}

			for (int i=0; i<velm->nvel[icont][1]; i++) {
				xposThis = velm->xvel[i][icont][1];
				if (xposThis == xpos || (xposThis+xShift<pCd.coord.xmin || xposThis+xShift>pCd.coord.xmax) ) continue; // xpos already plotted
				modX.dist = xposThis;
				vm.initModX(velm, &modX, isTime, true, true, vel.dz);
				p1 = pCd.mm_coordt(xposThis + xShift, (float)modX.timeMod[icont]);
				p2 = pCd.mm_coordt(xposThis + xShift, (float)modX.timeMod[icont + 1]);
				if (modX.timeMod[icont + 1] >= pCd.coord.tmin && modX.timeMod[icont + 1] <= pCd.coord.tmax) {
					bool isOnTheSide = i==0  ||  i==velm->nvel[icont][1]-1;
					if (!isOnTheSide || (isOnTheSide && abs(p2.y-p1.y)>logFontNum.lfHeight+2)) {
						tStr.Format(_T("%1.3f"), myFloat3(modX.vBot[icont]));
						pDC->TextOut(p2.x+10, p2.y, tStr);
					}
				} // if
			}
		} // if







		pDC->SetTextColor(oldColor);
		pDC->SelectObject(oldFont);

		// can move this code to a separate routine
		// xShift will not be applied to RMS velocity display as below
		if (!draw.vrmsTauName.IsEmpty() &&
			tx.xShot >= pCd.coord.xmin && 
			tx.xShot <= pCd.coord.xmax) {
				CDigitize::DIGITIZE dig2;
				CDigitize pDg;
				int xplot;
				int yplot;
				dig2.digName = draw.vrmsTauName;
				if (pDg.myDigitizingLoadTXTUnix2(&dig2, FALSE, FALSE)) {
					int n = dig2.nPoint[0];
					bool isMilisec = (dig2.x[n-1][0] > 1000.f) ? true  :  false;

					for (int j=0; j<n; j++) {
						if (j > 500) break; // we do not think this is a valid file

						float t = dig2.t[j][0];
						if (isMilisec) t *= 0.001f;
						if (t < pCd.coord.tmin || t > pCd.coord.tmax) continue;

						float v = dig2.x[j][0];
						if (isMilisec) v *= 0.001f;
						v = myFloat2(v);

						p1 = pCd.mm_coordt(xpos, t);

						xplot = p1.x + 9*logFontNum.lfWidth;
						yplot = p1.y;

						// minor adjustment for label vertical position
						if (j+1 < n) {
							float tNext = dig2.t[j+1][0];
							if (isMilisec) tNext *= 0.001f;
							p2 = pCd.mm_coordt(xpos, tNext);
							int yplotNext = p2.y;
							if (yplotNext - yplot < logFontNum.lfHeight + 2) {
								// the next label is too close. 
								yplot = yplotNext -  logFontNum.lfHeight - 2;
							}
						}

						tStr.Format(_T("%1.2f"), v);
						pDC->TextOut(xplot, yplot, tStr);
					} // for j
					tStr.Format(_T("(Vint-rms)"));
					p1 = pCd.mm_coordt(xpos, (float)pCd.coord.tmin);
					pDC->TextOut(xplot, p1.y, tStr);
				} // if
		} // if velMod


		pDC->SetBkMode(oldBkMode);
	}


	bool CSeisWideDoc::DrawVelocityTwtt(CDC* pDC, CVelMod::VELMOD *velm, BOOL isNoNodes, CPen* greenPen, double xShift)
	{
		// pointer velm must already has been initialized to continue.
		if(draw.isNoBoundary) return TRUE;
		if (draw.mode != 9) return FALSE;
		if(!isFileExistNotDirectory(velm->velSecName) || !this->isModelVisible(velm, xShift)) return FALSE;
		CVelMod vm;
		if (!vm.isVelModValid(velm)) return FALSE;

		if(!isFileExistNotDirectory(velm->velSecName) || !this->isModelVisible(velm, xShift)) return FALSE;

		int i,j,icont;

		//Generate velocity contours
		CPoint p,p1,plt[MOD_POINTS_MAX*2],pltOld[MOD_POINTS_MAX];
		double xx[MOD_POINTS_MAX],tt[MOD_POINTS_MAX],vsvp[MOD_POINTS_MAX];
		CPen* oldPen;

		//Start plotting velocity color map.
		COLORREF cl = (velm->velSecName == velMod.velSecName) ?  RGB(255,0,0)  :  RGB(255,255,0);

		CPen redPenThick(PS_SOLID, (int)(pCd.coord.logicalAxes.Height()/400), cl);
		CPen redPenThin(PS_SOLID, 0, cl);

		if (greenPen == NULL) {
			COLORREF colorThis = RGB(rand()*120 ,rand()*120 ,rand()*120 );
			greenPen = &CPen(PS_SOLID, 0, colorThis);
		}
		CPen normalPen(PS_SOLID, 0, RGB(0,100,255));

		CPen bluePen(PS_SOLID, 0, RGB(255,100,0));
		CPen dotPen(PS_DOT, 0, RGB(255,100,0));

		CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();

		if (draw.bigNodes < 1) draw.bigNodes = 1;
		int dPlt = (int)(MIN(pCd.coord.logicalAxes.Width(), pCd.coord.logicalAxes.Height())/350.) * draw.bigNodes;
		//	float biggerFactor = (pFrame->thicknessLines < 2.0f)  ?  pFrame->thicknessLines  :  2.0f;
		//	int dPlt =  (int)myRound( (float)dPlt * pFrame->thicknessLines);


		float *twttMod = (float *)malloc(sizeof(float)*velm->ncont);


		// consider S waves
		int poisCount = 0;
		if (draw.raymode > 0) {
			CStringArray *csArr = new CStringArray();
			if (loadParam(draw.rayName, _T("pois"), csArr) ) {
				poisCount = (int)csArr->GetCount();
				for (int ii=0; ii<velm->ncont-1; ii++)
				{
					float apois = (ii < poisCount)  ?  
						(float)_tstof(csArr->ElementAt(ii))  :  (float)_tstof(csArr->ElementAt(poisCount-1));
					vsvp[ii]=sqrt((1.-2.*apois)/(2.*(1.-apois)));
				}
			}
			csArr->RemoveAll();
			csArr = NULL;
		} // if draw.raymode
		if (poisCount == 0) {
			// if here we use Vp only
			for (int ii=0; ii<velm->ncont-1; ii++) {
				vsvp[ii]=1.f;
			}
		}

		// main loop
		for (icont=0; icont<velm->ncont; icont++) {
			BOOL isLast = FALSE;
			i =0;
			for (j=0; j<velm->nzed[icont]; j++) {
				xx[i] = velm->xm[j][icont] + xShift;
				if (xx[i] >= pCd.coord.xmax) {
					xx[i] = pCd.coord.xmax;
					isLast = TRUE;
				}

				tt[i] = velm->tm[j][icont];
				i++;
				if (isLast) break;
			} // for j



			i = myClipPoints2(i, MOD_POINTS_MAX, xx, tt, pCd.coord.xmin, pCd.coord.xmax, pCd.coord.tmin, pCd.coord.tmax);
			if (i > 1) {
				for (j=0; j<i; j++)
					plt[j] = pCd.mm_coordt(xx[j],tt[j]);



				if (draw.nodes==2) {
					if ( icont==draw.iLayerFocus && draw.isTopBound ) 
						oldPen = pDC->SelectObject(&redPenThick);
					else if ( icont==draw.iLayerFocus+1 && draw.isTopBound ) 
						oldPen = pDC->SelectObject(&redPenThin);
					else if ( icont==draw.iLayerFocus && !draw.isTopBound ) 
						oldPen = pDC->SelectObject(&redPenThin);
					else if ( icont==draw.iLayerFocus+1 && !draw.isTopBound ) 
						oldPen = pDC->SelectObject(&redPenThick);
					else if (greenPen!=NULL)
						oldPen = pDC->SelectObject(greenPen);
					else 
						oldPen = pDC->SelectObject(&normalPen);
				} else {
					if(draw.nodes ==1 && icont==draw.iLayerFocus)
						oldPen = pDC->SelectObject(&redPenThick);
					else if (greenPen!=NULL)
						oldPen = pDC->SelectObject(greenPen);
					else 
						oldPen = pDC->SelectObject(&normalPen);
				}

				pDC->Polyline(plt,i);
				pDC->SelectObject(oldPen);
			} // if

			if(!isNoNodes) {
				if(icont==draw.iLayerFocus) {
					oldPen = pDC->SelectObject(&redPenThick);
				} else {
					oldPen = pDC->SelectObject(&redPenThin);
				}
				if(draw.nodes==1) {
					for (j=0; j<i; j++)
						pDC->Ellipse(plt[j].x-dPlt,plt[j].y-dPlt,plt[j].x+dPlt,plt[j].y+dPlt);
				}
				else if (draw.nodes==2 && draw.iLayerFocus>=0 && draw.iLayerFocus<velm->ncont-1 && icont==draw.iLayerFocus) {
					for (int k=0; k<2; k++) {
						i = 0;
						int icontSel = (k==0)  ?  icont  :  icont+1;
						for (j=0; j<velm->nvel[icont][k]; j++) {
							register double x1 = velm->xvel[j][icont][k] + xShift;
							xx[i] = x1;
							for (int ix=0; ix<(velm->nzed[icontSel]-1); ix++) {
								if(x1>=velm->xm[ix][icontSel] + xShift && x1<=velm->xm[ix+1][icontSel] + xShift) {
									tt[i] = velm->tm[ix][icontSel] + (velm->tm[ix+1][icontSel] -
										velm->tm[ix][icontSel])*(x1 - velm->xm[ix][icontSel])/
										(velm->xm[ix+1][icontSel] - velm->xm[ix][icontSel]);
									break;
								}
							}
							if(isVisibleOrNot(xx[i], tt[i])) {
								plt[i] = pCd.mm_coordt(xx[i],tt[i]);
								i++;
							}
						}
						for (j=0; j<i; j++) 
							pDC->Ellipse(plt[j].x-dPlt,plt[j].y-dPlt,plt[j].x+dPlt,plt[j].y+dPlt);
					} // for k
				} // else
				pDC->SelectObject(oldPen);
			} // if isNoNodes
		} // for icont

		free(twttMod);

		return TRUE;
	}



	bool CSeisWideDoc::DrawVelocityTwtt(CDC* pDC)
	{
		if(draw.isNoBoundary) return TRUE;
		if (draw.mode != 9) return FALSE;
		setCurrentDirectoryAs(getWorkingPathSlash());

		CString tStr;
		if (!isFileExistNotDirectory(velMod.velSecName)) {
			tStr.Format(_T("A valid velocity model file not found: %s."), velMod.velSecName);
			myCaption(tStr);
		}

		CVelMod vm;
		DrawVelocityTwtt(pDC, &velMod, draw.isNoNodes);
		DrawVelocityLabelTwtt(pDC, &velMod, tx.xShot, 0.);

		if (draw.velSecNamesEx.GetLength()>0) {
			draw.velSecNamesEx.Replace(_T(",\n"), _T("\r\n"));
			draw.velSecNamesEx.Replace(_T(",\r\n"), _T("\r\n"));
			draw.velSecNamesEx.Replace(_T(","), _T("\r\n"));
			CVelMod::VELMOD velm;
			CStringArray arr;
			int nElementCount = SplitString(draw.velSecNamesEx, _T("\r\n"), arr);

			CPen greenPen(PS_SOLID, 0, RGB(0,0,255));
			for (int i=0; i<arr.GetCount()-1; i++) {
				// example:  80, 115, G:\arcticSBs\sb2007\sb21\model0721New.bin
				double xShift = 0.;
				double xpos = -99999.;
				if (IsNumeric(arr.ElementAt(i).Trim())) {
					xShift = StringToFloat(arr.ElementAt(i).Trim());
					i++;
				}
				if (IsNumeric(arr.ElementAt(i).Trim())) {
					xpos = StringToFloat(arr.ElementAt(i).Trim());
					i++;
				}

				tStr = arr.ElementAt(i).Trim();

				// GetPathFromFileSlash(f)
				//if (tStr.Find(_T("\\")) < 0) {
				//	// since no path info in tStr, we  need to add path to tStr as a file
				//	tStr = GetPathFromFileSlash(this->GetPathName()) + tStr;
				//}

				

				if (!IsNumeric(tStr) && isFileExistNotDirectory(tStr) && GetBaseFileName(tStr) != GetBaseFileName(velMod.velSecName) ) {
					// this is a vel model
					velm.velSecName = tStr;
					vm.velModSetArrays(&velm);
					if (vm.loadInitVel(&velm, velm.velSecName, vel.dz)) {
						DrawVelocityTwtt(pDC, &velm, TRUE, &greenPen, xShift);
						DrawVelocityLabelTwtt(pDC, &velm, xpos, xShift);
					}
					vm.velModFreeArrays(&velm);
				}
			}

			arr.RemoveAll();
		}



		draw.modeOld = 9;   // this means already converted to time

		return true;
	}




	/*
	NMO modes: depreciated. Some codes not working as a result of code updates
	*/
	void CSeisWideDoc::OnTimeForwideNmovelocity()
	{
		AfxMessageBox(_T("Depreciated. Some codes not working as a result of code updates"));
		return;   

		//	this->setContour4Raytrace("E:\\project\\work3\\myRayInvr2008\\sembRayInvr\\f.insemb", 12.830f, 0.005f, 0.6f, 3.f, 1.9f, 1, 3.3f);
		//	return;
		int j;
		int nvPerturb;

		// local parameters for the routine not saved by .sei file
		float vPerturb;
		static float vPerturbMin = 1.6f;
		static float vPerturbMax = 6.f;
		static float vPerturbDv = 0.02f;
		static float secsmooth = 0.06f;
		static int numDisplay = 0;
		static BOOL isCoh = false;
		static int raymode = 0;  // 0=PP; 1=PS; 2=SP
		static int stackmode = 0;  // 0=amplitude summation approach; 1=semblence coefficient; 2=Energy normalised cross correlation 
		static float xpercent = 0.8f; //
		static float offsetMax = 10.f;
		/*
		" Notes:								     ",
		" UnNormalized Selective CrossCorrelation sum: is based on the coherence     ",
		" measure known as crosscorrelation sum. The difference is that the selective",
		" approach sum only crosscorrelation pairs with relatively large differential",
		" moveout, thus increasing the resolving power in the velocity spectra       ",
		" compared to that achieved by conventional methods.  The selection is made  ",
		" using a parabolic approximation of the differential moveout and imposing a ",
		" threshold for those differential moveouts.				     ",
		"									     ",
		" That threshold is the parameter tau in this program, which varies between  ",
		" 0 to 1.  A value of tau=0, means conventional crosscorrelation sum is      ",
		" applied implying that all crosscorrelations are included in the sum. In    ",
		" contrast, a value of tau=1 (not recomended) means that only the            ",
		" crosscorrelation formed by the trace pair involving the shortest and longest",
		" offset is included in the sum. Intermediate values will produce percentages",
		" of the crosscorrelations included in the sum that will be shown in the     ",
		" screen before computing the velocity spectra. Typical values for tau are   ",
		" between 0.2 and 0.6, producing approximated percentages of crosscorrelations",
		" summed between 60% and 20%. The higher the value of tau the lower the     ",
		" percentage and higher the increase in the resolving power of velocity	      ",
		" spectra.								      ",
		"									      ",
		" Keeping the percentage of crosscorrelations included in the sum between 20%",
		" and 60% will increase resolution and avoid the precense of artifacts in the",
		" results.  In data contaminated by random noise or statics distortions is    ",
		" recomended to mantaing the percentage of crosscorrelations included in the  ",
		" sum above 25%.  After computing the velocity spectra one might want to     ",
		" adjust the level and number of contours before velocity picking.  	      ",
		*/

		draw.isSameDataDisplay = TRUE; //indicate display has been changed and will re-load all data in OnDraw().

		// dialog controls
		CdlgWide2Velocity dlg;
		dlg.m_timeSecName = draw.timeSecName;
		if (draw.depthSecName.IsEmpty()) draw.depthSecName = _T("depth.sgy");
		dlg.m_depthSecName = draw.depthSecName;
		dlg.m_velname = velMod.velSecName;
		dlg.m_rayTracing = draw.rayName;
		dlg.m_floatName = velMod.floatName;
		dlg.m_zmax = (float)pCd.coord.zmax;
		dlg.m_zmin = (float)pCd.coord.zmin;
		dlg.m_dz = (float)vel.dz;
		dlg.m_vPerturbMin = vPerturbMin;
		dlg.m_vPerturbMax = vPerturbMax;
		dlg.m_dv = vPerturbDv;
		dlg.m_iLayerFocus = draw.iLayerFocus;
		dlg.m_secsmooth = secsmooth;
		dlg.m_iscoh = isCoh;
		dlg.m_numDisplay = numDisplay;
		dlg.m_basePower = (float)para.basePower;  if(fabs(para.basePower) > 100.f) para.basePower = 0.f;
		dlg.m_rayMode = raymode;
		dlg.m_sumMethod = stackmode;
		dlg.m_xpercent = (int)myRound(xpercent*100.);
		dlg.m_offsetMax = offsetMax;

		dlg.m_tmin = (float)pCd.coord.tmin;
		dlg.m_tmax = (float)pCd.coord.tmax;

		if (dlg.DoModal() == IDOK)
		{
			draw.timeSecName = dlg.m_timeSecName.Trim();
			draw.depthSecName = dlg.m_depthSecName;
			velMod.velSecName = dlg.m_velname.Trim();
			draw.rayName = dlg.m_rayTracing;
			velMod.floatName = dlg.m_floatName;
			pCd.coord.zmax = dlg.m_zmax;
			pCd.coord.zmin = dlg.m_zmin;
			vel.dz = dlg.m_dz;
			vPerturbMin = dlg.m_vPerturbMin;
			vPerturbMax = dlg.m_vPerturbMax;
			vPerturbDv = dlg.m_dv;

			vPerturbMin = myFloat(vPerturbMin);
			vPerturbMax = myFloat(vPerturbMax);
			vPerturbDv = myFloat(vPerturbDv);

			draw.iLayerFocus = dlg.m_iLayerFocus; // note: this is 1-based, while our convention is 0-based
			if (draw.iLayerFocus < 1) draw.iLayerFocus = 1;
			secsmooth = dlg.m_secsmooth;
			isCoh = dlg.m_iscoh;
			numDisplay = dlg.m_numDisplay;
			para.basePower = dlg.m_basePower;
			raymode = dlg.m_rayMode ;
			stackmode = dlg.m_sumMethod;
			xpercent = (float)myFloat(dlg.m_xpercent * 0.01f);
			if (xpercent>1.f) xpercent = 1.f;
			else if (xpercent < 0.01f) xpercent = 0.01f;
			offsetMax = dlg.m_offsetMax;
			pCd.coord.tmin = dlg.m_tmin;
			pCd.coord.tmax = dlg.m_tmax;
		}
		else 
		{
			return;
		}












		// fix up for dz, since it cannot be too big
		if (vel.dz*MIL > USHRT_MAX-1) vel.dz = (double)(USHRT_MAX-1) / (double)MIL;
		draw.depthSecName = mySetFileExtension(draw.depthSecName, _T("sgy"));



		if (!isFileExistNotDirectory(draw.timeSecName)) return;

		if(draw.depthSecName.IsEmpty()) return;



		//################### Prepare the raytracing
		if(!checkModelError(velMod.velSecName))
		{
			if(AfxMessageBox(_T("Current model has boundary overlaps; Raytracing may hang up if this model is used; Do you want to continue?"), MB_YESNO |MB_ICONINFORMATION) != IDYES)
			{
				return;
			}
		} 

		CString txoutName = _T("tx.outsemb");
		if (raymode == 0) txoutName += _T("pp");
		else if (raymode == 1) txoutName += _T("ps");
		else if (raymode == 2) txoutName += _T("sp");

		CString astr;
		CString t;

		//make tx.out file in the same directory as velMod.velSecName.
		CString name = velMod.velSecName;
		int pathLen = name.ReverseFind( '\\' );
		t = name.Left(pathLen);
		t.MakeLower();
		if(pathLen<0) {
			TCHAR curDir[_MAX_PATH];
			GetCurrentDirectory(_MAX_PATH, curDir);
			t = (CString)curDir;
		}
		CString txPath;
		txPath.Format(_T("%s\\temp"), t);
		if(!isDirectoryExist(txPath)) {
			// create the temp dir
			if (!CreateDirectory(txPath, NULL)) {
				astr.Format(_T("Cannot create a working directory: %s"), txPath);
				AfxMessageBox(astr);
				return;
			}
		}
		SetCurrentDirectory(txPath);


		// copy r.in 
		t = txPath+"\\r.in";
		CString tempStr = draw.rayName;
		tempStr.MakeLower();
		if (tempStr != t &&  tempStr != _T("r.in")) {
			CopyFile(draw.rayName, t, FALSE);
		}

		// copy v.bin
		tempStr = velMod.velSecName;
		tempStr.MakeLower();
		t = txPath+"\\v.bin";
		if(tempStr != t && tempStr != _T("v.bin") ) {
			CopyFile(velMod.velSecName, _T("v.bin"), FALSE);
		} 


		if (pCd.coord.zmax < pCd.coord.zmin) pCd.coord.zmax = pCd.coord.zmax + 1.;
		int nz = (int)((pCd.coord.zmax - pCd.coord.zmin) / vel.dz + 1.0);
		if (nz > 6000) {
			nz = 6000;  // fortran program has this array limit to impose
			pCd.coord.zmax = pCd.coord.zmin + (nz-1)*vel.dz;
			AfxMessageBox(_T("Max depth adjusted due to array size limitation of 6000 points. Contact programer to increase size if needed."));
			OnTimeForwideNmovelocity();
			return;
		}


		//##################### now do the raytracing
		if ( !isXShotDefined(tx.xShot) ) {
			//CString txPath = getWorkingPathSlash();
			//if (!isDirectoryExist(txPath))
			//	txPath = _T("tx.out");
			//else
			//	txPath += _T("tx.out");
			tx.xShot = (float)getXPosAll();
		}
		//Do not refresh screen in any way until raytracing finished. Otherwise, 
		// it may refresh screen while raytracing is running!
		draw.isSameDataDisplay = TRUE; 

		astr.Format(_T("%s\\%s%5.3f"), txPath, txoutName, vPerturbMin);
		if(!isFileExistNotDirectory(astr) ||
			AfxMessageBox(_T("Do you want to raytrace for the current parameters? If you choose Yes, you will need to wait until raytracing completed, and rerun this processing."), MB_YESNO |MB_ICONINFORMATION) == IDYES) {
				// generate f.insemb file
				if (this->setContour4Raytrace(txPath+_T("\\f.insemb"), (float)tx.xShot, (float)vel.dz, (float)pCd.coord.zmin, &pCd.coord.zmax, vPerturbMin, vPerturbMax, vPerturbDv) == _T("")) {
					AfxMessageBox(_T("Failed to generate f.insemb file"));
					return;
				}
				// if raytracing fails, my display routine still uses the old "tx.out". This line avoids this.
				//DeleteFile("tx.out"); 
				//DeleteFile("rPath.out"); 
				//DeleteFile("r1.out"); 
				astr.Format(_T("%s\\%s*"), txPath, txoutName);
				CShellFileOp sfo;
				BOOL         bAPICalled;
				int          nAPIReturnVal;
				sfo.AddSourceFile (astr);
				sfo.SetOperationFlags
					( FO_DELETE,         // the operation type (delete in this case)
					AfxGetMainWnd(), // pointer to parent window
					FALSE,           // flag - silent mode?
					FALSE,           // flag - allow undo?
					FALSE,           // flag - should wild cards affect files only?
					TRUE,            // flag - suppress confirmation messages?
					TRUE,            // flag - suppress confirmation messages 
					// when making directories?
					FALSE,           // flag - rename files when name collisions occur?
					FALSE );         // flag - simple progress dialog?
				if ( sfo.Go ( &bAPICalled, &nAPIReturnVal ) )
				{
					// The operation succeeded!
				}



				name = m_strPathName;
				int nPathLength =  GetModuleFileName (NULL,name.GetBuffer(_MAX_PATH), _MAX_PATH );
				name.ReleaseBuffer();
				CString progPathBak = _T("\"") + name.Left(name.ReverseFind( '\\' ));
				progPathBak += _T("\\sembRayinvr.exe\"");
				CString progPath = "";
				CString str;

				// start generating string for fortran batch procoessing
				for (vPerturb = vPerturbMin, nvPerturb=0; vPerturb < vPerturbMax; vPerturb += vPerturbDv, nvPerturb++) {
					progPath += progPathBak;
					str.Format(_T(" %3d %3d %6.3f"), draw.iLayerFocus, raymode, vPerturb);
					// progPath += str + _T("\r\n";
					progPath.Format(_T("%s\r\n"), str);
				}

				myProcess(progPath, txPath);
				//if(AfxMessageBox(_T("Please wait for the raytracing program to finish. Click YES when finished raytracing.", MB_YESNO |MB_ICONINFORMATION) != IDYES) {
				//	return;
				//}
				return;
		}




		int np_max = 0;
		np_max = 30;
		int nv_max = 0;
		for (vPerturb = vPerturbMin, nvPerturb=0; vPerturb <= vPerturbMax; vPerturb += vPerturbDv, nvPerturb++ ) {
			astr.Format(_T("%s\\%s%5.3f"), txPath, txoutName, vPerturb);
			if (!isFileExistNotDirectory(astr)) {
				// we need to restrain the vPerturbMax accordingly, otherwise we may have array indexing problem
				vPerturbMax = vPerturbMin + (float)(nvPerturb - 1)*vPerturbDv;
				break;
			}
		}
		nv_max = nvPerturb;
		if (nvPerturb < 2) {
			AfxMessageBox(_T("Less than 2 pertubations read in. pertubations intervals may have changed. Please check."));
			return;
		}






		// ################### Use the raytracing results to form segy output
		segy tr;
		bhed bh;

		CFile file;
		if (!file.Open(draw.timeSecName, CFile::modeRead | CFile::typeBinary)) {
			return;
		}
		file.Seek(0, CFile::begin);
		UINT bytesRead = file.Read(head.ascHead, 3200L);
		if(bytesRead < 3200) 
			AfxMessageBox(_T("Ascii section header read wrong"));
		file.Read(&bh, sizeof(bhed));
		if(bytesRead < 400) 
			AfxMessageBox(_T("Binary section header read wrong"));
		//The following numbers have to be recalculated everytime,
		//because plotting the depth section will change these numbers.

		int numsamp = bh.hns; 
		int format = bh.format;
		// backup the original format since bh.format will be overwritten for output header
		int len = (format!=3) ? (numsamp*4 + 240) : (numsamp*2 + 240);
		int tpp = bh.hdt;

		long nzmin = (int)myRound (pCd.coord.zmin / vel.dz);
		long nzmax = nzmin + nz;


		float dtField = (float)((double)tpp / (double)MIL);

		int nsmooth = (int)myRound(secsmooth / dtField);
		if ((int)(nsmooth/2) == nsmooth*2) nsmooth++;  // we want odd numbers for nsmooth..... not needed

		//For progress control, need to know the last bytes no.
		ULONGLONG curBytesRead, totBytesRead = file.GetLength();
		file.Seek(3600, CFile::begin);

		//Begin progress control.
		CMainFrame* pFrame = 
			(CMainFrame*)AfxGetMainWnd();
		ASSERT(pFrame);
		ASSERT_KINDOF(CMainFrame, pFrame);
		pFrame->BeginProgress();

		int nxmax = 0;  // total number of traces in the input segy file
		while (file.Read(&tr, 240) == (UINT)240)
		{
			file.Seek(len-240, CFile::current);
			nxmax ++;
		}
		file.Seek(3600, CFile::begin);

		// allocate array big enough for storing all the input segy data in memory
		segydynamic *trArr = (segydynamic *)malloc( sizeof(segydynamic) * nxmax );
		if (ERROR == trArr) return;
		for (j=0; j<nxmax; j++) {
			// trArr[j].data = (float *)malloc(sizeof(float)*(numsamp));
			trArr[j].data = ealloc1float(numsamp);
			if (ERROR == trArr[j].data) {
				// clean up before return
				for (int jj=0; jj<j-1; jj++) {
					//free(trArr[jj].data); 
					free1float(trArr[jj].data);
					trArr[jj].data = NULL;
				}
				AfxMessageBox(_T("Sorry, failed to allocate memory for loading all traces into memory."));
				return;
			}
		} // for j


		int nxStore = 0;
		if (tx.xShot <= ERRORVAL) tx.xShot = 0.;  // a fix
		while (file.Read(&tr, len) == (UINT)len)
		{
			//Formulating velocity traces first.
			curBytesRead = file.Seek(0, CFile::current);
			int iPos = (int)((double)curBytesRead/(double)totBytesRead*100.);
			if(iPos<0)iPos=0;
			if(iPos>100)iPos=100;
			pFrame->SetProgress(iPos);

			if(tr.trid == 2) //dead traces.
			{
				file.Seek(len, CFile::current); 
				continue ;
			}


			// assign only the trace header to the trArr[]
			memcpy( (void *)&trArr[nxStore], (void *)&tr, 240L);

			// Note: format points to the original data in time, while bh.format  is already modified for output
			if(format==3)
				for (j=0; j<numsamp; j++) trArr[nxStore].data[j] = (float)tr.dat.datashort[j];
			else if (format==1) {
				ibm_to_float((int *) tr.dat.data, (int *) tr.dat.data, (int)numsamp);
				for (j=0; j<numsamp; j++) trArr[nxStore].data[j] = (float)tr.dat.data[j];
			}
			else if (format==2) 
				for (j=0; j<numsamp; j++) trArr[nxStore].data[j] = (float)tr.dat.dataint[j];
			else if (format==5) {
				for (j=0; j<numsamp; j++) trArr[nxStore].data[j] = (float)tr.dat.data[j];
			}
			else break;

			if(para.sphericOrder > 0.f)
			{
				double a = getTraceDelay(&tr);  // a is now the initial time in sec for this trace

				double aGain = pow(a + numsamp *  dtField,  (double)para.sphericOrder);  
				if (aGain > 0.) aGain = 1. / aGain;
				else aGain = 1.;

				double b;
				for (j=0; j<numsamp; j++) {
					b = a + j* (double)tpp / (double)MIL;      // b is now the actual time in sec for the inidex j
					if (para.sphericOrder == 2.f)
						trArr[nxStore].data[j] *= (float)(b*b*aGain);
					else
						trArr[nxStore].data[j] *= (float)(aGain* pow(b,(double)para.sphericOrder) );
				}  // for j
			} // if

			nxStore++;
		} // while file.Read
		file.Close();
		pFrame->EndProgress();
		// finished loading all segy data into memory trArr[]

		astr.Format(_T("finished loading all segy data into memory"));
		pFrame->SetMessageText(astr);



		//################################################################################
		//############################ start loading X-T values for velocity perturbation#####
		//################################################################################

		// first, we need to calculate max number of points of (x,t) pair for a certain iz
		int icont;
		int i,iz;
		float f1,f2,f7,f8;



		float ***xwAll = (float ***)ealloc3float(np_max, nz, nv_max);
		float ***twAll = (float ***)ealloc3float(np_max, nz, nv_max);    // data for the floating reflectors.
		int **isei_npAll = (int **)ealloc2int(nz, nv_max);
		float **sei_zAll = (float **)ealloc2int(nz, nv_max);
		memset( (void *)xwAll[0][0], 0, sizeof(float)*np_max*nz*nv_max );
		memset( (void *)twAll[0][0], 0, sizeof(float)*np_max*nz*nv_max );
		memset( (void *)isei_npAll[0], 0, sizeof(int)*nz*nv_max );
		memset( (void *)sei_zAll[0], 0, sizeof(float)*nz*nv_max );
		bool isTooMany = false;










		int izmaxTraced = -1; 
		bool isProb = false;
		for (vPerturb = vPerturbMin, nvPerturb=0; vPerturb <= vPerturbMax; vPerturb += vPerturbDv, nvPerturb++ ) {
			if (!isCoh && nvPerturb != numDisplay) continue;  // for simple non-coherency display, we only display one velocity pertubation
			astr.Format(_T("%s\\%s%5.3f"), txPath, txoutName, vPerturb);
			if (!isFileExistNotDirectory(astr)) {
				CString str2;
				str2.Format(_T("Raytracing result file %s does not exist. Please check parameter."), astr);
				AfxMessageBox(str2);
				break;
			}
			CStringArray *txArray = getLinesFromFile(astr);
			for (j=0; j<txArray->GetSize(); j++) { 
				if ( _stscanf_s(txArray->ElementAt(j).Trim(),_T("%f%f%d%d%f%f"),&f1, &f2, &iz, &icont, &f7, &f8) == 0) continue;
				if ( iz == 0 && !isFloatEqual(f8, (float)pCd.coord.zmin) ) {
					isProb = true;
					pCd.coord.zmin = f8;
					break;
				}
				if (iz==-1 && !isFloatEqual(f8, (float)pCd.coord.zmax) ) {
					isProb = true;
					pCd.coord.zmax = f8;
					break;
				}
				if (iz==-2 && !isFloatEqual(f8, (float)vel.dz) ) {
					// this is the last line of a raytracing file
					isProb = true;
					vel.dz = f8;
					break;
				}
				if (iz==-1 && icont>0) {
					draw.iLayerFocus = icont;  // update perturbation layer number since it may be different by the user input
				}
				if (iz<=0 || icont==0 || iz>nz) continue;  // note: input file has  iz=1:nz.... from Fortran
				if ( (i=isei_npAll[nvPerturb][iz-1]) < np_max) {
					xwAll[nvPerturb][iz-1][i] = f1;
					twAll[nvPerturb][iz-1][i] = f2;
					isei_npAll[nvPerturb][iz-1]++;  // we want array index to be zero based
					sei_zAll[nvPerturb][iz-1] = f8;
					// so we just ignore the user input
					if (izmaxTraced < iz) izmaxTraced = iz;
				}
				else {
					isTooMany = true;
				}
			} // if j
			txArray->RemoveAll();
			txArray = NULL;


			if (!isProb) {
				// since xw[][] may not be ordered monotonically with distance, we need to reorder it.
				for (iz=0; iz<nz; iz++) {
					for (j=0; j<isei_npAll[nvPerturb][iz]-1; j++) {
						for (int k=j+1; k<isei_npAll[nvPerturb][iz]; k++) {
							if (xwAll[nvPerturb][iz][j] > xwAll[nvPerturb][iz][k]) {
								// swap the 2 values
								f1 = xwAll[nvPerturb][iz][j];
								xwAll[nvPerturb][iz][j] = xwAll[nvPerturb][iz][k];
								xwAll[nvPerturb][iz][k] = f1;
								f1 = twAll[nvPerturb][iz][j];
								twAll[nvPerturb][iz][j] = twAll[nvPerturb][iz][k];
								twAll[nvPerturb][iz][k] = f1;
							} // if
						} // for k
					} // for j
				} // for iz

				astr.Format(_T("finished loading and parsing into memory the raytracing results for %5.3f (%5.3f, %5.3f, %5.3f) km/s"), vPerturb,vPerturbMin,vPerturbMax,vPerturbDv);
				pFrame->SetMessageText(astr);
			} // if


			// note: sei_zAll[nvPerturb][iz]  info is only for checking here, not used in later NMO calculation, as we all assume
			//       the depth indece are uniform.
			if (isProb) break;

		} // for vPerturb
		if (isTooMany) 
			AfxMessageBox(_T("Too many points found in the raytracing. Will truncate. You may limit number of points per ray <=30 ."));
		if (isProb) {
			free3float(xwAll); xwAll = NULL;
			free3float(twAll); twAll = NULL;
			free2int(isei_npAll); isei_npAll = NULL;
			free2float(sei_zAll); sei_zAll = NULL;
			for (j=0; j<nxmax; j++) {
				free(trArr[j].data); trArr[j].data = NULL;
			}
			free(trArr); trArr = NULL;

			//if (izmaxTraced < nz) {
			//	pCd.coord.zmax = (float)(pCd.coord.zmin + (izmaxTraced - 1) * vel.dz);
			//	astr = _T("Specified maximum depth is greater than raytraced, and adjusted accordingly. Please rerun this processing.";
			//}
			//else {
			//}
			astr = _T("Depth in the raytracing mismatches with desired zmin, zmax or dz that are now adjusted accordingly. Note that temporary raytracing results cannot be mixed for different running. Please rerun this processing.");
			AfxMessageBox(astr);
			OnTimeForwideNmovelocity();
			return;
		}







		CFile filez;
		if (!filez.Open(draw.depthSecName, CFile::modeCreate|CFile::modeReadWrite|CFile::typeBinary)) {
			return;
		}

		filez.Write(head.ascHead, 3200L);
		bh.hns = nz; // numsamp for output;
		bh.format = 1; // we always output in floating points
		bh.hdt = (unsigned short)myRound(vel.dz*MIL);	//Sampling rate;
		filez.Write(&bh, sizeof(bh));

		//Prepare to formulate velocity traces.
		WORD totShot=0;
		double oneodt = (double) (MIL/(float)tpp);

		segydynamic tTrcDepth;
		tTrcDepth.data = (float *)malloc(sizeof(float)*nz);





		astr.Format(_T("Start loop for velocity pertubation"));
		pFrame->SetMessageText(astr);


		//################################################################################
		//############################ start loop for velocity perturbation###############
		//################################################################################
		float **xw = (float **)ealloc2float(np_max, nz);
		float **tw = (float **)ealloc2float(np_max, nz);    // data for the floating reflectors.
		int *isei_np = (int *)ealloc1int(nz);

		for (vPerturb = vPerturbMin, nvPerturb=0; vPerturb <= vPerturbMax; vPerturb += vPerturbDv, nvPerturb++ ) {
			if (nvPerturb >= nv_max) break;
			if (!isCoh && nvPerturb != numDisplay) continue;  // for simple non-coherency display, we only display one velocity pertubation
			memset((void *)tTrcDepth.data, (int)'\0', sizeof(float)*nz);
			//memset((void *)xw[0], 0, sizeof(float)*np_max*nz);
			//memset((void *)tw[0], 0, sizeof(float)*np_max*nz);
			//memset((void *)isei_np, 0, sizeof(int)*nz);

			for (iz=0; iz<nz; iz++) {
				// just copy from xwAll to xw
				isei_np[iz] = isei_npAll[nvPerturb][iz];
				memcpy((void *)xw[iz], (const void *)xwAll[nvPerturb][iz], isei_np[iz]*sizeof(float));
				memcpy((void *)tw[iz], (const void *)twAll[nvPerturb][iz], isei_np[iz]*sizeof(float));
				//for (j=0; j<isei_npAll[nvPerturb][iz]; j++) {
				//	xw[iz][j] = xwAll[nvPerturb][iz][j];
				//	tw[iz][j] = twAll[nvPerturb][iz][j];
				//}
			} // for iz


			int lenz = 240+nz*4;
			double t1,t2,x1, x2, t12, x12;
			float dt = (float)((double)tpp / (double)MIL);
			if (!isCoh) {
				for (nxStore=0; nxStore < nxmax; nxStore++) {

					memcpy((void *)&tr, (void *)&trArr[nxStore], 240L);
					float offset = getOffset(&tr);
					if (!isFloatEqual(0.f, offsetMax) &&  fabs(offset) > offsetMax) continue;
					float dist = getDistance(&tr);
					if (dist > 11.f) {
						int dasdsa = 1;
					}

					for (iz=0; iz<nz; iz++) {
						tTrcDepth.data[iz] = 0.f;

						int n = isei_np[iz];
						if (n < 2) continue;
						// Be very careful here, as it affects the results drastically!
						if (dist < xw[iz][0] - offsetMax) continue; // we excluse any traces left of min raytraced distance
						if (dist > xw[iz][n-1] + offsetMax) continue;  // we excluse any traces right of max raytraced distance.


						double az = pCd.coord.zmin + (double)iz * vel.dz;
						bool isFound = false;
						for (j=1; j<isei_np[iz]; j++) {
							if (dist >= xw[iz][j-1] && dist < xw[iz][j]) {
								x1 = xw[iz][j-1] - tx.xShot; // we calculate using offset instead of dist here
								x2 = xw[iz][j] - tx.xShot;
								t1 = tw[iz][j-1];
								t2 = tw[iz][j];

								if ( (x1 < 0) == (x2 < 0) ) {
									// now x1 and x2 are on the same side of the source
									isFound = true;
								}
								else {
									// now the 2 points are on diff sides of the source
									if ( (x1 < 0) == (offset < 0) ) {
										// x1 and xw[iz][j-1] is on the same side as source
										if (j>1) {
											x1 = xw[iz][j-2] - tx.xShot;
											x2 = xw[iz][j-1] - tx.xShot;
											t1 = tw[iz][j-2];
											t2 = tw[iz][j-1];
											isFound = true;
										}
									} // if x1
									else {
										// x2 and xw[iz][j] is on the same side as source
										if (j<isei_np[iz]-1) {
											x1 = xw[iz][j] - tx.xShot;
											x2 = xw[iz][j+1] - tx.xShot;
											t1 = tw[iz][j];
											t2 = tw[iz][j+1];
											isFound = true;
										}
									}
								} // if x1

								break;
							} // if dist
						} // for j
						if (!isFound) {
							// this part is important, since sometimes Zelt's raytracing cannot reach a certain distance
							// while the observed phases are strong there, such as the shallowest sediment reflections in
							// a complex 2D structure
							int jj = isei_np[iz]-1;
							if (dist < xw[iz][0]) {
								x1 = xw[iz][0] - tx.xShot;
								x2 = xw[iz][1] - tx.xShot;
								t1 = tw[iz][0];
								t2 = tw[iz][1];
								isFound = true;
							}
							else if (dist > xw[iz][jj]) {
								x1 = xw[iz][jj-1] - tx.xShot;
								x2 = xw[iz][jj] - tx.xShot;
								t1 = tw[iz][jj-1];
								t2 = tw[iz][jj];
								isFound = true;
							}
						}
						if (!isFound) continue;

						// get the tTrcDepth.data[iz] for interpolation
						if ( fabs(t1 - t2) > 0.0001) {
							// testing shows here 0.0001  is better than MINAMP!!!
							bool isSuc = false;
							// first try hyperbola interpolation

							t12 = t1*t1;
							x12 = x1*x1;
							double vr2 = (x2*x2 - x12) / (t2*t2 - t12);
							if (fabs(vr2)>MINAMP) {
								// hyperbola interpolation
								double t02 = t12 + (offset*offset - x12) / vr2;
								if (t02 > 0.) {
									tTrcDepth.data[iz] = (float)sqrt(t02);
									isSuc = true;
								}
							}

							if (!isSuc) {
								// since hyperbola interpolation fails, we do linear interpolation
								// continue;  // testing
								if ( fabs(x2-x1) > 0.0001)
									tTrcDepth.data[iz] = (float)(t1 + (offset - x1) / (x2-x1) * (t2-t1));
								else
									tTrcDepth.data[iz] = (float)t1;
							}


						}
						else
							tTrcDepth.data[iz] = (float)t1;

					} // for iz

					//if (nxStore == nxmax/2)
					//	showArrayInFile(&tTrcDepth.data[0], nz);

					if (nxStore == 84) {
						//	showArrayInFile(&tTrcDepth.data[0], nz);
						//	showArrayInFile(&trArr[nxStore].data[0], numsamp);
					}

					//		trArr[nxStore].data[numsamp] = 0.f;  // fix up
					ints8r((int)numsamp, // ntin
						dt,   // dtin
						getTraceDelay(&tr),   // ftin
						&trArr[nxStore].data[0], // yin[t=ntin], with yin[0] = y(fxin)
						0.f,  // yinl    value used to extrapolate yin values to left of yin[0]
						0.f,  // yinr	 value used to extrapolate yin values to right of yin[ntin-1]
						nz,   // nxout
						(float *)&tTrcDepth.data[0],  // ntout
						(float *)&tr.dat.data[0]);    // tout


					//	memcpy( (void *)tr.dat.data, (void *)&vTrc[nzmin], (nzmax-nzmin+1)*sizeof(float));
					tr.ns = (unsigned short)nz;
					tr.dt = (unsigned short)(vel.dz*MIL);
					setTraceDelayF(&tr, pCd.coord.zmin);
					setDistance(&tr, dist);

					if ( bh.format==1 ) {
						float_to_ibm((int *) tr.dat.data, (int *) tr.dat.data, (int)tr.ns);
					}
					filez.Write(&tr, lenz);
				} // for nxStore
				break;  // for simple display, we only display one velocity pertubation
			} // if !isCoh
			else {
				//for (nxStore=0; nxStore < nxmax; nxStore++) {
				//	memset((void *)trArrOut[nxStore].data, 0, sizeof(float)*nz);
				//}
				float *numi = ealloc1float(nsmooth); // semblence nominator
				float *deno = ealloc1float(nsmooth); // semblence denominator
				float *nnz = ealloc1float(nsmooth);  // counting non-zero samples.
				float **amp = ealloc2float(nsmooth, nxmax);

				float *timew = ealloc1float(nsmooth); // at each iz and ix, we produce a time window timew[] for velocity analysis
				// int nsmoothHalf = (int)(nsmooth*0.5);

				float *offset2 = ealloc1float(nxmax); // 
				float offset;
				for (nxStore=0; nxStore < nxmax; nxStore++) {
					offset = getOffset(&trArr[nxStore]);
					offset2[nxStore] = signum(offset) * offset*offset;
				}
				float offset2_threshold = (1.f - xpercent) * getMaxValueAbsolute(offset2, nxmax);

				for (iz=0; iz<nz; iz++) {

					//int iPos = (int)((double)iz/(double)nz*100.);
					//if(iPos<0)iPos=0; 
					//if(iPos>100)iPos=100;
					//pFrame->SetProgress(iPos);

					if (iz==99) {
						int isfs=1;
						double az = pCd.coord.zmin + (double)iz * vel.dz;
					}

					// for each depth iz, we have <=nxmax traces (trArr[nxStore = 0 : nxmax]) for semblence stack
					// the semb stacking curve is defined by xw, tw [iz][j = 0 : isei_np[iz] ]
					// A stacking time window of nsmooth = 11 samples
					tTrcDepth.data[iz] = 0.f;
					if (isei_np[iz] < 2) continue;
					memset((void *)amp[0], 0, sizeof(float)*nsmooth*nxmax); 
					// this is needed since some traces have no data and we would not touch them during calculation!
					memset((void *)timew, 0, sizeof(float)*nsmooth); 

					for (nxStore=0; nxStore < nxmax; nxStore++) {
						float offset = getOffset(&trArr[nxStore]);
						if (!isFloatEqual(0.f, offsetMax) &&  fabs(offset) > offsetMax) continue;
						float dist = getDistance(&trArr[nxStore]);

						int n = isei_np[iz];
						if (n < 2) continue;
						// Be very careful here, as it affects the results drastically!
						if (dist < xw[iz][0] - offsetMax) continue; // we excluse any traces left of min raytraced distance
						if (dist > xw[iz][n-1] + offsetMax) continue;  // we excluse any traces right of max raytraced distance.



						// calculate the right t thru hiperbola interpolation
						bool isFound = false;
						for (j=1; j<isei_np[iz]; j++) {
							if (dist >= xw[iz][j-1] && dist <= xw[iz][j]) {
								x1 = xw[iz][j-1] - tx.xShot; // we calculate using offset instead of dist here
								x2 = xw[iz][j] - tx.xShot;
								t1 = tw[iz][j-1];
								t2 = tw[iz][j];

								if ( (x1 < 0) == (x2 < 0) ) {
									// now x1 and x2 are on the same side of the source
									isFound = true;
								}
								else {
									// now the 2 points are on diff sides of the source
									if ( (x1 < 0) == (offset < 0) ) {
										// x1 and xw[iz][j-1] is on the same side as source
										if (j>1) {
											x1 = xw[iz][j-2] - tx.xShot;
											x2 = xw[iz][j-1] - tx.xShot;
											t1 = tw[iz][j-2];
											t2 = tw[iz][j-1];
											isFound = true;
										}
									} // if x1
									else {
										// x2 and xw[iz][j] is on the same side as source
										if (j<isei_np[iz]-1) {
											x1 = xw[iz][j] - tx.xShot;
											x2 = xw[iz][j+1] - tx.xShot;
											t1 = tw[iz][j];
											t2 = tw[iz][j+1];
											isFound = true;
										}
									}
								} // if x1

								break;
							} // if dist
						} // for j
						if (!isFound) {
							// this part is important, since sometimes Zelt's raytracing cannot reach a certain distance
							// while the observed phases are strong there, such as the shallowest sediment reflections in
							// a complex 2D structure
							int jj = isei_np[iz]-1;
							if (dist < xw[iz][0]) {
								x1 = xw[iz][0] - tx.xShot;
								x2 = xw[iz][1] - tx.xShot;
								t1 = tw[iz][0];
								t2 = tw[iz][1];
								isFound = true;
							}
							else if (dist > xw[iz][jj]) {
								x1 = xw[iz][jj-1] - tx.xShot;
								x2 = xw[iz][jj] - tx.xShot;
								t1 = tw[iz][jj-1];
								t2 = tw[iz][jj];
								isFound = true;
							}
						}
						if (!isFound) continue;

						// get the t for interpolation
						float t;
						if ( fabs(t1 - t2) > 0.0001) {
							// testing shows here 0.0001  is better than MINAMP!!!
							bool isSuc = false;
							// first try hyperbola interpolation

							t12 = t1*t1;
							x12 = x1*x1;
							double vr2 = (x2*x2 - x12) / (t2*t2 - t12);
							if (fabs(vr2)>MINAMP) {
								// hyperbola interpolation
								double t02 = t12 + (offset*offset - x12) / vr2;
								if (t02 > 0.) {
									t = (float)sqrt(t02);
									isSuc = true;
								}
							}

							if (!isSuc) {
								// since hyperbola interpolation fails, we do linear interpolation
								if ( fabs(x2-x1) > 0.0001)
									t = (float)(t1 + (offset - x1) / (x2-x1) * (t2-t1));
								else
									t = (float)t1;
							}


						} // if fabs(t1-t2)
						else
							t = (float)t1;


						// start interpolation of trace data for the time window (length nsmooth) around t
						for (int iw=0; iw<nsmooth; iw++) {
							//timew[iw] = (float)( t - dt*(nsmoothHalf-iw) );
							timew[iw] = (float)( t + dt*iw );
						}
						ints8r((int)numsamp, // ntin
							dt,   // dtin
							getTraceDelay(&trArr[nxStore]),   // ftin
							&trArr[nxStore].data[0], // yin[t=ntin], with yin[0] = y(fxin)
							0.f,  // yinl    value used to extrapolate yin values to left of yin[0]
							0.f,  // yinr	 value used to extrapolate yin values to right of yin[ntin-1]
							nsmooth,   // nxout
							&timew[0],  // ntout
							&amp[nxStore][0]);    // tout

						// The following are for linear interpolation
						//int it=0; // it = the index for the exact time at point (nxStore, iz)
						//float ft = getTraceDelay(&trArr[nxStore]); // initial time for the current trace
						//float ti = (t - ft) / dt; // normalized time for interpolation
						//int iti = (int)ti;    // time sample index for interpolation
						//double frac = ti - iti;

						//// calculate semblence for the time t
						//for (int iw=0; iw<nsmooth; iw++) {
						//	it = iti - nsmoothHalf + iw;
						//	if (it>=0 && it < numsamp - 1) {
						//		amp[nxStore][iw] = (float)( (1.-frac)*trArr[nxStore].data[it] + frac*trArr[nxStore].data[it+1] ); // accurate interpolated amplitude
						//	} // if iti
						//} // for iw
					} // for nxStore


					memset((void *)numi, 0, sizeof(float)*nsmooth);
					memset((void *)deno, 0, sizeof(float)*nsmooth);
					memset((void *)nnz, 0, sizeof(float)*nsmooth);

					if (stackmode == 0) {
						//################################ amplitude summation ############################
						//########################################################################
						for (int iw=0; iw<nsmooth; iw++) {
							for (int i=0; i<nxmax; i++) {
								if (fabs(amp[i][iw]) > MINAMP) {
									numi[iw] += amp[i][iw];
									nnz[iw] += 1.f;
								}
							} // for i
						} // for iw
						double nsum = 0.; // semblence numerator sum
						double dsum = 0.; // semblence denominator sum
						for (int iw=0; iw<nsmooth; iw++) {
							nsum += fabs(numi[iw]);
							dsum += nnz[iw];
						} // for iw
						tTrcDepth.data[iz] = (dsum>MINAMP) ? (float)(nsum/dsum)  :   0.0f;
						//################################ end amplitude summation ############################
						//########################################################################
					}
					else if (stackmode == 1) {
						//################################ semblance ############################
						//########################################################################
						for (nxStore=0; nxStore<nxmax; nxStore++) {
							for (int iw=0; iw<nsmooth; iw++) {
								if (fabs(amp[nxStore][iw]) > MINAMP) {
									numi[iw] += (float)amp[nxStore][iw];
									deno[iw] += (float)(amp[nxStore][iw]*amp[nxStore][iw]);
									nnz[iw] += 1.f;
								}
							} // for iw
						} // for nxStore
						double nsum = 0.; // semblence numerator sum
						double dsum = 0.; // semblence denominator sum
						for (int iw=0; iw<nsmooth; iw++) {
							nsum += numi[iw] * numi[iw];
							dsum += nnz[iw] * deno[iw];
						} // for iw
						tTrcDepth.data[iz] = (dsum>MINAMP) ? (float)(nsum / dsum)  :   0.0f;
						//################################ end semblence ########################
						//########################################################################
					}
					else {
						//################################ Energy Normalized Cross Correlation function ############################
						//########################################################################
						// Energy Normalized Cross Correlation function, less sensitive to amp variations between traces

						// we first want to find the min and max offsets that have data, and calculate the min offset difference for correlation
						float offset2max = - MIL;
						for (int i=0; i<nxmax; i++) {
							if (fabs(amp[i][0]) > MINAMP) {
								if (offset2max < fabs(offset2[i]) ) offset2max = fabs(offset2[i]);
							}
						}
						offset2max *= (1.f - xpercent); // now offset2max is the maximum offset2 for x-correlation


						for (int iw=0; iw<nsmooth; iw++) {
							for (int i=0; i<nxmax; i++) {
								if (fabs(amp[i][iw]) > MINAMP) {
									for (int k=i+1; k<nxmax; k++) {
										if (fabs(offset2[i]-offset2[k]) > offset2max  &&  fabs(amp[k][iw]) > MINAMP) {
											numi[iw] += (float)( amp[i][iw]*amp[k][iw] );
											nnz[iw] += 1.f;
										} // if fabs(offset2
									} // for k
									deno[iw] += (float)(amp[i][iw]*amp[i][iw]);
								} // if
							} // for i
						} // for iw
						double nsum = 0.; // Correlation numerator sum
						double dsum = 0.; // Correlation denominator sum
						for (int iw=0; iw<nsmooth; iw++) {
							nsum += numi[iw]; // numi[] can be negative since it is X-correlation
							dsum += nnz[iw]* deno[iw];
						} // for iw
						tTrcDepth.data[iz] = (fabs(dsum)>MINAMP) ? (float)(nxmax * nsum / dsum )  :   0.0f;
						//tTrcDepth.data[iz] = (float)nsum;
						//################################ End Energy Normalized Cross Correlation function ############################
						//########################################################################
					} // if stackmode

					/*
					" Semblance is defined by the following quotient:			",
					"									",
					"		 n-1		 					",
					"		[ sum q(t,j) ]^2					",
					"		 j=0		 					",
					"	s(t) = ------------------					",
					"		 n-1		 					",
					"		n sum [q(t,j)]^2					",
					"		 j=0		 					",
					"									",
					" where n is the number of non-zero samples after muting.		",
					" Smoothing (nsmooth) is applied separately to the numerator and denominator",
					" before computing this semblance quotient.				",
					*/
					UpdateAllViews(NULL);
				} // for iz


				//if (nvPerturb % 20 == 0)
				//	showArrayInFile(&tTrcDepth.data[0], nz);


				memcpy((void *)&tr, (void *)&trArr[0], 240L);
				tr.tracl = nvPerturb;
				tr.cdp = nvPerturb;
				tr.cdpt = 1;
				tr.ns = (unsigned short)nz;
				tr.dt = (unsigned short)myRound(vel.dz*MIL);
				setTraceDelayF(&tr, pCd.coord.zmin);
				setDistance(&tr, vPerturb);
				setOffset(&tr, 0.f); // zero offset in output

				if ( bh.format==1 ) {
					tr.idistopt = 8;
					float_to_ibm((int *) &tTrcDepth.data[0], (int *) &tTrcDepth.data[0], (int)tr.ns);
				}

				filez.Write(&tr, 240);
				filez.Write(tTrcDepth.data, nz*sizeof(float));

				free1float(numi);
				free1float(deno);
				free1float(nnz);
				free2float(amp);
				free1float(offset2);
				free1float(timew);

			} // else if isCoh


			astr.Format(_T("Please wait: perturbation for velocity %5.3f => (%5.3f, %5.3f, %5.3f) completed"), vPerturb, vPerturbMin, vPerturbMax, vPerturbDv);
			pFrame->SetMessageText(astr);

			UpdateAllViews(NULL);
			NotifyChanged();
		} // for vPerturb 

		//################################################################################
		//############################ end loop for velocity perturbation###############
		//################################################################################

		//Free up space
		free2float(xw); xw = NULL;
		free2float(tw); tw = NULL;
		free1int(isei_np); isei_np = NULL;
		free3float(xwAll); xwAll = NULL;
		free3float(twAll); twAll = NULL;
		free2int(isei_npAll); isei_npAll = NULL;
		free2float(sei_zAll); sei_zAll = NULL;
		free(tTrcDepth.data);

		for (j=0; j<nxmax; j++) {
			free(trArr[j].data); trArr[j].data = NULL;
		}
		free(trArr); trArr = NULL;

		CVelMod vm;


		//#####################################################################################################
		//#####################################################################################################
		//#####################################################################################################
		//#####################################################################################################
		//#####################################################################################################
		//#####################################################################################################
		//############# compute V-Z curve and, for each iz, migrate the data due to velocity gradient##########
		//#####################################################################################################
		//#####################################################################################################
		//#####################################################################################################

		//Auto change mode to display both.
		if (!isCoh) {
			draw.modeOld = draw.mode;
			draw.mode = 3;	//Both velocity color and depth sections will be drawn.
			draw.isNoColorMap = true;
			setSegyTotalTrace(&filez, (unsigned short)nvPerturb);
			freeDigAll();
		}
		else {
			pCd.coord.xmin = vPerturbMin - vPerturbDv;
			if (pCd.coord.xmin < 0.1) pCd.coord.xmin = 0.1; // for PS perturb mode, the min is around 0.1
			pCd.coord.xmax = vPerturbMax;
			pCd.coord.xmax *= 2; // we have double the vPerturbMax only when outputing due to velocity gradient considered
			if (pCd.coord.xmax > 8.) pCd.coord.xmax = 8.;
			if (pCd.coord.xTick > 0.1) pCd.coord.xTick = 0.1;

			// display 
			// we need to use vTop[] and vBot[] info at the OBS location, so we pre-calculate


			// double depth[MOD_LAYER_MAX],vTop[MOD_LAYER_MAX],vBot[MOD_LAYER_MAX];
			CVelMod::VELMOD_X modX;
			modX.dist = tx.xShot;
			bool isTime = isTimeDomain() == TRUE;
			vm.initModX(&velMod, &modX, isTime, true, true, vel.dz);

			freeDigAll();
			initDigitizeArray(MOD_LAYER_MAX*2, 1);
			dig.isZeltFormat2 = FALSE;
			dig.totCurve = 1;
			dig.nPoint[0] = 0;

			//################################################################################
			//******************First we compute the single curve that delineates the input velocities****
			//################################################################################
			// draw in TWTT domain
			dig.digName = txPath + "\\_vtcurve.txt";
			int nzmaxModelAll = (int)(modX.depthMod[velMod.ncont - 1] / vel.dz + 1.0);
			tTrcDepth.data = (float *)malloc(sizeof(float)*nzmaxModelAll);
			vm.getTzFromZMod(&modX, nzmaxModelAll, 0.f, vel.dz, tTrcDepth.data);
			//  here, iz=0 is at the surface, not at pCd.coord.zmin !
			// now tTrcDepth.data[] contains TWTT trace data

			// now depth[]  needs to be in TWTT
			//	double time[MOD_LAYER_MAX];
			for (icont = 0; icont < velMod.ncont; icont++) {
				// we want :  depth[icont] ==>  time[icont]
				bool isSuc = false;
				for (iz = 0; iz < nzmaxModelAll - 1; iz++) {
					float z = (float)(iz*vel.dz);
					if (fabs(z - modX.depthMod[icont]) <= vel.dz) {
						// if here, the current iz is the closest to depth[icont] ==>  time[icont]
						modX.timeMod[icont] = tTrcDepth.data[iz] + (tTrcDepth.data[iz + 1] - tTrcDepth.data[iz]) / vel.dz * (modX.depthMod[icont] - z);
						// now we got TWTT writen in time[icont]
						isSuc = true;
						break;
					}
				} // for iz
				if (!isSuc) {
					if (icont > 0)
						modX.timeMod[icont] = modX.timeMod[icont - 1];
					//AfxMessageBox(_T("A boundary cannot be converted into TWTT domain");
				}
			} // for icont

			if (raymode > 0) {
				// raymode==1:  PS mode
				// raymode==2:  SP mode
				CStringArray *csArr = new CStringArray();
				loadParam(draw.rayName, _T("pois"), csArr);
				for (icont = 0; icont < csArr->GetCount(); icont++) {
					if (icont >= velMod.ncont - 1) continue;
					int ip = dig.nPoint[0];
					dig.x[ip][0] = (float)_tstof(csArr->ElementAt(icont));
					dig.t[ip][0] = (float)modX.timeMod[icont];

					if (modX.timeMod[icont] < pCd.coord.tmin && modX.timeMod[icont + 1] > pCd.coord.tmin) {
						// need to add a point at pCd.coord.zmin
						dig.x[ip + 1][0] = (float)_tstof(csArr->ElementAt(icont));
						dig.x[ip + 2][0] = (float)_tstof(csArr->ElementAt(icont));
						dig.t[ip + 1][0] = (float)pCd.coord.tmin;
						dig.t[ip + 2][0] = (float)modX.timeMod[icont + 1];
						dig.nPoint[0] += 3;
					}
					else if (modX.timeMod[icont] < pCd.coord.tmax && modX.timeMod[icont + 1] > pCd.coord.tmax) {
						// we need to add a point at the axis 
						dig.x[ip + 1][0] = (float)_tstof(csArr->ElementAt(icont));
						dig.x[ip + 2][0] = (float)_tstof(csArr->ElementAt(icont));
						dig.t[ip + 1][0] = (float)pCd.coord.tmax;
						dig.t[ip + 2][0] = (float)modX.timeMod[icont + 1];
						dig.nPoint[0] += 3;
					}
					else {
						dig.x[ip + 1][0] = (float)_tstof(csArr->ElementAt(icont));
						dig.t[ip + 1][0] = (float)modX.timeMod[icont + 1];
						dig.nPoint[0] += 2;
					}
				}
				csArr->RemoveAll();
				csArr = NULL;

			} // end raymode>0
			else {
				// P wave mode
				for (icont = 0; icont < velMod.ncont - 1; icont++) {
					// note:  depth[icont]  is now TWWW in sec!!!
					int ip = dig.nPoint[0];
					dig.x[ip][0] = (float)modX.vTop[icont];
					dig.t[ip][0] = (float)modX.timeMod[icont];

					if (modX.timeMod[icont] < pCd.coord.tmax && modX.timeMod[icont + 1] > pCd.coord.tmax) {
						// we need to add a point at the axis 
						dig.x[ip + 1][0] = (float)(modX.vTop[icont] + (modX.vBot[icont] - modX.vTop[icont]) / (modX.timeMod[icont + 1] - modX.timeMod[icont])*(pCd.coord.tmax - modX.timeMod[icont]));
						dig.t[ip + 1][0] = (float)pCd.coord.tmax;
						dig.t[ip + 2][0] = (float)modX.timeMod[icont + 1];
						dig.x[ip + 2][0] = (float)modX.vBot[icont];
						dig.nPoint[0] += 3;
					}
					else {
						dig.x[ip + 1][0] = (float)modX.vBot[icont];
						dig.t[ip + 1][0] = (float)modX.timeMod[icont + 1];
						dig.nPoint[0] += 2;
					}
				}
				free(tTrcDepth.data);
			}
			//} // end if producing single vz or vt curve
			CDigitize pDg;
			pDg.myDigSaveAs(&dig, FALSE, FALSE, tx.xShot);
			//draw.extLineDrawing = !draw.labelAsTWTT;
			//draw.extLineDrawingTim = draw.labelAsTWTT;
			draw.modeOld = draw.mode;
			draw.mode = 10;
			draw.strXLabelOverwrite = _T("Velocity");
			//################################################################################
			//******************End computing the single curve that delineates the input velocities****
			//################################################################################





			if (raymode == 0) {
				//################################################################################
				//################################################################################
				//############################ start preparing for P-velocity display###############
				//################################################################################
				int icontFocus = draw.iLayerFocus-1;
				// NOTE: draw.iLayerFocus  is   1-based, while all our other C++ code (icontFocus) is zero based!!!

				astr.Format(_T("Migrating due to velocity gradients at and below layer %d at [%6.3f, %6.3f] km"), 
					icontFocus + 1, (float)modX.depthMod[icontFocus], (float)modX.depthMod[icontFocus + 1]);
				pFrame->SetMessageText(astr);
				segydynamic *trzArr = (segydynamic *)malloc( sizeof(segydynamic) * nv_max );
				for (nvPerturb=0; nvPerturb<nv_max; nvPerturb++) {
					trzArr[nvPerturb].data = (float *)malloc(sizeof(float)*nz);
				}
				filez.Seek(3600L, CFile::begin);
				for (nvPerturb=0; nvPerturb<nv_max; nvPerturb++) {
					filez.Read(&trzArr[nvPerturb], 240L);
					filez.Read(&trzArr[nvPerturb].data[0], nz*sizeof(float));
					if (bh.format==1)
						ibm_to_float((int *) &trzArr[nvPerturb].data[0], (int *) &trzArr[nvPerturb].data[0], (int)nz);
				}

				segydynamic *trzArr2 = (segydynamic *)malloc( sizeof(segydynamic) * nv_max*2 ); // note: because of hor. migration, iv can be doubled
				for (nvPerturb=0; nvPerturb<nv_max*2; nvPerturb++) {
					if (nvPerturb < nv_max)
						memcpy((void *)&trzArr2[nvPerturb], (void *)&trzArr[nvPerturb], 240L); // just copy the segy trace header only
					else {
						memcpy((void *)&trzArr2[nvPerturb], (void *)&trzArr[0], 240L); // just copy the segy trace header only
						trzArr2[nvPerturb].tracl = nvPerturb;
						trzArr2[nvPerturb].cdp = nvPerturb;
						setDistance((segy *)&trzArr2[nvPerturb], vPerturbMin + nvPerturb*vPerturbDv);
					}
				} // for nvPerturb
				//// NOW: trzArr2 trace header already assigned, but its data[] not allocated at all!!!

				double val;

				// now we need to convert the depth domain segy data into twtt time domain!

				// We can think of this process as: for each  vPerturb, we vertically shift the amplutides along iz axis only; 
				// do not shift along the vPerturb axis. This wil convert to TWTT domain.
				CVelMod::VELMOD_X modX2;

				float **twtt2d = (float **)ealloc2float(nz, nv_max);
				memset((void *)twtt2d[0], 0, sizeof(float)*nz*nv_max);
				for (nvPerturb = 0; nvPerturb < nv_max; nvPerturb++) {
					for (icont = 0; icont < velMod.ncont - 1; icont++) {
						modX2.vTop[icont] = modX.vTop[icont];
						modX2.vBot[icont] = modX.vBot[icont];
						if (icont >= icontFocus) {
							modX2.vTop[icont] += -modX.vTop[icontFocus] + vPerturb;
							modX2.vBot[icont] += -modX.vTop[icontFocus] + vPerturb;
						}
					} // for icont
					vm.getTzFromZMod(&modX2, nz, pCd.coord.zmin, vel.dz, &twtt2d[nvPerturb][0]);
				} // for vPerturb



				//for (nvPerturb=0; nvPerturb < nv_max; nvPerturb++ ) {
				//	memcpy((void *)&trzArr2[nvPerturb].data[0], (void *)&trzArr[nvPerturb].data[0], sizeof(float)*nz ); 
				//	free(trzArr[nvPerturb].data);
				//} // for vPerturb
				for (nvPerturb = 0; nvPerturb < nv_max * 2; nvPerturb++) {
					trzArr2[nvPerturb].data = (float *)malloc(sizeof(float)*numsamp);
					memset((void *)&trzArr2[nvPerturb].data[0], 0, sizeof(float)*numsamp);
				} // for vPerturb
				//****************Now twtt2d[nvPerturb][iz] complete with all TWTT info****************
				//****************Now trzArr[nvPerturb].data[iz] with all un-migrated data in depth domain****************
				//****************Now trzArr2[nvPerturb].data[it] space allocated to store data in TWTT domain****************
				// NOTE: for twtt[nvPerturb][iz], and trzArr[nvPerturb].data[iz], iz=0 is at pCd.coord.zmin !

				int it;
				double frac;
				float atimeOutput;
				for (vPerturb = vPerturbMin, nvPerturb = 0; vPerturb <= vPerturbMax; vPerturb += vPerturbDv, nvPerturb++) {
					if (nvPerturb >= nv_max) break;
					for (icont = 0; icont < velMod.ncont - 1; icont++) {
						modX2.vTop[icont] = modX.vTop[icont];
						modX2.vBot[icont] = modX.vBot[icont];
						if (icont >= icontFocus) {
							modX2.vTop[icont] += -modX.vTop[icontFocus] + vPerturb;
							modX2.vBot[icont] += -modX.vTop[icontFocus] + vPerturb;
						}
					} // for icont

					for (atimeOutput = (float)pCd.coord.tmin, it = 0; atimeOutput <= (float)pCd.coord.tmax; atimeOutput += dtField, it++) {
						// now we need to find out the corresponding index in tTrcDepth.data[] for atime
						if (it >= numsamp) continue;

						for (iz = 1; iz<nz; iz++) {
							if (atimeOutput <= twtt2d[nvPerturb][iz]) {
								// now  atimeOutput is between  twtt2d[nvPerturb][iz-1]  and twtt2d[nvPerturb][iz]
								// NOTE: iz=0 is at pCd.coord.zmin !
								frac = twtt2d[nvPerturb][iz] - twtt2d[nvPerturb][iz - 1];
								register double zt = (fabs(frac) > 0.000001) ?
									vel.dz * (iz - 1 + (atimeOutput - twtt2d[nvPerturb][iz - 1]) / frac)
									:
									vel.dz * (iz - 1);
								register double vt = vm.getVFromVz(&modX2, zt + pCd.coord.zmin);
								register int iv = (int)myRound((vt - vPerturbMin) / vPerturbDv);
								//iv = nvPerturb; // test
								if (iv >= 0 && iv<nv_max * 2) {
									val = (fabs(frac) > 0.000001) ?
										trzArr[nvPerturb].data[iz - 1] + (trzArr[nvPerturb].data[iz] - trzArr[nvPerturb].data[iz - 1]) * (atimeOutput - twtt2d[nvPerturb][iz - 1]) / frac
										:
										trzArr[nvPerturb].data[iz - 1];

									if (fabs(val) > 0.0000001) {
										if (fabs(trzArr2[iv].data[it]) > 0.0000001f) {
											// both values are non-zero, so we average
											trzArr2[iv].data[it] = (float)((val + trzArr2[iv].data[it]) * 0.5);
										}
										else
											trzArr2[iv].data[it] = (float)val;
									}
								} // if iv
								break;  // finished for loop iz
							} // if atimeOutput, it
						} // for iz
					} // for atimeOutput
				} // for nvPerturb








				bh.hdt = (unsigned short)tpp;	//Sampling rate;
				bh.hns = numsamp;
				filez.Seek(3200L, CFile::begin);
				filez.Write(&bh, 400);
				for (nvPerturb = 0; nvPerturb < nv_max * 2; nvPerturb++) {
					// memcpy((void *)&tr, (void *)&trzArr2[nvPerturb], 240L);
					trzArr2[nvPerturb].ns = (unsigned short)numsamp;
					trzArr2[nvPerturb].dt = (unsigned short)tpp;
					setTraceDelayF(&trzArr2[nvPerturb], pCd.coord.tmin);

					if (bh.format == 1) {
						trzArr2[nvPerturb].idistopt = 8;
						float_to_ibm((int *)&trzArr2[nvPerturb].data[0], (int *)&trzArr2[nvPerturb].data[0], (int)numsamp);
					}

					filez.Write(&trzArr2[nvPerturb], 240L);  // note for simplicity, the segy headers in trzArr[nvPerturb]  is not directly assigned
					filez.Write(&trzArr2[nvPerturb].data[0], numsamp*sizeof(float));
					//showArrayInFile(trzArr[nvPerturb].data, numsamp);
				} // for nvPerturb

				free2float(twtt2d);
				//*******************************************************************
				//********* end display results in the TWTT domain***********************
				//*******************************************************************
				//}


				// free some last memory blocks
				for (j=0; j<nv_max; j++) {
					free(trzArr[j].data);
				}
				for (j=0; j<nv_max*2; j++) {
					free(trzArr2[j].data);
				}
				free(trzArr2);
				free(trzArr); 

				//para.vred = 0.;  // ***this is important, otherwise it may reduce in time
				para.isDistanceDisplay = TRUE;  // always display in distance


				//################################################################################
				//################################################################################
				//############################ end preparing for P-velocity display###############
				//################################################################################
			} // if (raymode == 0


		} // if else


		filez.Close();

		draw.depthSecOld = _T("");	//recalculate gain.
		draw.isSameDataDisplay = FALSE; //indicate display has been changed and will re-load all data in OnDraw().


		SetModifiedFlag();
		UpdateAllViews(NULL);
		NotifyChanged();
		//	AfxMessageBox(_T("Succesfully converting into depth domain");

	}

	int CSeisWideDoc::formatVelocityArray2(float distInModel, double depth[], double vTop[], double vBot[])
	{
		float dvUniform = 0.05f;
		double x1,x2,x3,x4,v1,v2,v3,v4;
		int j, icont, ncont;

		for (icont=0; icont<velMod.ncont; icont++)
		{
			for (j=1; j<velMod.nzed[icont]; j++)
			{
				if(distInModel>=velMod.xm[j-1][icont] && distInModel<=velMod.xm[j][icont])
				{
					if (fabs(velMod.xm[j][icont]-velMod.xm[j-1][icont]) < 0.00001f)
						depth[icont] = velMod.zm[j][icont];
					else
						depth[icont] = velMod.zm[j-1][icont] + (distInModel-velMod.xm[j-1][icont])*
						(velMod.zm[j][icont]-velMod.zm[j-1][icont])/(velMod.xm[j][icont]-velMod.xm[j-1][icont]);
					break;
				}
			}
		}

		//Now locate the four corners that define the velocity of for all points at distInModel.
		//*****x1*****************x2******* with distInModel at depth[icont]
		//**********distInModel************
		//***************************
		//**x3*********************x4 with distInModel at depth[icont+1]
		for (icont=0; icont<velMod.ncont-1; icont++)
		{
			for (j=1; j<velMod.nvel[icont][0]; j++)
			{
				if(distInModel>=velMod.xvel[j-1][icont][0] && distInModel<=velMod.xvel[j][icont][0])
				{
					x1=velMod.xvel[j-1][icont][0];
					x2=velMod.xvel[j][icont][0];
					v1=velMod.vf[j-1][icont][0];
					v2=velMod.vf[j][icont][0];
					break;
				}
			}
			for (j=1; j<velMod.nvel[icont][1]; j++)
			{
				if(distInModel>=velMod.xvel[j-1][icont][1] && distInModel<=velMod.xvel[j][icont][1])
				{
					x3=velMod.xvel[j-1][icont][1];
					x4=velMod.xvel[j][icont][1];
					v3=velMod.vf[j-1][icont][1];
					v4=velMod.vf[j][icont][1];
					break;
				}
			}
			vTop[icont] = v1 + (v2-v1)*(distInModel-x1)/(x2-x1);
			vBot[icont] = v3 + (v4-v3)*(distInModel-x3)/(x4-x3);
		}

		CVelMod vm;
		ncont = vm.formatVelocityArray(dvUniform, velMod.ncont, 4000, (double *)&depth[0], (double *)&vTop[0], (double *)&vBot[0]);

		return ncont;
	}

	// This will calculate a big list of contours as floating reflectors for raytracing, for NMO velocity analysis using semblence stack
	// expected file extension from aFile:   tx.insemb
	CString CSeisWideDoc::setContour4Raytrace(CString aFile, float xpos, float dz, float zmin, double *zmaxMod, 
		float vminPerturb, float vmaxPerturb, float dvPerturb)
	{
		// global variables used: velMod struct
		// velMod.floatName
		// return 0 if failed
		if (dz < 0.000001f) dz = 0.004f;

		// first calculate the total number of contours / floating reflectors to do raytracing
		int nz = (int)((*zmaxMod - zmin) / dz + 1.0);
		if (nz > 6000) {
			nz = 6000;  // fortran program has this array limit to impose
			*zmaxMod = zmin + (nz-1)*dz;
		}

		// calculate max number of points per curve
		int npoint = 0;
		int icont;
		for (icont=0; icont<velMod.ncont; icont++)
		{
			if (npoint < velMod.nzed[icont]) npoint = velMod.nzed[icont];
		}
		if (npoint == 0) {
			AfxMessageBox( _T("no points for output to raytracing.") );
			return _T("");
		}

		float *xArray = (float *)ealloc1float(npoint*2);
		float *zArray = (float *)ealloc1float(npoint*2);    // data for the floating reflectors.
		int *nArray = (int *)ealloc1int(npoint*2);

		CString out = setContour4Raytrace(aFile, xpos, dz, zmin, zmaxMod, vminPerturb,vmaxPerturb,dvPerturb,
			nArray, xArray, zArray);


		free1float (xArray);
		free1float (zArray);
		free1int (nArray);

		return out;
	}


	CString CSeisWideDoc::setContour4Raytrace(CString aFile, float xpos, float dz, float zmin, double *zmaxMod, 
		float vminPerturb, float vmaxPerturb, float dvPerturb, 
		int *nArray, float *xArray, float *zArray )
	{
		if (isTimeDomain()) {
			AfxMessageBox(_T("Sorry, this only works in the depth domain."));
			return _T("");
		}


		// global variables used: velMod struct
		// velMod.floatName
		// return 0 if failed
		if (dz < 0.000001f) dz = 0.004f;

		// first calculate the total number of contours / floating reflectors to do raytracing
		int nz = (int)((*zmaxMod - zmin) / dz + 1.0);
		if (nz > 6000) {
			nz = 6000;  // fortran program has this array limit to impose
			*zmaxMod = zmin + (nz-1)*dz;
		}

		// calculate max number of points per curve
		int j,jj,k,icont, iz;
		double v1,v2;

		CVelMod vm;
		CVelMod::VELMOD_X modX;
		modX.dist = xpos;
		vm.initModX(&velMod, &modX, isTimeDomain() == TRUE, true, true, vel.dz);
		// vm.getZModFromZ(&velMod, &modX, true); 
		// apply anisotropy automatically as long as it exists for the layer!


		// a dump of contours would be a good check on screen
		FILE *stream2;
		CString tt = _T("myf.txt");
		if (_tfopen_s(&stream2, tt, _T("w+") ) != 0) return _T("");





		CFile filev( aFile, CFile::modeCreate | CFile::modeWrite | CFile::typeBinary);
		if( filev == NULL )
		{
			AfxMessageBox( _T("A new file ") + aFile + _T(" could not open") );
			return _T("");
		}
		filev.Write(&nz, sizeof(int));
		filev.Write(&xpos, sizeof(float));
		filev.Write(&vminPerturb, sizeof(float));
		filev.Write(&vmaxPerturb, sizeof(float));
		filev.Write(&dvPerturb, sizeof(float));
		// we do not need to specify the following 2 lines. We do it in the command line!
		//filev.Write(&draw.iLayerFocus, sizeof(int));
		//filev.Write(&irefrMode, sizeof(int));


		// note: if there are extra floating reflectors imposed, npoint  should be added by the max number of these points!!!
		if (isFileExistNotDirectory(velMod.floatName)) {
			if (! myLoadFloatReflectors() ) velMod.floatName=_T(""); // always load again here: user may change from other places.
		} // if
		// now deals with specified floating reflectors: we only consider the first 2 of them.
		float zf1 = -1.f;
		float zf2 = -1.f;
		float zfThis = -1.f;
		for (int icurve=0; icurve<velMod.totCurve; icurve++) {
			if (icurve>=2) break;
			for (j=0; j<velMod.npArray[icurve]-1; j++)
			{
				if (xpos >= velMod.xArray[j][icurve] && xpos < velMod.xArray[j+1][icurve]) {
					float dx = velMod.xArray[j+1][icurve] - velMod.xArray[j][icurve];
					// if we have 2 curves, we restrain the curve between z1 and z2.
					// if only 1 curve, we just have z1
					if (dx > 0.00001f) zfThis = velMod.tArray[j][icurve] + (velMod.tArray[j+1][icurve] - velMod.tArray[j][icurve])
						/dx * (xpos-velMod.xArray[j][icurve]);
					else zfThis = velMod.tArray[j][icurve];
					if (icurve == 0) zf1 = zfThis;
					else if (icurve == 1) zf2 = zfThis;
					break;
				}
			} // for j
		} // for icurve


		float z1,z2;
		int np;

		for (iz=0; iz<nz; iz++) {

			float z = (float)(zmin + iz*dz);
			double v = 0.;
			np = 0; // initilize it !

			// first, calculate v at the current point (xpos, z)

			// which layer number is z situated?
			int icontSel = -1;
			for (icont=1; icont<velMod.ncont; icont++) {
				if (z >= modX.depthMod[icont - 1] && z < modX.depthMod[icont]) {
					icontSel = icont-1;
					break;
				}
			} // for icont
			if (icontSel < 0) continue; // no need to go further for this z

			if (icontSel  > 0) {
				int asdasd = 1;
			}

			// now for (xpos,z) inside layer icontSel, we need to formulate a contour for output
			for (j=0; j<velMod.nzed[icontSel]; j++) {
				xArray[j] = velMod.xm[j][icontSel];
			}
			np = velMod.nzed[icontSel];
			float ax;






			for (j=0; j<velMod.nzed[icontSel+1]; j++) {
				// we want to make sure the current velMod.xm[j][icontSel]  is not already inside xArray[]
				bool isExist = false;
				ax = velMod.xm[j][icontSel+1];
				for (jj=0; jj<velMod.nzed[icontSel]; jj++) {
					if (fabs(xArray[jj] - ax) < 0.00001) {
						// only if the point is not the same can we use it
						isExist = true;
						break;
					} // if
				} // for jj
				if (!isExist) {
					xArray[np] = ax;
					np++;
				}
			} // for j

			// now we sort for each point at xArray[][iz]. 
			for (j=0; j<np-1; j++) {
				for (k=j+1; k<np; k++) {
					if (xArray[j] > xArray[k]) {
						// swap the 2 values
						ax = xArray[j];
						xArray[j] = xArray[k];
						xArray[k] = ax;
					}
				} // for k
			} // for j

			// now we calculate the depth for each point xArray[k][iz]
			for (j=0; j<np; j++) {
				//v1 = vdepth[icontSel][0];
				//v2 = vdepth[icontSel][1];
				v1 = modX.vTop[icontSel];
				v2 = modX.vBot[icontSel];
				z1 = (float)modX.depthMod[icontSel];
				z2 = (float)modX.depthMod[icontSel + 1];
				v = (fabs(z2 - z1) > 0.00001) ?   v1+(v2-v1)*(z-z1)/(z2-z1)  :  v1;
				double percent = 0.;
				if ((z2 - z1) > 0.00001) percent = (z-z1)/(z2-z1);
				zArray[j] = (float)getDepthFromVel(xArray[j], v, icontSel, percent);
			} // for j

			// now deals with given floating reflectors
			if (velMod.npArray != NULL && zf1>0) {
				if (fabs(z-zf1) < 2.*dz) {
					// if only 1 curve, we just have zf1
					np = 0; // we reset for this iz
					for (j=0; j<velMod.npArray[0]; j++)
					{
						xArray[np] = velMod.xArray[j][0];
						zArray[np] = velMod.tArray[j][0] + z - zf1;
						np++;
					} // for j
				} // if fabs(z-zf1)
			} // if zf1

			// now write results to file
			int ai = iz+1;
			filev.Write(&ai, sizeof(int));  // seq contour number, starting from 1
			ai = icontSel+1;
			filev.Write(&ai, sizeof(int));  // layer number in the Zelt's model, starting from 1
			filev.Write(&np, sizeof(int));  // number of points for each contour
			filev.Write(&z, sizeof(float)); // the depth of the contour at xpos 
			filev.Write(&xArray[0], np*sizeof(float));
			filev.Write(&zArray[0], np*sizeof(float));

			if( stream2 != NULL ) {
				for (int i=0; i<np; i++)
				{
					_ftprintf_s(stream2,_T(" %9.3f %9.3f %9d\n"),xArray[i],zArray[i],iz);
				}
			}
		} // for iz




		filev.Close();

		fclose(stream2);

		return tt;  // success
	}

	double CSeisWideDoc::getDepthFromVel(double dist, double vel, int icont, double percent) 
	{
		CVelMod vm;
		return vm.getDepthFromVel(&velMod, dist, vel, icont, percent);
	}



	//
	//bool CSeisWideDoc::getVZCurveAtDist(double dist, double depth[], double vTop[], double vBot[], bool isAnisotropyApply)
	//{
	//	CVelMod vm;
	//	return vm.getVZCurveAtDist(&velMod, dist, depth, vTop, vBot, isAnisotropyApply);
	//}
	//
	//
	//bool CSeisWideDoc::getTZCurveAtDist(float dist, double time[], double vTop[], double vBot[], bool isAnisotropyApply)
	//{
	//	CVelMod vm;
	//	return vm.getTZCurveAtDist(&velMod, dist, time, vTop, vBot, isAnisotropyApply);
	//}
	//


	void CSeisWideDoc::OnViewNmoVelocity()
	{
		if (draw.isDigitizing && (draw.mode<1 || (draw.mode>4 && draw.mode<10)) ) 
		{
			AfxMessageBox(_T(" You are still digitizing a time section "), MB_OK |MB_ICONINFORMATION);
			return;
		}
		draw.modeOld = draw.mode;
		draw.mode = 10;	//Depth section will be drawn.

		if(!myParas())
		{
			return;
		}
		draw.isSameDataDisplay = FALSE; //indicate display has been changed and will re-load all data in OnDraw().

		SetModifiedFlag();
		UpdateAllViews(NULL);
		NotifyChanged();
	}

	//BOOL CSeisWideDoc::myLoadDigFile() 
	//{
	//	return myLoadDigFile(dig.digName, &dig);
	//}
	//
	//BOOL CSeisWideDoc::myLoadDigFile(CString aName) {
	//	return myLoadDigFile(aName, &dig);
	//}

	//BOOL CSeisWideDoc::myLoadDigFile(CString aName, CDigitize::DIGITIZE *dig2) {
	//	return myDigitizingLoadTXTUnix2(dig2, aName, FALSE, FALSE);
	//}
	//


	void CSeisWideDoc::OnModelingMergemodel()
	{
		CString tStr;

		static double shiftKm = 0.;
		static double shiftKm2 = 0.;
		static double vTolerance = 0.05;

		//	CString secondFile;
		CdlgMergeModels dlg;
		dlg.m_velSecName = velMod.velSecName;
		dlg.m_shiftKm2 = (float)shiftKm2;
		dlg.m_vTolerancePerc = (float)(vTolerance * 100.);

		if (draw.velSecNamesEx.GetLength()>0) {
			draw.velSecNamesEx.Replace(_T(",\n"), _T("\r\n"));
			draw.velSecNamesEx.Replace(_T(",\r\n"), _T("\r\n"));
			draw.velSecNamesEx.Replace(_T(","), _T("\r\n"));
			CStringArray arr;
			int nElementCount = SplitString(draw.velSecNamesEx, _T("\r\n"), arr);
			for (int i=0; i<arr.GetCount()-1; i++) {
				// example:  80, 115, G:\arcticSBs\sb2007\sb21\model0721New.bin
				double xShift = 0.;
				double xpos = -99999.;
				if (IsNumeric(arr.ElementAt(i).Trim())) {
					xShift = StringToFloat(arr.ElementAt(i).Trim());
					i++;
				}
				if (IsNumeric(arr.ElementAt(i).Trim())) {
					xpos = StringToFloat(arr.ElementAt(i).Trim());
					i++;
				}
				tStr = arr.ElementAt(i).Trim();
				if (!IsNumeric(tStr) && isFileExistNotDirectory(tStr)) {
					if (dlg.m_velSecName.IsEmpty()) {
						dlg.m_velSecName = tStr;
						dlg.m_shiftKm = (float)xShift;
					}
					else if (tStr!=dlg.m_velSecName) {
						dlg.m_velSecName2 = tStr;
						dlg.m_shiftKm2 = (float)xShift;
						break;
					}
				}
			} // for
			arr.RemoveAll();
		} // if
		if(dlg.DoModal() != IDOK) return;
		dlg.m_velSecName = dlg.m_velSecName.Trim();
		dlg.m_velSecName2 = dlg.m_velSecName2.Trim();
		shiftKm = dlg.m_shiftKm;
		shiftKm2 = dlg.m_shiftKm2;
		vTolerance = dlg.m_vTolerancePerc * 0.01;

		CVelMod vm;
		velMod.velSecName = dlg.m_velSecName;
		if (!vm.loadInitVel(&velMod, velMod.velSecName, vel.dz)) {
			myCaption(_T("Sorry, initialization of the first model failed."));
			return;
		}

		CVelMod::VELMOD velMod2;
		vm.velModSetArrays(&velMod2);
		velMod2.velSecName = dlg.m_velSecName2;
		if (!vm.loadInitVel(&velMod2, velMod2.velSecName, vel.dz)) {
			myCaption(_T("Sorry, initialization of the second model failed."));
			return;
		}

		// decide if velMod and velMod2 should be swapped.!
		if (velMod.xmin > velMod2.xmin) {
			// do the swapping
			tStr = dlg.m_velSecName;
			velMod.velSecName = dlg.m_velSecName = dlg.m_velSecName2;
			velMod2.velSecName = dlg.m_velSecName2 = tStr;
			vm.loadInitVel(&velMod, velMod.velSecName, vel.dz);
			vm.loadInitVel(&velMod2, velMod2.velSecName, vel.dz);
		}


		if (vm.myModelsMerge(&velMod, shiftKm, &velMod2, shiftKm2, vTolerance, vel.dz)) {
			CdlgNewVelFile dlg2;
			dlg2.m_velNewFileName =  getFileNameAppend(dlg.m_velSecName, _T("_merge"));
			if(dlg2.DoModal() == IDOK) {

				//if (myModelSaveAs(dlg2.m_velNewFileName))
				if (!vm.saveModelAs(&velMod, dlg2.m_velNewFileName, vel.dz, isTimeDomain(), TRUE)) {
					tStr.Format(_T("Models merged but cannot save"));
					myCaption(tStr);
				}

				SetModifiedFlag();
				UpdateAllViews(NULL);
				NotifyChanged();
			}
		}
		else {
			myCaption(_T("Sorry, model merging failed."));
		}
		//velMod.velSecOld = _T("");

		// must free the dynamicly assigned arrays
		vm.velModFreeArrays(&velMod2);
	}

	void CSeisWideDoc::OnModelingGeneratesyntheticsegydata()
	{
		CString tStr = _T("To generate synthetic segy, you need to:\n1. Dos consol.\n2. Run myTramp.exe.\n3. Run myPltSyn.exe to produce syn.sgy.data (self-containing all needed header info).\n4. Click this menu item. Continue?");
		if(AfxMessageBox(tStr, MB_OKCANCEL|MB_ICONINFORMATION) == IDCANCEL) return;

		//Openfiles.
		CString inFile = _T(""), outFile=_T("");
		CFileDialog dlg( TRUE,_T("data; DATA"),_T("*.data; *.DATA"),
			OFN_HIDEREADONLY|OFN_OVERWRITEPROMPT|OFN_EXPLORER,
			_T("Input syn.sgy.data File (*.data;*.DATA)|*.data; *.DATA|"));

		TCHAR* buff=new TCHAR[65535];
		buff[0]='\0';
		dlg.m_ofn.lpstrTitle = _T("Select the syn.sgy.data file generated by myPltsyn.exe program");
		dlg.m_ofn.lpstrFile=buff;
		dlg.m_ofn.nMaxFile = 65535;//sizeof(buff);

		if(dlg.DoModal()==IDOK)
		{
			inFile = dlg.GetPathName();
		}
		else {
			delete [] buff;
			return;
		}

		delete [] buff;
		delete dlg;
		outFile = inFile + _T(".sgy");


		float dist, xshot;
		int npts;
		float sps;  // rate in sec
		float tmin;
		segy tr;
		CFile file;
		if (!file.Open(inFile, CFile::modeRead | CFile::typeBinary)) {
			return;
		}
		//  write(13) dist,xshot,npts,tmin,sps,(s(j),j=1,npts)
		file.Read(&dist, 4);
		file.Read(&xshot, 4);
		file.Read(&npts, 4);
		file.Read(&tmin, 4);
		file.Read(&sps, 4);

		int deltaT = (int)(MIL/(float)sps);
		if (deltaT > USHRT_MAX) {
			tStr.Format(_T("Sampling interval is too large: the maximum is about 65000!"));
			AfxMessageBox(tStr);
			file.Close();
			return;
		}
		file.SeekToBegin();

		CFile file2;
		if (!file2.Open(outFile, CFile::modeReadWrite|CFile::modeCreate|CFile::typeBinary)) {
			file.Close();
			return;
		}

		file2.Write(head.ascHead, 3200L);
		bhed bh;
		//bh.format = 1;
		bh.format = ((CMainFrame*)AfxGetMainWnd())->gIsIBMFloatSegy2  ?  1  :  5; // only floating is adopted for output
		bh.hns = npts;
		bh.hdt = (unsigned short)deltaT; // convert from 
		file2.Write(&bh, 400L);

		int k = 0;
		while (file.Read(&dist, 4) == 4) {
			if (file.Read(&xshot, 4) != 4) break;
			file.Read(&npts, 4);
			file.Read(&tmin, 4);
			file.Read(&sps, 4);

			tr.tracl = k;
			tr.tracr = k;
			tr.fldr = k;
			tr.tracf = k;
			tr.ep = k;
			tr.trid = 1; // seismic trace
			tr.cdp = k;
			tr.sx =  (int)( xshot*1000. );

			tr.ns = (unsigned short)npts;
			tr.dt = (unsigned short) deltaT;
			setTraceDelayF(&tr, tmin );
			setOffset(&tr, dist - xshot);
			setDistance(&tr, dist);

			// note: this non-segy data is not IBM float!
			file.Read(&tr.dat.data[0], (long)(npts*4) );


			if ( bh.format==1) {
				float_to_ibm((int *) tr.dat.data, (int *) tr.dat.data, (int)tr.ns);
			}
			file2.Write(&tr, (long)(240+npts*4) );
			k++;
		} // while

		setSegyTotalTrace(&file2, k);
		file.Close();

		//         write(13) dist(i),xshot,npts,tmin,sps,(s(j),j=1,npts)
		tStr.Format(_T("Generated segy is %s."), outFile);
		AfxMessageBox(tStr);

		file2.Close();
	}





	BOOL CSeisWideDoc::InitializeSec()
	{

		//When a new file is opened, amplitude parameters have
		//to be initialized.
		CString tStr;

		if(draw.mode == 0 || draw.mode == 7 || draw.mode == 9 || draw.mode == 10) {
			if (getFileModifiedTime(draw.timeSecName) != head.modifiedtime) {
				if(isFileExistNotDirectory(draw.timeSecName)) {
					tStr.Format(_T("Initializing: %s"), GetBaseFileName(draw.timeSecName));
					myCaption(tStr);
					if (CSegyMeta::getSegyMeta(draw.timeSecName, &head)) {
						head.modifiedtime = getFileModifiedTime(draw.timeSecName);
					} else {
						// AfxMessageBox(_T("Cannot initialize segy file: ")+	draw.timeSecName);
						tStr.Format(_T("Cannot initialize segy file: %s"), draw.timeSecName);
						myCaption(tStr);
						head.modifiedtime = getFileModifiedTime(draw.timeSecName); // it will not prompt again
						return FALSE;
					}	
					draw.depthSecOld = _T("");
				}
			}
		} else if(draw.mode == 6) {
			if (getFileModifiedTime(draw.timeSecName) != head.modifiedtime) {
				if(isFileExistNotDirectory(draw.timeSecName)) {
					tStr.Format(_T("Initializing: %s"), GetBaseFileName(draw.timeSecName));
					myCaption(tStr);
					if (CSegyMeta::getSegyMeta(draw.timeSecName, &head)) {
						//	head.timeSecModTime = getFileModifiedTime(draw.timeSecName);
						//para.ratioDisplayWindow = (double)draw.trcInt / (double)(kmForOnePixel * pDC->GetWindowExt().cx) * 0.01;
					} else  {
						// AfxMessageBox(_T("Cann't initialize segy file: ")+	draw.timeSecName);
						tStr.Format(_T("Cannot initialize segy file: %s"), draw.timeSecName);
						myCaption(tStr);
						//	head.timeSecModTime = getFileModifiedTime(draw.timeSecName); // it will not prompt again
						return FALSE;
					}		
					draw.depthSecOld = _T("");
				}
			}
		} else if(draw.mode == 1) {
			if(draw.depthSecOld != draw.depthSecName) {
				if(isFileExistNotDirectory(draw.depthSecName)) {
					tStr.Format(_T("Initializing: %s"), GetBaseFileName(draw.depthSecName));
					myCaption(tStr);
					para.isDistanceDisplay = TRUE;  // indicate it will display as distance, not offset!
					if (CSegyMeta::getSegyMeta(draw.depthSecName, &head)) {
						draw.depthSecOld = draw.depthSecName;
					} else  {
						head.modifiedtime = zeroTime;
						return FALSE;
					}
					head.modifiedtime = zeroTime;
				}
			} // if depthSecOld
		}
		else if(draw.mode == 3) {
			if(draw.depthSecOld != draw.depthSecName) {
				if(isFileExistNotDirectory(draw.depthSecName)) {
					tStr.Format(_T("Initializing: %s"), GetBaseFileName(draw.depthSecName));
					myCaption(tStr);
					if (CSegyMeta::getSegyMeta(draw.depthSecName, &head)) {
						draw.depthSecOld = draw.depthSecName;
					} else  {
					}
					head.modifiedtime = zeroTime;
				}
			}
		}

		CVelMod vm;
	//	vm.velModSetArrays(&velMod);
		if (!vm.loadInitVel(&velMod, velMod.velSecName, vel.dz)) {
			// failed to initialize model. ok to continue
			draw.velErr = FALSE;	//new vel file assuming no error.
		} 

		if (head.numTraces<2) {
			// if no segy file is defined, we need to define head to avoid problems
			head.tminFile = 0;
			if (vm.isVelModValid(&velMod))
				head.tmaxFile = vm.getTimeMax(&velMod);
			else
				head.tmaxFile = 12.; // just assume a common value since not existing
		}


		return TRUE;
	}


	//bool CSeisWideDoc::isVelModPointInsideLayer(VELMOD *velm, double x, double y, int ilayer)
	//{
	//	if (!velm) return FALSE;
	//
	//	for (int j=0; j<
	//	return  velm->ncont>0 && velm->nzed[0]>0 && velm->nzed[0]<=MOD_POINTS_MAX;
	//}


	bool CSeisWideDoc::isVelModValid(void)
	{
		CVelMod vm;

		return vm.isVelModValid(&velMod);

		// return  this->velMod.ncont>0 && this->velMod.nzed[0]>0 && this->velMod.nzed[0]<=MOD_POINTS_MAX;
	}

	bool CSeisWideDoc::isVelModShown(CVelMod::VELMOD *velm)
	{
		return draw.mode==9 || draw.mode==1 || draw.mode==2 || draw.mode==3 || draw.mode==4;
	}


	void CSeisWideDoc::OnModelingDosconsol()
	{
		CString name = m_strPathName;
		int nPathLength =  GetModuleFileName (NULL,name.GetBuffer(_MAX_PATH), _MAX_PATH );
		name.ReleaseBuffer();
		CString progPathBak = name.Left(name.ReverseFind( '\\' ));
		CString progPath; 
		BOOL isDebug = progPathBak.Find(_T("Debug")) > 0;
		if (isDebug) {
			progPath = progPathBak + _T("\\..\\docs\\SeisWide\\others\\myRayInvrWork\\run2010");
			if (!isDirectoryExist(progPath)) 
				progPath = progPathBak + _T("\\..\\docs\\SeisWide\\others\\myRayInvrWork\\run2010");

			if (isDirectoryExist(progPath)) {
				SetCurrentDirectory(progPath);
			}
		}
		else {
			progPath = progPathBak + _T("\\..\\docs\\myRayInvrWork\\run2010");
			if (isDirectoryExist(progPath)) {
				// this is some older version format
				SetCurrentDirectory(progPath);
			}
			else {
				progPath = progPathBak + _T("\\others\\myRayInvrWork\\run2010");
				// this is the newer dir formats of SeisWide
				if (isDirectoryExist(progPath)) {
					SetCurrentDirectory(progPath);
				}
			}
		}

		myProcess("cmd.exe", progPath);
	}

	void CSeisWideDoc::OnTimeTimesectionwithperturbedtravel()
	{
		if (draw.mode != 0) {
			AfxMessageBox(_T("Please show a wide-angle time section with km first, and rerun this processing to display computed traveltime curves for 2D NMO-velocity analysis."));
			return;
		}

		int j;
		int nvPerturb;

		// local parameters for the routine not saved by .sei file
		float vPerturb;
		static float vPerturbMin = 1.9f;
		static float vPerturbMax = 2.5f;
		static float vPerturbDv = 0.02f;
		static float secsmooth = 0.06f;
		static int numDisplay = -1;
		static BOOL isCoh = false;
		static int raymode = 0;  // 0=PP; 1=PS; 2=SP
		static int stackmode = 0;  // 0=amplitude summation approach; 1=semblence coefficient; 2=Energy normalised cross correlation 
		static float xpercent = 0.5f; //

		draw.isSameDataDisplay = TRUE; //indicate display has been changed and will re-load all data in OnDraw().

		// dialog controls
		CdlgWide2Velocity dlg;
		dlg.m_timeSecName = draw.timeSecName;
		if (draw.depthSecName.IsEmpty()) draw.depthSecName = _T("depth.sgy");
		dlg.m_depthSecName = draw.depthSecName;
		dlg.m_velname = velMod.velSecName;
		dlg.m_rayTracing = draw.rayName;
		dlg.m_floatName = velMod.floatName;
		dlg.m_zmax = (float)pCd.coord.zmax;
		dlg.m_zmin = (float)pCd.coord.zmin;
		dlg.m_dz = (float)vel.dz;
		dlg.m_vPerturbMin = vPerturbMin;
		dlg.m_vPerturbMax = vPerturbMax;
		dlg.m_dv = vPerturbDv;
		dlg.m_iLayerFocus = draw.iLayerFocus;
		dlg.m_secsmooth = secsmooth;
		dlg.m_iscoh = isCoh;
		dlg.m_numDisplay = numDisplay;
		dlg.m_basePower = (float)para.basePower;  if(fabs(para.basePower) > 100.f) para.basePower = 0.f;
		dlg.m_rayMode = raymode;
		dlg.m_sumMethod = stackmode;
		dlg.m_xpercent = (int)myRound(xpercent*100.);

		if (dlg.DoModal() == IDOK)
		{
			draw.timeSecName = dlg.m_timeSecName.Trim();
			draw.depthSecName = dlg.m_depthSecName.Trim();
			velMod.velSecName = dlg.m_velname.Trim();
			draw.rayName = dlg.m_rayTracing;
			velMod.floatName = dlg.m_floatName;
			pCd.coord.zmax = dlg.m_zmax;
			pCd.coord.zmin = dlg.m_zmin;
			vel.dz = dlg.m_dz;
			vPerturbMin = dlg.m_vPerturbMin;
			vPerturbMax = dlg.m_vPerturbMax;
			vPerturbDv = dlg.m_dv;
			draw.iLayerFocus = dlg.m_iLayerFocus; // note: this is 1-based, while our convention is 0-based
			if (draw.iLayerFocus < 1) draw.iLayerFocus = 1;
			secsmooth = dlg.m_secsmooth;
			isCoh = dlg.m_iscoh;
			numDisplay = dlg.m_numDisplay;
			para.basePower = dlg.m_basePower;
			raymode = dlg.m_rayMode ;
			stackmode = dlg.m_sumMethod;
			xpercent = (float)myFloat(dlg.m_xpercent * 0.01f);
			if (xpercent>1.f) xpercent = 1.f;
			else if (xpercent < 0.01f) xpercent = 0.01f;
		}
		else 
		{
			return;
		}












		// fix up for dz, since it cannot be too big
		if (vel.dz*MIL > USHRT_MAX-1) vel.dz = (double)(USHRT_MAX-1) / (double)MIL;
		if (!isFileExistNotDirectory(draw.timeSecName)) return;
		CString txoutName = _T("tx.outsemb");
		if (raymode == 1) txoutName += _T("ps");
		else if (raymode == 2) txoutName += _T("sp");

		CString astr;

		//make tx.out file in the same directory as velMod.velSecName.
		CString name = velMod.velSecName, txPath, t;
		int pathLen = name.ReverseFind( '\\' );
		txPath = name.Left(pathLen);
		txPath.MakeLower();
		if(pathLen>(-1))
		{
			SetCurrentDirectory(txPath);
			t = txPath+"\\r.in";
		}
		else {
			t = _T("r.in");
			TCHAR curDir[_MAX_PATH];
			GetCurrentDirectory(_MAX_PATH, curDir);
			txPath = (CString)curDir;
		}

		//##################### now do the raytracing
		if ( !isXShotDefined(tx.xShot) ) {
			//txPath = getWorkingPathSlash();
			//if (!isDirectoryExist(txPath))
			//	txPath = _T("tx.out");
			//else
			//	txPath += _T("tx.out");
			tx.xShot = (float)getXPosAll();
		}
		//Do not refresh screen in any way until raytracing finished. Otherwise, 
		// it may refresh screen while raytracing is running!
		draw.isSameDataDisplay = TRUE; 
		astr.Format(_T("%s\\%s%5.3f"), txPath, txoutName, vPerturbMin);


		int nz = (int)((pCd.coord.zmax - pCd.coord.zmin) / vel.dz + 1.0);
		if (nz > 9999) {
			nz = 9999;  // fortran program has this array limit to impose
			pCd.coord.zmax = pCd.coord.zmin + (nz-1)*vel.dz;
			AfxMessageBox(_T("Max depth adjusted due to array size limitation of 9999 points. Contact programer to increase size if needed."));
		}

		int np_max = 0;
		np_max = 30;
		for (vPerturb = vPerturbMin, nvPerturb=0; vPerturb <= vPerturbMax; vPerturb += vPerturbDv, nvPerturb++ ) {
			astr.Format(_T("%s\\%s%5.3f"), txPath, txoutName, vPerturb);
			if (!isFileExistNotDirectory(astr)) break;
		}
		if (nvPerturb < 2) {
			AfxMessageBox(_T("Less than 2 pertubations read in. pertubations intervals may have changed. Please check."));
			return;
		}
		int nv_max = nvPerturb;






		// ################### Use the raytracing results to form segy output
		segy tr;
		bhed bh;

		CFile file;
		if (!file.Open(draw.timeSecName, CFile::modeRead | CFile::typeBinary)) {
			return;
		}
		file.Seek(0, CFile::begin);
		UINT bytesRead = file.Read(head.ascHead, 3200L);
		if(bytesRead < 3200) 
			AfxMessageBox(_T("Ascii section header read wrong"));
		file.Read(&bh, sizeof(bhed));
		if(bytesRead < 400) 
			AfxMessageBox(_T("Binary section header read wrong"));
		//The following numbers have to be recalculated everytime,
		//because plotting the depth section will change these numbers.

		int numsamp = bh.hns; 
		int format = bh.format;
		// backup the original format since bh.format will be overwritten for output header
		int len = (format!=3) ? (numsamp*4 + 240) : (numsamp*2 + 240);
		int tpp = bh.hdt;

		//For progress control, need to know the last bytes no.
		ULONGLONG curBytesRead, totBytesRead = file.GetLength();
		file.Seek(3600, CFile::begin);

		//Begin progress control.
		CMainFrame* pFrame = 
			(CMainFrame*)AfxGetMainWnd();
		ASSERT(pFrame);
		ASSERT_KINDOF(CMainFrame, pFrame);
		pFrame->BeginProgress();

		int nxmax = 0;  // total number of traces in the input segy file
		while (file.Read(&tr, 240) == (UINT)240)
		{
			file.Seek(len-240, CFile::current);
			nxmax ++;
		}
		file.Seek(3600, CFile::begin);

		// allocate array big enough for storing all the input segy data in memory
		segydynamic *trArr = (segydynamic *)malloc( sizeof(segydynamic) * nxmax );
		if (ERROR == trArr) return;
		for (j=0; j<nxmax; j++) {
			trArr[j].data = (float *)malloc(sizeof(float)*(numsamp));
			if (ERROR == trArr[j].data) {
				// clean up before return
				for (j=0; j<nxmax; j++) {
					free(trArr[j].data);
				}
				AfxMessageBox(_T("Sorry, failed to allocate memory for loading all traces into memory."));
				return;
			}
		}


		int nxStore = 0;
		if (tx.xShot <= ERRORVAL) tx.xShot = 0.;  // a fix
		while (file.Read(&tr, len) == (UINT)len)
		{
			//Formulating velocity traces first.
			curBytesRead = file.Seek(0, CFile::current);
			int iPos = (int)((double)curBytesRead/(double)totBytesRead*100.);
			if(iPos<0)iPos=0;
			if(iPos>100)iPos=100;
			pFrame->SetProgress(iPos);

			if(tr.trid == 2) //dead traces.
			{
				file.Seek(len, CFile::current); 
				continue ;
			}


			// assign only the trace header to the trArr[]
			memcpy( (void *)&trArr[nxStore], (void *)&tr, 240L);

			// Note: format points to the original data in time, while bh.format  is already modified for output
			if(format==3)
				for (j=0; j<numsamp; j++) trArr[nxStore].data[j] = (float)tr.dat.datashort[j];
			else if (format==1) {
				ibm_to_float((int *) tr.dat.data, (int *) tr.dat.data, (int)numsamp);
				for (j=0; j<numsamp; j++) trArr[nxStore].data[j] = (float)tr.dat.data[j];
			}
			else if (format==2) 
				for (j=0; j<numsamp; j++) trArr[nxStore].data[j] = (float)tr.dat.dataint[j];
			else if (format==5) {
				for (j=0; j<numsamp; j++) trArr[nxStore].data[j] = (float)tr.dat.data[j];
			}
			else break;

			if(para.sphericOrder > 0.f)
			{
				double a = getTraceDelay(&tr);  // a is now the initial time in sec for this trace

				double aGain = pow(a + numsamp *  (double)tpp / (double)MIL,  (double)para.sphericOrder);  
				if (aGain > 0.) aGain = 1. / aGain;
				else aGain = 1.;

				double b;
				for (j=0; j<numsamp; j++) {
					b = a + j* (double)tpp / (double)MIL;      // b is now the actual time in sec for the inidex j
					if (para.sphericOrder == 2.f)
						trArr[nxStore].data[j] *= (float)(b*b*aGain);
					else
						trArr[nxStore].data[j] *= (float)(aGain* pow(b,(double)para.sphericOrder) );
				}  // for j
			} // if

			nxStore++;
		} // while file.Read
		file.Close();
		pFrame->EndProgress();
		// finished loading all segy data into memory trArr[]

		astr.Format(_T("finished loading all segy data into memory"));
		pFrame->SetMessageText(astr);




		//################################################################################
		//############################ start loading X-T values for velocity perturbation#####
		//################################################################################

		// first, we need to calculate max number of points of (x,t) pair for a certain iz
		int icont;
		int i,iz;
		float f1,f2,f7,f8;



		float ***xwAll = (float ***)ealloc3float(np_max, nz, nv_max);
		float ***twAll = (float ***)ealloc3float(np_max, nz, nv_max);    // data for the floating reflectors.
		int **isei_npAll = (int **)ealloc2int(nz, nv_max);
		float **sei_zAll = (float **)ealloc2int(nz, nv_max);
		memset( (void *)xwAll[0][0], 0, sizeof(float)*np_max*nz*nv_max );
		memset( (void *)twAll[0][0], 0, sizeof(float)*np_max*nz*nv_max );
		memset( (void *)isei_npAll[0], 0, sizeof(int)*nz*nv_max );
		memset( (void *)sei_zAll[0], 0, sizeof(float)*nz*nv_max );
		bool isTooMany = false;
		int izmaxTraced = -1; 
		bool isProb = false;
		for (vPerturb = vPerturbMin, nvPerturb=0; vPerturb <= vPerturbMax; vPerturb += vPerturbDv, nvPerturb++ ) {
			astr.Format(_T("%s\\%s%5.3f"), txPath, txoutName, vPerturb);
			if (!isFileExistNotDirectory(astr)) {
				CString str2;
				str2.Format(_T("Raytracing result file %s does not exist. Please check parameter."), astr);
				AfxMessageBox(str2);
				break;
			}
			CStringArray *txArray = getLinesFromFile(astr);
			for (j=0; j<txArray->GetSize(); j++) { 
				if ( _stscanf_s(txArray->ElementAt(j).Trim(),_T("%f%f%d%d%f%f"),&f1, &f2, &iz, &icont, &f7, &f8) == 0) continue;

				if ( iz == 0 && !isFloatEqual(f8, (float)pCd.coord.zmin) ) {
					isProb = true;
					pCd.coord.zmin = f8;
					break;
				}
				if (iz==-1 && !isFloatEqual(f8, (float)pCd.coord.zmax) ) {
					isProb = true;
					pCd.coord.zmax = f8;
					break;
				}
				if (iz==-2 && !isFloatEqual(f8, (float)vel.dz) ) {
					// this is the last line of a raytracing file
					isProb = true;
					vel.dz = f8;
					break;
				}
				if (iz==-1 && icont>0) {
					draw.iLayerFocus = icont;  // update perturbation layer number since it may be different by the user input
				}
				if (iz<=0 || icont==0 || iz>nz) continue;  // note: input file has  iz=1:nz.... from Fortran

				if ( (i=isei_npAll[nvPerturb][iz-1]) < np_max) {
					xwAll[nvPerturb][iz-1][i] = f1;
					twAll[nvPerturb][iz-1][i] = f2;
					isei_npAll[nvPerturb][iz-1]++;  // we want array index to be zero based
					sei_zAll[nvPerturb][iz-1] = f8;
					// so we just ignore the user input
					if (izmaxTraced < iz) izmaxTraced = iz;
				}
				else {
					isTooMany = true;
				}
			}
			txArray->RemoveAll();
			txArray = NULL;

			if (izmaxTraced < nz) break;

			// since xw[][] may not be ordered monotonically with distance, we need to reorder it.
			for (iz=0; iz<nz; iz++) {
				for (j=0; j<isei_npAll[nvPerturb][iz]-1; j++) {
					for (int k=j+1; k<isei_npAll[nvPerturb][iz]; k++) {
						if (xwAll[nvPerturb][iz][j] > xwAll[nvPerturb][iz][k]) {
							// swap the 2 values
							f1 = xwAll[nvPerturb][iz][j];
							xwAll[nvPerturb][iz][j] = xwAll[nvPerturb][iz][k];
							xwAll[nvPerturb][iz][k] = f1;
							f1 = twAll[nvPerturb][iz][j];
							twAll[nvPerturb][iz][j] = twAll[nvPerturb][iz][k];
							twAll[nvPerturb][iz][k] = f1;
						} // if
					} // for k
				} // for j
			} // for iz


			// note: sei_zAll[nvPerturb][iz]  info is only for checking here, not used in later NMO calculation, as we all assume
			//       the depth indece are uniform.
			if (isProb) break;


			astr.Format(_T("finished loading and parsing into memory the raytracing results for %5.3f (%5.3f, %5.3f, %5.3f) km/s"), vPerturb,vPerturbMin,vPerturbMax,vPerturbDv);
			pFrame->SetMessageText(astr);
		} // for vPerturb
		if (isTooMany) 
			AfxMessageBox(_T("Too many points found in the raytracing. Will truncate. You may limit number of points per ray <=30 ."));
		if (isProb || izmaxTraced < nz ) {
			free3float(xwAll);
			free3float(twAll);
			free2int(isei_npAll);
			free2float(sei_zAll);
			for (j=0; j<nxmax; j++) {
				free(trArr[j].data);
			}
			free(trArr);

			//if (izmaxTraced < nz) {
			//	pCd.coord.zmax = (float)(pCd.coord.zmin + (izmaxTraced - 1) * vel.dz);
			//	astr = _T("Specified maximum depth is greater than raytraced, and adjusted accordingly. Please rerun this processing.";
			//}
			//else {
			//}
			astr = _T("Depth in the raytracing mismatches with desired zmin, zmax and dz which are adjusted accordingly. Note that temporary raytracing results cannot be mixed for different running. Please rerun this processing.");
			AfxMessageBox(astr);
			return;
		}




		astr.Format(_T("Start loop for velocity pertubation"));
		pFrame->SetMessageText(astr);


		//################################################################################
		//############################ start loop for velocity perturbation###############
		//################################################################################

		int izShow = 99;
		if (izShow >= nz) izShow = nz-2;

		freeDigAll();
		dig.isZeltFormat2 = FALSE;
		dig.digName = txPath+"\\_vtcurve.txt";

		if (numDisplay>=0 && numDisplay<nv_max) {
			initDigitizeArray(np_max, 1);
			dig.totCurve = 1;
			dig.nPoint[0] = isei_npAll[numDisplay][izShow];
			for (j=0; j<isei_npAll[numDisplay][izShow]; j++) {
				dig.x[j][0] = xwAll[numDisplay][izShow][j];
				dig.t[j][0] = twAll[numDisplay][izShow][j];
			}
		}
		else {
			initDigitizeArray(np_max, nv_max);
			dig.totCurve = nv_max;
			for (vPerturb = vPerturbMin, nvPerturb=0; vPerturb <= vPerturbMax; vPerturb += vPerturbDv, nvPerturb++ ) {
				if (nvPerturb >= nv_max) break;
				dig.nPoint[nvPerturb] = isei_npAll[nvPerturb][izShow];
				for (j=0; j<isei_npAll[nvPerturb][izShow]; j++) {
					dig.x[j][nvPerturb] = xwAll[nvPerturb][izShow][j];
					dig.t[j][nvPerturb] = twAll[nvPerturb][izShow][j];
				}

			} // for vPerturb 
		}


		CDigitize pDg;
		pDg.myDigSaveAs(&dig, FALSE, FALSE, tx.xShot); 

		//################################################################################
		//############################ end loop for velocity perturbation###############
		//################################################################################

		//Free up space
		free3float(xwAll);
		free3float(twAll);
		free2int(isei_npAll);
		free2float(sei_zAll);

		for (j=0; j<nxmax; j++) {
			free(trArr[j].data);
		}
		free(trArr);

		draw.isSameDataDisplay = FALSE; //indicate display has NOT been changed and do not re-load all data in OnDraw().


		SetModifiedFlag();
		UpdateAllViews(NULL);
		NotifyChanged();
		//	AfxMessageBox(_T("Succesfully converting into depth domain");

	}



	void CSeisWideDoc::close_unused_documents(const CDocument* const pNotThisOne)
	{


		////////////////////////////////////////////////////////////////////
		// loop through all of the documents
		// and close the ones that match the criteria of:
		// 1) NOT previously saved ( CDocument::GetPathName() is empty)
		// and
		// 2) NOT Modified	( CDocument::IsModified() is zero )
		// and
		// 3) NOT the document we are in the process of opening (pNotThisOne)
		////////////////////////////////////////////////////////////////////

		POSITION template_pos = AfxGetApp()->GetFirstDocTemplatePosition();
		while(NULL!=template_pos) {
			CDocTemplate* pDocTemplate = AfxGetApp()->GetNextDocTemplate(template_pos);
			if(NULL!=pDocTemplate) {
				POSITION document_pos = pDocTemplate->GetFirstDocPosition();
				while(NULL!=document_pos) {
					CDocument* pDoc_to_check = pDocTemplate->GetNextDoc(document_pos);
					if(pNotThisOne != pDoc_to_check) {
						if((pDoc_to_check->GetPathName()==_T("")) // If not saved 
							&&(0==pDoc_to_check->IsModified())){   // and not modified
								pDoc_to_check->OnCloseDocument();     // then close it
						}
					}
				}
			}		
		}
	}



	BOOL CSeisWideDoc::OnOpenDocument(LPCTSTR lpszPathName)
	{
		if (!COleServerDoc::OnOpenDocument(lpszPathName))
			return FALSE;



		// TODO:  Add your specialized creation code here
		// All opening file name issues are dealt with here!
		CString seiFilePath(lpszPathName);
		//if (bmp24.bmp24Name.IsEmpty()) name = bmp24.bmp24Name;
		//else if(velMod.velSecName!=_T("")) name = velMod.velSecName;
		//else if (!draw.timeSecName.IsEmpty()) name = draw.timeSecName;
		//else if (!draw.depthSecName.IsEmpty()) name = draw.depthSecName;
		//
		//if(!name.IsEmpty())
		//{
		//	int pathLen = name.ReverseFind( '\\' );
		//	if(pathLen>2)
		//		SetCurrentDirectory(name.Left(pathLen));
		//}
		CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
		//	if (!pFrame->gDriveNew.IsEmpty()) myChangeDrive(&pFrame->gDriveNew);

		draw.timeSecName = getSecNameRevised(draw.timeSecName, seiFilePath);
		draw.depthSecName = getSecNameRevised(draw.depthSecName, seiFilePath);
		velMod.velSecName = getSecNameRevised(velMod.velSecName, seiFilePath);
		draw.rayName = getSecNameRevised(draw.rayName, seiFilePath);
		draw.vrmsTauName = getSecNameRevised(draw.vrmsTauName, seiFilePath);

		if (isModelDisplayed())
			velModSetArrays(); // allocate the dynamic arrays for velMod struct

		velMod.floatName = getSecNameRevised(velMod.floatName, seiFilePath);
		draw.markerName = getSecNameRevised(draw.markerName, seiFilePath);
		draw.txRaytraceName= getSecNameRevised(draw.txRaytraceName, seiFilePath);
		//	return TRUE;
		dig.digName = getSecNameRevised(dig.digName, seiFilePath);
		bmp24.bmp24Name = getSecNameRevised(bmp24.bmp24Name, seiFilePath);
		//	draw.velSecNamesEx = getSecNameRevised(draw.velSecNamesEx, seiFilePath);

		// this color palette file is by default in the same dir as the time section:
		if (ampColorDyn.colFileName.IsEmpty()) 
			ampColorDyn.colFileName = GetPathFromFileSlash(draw.timeSecName) + _T("colPalette.txt");
		if (ampColorDyn.logScaleThreshold<0 || ampColorDyn.logScaleThreshold > 100) ampColorDyn.logScaleThreshold = 70;



		//The following must be reset every time a SEI file is read in.
		draw.TTCurveColor = 4;
		draw.isPrinting = 0;
		if (fabs(draw.distShift) > 10000.f) draw.distShift = 0.f;  // sometimes older SEI files have invalid draw.distShift value
		if (draw.bigNodes < 1) draw.bigNodes = 1;
		draw.move = 0;
		draw.remove = 0;
		draw.add = 0;
		draw.pick = 1;
		draw.pickOld = 0;

		tx.circleCurve = -1;  // this means no circle display

		// When opening an older version of .SEI file, some variables are invalid, so we fix them here:
		if (_isnan(draw.distShift) || fabs(draw.distShift)>99999.) 
			draw.distShift = 0.;


		close_unused_documents(this);


		return TRUE;
	}

	void CSeisWideDoc::OnDisplaytuneOverwritexlabel()
	{
		CdlgLabelOverwrite dlg;
		dlg.m_labelNew = (draw.strXLabelOverwrite.IsEmpty()) ? "Distance"  :  draw.strXLabelOverwrite;
		if (dlg.DoModal()) {
			draw.strXLabelOverwrite = dlg.m_labelNew;
			draw.isSameDataDisplay = FALSE; //indicate display has NOT been changed and do not re-load all data in OnDraw().
			SetModifiedFlag();
			UpdateAllViews(NULL);
			NotifyChanged();
		}
	}

	/*
	bool CSeisWideDoc::loadModelZeltAll(CString zeltName, int numDecimal)
	{
	CStringArray *zeltArray = getLinesFromFile(zeltName);
	if (zeltArray == NULL) {
	return false;
	}

	int  nrz, nrv, i, j, j1, j2, icont, ilyr, icnt;
	//	TCHAR line[MAXLINE];
	CString tStr;

	i = 0;
	for (j=0; j<zeltArray->GetSize(); j++) { 
	if ( _stscanf_s(zeltArray->ElementAt(j).Trim(),"%f%f%d%d%f%f",&f1, &f2, &iz, &icont, &f7, &f8) == 0) continue;
	} // for j


	for (icont=0; icont<MOD_LAYER_MAX; icont++) {
	nrz=1;
	j1=0;
	j2=9;  
	while(true) 
	{
	// sometimes a model contain more points than SeisWide
	if (j2 >= MOD_POINTS_MAX) {
	zeltArray->RemoveAll();
	tStr.Format(_T("Sorry, maximum number of points %d encountered. Please contact SeisWide developer to increase the limit!"), i);
	AfxMessageBox(tStr);
	return false;
	}

	if (_tcslen(line) < 2) continue;
	if (line[0] == '#') continue; // we do not need comment lines
	trimRight(line);
	if (_tcslen(line)<3) {
	iEOF=TRUE;
	break;
	}

	_stscanf_s(line,"%2d ",&ilyr);
	for (j=j1; j<=j2; j++)
	{
	UINT k = 3+(j-j1)*9; if (k>=_tcslen(line)-1) break;
	if (_stscanf_s(&line[k],"%9f",&velMod.xm[j][icont])==0) break;  
	velMod.nzed[icont]++;
	}

	if (_fgetts(line,MAXLINE,jpfp)==NULL) break; 
	trimRight(line);
	_stscanf_s(line,"%2d ",&icnt);
	for (j=j1; j<=j2; j++)
	{
	UINT k = 3+(j-j1)*9; if (k>=_tcslen(line)-1) break;
	if (_stscanf_s(&line[k],"%9f",&velMod.zm[j][icont])==0) break;
	}

	if (_fgetts(line,MAXLINE,jpfp)==NULL) {
	// if here, the last interface only has a depth with no velocity defined.
	iEOF=TRUE;
	break; 
	}

	nrz++;
	if(icnt!=1) break;
	j1+=10;
	j2+=10;
	}

	if (iEOF) {
	// velMod.ncont++; 
	break;
	}

	nrv=1;
	j1=0;
	j2=9;
	while(true) 
	{
	if (_fgetts(line,MAXLINE,jpfp)==NULL) {
	iEOF=TRUE; break;
	}
	if (_tcslen(line) < 2) continue;
	if (line[0] == '#') continue; // we do not need comment lines
	trimRight(line);
	_stscanf_s(line,"%2d ",&ilyr);
	if(ilyr<1)
	{
	iEOF=TRUE; break;
	}
	for (j=j1; j<=j2; j++)
	{
	UINT k = 3+(j-j1)*9; if (k>=_tcslen(line)-1) break;
	if (_stscanf_s(&line[k],"%9f",&velMod.xvel[j][icont][0])==0) break;  
	velMod.nvel[icont][0]++;
	}

	if (_fgetts(line,MAXLINE,jpfp)==NULL) break; 
	trimRight(line);
	_stscanf_s(line,"%2d ",&icnt);
	for (j=j1; j<=j2; j++)
	{
	UINT k = 3+(j-j1)*9; if (k>=_tcslen(line)-1) break;
	if (_stscanf_s(&line[k],"%9f",&velMod.vf[j][icont][0])==0) break;
	}

	if (_fgetts(line,MAXLINE,jpfp)==NULL) break; 
	nrv++;
	if(icnt!=1) break;
	j1+=10;
	j2+=10;
	}

	if(iEOF) {break;}

	nrv=1;
	j1=0;
	j2=9;
	while(true) 
	{
	if (_fgetts(line,MAXLINE,jpfp)==NULL) break; 
	if (_tcslen(line) < 2) continue;
	if (line[0] == '#') continue; // we do not need comment lines
	trimRight(line);
	_stscanf_s(line,"%2d ", &ilyr);
	for (j=j1; j<=j2; j++)
	{
	UINT k = 3+(j-j1)*9; if (k>=_tcslen(line)-1) break;
	if (_stscanf_s(&line[k],"%9f",&velMod.xvel[j][icont][1])==0) break; 
	velMod.nvel[icont][1]++;
	}

	if (_fgetts(line,MAXLINE,jpfp)==NULL) break; 
	trimRight(line);
	_stscanf_s(line,"%2d ",&icnt);
	for (j=j1; j<=j2; j++)
	{
	UINT k = 3+(j-j1)*9; if (k>=_tcslen(line)-1) break;
	if (_stscanf_s(&line[k],"%9f",&velMod.vf[j][icont][1])==0) break;
	}

	if (_fgetts(line,MAXLINE,jpfp)==NULL) break;
	nrv++;
	if(icnt!=1) break;
	j1+=10;
	j2+=10;

	}

	} // for icont


	velMod.ncont = icont + 1;
	velMod.nlayer = velMod.ncont-1;

	// additions: anisotropy added Oct., 2009 for model
	for (icont=0; icont<velMod.nlayer; icont++)
	velMod.anisotropy[icont] = 0.f;

	zeltArray->RemoveAll();
	zeltArray = NULL;
	return true;
	}
	*/






	void CSeisWideDoc::OnModelingDisplaycircle()
	{
		if (!isTimeDomain()) return;
		tx.circleCurve++;
		draw.isSameDataDisplay = TRUE;
		UpdateAllViews(NULL);
		//NotifyChanged();
	}


	void CSeisWideDoc::OnProcessingDatadespike()
	{
		long i;
		CString inFile = _T(""), outFile=_T("");
		static int trace1 = 0;
		static int trace2 = 99999;

		static BOOL isLTZ = FALSE;
		static float ftlength = 0.07f;  // sliding time window size
		static float fgw = 0.14f;  // maximum tolerance of zero-crossings in terms of number of samples. amplitudes will be trimmed if trZ[z+1] > trZ[z]+gw

		static BOOL isSpikeZeroing = TRUE;
		static float tlag = 0.04f;
		static float dac = 2.f;


		// AfxMessageBox(_T("After Trehu/Sutton: Marine Gephysical Researches 16: 91-103, 1994. Spikes are defined by |a[2]-a[1]| + |a[2]-a[3]| > fac * (|a[0]-a[1]| + |a[3]-a[4]|). If spike condition is met, replace a[2] with (a[1]+a[3])/2.");

		segy tr;  // for reading all kind of traces
		segy tr2;  // for output 

		bhed bh;

		CdlgDespiking dlg;
		dlg.m_inFile = draw.timeSecName;	

		//int pathLen = dlg.m_inFile.ReverseFind( '.' );
		//if(pathLen>(-1))
		//{
		//	CString t = dlg.m_inFile.Left(pathLen);
		//	dlg.m_outFile = t + _T("_despike.sgy";
		//}
		dlg.m_outFile = getFileNameAppend(draw.timeSecName, _T("Despike"));

		dlg.m_trace1 = trace1;
		dlg.m_trace2 = trace2;
		dlg.m_tlength = ftlength;
		dlg.m_gw = fgw;
		dlg.m_isLTZ = isLTZ;
		dlg.m_isSpikeZeroing = isSpikeZeroing;
		dlg.m_tlag = tlag;
		dlg.m_dac = dac;
		if (dlg.DoModal() == IDOK)
		{
			inFile = dlg.m_inFile;
			outFile = dlg.m_outFile;
			trace1 = dlg.m_trace1;
			trace2 = dlg.m_trace2;
			if (trace2 == trace1) {
				trace1 = 0;
				trace2 = 99999;
			}
			ftlength = dlg.m_tlength;
			fgw = dlg.m_gw;
			isLTZ = dlg.m_isLTZ;
			isSpikeZeroing = dlg.m_isSpikeZeroing;
			tlag = dlg.m_tlag;
			dac = dlg.m_dac;
		}
		else 
		{
			return;
		}

		if (!isFileExistNotDirectory(inFile)) return;
		if(outFile==_T("")) return;
		if(outFile == inFile)
		{
			AfxMessageBox(_T("Output file name is the same as the input file name!"));
			return;
		}
		CFile file;
		if (!file.Open(inFile, CFile::modeRead | CFile::typeBinary)) {
			AfxMessageBox(_T("Input time section cannot be read."));
			return;
		}
		outFile = mySetFileExtension(outFile, _T("sgy"));

		//put the path onto file2 if it doesn't have it.
		int pathLen = outFile.ReverseFind( '\\' );
		if(pathLen==(-1))
		{
			TCHAR curDir[_MAX_PATH];
			GetCurrentDirectory(_MAX_PATH, curDir);
			//outFile = (CString)curDir + _T("\\" + outFile;
			outFile.Format(_T("%s\\%s"), (CString)curDir, outFile);
		}


		//For progress control, need to know the last bytes no.
		ULONGLONG curBytesRead, totBytesRead = file.GetLength();
		file.Seek(0, CFile::begin);
		//Begin progress control.
		CMainFrame* pFrame = 
			(CMainFrame*)AfxGetMainWnd();
		ASSERT(pFrame);
		ASSERT_KINDOF(CMainFrame, pFrame);
		pFrame->BeginProgress();


		UINT bytesRead = file.Read(head.ascHead, 3200L);
		if(bytesRead < 3200) {
			file.Close();
			AfxMessageBox(_T("Ascii section header read wrong"));
			return;
		}
		bytesRead=file.Read(&bh, 400L);
		if(bytesRead < 400) {
			file.Close();
			AfxMessageBox(_T("Binary section header read wrong"));
			return;
		}
		//The following numbers have to be recalculated everytime,
		//because plotting the depth section will change these numbers.
		int numsamp = bh.hns; // (unsigned short)i2buf[10];
		int len;

		BOOL dataInt;
		if(bh.format !=3)  
		{
			dataInt = FALSE;
			len = numsamp*4 + 240;
		}
		else 
		{
			dataInt = TRUE;
			len = numsamp*2 + 240;
		}
		long headLenOut = numsamp*4 + 240;  // output in floating point only


		CFile file2;
		if (!file2.Open(outFile, CFile::modeWrite|CFile::modeCreate|CFile::typeBinary)) {
			file.Close();
			return;
		}

		file2.Write(head.ascHead, 3200L);
		int formatOrig = bh.format; // original data format
		bh.format = 1;  // always output in floating format
		file2.Write(&bh, 400L);

		ULONGLONG byteFileEnd = file.SeekToEnd();
		file.Seek(3600L, CFile::begin);

		// for storing adjacent traces
		segydynamic trPrev; // for storing the previous trace
		trPrev.tracl = -99999; // markup for invalid trace
		trPrev.data = (float *)malloc(sizeof(float)*numsamp);
		float dt = (float)bh.hdt / (float)MIL;
		float odt = 1.f / dt;

		segydynamic trAvg; // averaged trace for a small sliding time window of tlength samples
		segydynamic trZ;   // for store times for zero-crossings of trAvg[]
		trAvg.data = (float *)malloc(sizeof(float)*numsamp);
		trZ.data = (float *)malloc(sizeof(float)*numsamp);


		while (file.Read(&tr, len) == (UINT)len)
		{
			// trace1 and trace are already re-conditioned properly
			if ( tr.tracl < trace1 || tr.tracl > trace2  ) continue;

			if(tr.trid == 2) //dead traces.
			{
				continue;
			}
			/* data sample format code:
			1 = floating point (4 bytes)
			2 = fixed point (4 bytes)     long
			3 = fixed point (2 bytes)     short
			4 = fixed point w/gain code (4 bytes) */

			if(formatOrig == 1 ) {	 // float data
				ibm_to_float((int *) tr.dat.data, (int *) tr.dat.data, (int)numsamp);
				for (i=0; i<numsamp; i++) 
					tr2.dat.data[i]=(float)(tr.dat.data[i]); 
			}
			else if(formatOrig  == 2) {
				for (i=0; i<numsamp; i++)
					tr2.dat.data[i] = (float)(tr.dat.dataint[i]);
			}
			else if(formatOrig  == 3) {	// short int data
				for (i=0; i<numsamp; i++)
					tr2.dat.data[i]=(float)(tr.dat.datashort[i]); 
			}
			else if(formatOrig == 5 ) {	 // float data
				for (i=0; i<numsamp; i++) 
					tr2.dat.data[i]=(float)(tr.dat.data[i]); 
			}
			else {
				if (file) file.Close();
				if (file2) file2.Close();
				free(trPrev.data);
				//free(trNext.data);
				AfxMessageBox(_T("Unknown Data format"));
				return;
			}
			memcpy( (void *)&tr2, (void *)&tr, 240);

			// backup the tr2 data to tr.data before overwriting it soon.
			memcpy( (void *)&tr.dat.data[0], (void *)&tr2.dat.data[0], numsamp*4);


			// debias first
			double sum = 0.;
			for (i=0; i<numsamp; i++)
				sum += (double)(tr2.dat.data[i]);
			float mean= (float)(sum/(double)numsamp);
			for (i=0; i<numsamp; i++) 
				tr2.dat.data[i] = tr2.dat.data[i] - mean; 
			// filterTimeDomain(&tr2.dat.data[0], numsamp,1.f, -1.f, bh.hdt);

			if (isLTZ) {
				int tlength = (int)myRound(ftlength * odt);  // sliding time window size
				int gw = (int)myRound(fgw * odt) ;  // maximum tolerance of zero-crossings in terms of number of samples. amplitudes will be trimmed if trZ[z+1] > trZ[z]+gw
				memset((void *) trAvg.data, (int) '\0', sizeof(float)*numsamp);
				int it;
				int ihtlength = tlength/2; if (ihtlength < 1) ihtlength = 1;
				for (i=0; i<numsamp; i++) {
					for (it=i-tlength/2; it<=i+tlength/2; it++) {
						if (it >= 0 && it < numsamp) 
							trAvg.data[i] += tr2.dat.data[it];
					} // for it
				} // for i

				//memset((void *) trZ.data, (int) '\0', sizeof(float)*numsamp);
				int nz = 0; // number of zero crossings
				for (i=0; i<numsamp-1; i++) {
					if ( !sameSign(trAvg.data[i], trAvg.data[i+1]) ) {
						trZ.data[nz] = (float)i;
						nz++;
					} // if
				} // for i

				// trZ.data[0:nz-1] now indicates the index where sign changes occurs
				for (int z=0; z<nz-1; z++) {
					if ( (int)(trZ.data[z+1] - trZ.data[z]) >= gw ) {
						for (i=(int)trZ.data[z]+1; i<=(int)trZ.data[z+1]; i++) {
							tr2.dat.data[i] = 0.f;
						} // for i
					} // if
				} // for z
			} // if isLTZ






			if (isSpikeZeroing) {
				// we reuse 2 arrays:  trAvg.data[]   and   trZ.data[]
				memset((void *) trAvg.data, (int) '\0', sizeof(float)*numsamp);
				memset((void *) trZ.data, (int) '\0', sizeof(float)*numsamp);
				int numSum;
				int ntlag = (int)myRound(tlag * odt);  // sliding time window size
				for (i=0; i<numsamp; i++) {

					numSum = 0;
					for (int t=i-2*ntlag; t<i-ntlag; t++) {
						if (t >= 0) {
							trAvg.data[i] += fabs(tr2.dat.data[t]);
							numSum++;
						}
					} // for t
					if (numSum > 1) trAvg.data[i] /= (float)numSum;

					numSum = 0;
					for (int t=i+ntlag; t<i+2*ntlag; t++) {
						if (t < numsamp) {
							trZ.data[i] += fabs(tr2.dat.data[t]);
							numSum++;
						}
					} // for t
					if (numSum > 1) trZ.data[i] /= (float)numSum;
				} // for i
				for (i=0; i<numsamp; i++) {
					float amp = fabs(tr2.dat.data[i]);

					if (amp > dac*trAvg.data[i] && amp > dac*trZ.data[i]) {
						// now we make a last comparision with the previous trace
						float maxPrev = 0.f;
						int j;
						if (trPrev.tracl != -99999) {
							for (j=i-ntlag; j<i+ntlag; j++) {
								if (j>=0 && j<numsamp && maxPrev < fabs(trPrev.data[j])) 
									maxPrev = fabs(trPrev.data[j]);
							} // for j
						} // if
						if (amp > dac*maxPrev) {
							// now it is decided we want to zero the sample at i and around it!
							amp = tr2.dat.data[i]; // backup first before zeroing
							tr2.dat.data[i] = 0.f; // spike zeroing
							for (j=i-1; j>=0; j--) {
								if (sameSign(amp, tr2.dat.data[j]))
									tr2.dat.data[j] = 0.f;
								else break;
							}
							for (j=i+1; j<numsamp; j++) {
								if (sameSign(amp, tr2.dat.data[j]))
									tr2.dat.data[j] = 0.f;
								else 
									break;
							} // for j
						} // if a
					} // if 
				} // for i

				// now process tr2.data[]
				// Spikes are defined by |a[2]-a[1]| + |a[2]-a[3]| > fac * (|a[0]-a[1]| + |a[3]-a[4]|). 
				// If spike condition is met, replace a[2] with (a[1]+a[3])/2.;
				//for (i=2; i<numsamp-2; i++) {
				//	bool isSpike =
				//		fabs(tr2.dat.data[i]-tr2.dat.data[i-1]) + fabs(tr2.dat.data[i]-tr2.dat.data[i+1]) > dac *
				//		(fabs(tr2.dat.data[i-2]-tr2.dat.data[i-1]) + fabs(tr2.dat.data[i+1]-tr2.dat.data[i+2]));
				//	if (isSpike)
				//		tr2.dat.data[i] = (tr2.dat.data[i-1]+tr2.dat.data[i+1]) * 0.5f;
				//}
			} // if isSpikeZeroing




			// read the next trace for despiking along the X-axis
			//if (trPrev.trid != 2) {  // this means the trPrev is a valid trace for considering despiking along X-axis
			//	if (file.Read(&tr, len) == (UINT)len) {
			//		 if(formatOrig == 1 ) {	 // float data
			//			 for (i=0; i<numsamp; i++) 
			//				 trNext.data[i]=(float)(tr.dat.data[i]); 
			//		 }
			//		 else if(formatOrig  == 2) {
			//			 for (i=0; i<numsamp; i++) 
			//				 trNext.data[i] = (float)(tr.dat.dataint[i]);
			//		 }
			//		 else if(formatOrig  == 3) {	// short int data
			//			 for (i=0; i<numsamp; i++) 
			//				 trNext.data[i]=(float)(tr.dat.datashort[i]); 
			//		 }
			//		memcpy( (void *)&trNext, (void *)&tr, 240);
			// 
			//		 
			//		for (i=2; i<numsamp; i++) {  // // now do the X-despiking using trPrev, tr2, and trNext
			//			bool isSpikeThis = fabs(tr2.dat.data[i]-tr2.dat.data[i-1]) > dac * fabs(tr2.dat.data[i-2]-tr2.dat.data[i-1]) ;
			//			if (isSpikeThis) {
			//				bool isSpikePrev = fabs(trPrev.data[i]-trPrev.data[i-1]) > dac * fabs(trPrev.data[i-2]-trPrev.data[i-1]) ;
			//				bool isSpikeNext = fabs(trNext.data[i]-trNext.data[i-1]) > dac * fabs(trNext.data[i-2]-trNext.data[i-1]) ;
			//				if (!isSpikePrev && !isSpikeNext)
			//					tr2.dat.data[i] = (trPrev.data[i] + trNext.data[i]) * 0.5f;
			//			} // if (isSpikeThis) 
			//		} // for i=0
			//		file.Seek(-len, CFile::current);// rewind back 1 trace 
			//	} // if file.Read
			//	// if failed reading, no need for despiking
			//} // if trPrev


			tr2.ns = (unsigned short)numsamp;
			// assign segy arrays for later usage
			memcpy( (void *)&trPrev, (void *)&tr2, 240);
			memcpy( (void *)&trPrev.data[0], (void *)&tr.dat.data[0], numsamp*4);


			if (bh.format==1 ) {
				float_to_ibm((int *) tr2.dat.data, (int *) tr2.dat.data, (int)tr2.ns);
			}
			file2.Write(&tr2, headLenOut);



			// progress control. Do not change
			curBytesRead = file.Seek(0, CFile::current);
			int iPos = (int)((double)curBytesRead/(double)totBytesRead*100.);
			if(iPos<0)iPos=0;
			if(iPos>100)iPos=100;
			pFrame->SetProgress(iPos);
		}	// while


		free(trPrev.data);
		//free(trNext.data);
		free(trAvg.data);
		free(trZ.data);
		if (file) file.Close();
		if (file2) file2.Close();
		if (pFrame) { 
			pFrame->EndProgress();
		}
		draw.timeSecName = outFile;
		//		draw.timeSecOld = _T("");
		OnToolbarRefreshAll();
	}


	void CSeisWideDoc::OnAcceleratorFontsize()
	{
		CMainFrame* pFrame = 
			(CMainFrame*)AfxGetMainWnd();
		ASSERT(pFrame);
		ASSERT_KINDOF(CMainFrame, pFrame);

		// if (pFrame->myLabelNumberHeigth <1) pFrame->myLabelNumberHeigth = 1;
		//if (pFrame->myLabelNumberWidth <1) pFrame->myLabelNumberWidth = 1;

		// float xyRatio = (float)pFrame->myLabelNumberHeight / (float)pFrame->myLabelNumberWidth;

		pFrame->fLabelDistance3 *= 1.2f;


		if (pFrame->thicknessLines < 1.f) 
			pFrame->thicknessLines = 1.f; // note: pFrame->thicknessLines<1 meaning the same as 1.
		pFrame->thicknessLines *= 2.f;
		if (pFrame->thicknessLines > 2.2f) 
			pFrame->thicknessLines = 2.2f;


		draw.bigNodes++;
		if (draw.bigNodes>3) draw.bigNodes = 3;

		draw.isNodeChanged = TRUE;
		UpdateAllViews(NULL);

		if (pFrame->pViewPrev != NULL) {
			// ( (CSeisWideDoc *)pFrame->pDocPrev )->draw.thicknessLines *= 2.f;
			this->myUpdatePrevFrame();
		}

	}

	void CSeisWideDoc::OnAcceleratorFontminus()
	{
		CMainFrame* pFrame = 
			(CMainFrame*)AfxGetMainWnd();
		ASSERT(pFrame);
		ASSERT_KINDOF(CMainFrame, pFrame);
		// float xyRatio = (float)pFrame->myLabelNumberHeight / (float)pFrame->myLabelNumberWidth;
		pFrame->fLabelDistance3 *= 0.83f;
		pFrame->thicknessLines *= 0.5f;
		if (pFrame->thicknessLines < 1.f) 
			pFrame->thicknessLines = 1.f;

		draw.bigNodes--;
		if (draw.bigNodes<1) draw.bigNodes = 1;

		draw.isNodeChanged = TRUE;
		UpdateAllViews(NULL);

		if (pFrame->pViewPrev != NULL) {
			// ( (CSeisWideDoc *)pFrame->pDocPrev )->draw.thicknessLines *= 0.5f;
			this->myUpdatePrevFrame();
		}

	}

	void CSeisWideDoc::OnModelingDumpcmpTwtt()
	{
		long icont;

		if(draw.mode<2 || draw.mode>4)
		{
			AfxMessageBox(_T("Please display the model before dumping model values."));
			return;
		}

		FILE *stream;
		CString outName = getSystemTempPathSlash() + _T(".tmpSeisWideModelDump.txt");
		if( _tfopen_s(&stream, outName, _T("w+") ) != 0 ) 
		{
			AfxMessageBox ( _T("Could not open a temporary file") );
			return;
		}

		CVelMod vm;
		CVelMod::VELMOD_X modX;

		// calculate the proper label to output
		CString strNameLineSB;
		if (isFileExistNotDirectory(draw.timeSecName)) {
			strNameLineSB = draw.timeSecName;
		} // if
		else {
			strNameLineSB = velMod.velSecName;
		}

		int pathLen = strNameLineSB.ReverseFind( '.' );
		if(pathLen>(-1))
		{
			strNameLineSB.Format(_T("%s"), strNameLineSB.Left(pathLen));
			pathLen = strNameLineSB.ReverseFind( '\\' );
			if(pathLen>(-1))
				strNameLineSB.Format(_T("%s"), strNameLineSB.Mid(pathLen+1));
		}

		if (!isTimeDomain())
			vm.myModel_Depth2TWTT(&velMod, vel.dz);

		float x = velMod.xm[0][0]; // xmin in model
		_ftprintf_s(stream,_T("#2D Model dump to overlay onto reflection profile. \n#LineName,        cmp,dpth(km),twtt(s),v_int(km/s),x(km)\n"));
		while (x <= velMod.xm[ velMod.nzed[0]-1 ][0]) {
			modX.dist = x;
			vm.initModX(&velMod, &modX, isTimeDomain() == TRUE, true, true, vel.dz);
			// vm.getTModFromZMod(&modX, vel.dz);

			// calculate CMP for x
			float aCmp = 0.f;
			for (int i=0; i<head.numTraces-1; i++) {
				if (x>=head.dist[i] && x<=head.dist[i+1]) {
					if (head.dist[i+1]-head.dist[i] != 0.f)
						aCmp = head.cmp[i] + (head.cmp[i+1] - head.cmp[i])* (x-head.dist[i])/(head.dist[i+1]-head.dist[i]);
					else
						aCmp = (float)head.cmp[i];
					break;
				} // if
			} // for i
			CString strInterpol = _T("");
			if (myRound(aCmp) == 0) {
				// we need a fix if the segy file does not extend to the full model.
				if (head.numTraces >= 2 && 
					(x > head.dist[head.numTraces-1] || x < head.dist[0])
					) {
						// we interpolate
						if (head.dist[head.numTraces-1]-head.dist[head.numTraces-2] != 0.f)
							aCmp = head.cmp[head.numTraces-2] + (head.cmp[head.numTraces-1] - head.cmp[head.numTraces-2])* (x-head.dist[head.numTraces-2])/(head.dist[head.numTraces-1]-head.dist[head.numTraces-2]);
						else
							aCmp = (float)head.cmp[head.numTraces-2];
						strInterpol = _T("CMP_interpolated");
				} // if
			} // if

			// now print out the results
			for (icont=0; icont<velMod.ncont-1; icont++) {
				if (aCmp > 0.f) {
					double d1 = modX.depthMod[icont];
					double d2 = modX.depthMod[icont + 1];
					if (icont>0) d1 += 0.01;
					if (icont < velMod.ncont-1 - 1) d2 -= 0.01;

					double t1 = modX.timeMod[icont];
					double t2 = modX.timeMod[icont + 1];
					if (icont>0) t1 += 0.03;
					if (icont < velMod.ncont-1 - 1) t2 -= 0.03;

					// it turns out
					if (d2 >= d1 + 0.02) {
						_ftprintf_s(stream,_T("%14s %6d  %6.3f  %6.3f %6.3f %8.3f %s\n"),strNameLineSB, (int)myRound(aCmp), d1, t1, modX.vTop[icont], x, strInterpol);
						_ftprintf_s(stream, _T("%14s %6d  %6.3f  %6.3f %6.3f %8.3f %s\n"), strNameLineSB, (int)myRound(aCmp), d2, t2, modX.vBot[icont], x, strInterpol);
					}
					else {
						_ftprintf_s(stream, _T("%14s %6d  %6.3f  %6.3f %6.3f %8.3f %s\n"), strNameLineSB, (int)myRound(aCmp), modX.depthMod[icont], modX.timeMod[icont], modX.vTop[icont], x, strInterpol);
					}
					//_ftprintf_s(stream,"%14s %6d  %6.3f  %6.3f %6.3f %8.3f %s\n",strNameLineSB, (int)myRound(aCmp), depth[icont], twttMod[icont], vTop[icont], x, strInterpol);
					//_ftprintf_s(stream,"%14s %6d  %6.3f  %6.3f %6.3f %8.3f %s\n",strNameLineSB, (int)myRound(aCmp), depth[icont+1], twttMod[icont+1],  vBot[icont], x, strInterpol);

					// but John wanted "interval velocity" outputs, so there is change below:
					//_ftprintf_s(stream,"%14s %6d  %6.3f  %6.3f %6.3f %8.3f %s\n",strNameLineSB, (int)myRound(aCmp), depth[icont], twttMod[icont], (vTop[icont]+vBot[icont])*0.5f, x, strInterpol);
				}
			}
			x = getModelPointNext(x);
		} // while

		//free(twttMod);
		if( stream != NULL ) fclose( stream );
		showFileInNotePad(outName);
	}

	// get next model control point after the xCurrent along the X-axis
	// if the next point is beyond the model max limit, returns 99999.f
	float CSeisWideDoc::getModelPointNext(float xCurrent)
	{
		int j;
		int icont;
		float x = velMod.xm[ velMod.nzed[0]-1 ][0];  // the maximum model boundary in X axis
		if (isFloatEqual(x, xCurrent)) return 99999.f; // meaning already going beyond the model max limit

		for (icont=0; icont<velMod.ncont; icont++)
		{
			for (j=0; j<velMod.nzed[icont]-1; j++)
			{
				if (xCurrent >= velMod.xm[j][icont] && xCurrent < velMod.xm[j+1][icont]) {
					// found the next point for the current boundary
					x = MIN(x, velMod.xm[j+1][icont]);
					break;
				}
			}  // for j
		} // for icont


		return x;
	}

	void CSeisWideDoc::OnProcessingDumpsegylatlong()
	{
		short nf = 0;
		CString inFileName, inFileNames[999], logFileName ;

		//Open file dialog.
		CFileDialog dlg( TRUE,_T("sgy; SEG"),_T("*.sgy"),
			OFN_HIDEREADONLY|OFN_OVERWRITEPROMPT|OFN_ALLOWMULTISELECT|OFN_EXPLORER,
			_T("Input Segy Files (*.sgy)|*.sgy|"));
		TCHAR* buff=new TCHAR[65535];
		buff[0]='\0';
		dlg.m_ofn.lpstrTitle = _T("Select all segy files for dumping lat/longs");
		dlg.m_ofn.lpstrFile=buff;
		dlg.m_ofn.nMaxFile = 65535;//sizeof(buff);


		POSITION Position;

		if(dlg.DoModal()==IDOK)
		{

			Position=dlg.GetStartPosition();
			while(Position)
			{
				inFileName = dlg.GetNextPathName(Position);
				if(!inFileName.IsEmpty()) {
					inFileNames[nf] = inFileName;
					nf++; }
			}
			delete dlg;

		} //end dlg.DoModal function.
		else {
			delete [] buff;
			delete dlg;
			return;
		}

		delete [] buff;

		// If data numbers exceed max, just change this number
		int MAX_FILES=999;
		if(nf>MAX_FILES)
		{
			AfxMessageBox(_T("Maximum number of files selected is exceeded."));
			return;
		}



		//	BOOL isConcatenate = false;
		//	if(AfxMessageBox(_T("Do you want to concatenate to a new segy file? \nIf no, the first alphabetically-listed segy file will be appended with traces \nfrom all other selected files.", MB_YESNO|MB_ICONINFORMATION) == IDYES) 
		//		isConcatenate = true;


		//now reorganize these files sequentially, alphabetically.
		int n;
		CString t;
		for (n=0; n<nf-1; n++)
		{
			for (int i=n+1; i<nf; i++)
			{
				if(inFileNames[n]>inFileNames[i]) 
				{
					t = inFileNames[i];			
					inFileNames[i] = inFileNames[n];
					inFileNames[n] = t;			
				}
			}
		}




		int totShot;
		bhed bh;
		segy tr;

		ULONGLONG bytesRead;
		int iPos;
		TCHAR s[80];
		BOOL isUnix = false;



		//###############initilize output file pointer###################
		if ((n = inFileNames[0].GetLength()) > 4) {
			logFileName = GetFileNameAppendExt(inFileNames[0], _T("Latlong"), _T("log"));

			int pathLen = inFileNames[0].ReverseFind( '\\' );
			if(pathLen>2)
				SetCurrentDirectory(inFileNames[0].Left(pathLen));
		}
		else {
			logFileName = _T("Latlong.log");
		}

		FILE *log;
		if (_tfopen_s(&log, logFileName, _T("w")) != 0 ) {
			AfxMessageBox(_T("Cannot open log file to write."));
			return;
		}
		_ftprintf_s(log, _T("#Dump of all the lat longs for every Trace in many segy files, for gmt plotting\n"));


		//Begin progress control.
		CMainFrame* pFrame = 
			(CMainFrame*)AfxGetMainWnd();
		ASSERT(pFrame);
		ASSERT_KINDOF(CMainFrame, pFrame);
		pFrame->BeginProgress();


		//###############loop thru the input files ###################
		totShot = 0;
		float lat;
		float lon;
		for (n=0; n<nf; n++) {
			// curBytesRead = file2.Seek(0, CFile::current);
			iPos = (int)((double)n/(double)nf*100.);
			if(iPos<0)iPos=0;
			if(iPos>100)iPos=100;
			pFrame->SetProgress(iPos);


			if (!isFileExistNotDirectory(inFileNames[n])) continue;
			CFile file;
			if (!file.Open(inFileNames[n], CFile::modeRead | CFile::typeBinary)) {
				continue;
			}

			// first, we processs the tape headers
			bytesRead = file.Read(head.ascHead, 3200L);
			if(bytesRead < 3200) {
				AfxMessageBox(_T("Ascii section header read wrong: ") + inFileNames[n]);
				file.Close();
				continue;  // skip this file and continue to the next file
			}
			// ebc2asc(head.ascHead, 3200);
			_ftprintf_s(log, _T("> %s\n"), inFileNames[n]);
			bytesRead = file.Read(&bh, 400L);
			if (isUnix = IsUnix(bh.format)) SwapTapeHeader(&bh);
			if(bytesRead < 400 || !IsFormatValid(bh.format)) {
				// AfxMessageBox(_T("Binary section header read wrong");
				file.Close();
				continue;  // skip this file and continue to the next file
			}

			// get some parameters from the tape header: note: every file can be different!
			int len = (bh.format==3) ? (2*bh.hns) :  4*bh.hns;

			// we now process the trace data
			while (file.Read(&tr, 240) == (UINT)240) {
				if (isUnix) {
					SwapTraceHeader(&tr);
					// SwapN(&tr, bh.format);
				}
				tr.tracl = totShot + 1;

				// _ftprintf_s(log, _T("%d %8.5f %8.5f %d %d %d:%d:%d:%d\n", tr.tracl,(float)(0.0001f*tr.gx), (float)(0.0001f*tr.gy), tr.cdp,tr.cdpbak,tr.year,tr.hour,tr.minute,tr.sec);
				// _ftprintf_s(logGmt, _T("%8.5f %8.5f %d:%d:%d:%d\n", (float)(0.0001f*tr.gx), (float)(0.0001f*tr.gy),tr.year,tr.hour,tr.minute,tr.sec);
				lon = (float)(tr.gx / 360000.);
				lat = (float)(tr.gy / 360000.);
				if (lon > 180.f) 
					lon -= 360.f;
				// _ftprintf_s(log, _T("%8.5f %8.5f 6 0 8 LM \\040\n", lon, lat);
				_ftprintf_s(log, _T("%8.5f %8.5f\n"), lon, lat);
				file.Seek(len, CFile::current);
				totShot++;
			}
			file.Close();
		}
		pFrame->EndProgress();

		if(totShot>0) 
		{
			//	file2.Seek(3212L, CFile::begin);
			//	file2.Write(&totShot, 2);
			_stprintf_s(s, _T("Success! A total of %d traces processed"), totShot);
			AfxMessageBox(s);
		}
		else
			AfxMessageBox(_T("Not even one trace appended!"));

		fclose(log);
		showFileInNotePad(logFileName);
	}

	void CSeisWideDoc::OnProcessingDecimatedatalines()
	{
		static int skip = 0;
		static int decimate = 10;

		CdlgDesimate dlg0;
		dlg0.m_skip = skip;
		dlg0.m_decimate = decimate;
		if (dlg0.DoModal() == IDOK) {
			skip = dlg0.m_skip;
			decimate = dlg0.m_decimate;
		}
		else
			return;

		//
		CString inFile = _T(""), outFile=_T("");
		CStringArray linesArr;
		FILE *stream;
		//Openfiles.
		CFileDialog dlg( TRUE,_T("lld; txt; log"),_T("*.lld; *.txt; log"),
			OFN_HIDEREADONLY|OFN_OVERWRITEPROMPT|OFN_ALLOWMULTISELECT|OFN_EXPLORER,
			_T("Input text File (*.lld;*.txt;*.log)|*.lld;*.txt;*.log|"));

		TCHAR* buff=new TCHAR[65535];
		buff[0]='\0';
		dlg.m_ofn.lpstrTitle = _T("Select all nav data files for conversion in batch");
		dlg.m_ofn.lpstrFile=buff;
		dlg.m_ofn.nMaxFile = 65535;//sizeof(buff);


		POSITION Position;

		CString t;
		CString tOld = _T("");
		if(dlg.DoModal()==IDOK)
		{

			Position=dlg.GetStartPosition();
			while(Position)
			{
				inFile = dlg.GetNextPathName(Position);
				if (!isFileExistNotDirectory(inFile)) continue;
				getLinesFromFile2(&linesArr, inFile, true, 0);

				outFile = inFile + _T("_Deci.lld");
				if( _tfopen_s(&stream, outFile, _T("w") ) != 0)
				{
					AfxMessageBox( _T("Unable to open a temporary file in the current firectory") );
					delete [] buff;
					return;
				}
				t.Format(_T("#Decimate by %d\n"), decimate);
				int idecimate = decimate;
				for (int i=0; i<linesArr.GetSize(); i++) {
					t.Format(_T("%s"), linesArr.ElementAt(i));
					if (t.GetAt(0) == '#') {
						_ftprintf_s(stream, t);
						tOld = _T("");  // this line does not contain valid data
					}
					else if (t.GetAt(0) == '>') {
						// '>' means a start of the line segment
						// first check if the previous line segment is properly ended
						if (tOld.GetLength() > 0)
							_ftprintf_s(stream, tOld);
						_ftprintf_s(stream, t);
						idecimate = 0; // this indicate that the next line will be needed and reset counter at that time
						tOld = _T(""); // this line does not contain valid data
					}
					else if (i<skip || i==linesArr.GetSize()-1 || idecimate==0) {
						_ftprintf_s(stream, t);
						tOld = t;
						idecimate = decimate;
					}
					else {
						tOld = t;
						idecimate --;
					} // else

				} // for i
				fclose(stream);

				linesArr.RemoveAll();

			} //end the while file POSITION loop.
		} //end dlg.DoModal function.
		delete [] buff;

		// only show the last file output
		showFileInNotePad(outFile);

	}

	void CSeisWideDoc::OnDigitizingZeltSwapsource()
	{
		// only Zelt's format can define source position
		if (!draw.isDigitizing || dig.nPoint==NULL || !dig.isZeltFormat2) return;

		if (para.isDistanceDisplay) {
			// only when displaying as distance should the x be shifted according to source
			float srcNew = (float)pCd.coord.xmax;
			for (int i=0; i<dig.totCurve; i++) {
				for (int j=0; j<dig.nPoint[i]; j++) {
					dig.x[j][i] = srcNew - dig.x[j][i];
				}
			}
			tx.xShot = srcNew;
			CDigitize pDg;
			pDg.myDigSaveAs(&dig, dig.isSorted, dig.isSortedY, tx.xShot); 
			CString str;
			str.Format(_T("Source position is changed to %f . As a result, the shifted points will not be displayed until your displayed segy has the same source position."), srcNew);
			AfxMessageBox(str);
		}
		UpdateAllViews(NULL);
		NotifyChanged();
	}

	void CSeisWideDoc::clearGDC(void)
	{
		if (draw.gDC != NULL) {
			//CSize cs = draw.gDC->GetWindowExt();
			//draw.gDC->FillSolidRect(0, 0, cs.cx, cs.cy, RGB(255, 255, 255)); 
			draw.gDC_vred = 0.f;
			//	draw.gDC->is

			CRect rect; 
			draw.gDC->GetClipBox(&rect); 
			draw.gDC->PatBlt(rect.left, rect.top, rect.Width(), rect.Height(), PATCOPY); 
		}
	}

	void CSeisWideDoc::OnSegyconversionUnixtopcconvert()
	{
		// this routine converts input data file in segy format (see segy.h file for definition) 
		// from big-endian to small-endian or Intel platform. It must consider input data in the 
		// formats of short integer, long integer, and floating point. See file suSwapByte.c for
		// routines of conversion.

		// A segy file contains an 3200-byte ascii section header, 400-byte binary section header, 
		// and many traces. Each trace is mapped in the struct "segy" which contains 240-byte 
		// binary header followed by data chunk.
		// 
		// NOTE: only segy data are converted. any headers will be un-changed.
		//	short iDatForm;
		short *i2buf;
		long k;
		long *i4buf;
		//	float *trcdat;
		segy tr;
		bhed bh;
		BOOL isUnix = false;

		BOOL  trcRenum = false;
		BOOL isBackupCDP = false;
		CString inFile = _T(""), outFile=_T("");

		i2buf = (short *) &tr;
		i4buf = (long *) &i2buf[0];
		//	i2short = (short *) &i2buf[120];
		//	headLong = (long *) &i2buf[0];
		//	trcdat = (float *) &i2buf[120];

		//Openfiles.
		CFileDialog dlg( TRUE,_T("sgy; SEG"),_T("*.sgy; *.SEG"),
			OFN_HIDEREADONLY|OFN_OVERWRITEPROMPT|OFN_ALLOWMULTISELECT|OFN_EXPLORER,
			_T("Input Segy File (*.sgy;*.SEG)|*.sgy; *.SEG|"));

		TCHAR* buff=new TCHAR[65535];
		buff[0]='\0';
		dlg.m_ofn.lpstrTitle = _T("Select all files for conversion in batch");
		dlg.m_ofn.lpstrFile=buff;
		dlg.m_ofn.nMaxFile = 65535;//sizeof(buff);

		//Begin progress control.
		CMainFrame* pFrame = 
			(CMainFrame*)AfxGetMainWnd();
		ASSERT(pFrame);
		ASSERT_KINDOF(CMainFrame, pFrame);
		pFrame->BeginProgress();

		POSITION Position;

		if(dlg.DoModal()==IDOK)
		{

			Position=dlg.GetStartPosition();
			while(Position)
			{
				inFile = dlg.GetNextPathName(Position);
				CString tempStr = inFile;
				tempStr.MakeLower();
				// must make it lower case before comparing, in case some file has extension
				// like ".Sgy" or ".sGY".
				outFile = getFileNameAppend(inFile, _T("PC"));
				if(outFile==_T("")) continue;

				if (!isFileExistNotDirectory(inFile)) continue;
				CFile file;
				if (!file.Open(inFile, CFile::modeRead | CFile::typeBinary)) {
					continue;
				}
				//For progress control, need to know the last bytes no.
				ULONGLONG curBytesRead, totBytesRead = file.GetLength();
				file.Seek(0, CFile::begin);

				UINT bytesRead = file.Read(head.ascHead, 3200L);
				if(bytesRead < 3200) 
				{
					file.Close();
					AfxMessageBox(_T("File ") + inFile + _T(" Ascii section header read wrong"));
					continue;
				}
				file.Read(&bh, 400L);
				if(bytesRead < 400) 
				{
					file.Close();
					AfxMessageBox(_T("File ") + inFile + _T(" Binary section header read wrong"));
					continue;
				}


				if (isUnix = IsUnix(bh.format)) SwapTapeHeader(&bh);


				int numsamp = bh.hns;
				int len;
				//			iDatForm = bh.format;
				if(bh.format == 4)
				{
					file.Close();
					AfxMessageBox(_T("File ") + inFile + _T(" Data in 4-byte fixed point w/gain code is not supported in SeisWide; Try using NSCU in UNIX to convert"));
					continue;
				}
				else if(bh.format==1 || bh.format==2 || bh.format==5)
					len = numsamp*4 + 240;
				else if (bh.format==3)
					len = numsamp*2 + 240;
				else
				{
					file.Close();
					AfxMessageBox(_T("File ") + inFile + _T(" has unknown format"));
					continue;
					//	bh.format = 1;
					//	len = numsamp*4 + 240;
				}
				int tpp = bh.hdt;
				ULONGLONG byteFileEnd = file.SeekToEnd();
				file.Seek(3600L, CFile::begin);

				CFile file2;
				if (!file2.Open(outFile, CFile::modeWrite|CFile::modeCreate|CFile::typeBinary)) {
					file.Close();
					continue;
				}
				ebc2asc(head.ascHead, 3200L);
				file2.Write(head.ascHead, 3200L);
				// if (iDatForm==2) bh.format = 1; //if 4-byte fix point, output floating point.
				file2.Write(&bh, 400L);

				k = 0;
				// NOTE: this routine does not convert between IBM and IEEE formats
				while (file.Read(&tr, len) == (UINT)len)
				{
					k ++; //trace counter

					if (isUnix) {
						SwapTraceHeader(&tr);
						SwapN(&tr, bh.format);
					}


					if (trcRenum) tr.tracl = k;

					file2.Write(&tr, len);

					curBytesRead = file.Seek(0, CFile::current);
					int iPos = (int)((double)curBytesRead/(double)totBytesRead*100.);
					if(iPos<0)iPos=0;
					if(iPos>100)iPos=100;
					pFrame->SetProgress(iPos);
				} //end the while Read loop.

				file.Close();
				file2.Close();
				//			draw.timeSecOld = _T("");	//recalculate gain.


			} //end the while file POSITION loop.
		} //end dlg.DoModal function.
		delete [] buff;

		pFrame->EndProgress();

	}

	void CSeisWideDoc::OnModelup()
	{
		CVelMod vm;
		CString tStr;

		bool isChanged = false;
		if ( 
			(draw.mode==2 || draw.mode==3 || draw.mode==4|| draw.mode==9)
			&& velMod.ncont > 1 && 
			draw.iLayerFocus >= 0
			) {
				int icont = draw.iLayerFocus;
				if (draw.nodes == 1) {
					// boundary mode
					if (icont<1) return;  // we do not move the top boundary
					if (icont>=velMod.ncont) return;
					float dz = (draw.isControlPressed)  ?   0.001f  :  (float)fabs(draw.modelUpInc);

					for (int j=0; j<velMod.nzed[icont]; j++)  {
						if (draw.mode==9) 
							velMod.tm[j][icont] -= dz;
						else
							velMod.zm[j][icont] -= dz;
					}
				} // if draw
				else if (draw.nodes == 2) {
					// velocity editting mode
					if (icont>=velMod.ncont-1) return;
					// float dv = 0.02f;
					int n;
					n = velMod.nvel[icont][0];
					double dv = fabs(draw.modelVelInc);
					if (draw.isControlPressed) dv = 0.01f;
					else if (draw.isShiftPressed) {
						if (velMod.vf[0][icont][0] >= 2.5f) dv = 0.5;
						else dv = 0.2;
					}
					for (int j=0; j<n; j++)  {
						velMod.vf[j][icont][0] += (float)dv;
					}
					n = velMod.nvel[icont][1];
					for (int j=0; j<n; j++)  {
						velMod.vf[j][icont][1] += (float)dv;
					}
					tStr.Format(_T("Velocity increased by %f. Ctrl key to fine tune."), fabs(draw.modelVelInc));
					myCaption(tStr);
				} // else

				if (draw.mode==9) {
					vm.myModel_TWTT2Depth(&velMod, vel.dz);
				}
				// OnToolbarSavev();
				if (draw.mode == 2 || draw.mode == 4) {
					// in velocity colormap or contour mode, the screen does not refresh the model, so we need to force it.
					// but in moode=3, it is handled separately.
					//	draw.isSameDataDisplay = FALSE;
				}
				isChanged = true;
		} // if
		else if( (draw.mode==0 || draw.mode==7)  &&  abs(pCd.coord.vred)>0.001 ) {
			double xUse = (para.isDistanceDisplay && isXShotDefined(tx.xShot))  ?  tx.xShot  :  pCd.coord.xmin;

			double tRed1 = this->getReduceTime(this->getOffsetFromXVal(xUse), pCd.coord.vred);


			double aVred = 0.; 
			if ( draw.mode==0 && fabs(draw.dxdyDrawn)>0.0001 && fabs(draw.dxdyDrawn)<15. ) {
				pCd.coord.vred = myFloat2(draw.dxdyDrawn);
				draw.dxdyDrawn = 0.0f; // already used this value and should now be set to zero
			} else if (draw.mode == 7 && fabs(draw.dxdyDrawn)>0.0001 && fabs(draw.dxdyDrawn)<15. ) {
				pCd.coord.vred = myFloat2(draw.dxdyDrawn);
				draw.dxdyDrawn = 0.0f; // already used this value and should now be set to zero
			} else {
				if (draw.isShiftPressed)
					pCd.coord.vred -= 0.5;
				else if (fabs(pCd.coord.vred) >= 2.5 && !draw.isControlPressed)
					pCd.coord.vred -= 0.1;
				else
					pCd.coord.vred -= 0.01;
			}
			float tRed2 = (float)this->getReduceTime(this->getOffsetFromXVal(xUse), pCd.coord.vred);

			// we we want to shift vertically otherwise we can be off seeing the data
			//pCd.coord.tmin -= (tRed2 - tRed1);
			//pCd.coord.tmax -= (tRed2 - tRed1);



			draw.isSameDataDisplay = (draw.mode==0 && !isFloatEqual(draw.gDC_vred, 0.0f))  ?  TRUE  :  FALSE;
			//draw.isSameDataDisplay = FALSE;
			isChanged = true;
		}


		if (isChanged) {
			UpdateAllViews(NULL);
			NotifyChanged();
		}
	}

	void CSeisWideDoc::OnModeldown()
	{
		CVelMod vm;
		CString tStr;
		bool isChanged = false;
		if ( 
			(draw.mode==2 || draw.mode==3 || draw.mode==4|| draw.mode==9)
			&& velMod.ncont > 1 && draw.iLayerFocus >= 0) {
				int icont = draw.iLayerFocus;
				if (draw.nodes == 1) {
					// boundary mode
					if (icont<1) return;  // we do not move the top boundary
					if (icont>=velMod.ncont) return;
					double dz = (draw.isControlPressed)  ?   0.001  :  fabs(draw.modelUpInc);
					for (int j=0; j<velMod.nzed[icont]; j++)  {
						if (draw.mode==9) 
							velMod.tm[j][icont] += (float)dz;
						else
							velMod.zm[j][icont] += (float)dz;
					}
				} // if draw
				else if (draw.nodes == 2) {
					// velocity editting mode
					if (icont>=velMod.ncont-1) return;
					double dv = fabs(draw.modelVelInc);
					if (draw.isControlPressed) dv = 0.01;
					else if (draw.isShiftPressed) {
						if (velMod.vf[0][icont][0] >= 2.5f) dv = 0.5;
						else dv = 0.2;
					}

					int n;
					n = velMod.nvel[icont][0];
					for (int j=0; j<n; j++)  {
						velMod.vf[j][icont][0] -= (float)dv;
					}
					n = velMod.nvel[icont][1];
					for (int j=0; j<n; j++)  {
						velMod.vf[j][icont][1] -= (float)dv;
					}
					CString tStr;
					tStr.Format(_T("Velocity decreased by %f. Ctrl key to fine tune."), fabs(draw.modelVelInc));
					myCaption(tStr);
				} // else
				if (draw.mode==9) {
					vm.myModel_TWTT2Depth(&velMod, vel.dz);
				}
				// OnToolbarSavev();
				if (draw.mode == 2 || draw.mode == 4) {
					// in velocity colormap or contour mode, the screen does not refresh the model, so we need to force it.
					// but in moode=3, it is handled separately.
					//	draw.isSameDataDisplay = FALSE;
				}
				isChanged = true;
		} // if

		else if( (draw.mode==0 || draw.mode==7)  &&  abs(pCd.coord.vred)>0.001 ) {
			double xUse = (para.isDistanceDisplay && isXShotDefined(tx.xShot))  ?  tx.xShot  :  pCd.coord.xmin;
			float tRed1 = (float)this->getReduceTime(this->getOffsetFromXVal(xUse), pCd.coord.vred);

			if ( draw.mode==0 && fabs(draw.dxdyDrawn)>0.0001 && fabs(draw.dxdyDrawn)<15. ) {
				pCd.coord.vred = myFloat2(draw.dxdyDrawn);
				draw.dxdyDrawn = 0.0f; // already used this value and should now be set to zero
			} else if (draw.mode == 7 && fabs(draw.dxdyDrawn)>0.0001 && fabs(draw.dxdyDrawn)<15. ) {
				pCd.coord.vred = myFloat2(draw.dxdyDrawn);
				draw.dxdyDrawn = 0.0f; // already used this value and should now be set to zero
			} else {
				if (draw.isShiftPressed)
					pCd.coord.vred += 0.5;
				else if (fabs(pCd.coord.vred) >= 2.5 && !draw.isControlPressed)
					pCd.coord.vred += 0.1;
				else
					pCd.coord.vred += 0.01;
			}
			float tRed2 = (float)this->getReduceTime(this->getOffsetFromXVal(xUse), pCd.coord.vred);

			// we we want to shift vertically otherwise we can be off seeing the data
			//pCd.coord.tmin -= (tRed2 - tRed1);
			//pCd.coord.tmax -= (tRed2 - tRed1);
			draw.isSameDataDisplay = (draw.mode==0 && !isFloatEqual(draw.gDC_vred, 0.0f))  ?  TRUE  :  FALSE;
			isChanged = true;
		}


		if (isChanged) {
			draw.isNodeChanged = TRUE;
			UpdateAllViews(NULL);
			NotifyChanged();
		}
	}

	BOOL CSeisWideDoc::setGainCorr(segy *tr, int dformat, int tpp)
	{
		return setGainCorr(tr, dformat, tpp, para.sphericOrder, 
			para.attenuationCorr, para.attenuationSeafloor);
	}

	BOOL CSeisWideDoc::setGainCorr(segy *tr, int dformat, int tpp, float sphericOrder, 
		float attenuationCorr, float attenuationSeafloor)
	{
		//Correct for amptitude of spherical correction, and attenuation
		// will use global varioables:  
		//  numsamp, tpp, pCd.coord.tmin, pCd.coord.tmax

		// 		BOOL isTrue = setGainCorr(&tr, dformat);

		if(sphericOrder <= 0.f && attenuationCorr <= 0.f) return TRUE;  // no need to correct anything, normal.

		if (dformat != 1) {
			myCaption(_T("Sorry, spherical correction is only for float data."));
			return FALSE;
		}

		int i;
		double t, tbs;
		float b;

		double attenuation = pow(10., attenuationCorr/20.);
		float tShift = getTraceDelay(tr);
		double tppSEC = (double) tpp/(double)MIL;
		int numsamp = tr->ns;

		for (i=0; i<numsamp; i++) {
			t = tShift + i*tppSEC; // t now the absolute time in sec
			if(sphericOrder > 0.f) {
				b = (float)pow(t,(double)sphericOrder) + 1.f;
				tr->dat.data[i] *= b;
			} // if para.spherical

			if(attenuationCorr > 0.f) {	//apply trace attenuation correction. If para.attenuationCorr==0., the gain should be 1.0
				tbs = t - attenuationSeafloor;  // tbs is now the time in sec below the seafloor
				if (tbs > 0.f) {
					b = (float)(pow(attenuation, tbs));
					tr->dat.data[i] *= b;
				} // if tbs
			} // if para.attenuan
		} // for i

		// final auto gains down by 1000 since the overal amp can be too high 
		float norm = 0.001f;
		for (i=0; i<numsamp; i++) {
			tr->dat.data[i] *= norm;
		}

		return TRUE;
	}

	void CSeisWideDoc::OnModelingTogglepeglet()
	{
		if ( !isTimeDomain() ) {
			if (draw.iModelPeglet == draw.iLayerFocus) {
				// this means that the model peglet has been activated
				draw.iModelPeglet = -1;
			}
			else {
				draw.iModelPeglet = draw.iLayerFocus;
			}
			UpdateAllViews(NULL);
		}
	}


	void CSeisWideDoc::OnModelingTheoreticalcurves()
	{
		draw.isShowTheoryModel = !draw.isShowTheoryModel;

		if (draw.isShowTheoryModel) {
			CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
			if (!pFrame) return;
			CdlgRegionalModel dlg;
			dlg.m_regionalModelA = pFrame->psei->regionalModelA;
			dlg.m_regionalModelB = pFrame->psei->regionalModelB;
			dlg.m_regionalModelAlpha = pFrame->psei->regionalModelAlpha;
			//dlg.m_regionalModelBeta = pFrame->psei->regionalModelV0;
			if (dlg.DoModal()) {
				pFrame->psei->regionalModelA = dlg.m_regionalModelA;
				pFrame->psei->regionalModelB = dlg.m_regionalModelB;
				pFrame->psei->regionalModelAlpha = dlg.m_regionalModelAlpha;
				//pFrame->psei->regionalModelBeta = dlg.m_regionalModelBeta;
			}
		}

		UpdateAllViews(NULL);
	}


	void CSeisWideDoc::myUpdatePrevFrame(void)
	{
		CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
		if (!pFrame) return;
		if (pFrame->pViewPrev != NULL && pFrame->pViewCurr != pFrame->pViewPrev) {
			TRY {
				pFrame->pViewPrev->Invalidate();
				// pFrame->pDocPrev->UpdateAllViews(NULL);
			} // TRY 
			CATCH_ALL(e)
			{
				// it's ok to be here
			}
			END_CATCH_ALL
				//AfxMessageBox( ((CSeisWideDoc *)pFrame->pDocPrev)->GetTitle() + _T(" was also updated.");
		}
	}

	int CSeisWideDoc::myUpdateAllFramesExcept(CDocument *aDoc)
	{
		CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
		if (!pFrame) return 0;
		int count = 0;
		CMDIChildWnd* pChild = pFrame->GetNextMDIChildWnd();
		while (pChild)
		{
			if (pChild->GetActiveDocument() != this) {
				count++;
				pChild->GetActiveView()->Invalidate(FALSE);
			}
			pChild = pFrame->GetNextMDIChildWnd();
		}
		return count;
	}


	void CSeisWideDoc::OnModelingToggleswavelabels()
	{
		if ( !isTimeDomain() ) {
			CMainFrame* pFrame = 
				(CMainFrame*)AfxGetMainWnd();
			ASSERT(pFrame);
			ASSERT_KINDOF(CMainFrame, pFrame);


			if (pFrame->gDisplayVsModel < 1) 
				pFrame->gDisplayVsModel = 1;
			else
				pFrame->gDisplayVsModel = 0;
			UpdateAllViews(NULL);
		}
	}

	void CSeisWideDoc::OnProcessingDatasplit()
	{
		if(AfxMessageBox(_T("This will split an on screen segy file into two based on a given trace number. Any trace having this or larger trace number will appear in the second file. Continue?"), MB_YESNO |MB_ICONINFORMATION) != IDYES) {
			return;
		}

		if (! isFileExistNotDirectory(draw.timeSecName) ) {
			myCaption(_T("Please display a valid segy file to split."));
			return;
		}

		static float xSplit=0.f;
		CdlgInputValie dlg;
		dlg.m_value = xSplit;
		if (dlg.DoModal() == IDOK) 
		{
			xSplit = dlg.m_value;
		}
		else return;
		delete dlg;

		CFile file;
		if (!file.Open(draw.timeSecName, CFile::modeRead | CFile::typeBinary)) {
			return;
		}
		ULONGLONG bytesRead = file.Read(head.ascHead, 3200L);
		if(bytesRead < 3200) 
		{
			file.Close();
			AfxMessageBox(_T("Ascii section header read wrong"));
			return;
		}
		bhed bh;
		bytesRead = file.Read(&bh, 400);
		BOOL isUnix = false;
		CString tStr;
		if (isUnix = IsUnix(bh.format)) {
			file.Close();
			tStr.Format(_T("Sorry, please convert to PC format (small-endian) before continue."));
			AfxMessageBox(tStr);
			return;
		}



		if(bytesRead < 400) 
		{
			file.Close();
			AfxMessageBox(_T("Binary section header read wrong"));
			return;
		}
		int numsamp = bh.hns;
		int format = bh.format;
		int len = (bh.format != 3) ? numsamp*4 + 240   :   numsamp*2 + 240;
		int tpp = bh.hdt;

		CFile filez;
		CString outFile = getFileNameAppend(draw.timeSecName, _T("_split1"));
		if (!filez.Open(outFile, CFile::modeWrite|CFile::modeCreate|CFile::typeBinary)) {
			file.Close();
			return;
		}
		filez.Write(head.ascHead, 3200L);
		filez.Write(&bh, 400);

		CString outFile2 = getFileNameAppend(draw.timeSecName, _T("_split2"));
		CFile filez2;
		if (!filez2.Open(outFile2, CFile::modeWrite|CFile::modeCreate|CFile::typeBinary)) {
			file.Close();
			filez.Close();
			return;
		}
		filez2.Write(head.ascHead, 3200L);
		filez2.Write(&bh, 400);

		segy tr;
		int atrc;
		int count1 = 0;
		int count2 = 0;
		// NOTE: here in reading/writing, we do not convert between IBM and IEEE float at all, since no processing involved.
		while (file.Read(&tr, len) == (UINT)len)
		{
			atrc = tr.tracl;
			if (atrc < xSplit) {
				filez.Write(&tr, len);
				count1++;
			}
			else {
				filez2.Write(&tr, len);
				count2++;
			}
		} //end of while loop.


		if (count1 > 0)
			setSegyTotalTrace(&filez, (unsigned short)count1);
		if (count2 > 0)
			setSegyTotalTrace(&filez, (unsigned short)count2);

		file.Close();
		filez.Close();
		filez2.Close();
		AfxMessageBox(_T("Finished segy file split. Please check files: ") + outFile + _T(" and ") + outFile2);
	}

	void CSeisWideDoc::OnProcessingIdProcessingTracedub()
	{
		CString t;
		if (!isTimeDomain()  ||  !isFileExistNotDirectory(draw.timeSecName) )  {
			t.Format(_T("To double the trace length, please show a segy file in time domain first."));
			AfxMessageBox(t);
			return;
		}
		t.Format(_T("Here, the program will double the trace length for sonobuoy data, based on the information of time in the header. The results will be invalid when an invalid firing rate used.  Continue?"));
		if( AfxMessageBox(t, MB_YESNO |MB_ICONINFORMATION) == IDNO) {
			return;
		}

		// here, the program will double the trace length for sonobuoy data, based on the information of time in the header
		bool isFiringRateManual = false;

		static float aFireRate1 = 20.f;
		static float aFireRate2 = 0.f;
		static int   aTraceSplit = 0;

		isFiringRateManual = false;  // auto firing rate is disabled for now.

		//t.Format(_T("Do you want to manually set a firing rate (in sec) ? If not sure, click No to automatically calculate firing rate.");
		//if (AfxMessageBox(t, MB_YESNO |MB_ICONINFORMATION) == IDYES) {
		isFiringRateManual = true;

		CdlgTraceDub dlg;
		dlg.m_fireRate1 = aFireRate1;
		dlg.m_fireRate2 = aFireRate2;
		dlg.m_traceSplit = aTraceSplit;
		if (dlg.DoModal() == IDOK) 
		{
			aFireRate1 = dlg.m_fireRate1;
			aFireRate2 = dlg.m_fireRate2;
			aTraceSplit = dlg.m_traceSplit;
		}
		else return;
		delete dlg;

		if (aFireRate1<= 0.f) {
			t.Format(_T("To double the trace length, a valid firing rate is needed."));
			AfxMessageBox(t);
			return;
		}
		//}

		bhed bh;
		segy tr, tr2;
		BOOL isUnix = false;
		char ascHead[3200];


		CFile file;
		if (!file.Open(draw.timeSecName, CFile::modeRead | CFile::typeBinary)) {
			return;
		}

		LONGLONG bytesRead = file.Read(&ascHead, 3200);
		if(bytesRead < 3200) 
		{
			file.Close();
			t.Format(_T("Ascii section header read wrong."));
			AfxMessageBox(t);
			return;
		}

		bytesRead = file.Read(&bh, 400);
		if(bytesRead < 400) 
		{
			file.Close();
			t.Format(_T("Binary section header read wrong."));
			AfxMessageBox(t);
			return;
		}

		//if (bh.format != 1 ) {
		//	file.Close();
		//	t.Format(_T("Sorry, this routine only works for float data. You may convert to float by using 'Data Reduction and Filter'");
		//	AfxMessageBox(t);
		//	return;
		//}

		if (isUnix = IsUnix(bh.format)) {
			file.Close();
			t.Format(_T("Sorry, please convert to PC format (small-endian) before continue."));
			AfxMessageBox(t);
			return;
		}

		int numSamp1 = bh.hns;
		int len1 = (bh.format==3) ? (2*bh.hns) + 240 :  4*bh.hns + 240;

		int i;
		int k;
		double firingRateSecOld = 0.;
		double firingRateSec = 0.;
		double dt = (double)bh.hdt / (double)MIL;
		double odt = 1. / dt;

		// we double the trace length
		if (aTraceSplit>0 && aFireRate2>0) {
			float aFireRateMax = max(aFireRate1, aFireRate2);
			bh.hns = (unsigned short)myRound(aFireRateMax*odt*2.0);
		}
		else {
			//bh.hns *= 2;
			bh.hns = (unsigned short)myRound(aFireRate1*odt*2.0);
		}


		int len2 = (bh.format==3) ? (2*bh.hns) + 240 :  4*bh.hns + 240;  // output trace length


		// write to the output file
		CString fname2 = getFileNameAppend(draw.timeSecName, _T("Dub"));
		CFile file2;
		if (!file2.Open(fname2, CFile::modeWrite|CFile::modeCreate|CFile::typeBinary)) {
			file.Close();
			t.Format(_T("Failed to open a file to write to."));
			AfxMessageBox(t);
			return;
		}

		file2.Write(&ascHead[0], 3200);
		file2.Write(&bh, 400);



		// NOTE: here in reading/writing, we do not convert between IBM and IEEE float at all, since no processing involved.
		while (file.Read(&tr, len1) == len1)
		{

			// now, we calculate offset between (obslong,obslat) and (gx,gy); assuming (gx,gy) already in long/lat degrees:
			double aitime=tr.day*24+tr.hour+tr.minute/60.0+(tr.sec + tr.timbas/1000.0)/3600.0;
			if (file.Read(&tr2, len1) == len1) {

				// this is a special case for SB18, 2008, where the firing rate changed along. Be sure to remove these lines after that!
				//if (tr.hour >= 10 && tr.minute == 25) {
				//	this->m_value = 19.505;
				//}
				if (isFiringRateManual) {
					if (aTraceSplit>0 && tr.tracl >= aTraceSplit && aFireRate2>0.f) {
						firingRateSec = aFireRate2;
					}
					else {
						// normally it should be this part working
						firingRateSec = aFireRate1;
					}
				}
				else {
					double aitime2=tr2.day*24+tr2.hour+tr2.minute/60.0+(tr2.sec + tr2.timbas/1000.0)/3600.0;
					firingRateSec = (aitime2 - aitime)*3600.;
					if (firingRateSecOld>0. && fabs(firingRateSecOld-firingRateSec) > 0.4) {
						file.Close();
						file2.Close();
						t.Format(_T("firingRateSecOld-firingRateSec= %f . Firing rate seems to fluctuate too much. You may try manually set the firing rate."), firingRateSecOld-firingRateSec);
						AfxMessageBox(t);
						return;
					}
					firingRateSecOld = firingRateSec;
				}

				int iDubStart = (int)myRound( (firingRateSec + getTraceDelay(&tr))*odt); // this is the start of the appended trace length
				memset((void *) &tr.dat.data[numSamp1], (int) '\0', (len2 - len1) ); //   len1---> numSamp1;  len2---> numSamp1*2
				if(bh.format == 1 || bh.format==5 )
				{	
					// float data
					for (i=0; i<numSamp1; i++) {
						k = i+iDubStart;
						if (k >= 0 && k < bh.hns)
							tr.dat.data[k] = tr2.dat.data[i];
					} // for i
				}
				else if(bh.format == 2)
				{	
					// long data
					for (i=0; i<numSamp1; i++) {
						k = i+iDubStart;
						if (k >= 0 && k < bh.hns)
							tr.dat.dataint[k] = tr2.dat.dataint[i];
					}
				}
				else if(bh.format == 3)
				{	
					// short int data
					for (i=0; i<numSamp1; i++) {
						k = i+iDubStart;
						if (k >= 0 && k < bh.hns)
							tr.dat.datashort[k] = tr2.dat.datashort[i];
					}
				}

				file.Seek(-len1, CFile::current);  // point to the next trace
			}
			else {
				// if here, the next trace is not valid.   len1--->numSamp1;  len2--->numSamp1*2
				memset((void *) &tr.dat.data[numSamp1], (int) '\0', (len2 - len1) );
			}



			tr.ns = (unsigned short)(numSamp1*2);
			file2.Write(&tr, len2);
		}
		file.Close();
		file2.Close();

		t.Format(_T("Success in doubling the trace length in %s."), fname2);
		myCaption(t);
	}

	/*
	************* convert a big file from TWTT to depth using a polynomial function
	************* Need to consider: 
	*************
	*************
	*************
	*************
	*
	*
	*/
	void CSeisWideDoc::OnToolsMapconverttime()
	{
		//new file dialog.
		CFileDialog dlg( TRUE,_T("txt;lstpc"),_T("*.txt; *.lstpc"),
			OFN_HIDEREADONLY|OFN_ALLOWMULTISELECT|OFN_EXPLORER,
			_T("Input text File (*.txt;*.lstpc)|*.txt;*.lstpc|"));
		dlg.m_ofn.lpstrTitle = _T("Select all valid ascii files. lstpc format is a special CMP-TWTT format from John");
		TCHAR* buff=new TCHAR[65535];
		buff[0]='\0';
		dlg.m_ofn.lpstrFile=buff;
		dlg.m_ofn.nMaxFile = 99;//sizeof(buff);

		bool isJohnLstpc = false;
		CDigitize pDg;
		if(dlg.DoModal()==IDOK) {
			POSITION position=dlg.GetStartPosition();
			dig.digName = dlg.GetNextPathName(position);
			isJohnLstpc = GetFileExtension(dig.digName) == _T("lstpc");
			if (isJohnLstpc) {
				// in the case of .lstpc format, we need to make a new name for the digitizing format, with the same extension of .txt
				if( (AfxMessageBox(_T("lstpc format will compare the CMP of lstpc and current segy file to obtain distance info. If segy file does not match lstpc in CMP, it will result in wrong distance info. The processing can take minutes to finish. Continue?"), MB_YESNO |MB_ICONINFORMATION) != IDYES) )
					delete [] buff;
				return;

				CString fileSegy;
				if ( isFileExistNotDirectory(draw.timeSecName) )  {
					fileSegy = draw.timeSecName;
				}
				else {
					fileSegy = draw.depthSecName;
				}
				dig.digName	= GetFileNameAppendExt(fileSegy, _T("_lstTWTT"), _T("txt"));

				freeDigAll();
				position=dlg.GetStartPosition();
				while(position)
				{
					CString lstFile = dlg.GetNextPathName(position);
					if (!MyLoadDistTwttDrawings4John(fileSegy, lstFile, dig.digName)) {
						// when it fails, we do not want any digitized points, and return
						dig.digName.Format(_T(""));
						delete [] buff;
						return;
					}
				} //end the while file POSITION loop.
				pDg.myDigSaveAs(&dig, FALSE, FALSE, tx.xShot); 
			} // if isJohnLstpc
		}
		else
		{
			return;
		}
		delete [] buff;
		delete dlg;




	}

	void CSeisWideDoc::OnProcessingSphericalcorrection()
	{
		CString outFile=_T("");
		CString tempStr = draw.timeSecName;
		tempStr.MakeLower();
		if(tempStr.Right(4) == _T(".sgy"))
			outFile = getFileNameAppend(draw.timeSecName, _T("Spher"));
		else
			outFile = draw.timeSecName + _T("Spher.sgy");


		CdlgAttenuationCorr dlg;
		dlg.m_inFile = draw.timeSecName;
		dlg.m_outFile = outFile;
		dlg.m_sphericOrder = para.sphericOrder;
		dlg.m_attenuationCorr = para.attenuationCorr;
		dlg.m_attenuationSeafloor =	para.attenuationSeafloor;
		if (dlg.DoModal() == IDOK)
		{
			draw.timeSecName = dlg.m_inFile.Trim();
			outFile = dlg.m_outFile;
			para.sphericOrder = dlg.m_sphericOrder;
			para.attenuationCorr = dlg.m_attenuationCorr;
			para.attenuationSeafloor = dlg.m_attenuationSeafloor;
		}
		else 
		{
			return;
		}

		if (!isFileExistNotDirectory(draw.timeSecName)) return;
		if(outFile==_T("")) return;
		if(outFile == draw.timeSecName)
		{
			AfxMessageBox(_T("Output file name is the same as the input file name!"));
			return;
		}


		outFile = mySetFileExtension(outFile, _T("sgy"));

		//put the path onto file2 if it doesn't have it.
		int pathLen = outFile.ReverseFind( '\\' );
		if(pathLen==(-1))
		{
			TCHAR curDir[_MAX_PATH];
			GetCurrentDirectory(_MAX_PATH, curDir);
			outFile.Format(_T("%s\\%s"), (CString)curDir, outFile);
		}

		CFile file;
		if (!file.Open(draw.timeSecName, CFile::modeRead | CFile::typeBinary)) {
			return;
		}



		segy tr, tr2;
		bhed bh;
		int i;

		//For progress control, need to know the last bytes no.
		ULONGLONG curBytesRead, totBytesRead = file.GetLength();
		file.Seek(0, CFile::begin);
		//Begin progress control.
		CMainFrame* pFrame = 
			(CMainFrame*)AfxGetMainWnd();
		ASSERT(pFrame);
		ASSERT_KINDOF(CMainFrame, pFrame);
		pFrame->BeginProgress();


		UINT bytesRead = file.Read(head.ascHead, 3200L);
		if(bytesRead < 3200) 
			AfxMessageBox(_T("Ascii section header read wrong"));
		bytesRead=file.Read(&bh, 400L);
		if(bytesRead < 400) 
			AfxMessageBox(_T("Binary section header read wrong"));

		if(bh.format<1 || bh.format>3 )
		{
			AfxMessageBox(_T("Data is Fixed Point w/ Gain Code, not supported, or unknown format."));
			if (file) file.Close();
			return;
		}
		int numsamp = bh.hns; // (unsigned short)i2buf[10];
		int len;
		if(bh.format !=3)  
		{
			len = numsamp*4 + 240;
		}
		else 
		{
			len = numsamp*2 + 240;
		}


		CFile file2;
		if (!file2.Open(outFile, CFile::modeWrite|CFile::modeCreate|CFile::typeBinary)) {
			file.Close();
			return;
		}
		file2.Write(head.ascHead, 3200L); 
		int formatInput = bh.format;
		bh.format = 1;  // always output in floating format
		bh.format = pFrame->gIsIBMFloatSegy2  ?  1  :  5; // only floating is adopted for output
		file2.Write(&bh, 400L); 

		ULONGLONG byteFileEnd = file.SeekToEnd();
		file.Seek(3600L, CFile::begin);


		double aratio = (double) bh.hdt /(double)MIL;
		while (file.Read(&tr, len) == (UINT)len)
		{
			memcpy( (void *) &tr2, (const void *) &tr, 240);
			if(formatInput == 1 ) {	
				// float data
				ibm_to_float((int *) tr.dat.data, (int *) tr.dat.data, (int)numsamp);
				for (i=0; i<numsamp; i++) {
					tr2.dat.data[i]=(float)(tr.dat.data[i]); 
				}
			} else if(formatInput  == 2) {
				for (i=0; i<numsamp; i++)
				{
					tr2.dat.data[i] = (float)(tr.dat.dataint[i]);
				}
			} else if(formatInput  == 3) {	
				// short int data
				for (i=0; i<numsamp; i++)
				{					 
					tr2.dat.data[i]=(float)(tr.dat.datashort[i]); 
				}
			}
			else if(formatInput == 5 ) {	
				// float data
				for (i=0; i<numsamp; i++) {
					tr2.dat.data[i]=(float)(tr.dat.data[i]); 
				}
			}


			BOOL isTrue = setGainCorr(&tr2, bh.format, bh.hdt, para.sphericOrder, para.attenuationCorr, para.attenuationSeafloor);
			// note: here we should use bh.format instead of formatInput since tr2 is already floating point

			if (bh.format == 1 ) {
				float_to_ibm((int *) tr2.dat.data, (int *) tr2.dat.data, (int)numsamp);
			}
			file2.Write(&tr2, numsamp*4 + 240);

			// progress control. Do not change
			curBytesRead = file.Seek(0, CFile::current);
			int iPos = (int)((double)curBytesRead/(double)totBytesRead*100.);
			if(iPos<0)iPos=0;
			if(iPos>100)iPos=100;
			pFrame->SetProgress(iPos);
		}	// while


		if (file) file.Close();
		if (file2) file2.Close();
		if (pFrame) { 
			pFrame->EndProgress();
		}

		// now finished work. Clean up
		draw.timeSecName = outFile;

		// now we do not want the spherical corr for this file
		para.sphericOrder = 0.f;
		para.attenuationCorr = 0.f;


		SetModifiedFlag();
		UpdateAllViews(NULL);
		NotifyChanged();
	}




	void CSeisWideDoc::OnProcessingAdddata()
	{
		// Add amplitude from Primary and secondary segy files, output to a third file
		// with an option of static shift and amplitude scaling for the second file
		CString str;
		CString inFile2 = _T("");
		static CString outFile = _T("");
		static float timeShift = 0.f;
		static BOOL isAmpAuto = FALSE;

		CdlgAddData dlg;
		dlg.m_timeSecName = draw.timeSecName;
		dlg.m_timeSecName2 = _T("");
		dlg.m_outputSecName = getFileNameAppend(draw.timeSecName, _T("_Add"));
		dlg.m_shift = timeShift;
		dlg.m_isAutoScaling = isAmpAuto;
		if (dlg.DoModal() == IDOK)
		{
			draw.timeSecName = dlg.m_timeSecName.Trim();
			inFile2 = dlg.m_timeSecName2;
			outFile = dlg.m_outputSecName.Trim();
			timeShift = dlg.m_shift;
			isAmpAuto = dlg.m_isAutoScaling;
		}
		else 
		{
			return;
		}

		if (!isFileExistNotDirectory(draw.timeSecName) || !isFileExistNotDirectory(inFile2)) {
			str.Format(_T("An input segy file is invalid!") );
			AfxMessageBox(str);
			return;
		}
		if ( outFile.IsEmpty() || outFile == draw.timeSecName) {
			outFile = getFileNameAppend(draw.timeSecName, _T("_Add"));
		}

		// now start
		CFile file;
		if (!file.Open(draw.timeSecName, CFile::modeRead | CFile::typeBinary)) {
			return;
		}
		CFile file2;
		if (!file2.Open(inFile2, CFile::modeRead | CFile::typeBinary)) {
			file.Close();
			return;
		}
		CFile fileOut;
		if (!fileOut.Open(outFile, CFile::modeCreate  |CFile::modeWrite | CFile::typeBinary)) {
			file.Close();
			file2.Close();
			return;
		}

		bhed bh, bh2;
		file.Read(head.ascHead, 3200L);
		file.Read(&bh, 400L);
		file2.Read(head.ascHead, 3200L);
		file2.Read(&bh2, 400L);
		file.Close();
		file2.Close();

		if (bh.hdt != bh2.hdt )
		{
			str.Format(_T("Sample rate in 2nd file is %d, different from the 1st file which is %d"), bh2.hdt, bh.hdt);
			AfxMessageBox(str);
			return;
		}
		if(bh.format != bh2.format)  
		{
			str.Format(_T("Data format in 2nd file is different from the 1st file") );
			AfxMessageBox(str);
			return;
		}
		//if(bh.hns != bh2.hns) {
		//	str.Format(_T("Num of samples in 1st file is %d, different from %d the 2nd file."), bh.hns, bh2.hns );
		//	AfxMessageBox(str);
		//	return;
		//} // if

		CSegyMeta::segyHeadInit(draw.timeSecName, &head, 0);
		SegyWrapper sw(draw.timeSecName);
		CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
		bool isTrue = sw.openTrace(0, 99999, 1, 0, &head);


		HEAD head2;
		CSegyMeta::segyHeadInit(inFile2, &head2, 0);
		SegyWrapper sw2(inFile2);
		isTrue = sw2.openTrace(0, 99999, 1, 0, &head2);
		CSegyMeta::segyHeadFree(&head2);  // head2 must be free-ed manually, but head should not free





		// now do the addition
		fileOut.Write(sw.ascHead, 3200L);
		int formatIn = sw.bh.format;
		sw.bh.format = pFrame->gIsIBMFloatSegy2  ?  1  :  5; // only floating is adopted for output
		fileOut.Write(&sw.bh, 400);
		// segy tr;

		float deltaxAllowed = 0.0125f;  // manual input this
		for (int nxStore=0; nxStore < sw.nxmax; nxStore++) {
			// memcpy((void *)&tr, (void *)&sw.trArr[nxStore], 240L);
			float dist = getDistance(&sw.trArr[nxStore]);

			float dist2;
			float deltax;
			float  deltaxLast;
			double amp2;
			int indSelected;
			deltaxLast = 99999.f;
			indSelected = -1;
			int jj;

			for (int nx2 = 0; nx2<sw2.nxmax; nx2++) {
				dist2 = getDistance(&sw2.trArr[nx2]);
				deltax = fabs(dist2 - dist);
				if (deltax > deltaxAllowed) continue;
				if (deltax < deltaxLast) {
					deltax = deltaxLast;
					indSelected = nx2;
				}
			} // for nx2
			if (indSelected >= 0) {
				// now we found a trace to add to the current trace
				double aMedian2 = getMedianAbsolute(&sw2.trArr[indSelected].data[0], sw2.bh.hns);
				if (aMedian2 > MINAMP) {
					double ratio = 1.;
					if (isAmpAuto) {
						double aMedian = getMedianAbsolute(&sw.trArr[nxStore].data[0], sw.bh.hns);
						ratio = aMedian / aMedian2;
					} else {
						// do nothing
					}

					// we assume the same samprate for each file. If not the same rate, we cannot use a single jShift for each trace to be added
					float tDelay = getTraceDelay(&sw.trArr[nxStore]);
					float tDelay2 = getTraceDelay(&sw2.trArr[indSelected]);
					int jShift = (int)myRound( (tDelay - tDelay2 - timeShift) / (double)sw.bh.hdt * (double) MIL);


					for (int j=0; j<sw.bh.hns; j++) {
						jj = j + jShift;
						if (jj >= 0 && jj< sw2.bh.hns) {
							amp2 = sw2.trArr[indSelected].data[jj] * ratio;
							sw.trArr[nxStore].data[j] += (float)(amp2);
							sw.trArr[nxStore].data[j] *= 0.5f;
						} // if jj
					} // for j
				} // else
			} // if

			if ( sw.bh.format==1 ) {
				float_to_ibm((int *) &sw.trArr[nxStore].data[0], (int *) &sw.trArr[nxStore].data[0], (int)sw.bh.hns);
			}

			// it seems we cannot write the 2 items together? Maybe problems 
			fileOut.Write(&sw.trArr[nxStore], 240 );
			fileOut.Write(&sw.trArr[nxStore].data[0], sw.bh.hns * sizeof(float) );
			if (nxStore / 10 * 10 == nxStore) fileOut.Flush();

			str.Format(_T("T%d."), nxStore);
			myCaption(str);
		} // for nxStore









		fileOut.Close();
		myCaption(_T("success in adding segy data."));
		draw.timeSecName = outFile;
		OnToolbarRefreshAll();
	}


	void CSeisWideDoc::OnTimeRmsvelocityanalysis()
	{
		if(!CheckTime(100))
		{
			return;
		}

		//static float stackWidth = 2.0f;
		//static float stackWidth2 = 3.0f;

		static int dtratio = 5;
		static float dv_out = 0.05f;
		static float secsmooth = 0.1f;
		static float percMute = 0.9f; 
		static BOOL isNmoPanels = FALSE;
		static BOOL isNorm = FALSE;
		static float xmax = 0.f;
		static float vmax = 4.5f;
		static float pwr = 1.5f;      /* power of semblance */
		CString outfile;
		CString tstr;

		dlgRmsVelocityAnalysis dlg;
		dlg.m_timeSecName = draw.timeSecName;
		dlg.m_outfile = getFileNameSubdir(draw.timeSecName, _T("rms"), _T("RmsVelocity.sgy"), true);
		dlg.m_velSecName = velMod.velSecName;
		dlg.m_dtRatio = dtratio;
		dlg.m_tmax = (float)pCd.coord.tmax;
		dlg.m_tmin = (float)pCd.coord.tmin;
		dlg.m_vmin = 1.4f;
		dlg.m_vmax = vmax; // usually bigger velocity is not needed for rms
		dlg.m_dv = dv_out;
		dlg.m_xmax = xmax;
		dlg.m_secsmooth = secsmooth;
		dlg.m_percMute = percMute;
		dlg.m_isNmoPanels = isNmoPanels;
		dlg.m_isNorm = isNorm;
		dlg.m_pwr = pwr;

		if (dlg.DoModal() == IDOK)
		{
			draw.timeSecName = dlg.m_timeSecName.Trim();
			outfile = dlg.m_outfile;
			velMod.velSecName = dlg.m_velSecName.Trim();
			dtratio = dlg.m_dtRatio;
			pCd.coord.tmin = dlg.m_tmin;
			pCd.coord.tmax = dlg.m_tmax;
			vmax = dlg.m_vmax;
			vel.vmin = dlg.m_vmin;
			dv_out = dlg.m_dv;
			xmax = dlg.m_xmax;
			secsmooth = dlg.m_secsmooth;
			percMute = dlg.m_percMute;
			isNmoPanels = dlg.m_isNmoPanels;
			isNorm = dlg.m_isNorm;
			pwr = dlg.m_pwr;
		}
		else 
		{
			return;
		}
		if (!isFileExistNotDirectory(draw.timeSecName)) return;
		delete dlg;
		if(outfile.IsEmpty()) return;
		CFile fileout;
		if (!fileout.Open(outfile, CFile::modeCreate  |CFile::modeWrite | CFile::typeBinary)) {
			tstr.Format(_T("Outfile cannot be created"));
			AfxMessageBox(tstr);
			return;
		}
		CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();

		tstr.Format(_T("Loading data..."));
		myCaption(tstr);
		SegyWrapper sw(draw.timeSecName);
		if (CSegyMeta::segyHeadInit(draw.timeSecName, &head, 0) != 1) return;
		//sw.m_tminFile = head.tminFile;
		//sw.m_tmaxFile = head.tmaxFile;
		if (!sw.open(&head, 0)) {
			fileout.Close();
			tstr.Format(_T("Input file cannot be opened properly."));
			AfxMessageBox(tstr);
			return;
		}

		setXShotAll();

		int tpp = sw.bh.hdt; // input samp rate
		int numsamp = sw.bh.hns;

		double dt = ((double)tpp / (double)MIL);
		double odt = (double) (MIL/(double)tpp);
		int nsmooth = (int)myRound(secsmooth * odt);
		if ((int)(nsmooth/2) == nsmooth*2) nsmooth++;  // we want odd numbers for nsmooth
		segy tr;
		bhed bhout;
		fileout.Write(sw.ascHead, 3200L);
		memcpy((void *)&bhout, (void *)&sw.bh, 240L);
		double dt_out = dt*dtratio;
		int nsout = bhout.hns = (unsigned short)myRound ( (pCd.coord.tmax - pCd.coord.tmin) / dt_out );
		bhout.hdt = (unsigned short)myRound(dt_out * MIL);
		bhout.hns = (unsigned short)nsout;
		//	bhout.format = 1; // only floating is adopted for output
		bhout.format = pFrame->gIsIBMFloatSegy2  ?  1  :  5; // only floating is adopted for output
		bhout.ntrpr = (unsigned short)myRound ( (vmax - vel.vmin) / dv_out );
		fileout.Write(&bhout, 400);

		segydynamic tTrc;
		tTrc.data = (float *)malloc(sizeof(float)*nsout);
		segydynamic ampTrc;
		ampTrc.data = (float *)malloc(sizeof(float)*nsout);

		int iv;
		int it0;
		float t0; // intercept time
		float x, v, t;
		int countTrc = 1;
		int nxStore; // for loop index

		float *numi = ealloc1float(nsmooth); // semblence nominator
		float *deno = ealloc1float(nsmooth); // semblence denominator
		float *nnz = ealloc1float(nsmooth);  // counting non-zero samples.
		float *amp = ealloc1float(nsmooth);
		float *timew = ealloc1float(nsmooth); // at each iz and ix, we produce a time window timew[] for velocity analysis
		//	int nsmoothHalf = (int)(nsmooth*0.5);


		for (iv=0; iv<bhout.ntrpr ; iv++) {
			// perform NMO for v
			v = (float)(vel.vmin + iv * dv_out);
			memset((void *)&ampTrc.data[0], (int)'\0', sizeof(float)*nsout);
			double oneov2 = 1. / (v*v);

			if (isNmoPanels) {
				for (nxStore=0; nxStore < sw.nxmax; nxStore++) {
					x = getOffset(&sw.trArr[nxStore]);
					if (xmax>0.00001f && fabs(x)>xmax) continue;
					for (it0=0; it0<nsout; it0++) {
						tTrc.data[it0] = -1.f; // this is to initilize
						t0 = (float)(pCd.coord.tmin + it0 * dt_out);
						// muting
						t = (float)sqrt(t0*t0 + x*x*oneov2);
						if (t0 > 0.00001f && (t-t0)/t0 > percMute) {
							// need to mute this sample for rms velocity calc
							continue;
						}
						tTrc.data[it0] = t;
					} // for it0

					ints8r((int)numsamp, // ntin
						(float)dt,   // dtin
						getTraceDelay(&sw.trArr[nxStore]),   // ftin
						&sw.trArr[nxStore].data[0], // yin[t=ntin], with yin[0] = y(fxin)
						0.f,  // yinl    value used to extrapolate yin values to left of yin[0]
						0.f,  // yinr	 value used to extrapolate yin values to right of yin[ntin-1]
						nsout,   // nxout
						(float *)&tTrc.data[0],  // ntout
						(float *)&ampTrc.data[0]);    // tout
					memcpy((void *)&tr, (void *)&sw.trArr[nxStore], 240L);
					tr.tracl = countTrc;
					// tr.cdp = countStack;
					tr.cdpt = 1;
					tr.ns = (unsigned short)nsout;
					tr.dt = (unsigned short)myRound(dt_out*MIL);
					setTraceDelayF(&tr, pCd.coord.tmin);

					if ( bhout.format==1 ) {
						float_to_ibm((int *) &ampTrc.data[0], (int *) &ampTrc.data[0], (int)nsout);
					}

					fileout.Write(&tr, 240);
					fileout.Write(&ampTrc.data[0], nsout*sizeof(float));
					countTrc++;
				} // for nxStore
			} // if isNmoPanels
			else {
				/*
				" Semblance is defined by the following quotient:			",
				"									",
				"		 n-1		 					",
				"		[ sum q(t,j) ]^2					",
				"		 j=0		 					",
				"	s(t) = ------------------					",
				"		 n-1		 					",
				"		n sum [q(t,j)]^2					",
				"		 j=0		 					",
				"									",
				" where n is the number of non-zero samples after muting.		",
				" Smoothing (nsmooth) is applied separately to the numerator and denominator",
				" before computing this semblance quotient.				",
				*/
				//################################ semblance ############################
				//########################################################################
				for (it0=0; it0<nsout; it0++) {
					//tTrc.data[it0] = -1.f; // this is to initilize
					t0 = (float)(pCd.coord.tmin + it0 * dt_out);
					memset((void *)numi, (int) '\0', sizeof(float)*nsmooth);
					memset((void *)deno,(int) '\0', sizeof(float)*nsmooth);
					memset((void *)nnz, (int) '\0', sizeof(float)*nsmooth);
					for (nxStore=0; nxStore < sw.nxmax; nxStore++) {

						//trArr[nxStore].data[it0] = 0.f; // test line

						x = getOffset(&sw.trArr[nxStore]);
						if (xmax>0.00001f && fabs(x)>xmax) continue;
						// muting
						t = (float)sqrt(t0*t0 + x*x*oneov2);
						if (t0 > 0.00001f && (t-t0)/t0 > percMute) {
							// need to mute this sample for rms velocity calc
							continue;
						}

						// start interpolation of trace data for the time window (length nsmooth) around t
						for (int iw=0; iw<nsmooth; iw++) {
							//	timew[iw] = (float)( t - dt*(nsmoothHalf-iw) );
							timew[iw] = (float)( t + dt*iw );
						}
						ints8r((int)numsamp, // ntin
							(float)dt,   // dtin
							getTraceDelay(&sw.trArr[nxStore]),   // ftin
							&sw.trArr[nxStore].data[0], // yin[t=ntin], with yin[0] = y(fxin)
							0.f,  // yinl    value used to extrapolate yin values to left of yin[0]
							0.f,  // yinr	 value used to extrapolate yin values to right of yin[ntin-1]
							nsmooth,   // nxout
							(float *)&timew[0],  // ntout
							(float *)&amp[0]);    // tout
						if (isNorm) {
							// normalize before stacking
							float amax = (float)getMedianAbsolute(&amp[0], nsmooth);
							if (amax > MIL) {
								amax = 1.f / amax;
								for (int iw=0; iw<nsmooth; iw++) amp[iw] *= amax;
							}
						}

						for (int iw=0; iw<nsmooth; iw++) {
							if (fabs(amp[iw]) > MINAMP) {
								numi[iw] += (float)amp[iw];
								deno[iw] += (float)(amp[iw]*amp[iw]);
								nnz[iw] += 1.f;
							} // if
						} // for iw

						// test line
						//trArr[nxStore].data[it0] = amp[nsmoothHalf];

					} // for nxStore

					double nsum = 0.; // semblence numerator sum
					double dsum = 0.; // semblence denominator sum
					for (int iw=0; iw<nsmooth; iw++) {
						nsum += numi[iw] * numi[iw];
						// dsum += nnz[iw] * deno[iw];
						dsum += deno[iw];
					} // for iw
					double weight = getMedian3(&nnz[0], nsmooth);  // weight not tested !!!!!!!
					ampTrc.data[it0] = (dsum>MINAMP) ? (float)(nsum / dsum * weight)  :   0.0f;

					if (pwr != 1.0) {
						ampTrc.data[it0] = pow (ampTrc.data[it0], pwr);
					};

				} // for t0
				//################################ end semblence ########################
				//########################################################################
				memcpy((void *)&tr, (void *)&sw.trArr[0], 240L);
				tr.cdp = iv;
				tr.cdpt = 1;
				tr.ns = (unsigned short)nsout;
				tr.dt = (unsigned short)dt_out;
				setTraceDelayF(&tr,  pCd.coord.tmin);
				setDistance(&tr, v);
				setOffset(&tr, 0.f); // zero offset in output

				tr.tracl = countTrc;  countTrc++;
				if ( bhout.format==1 ) {
					float_to_ibm((int *) &ampTrc.data[0], (int *) &ampTrc.data[0], (int)tr.ns);
				}
				fileout.Write(&tr, 240);
				fileout.Write(&ampTrc.data[0], bhout.hns*sizeof(float));

				// testing
				//for (j=0; j<sw.nxmax; j++) {
				//	tr.tracl = countTrc;  countTrc++;
				//	if ( ((CMainFrame*)AfxGetMainWnd())->gIsIBMFloatSegy ) {
				//		tr.idistopt = 8;
				//		float_to_ibm((int *) &trArr[j].data[0], (int *) &trArr[j].data[0], (int)tr.ns);
				//	}
				//	fileout.Write(&tr, 240);
				//	fileout.Write(&trArr[j].data[0], bhout.hns*sizeof(float));
				//} // for j

			} // if semblence

			tstr.Format(_T("v%4.3f..."), v);
			myCaption(tstr);
		} // for iv

		free1float(numi);
		free1float(deno);
		free1float(nnz);
		free1float(amp);
		free1float(timew);

		draw.timeSecName = outfile;
		if (isNmoPanels) {
			draw.modeOld = draw.mode;
			draw.mode = 6;	
			pCd.coord.xmin = 0;
			pCd.coord.xmax = countTrc;
			pCd.coord.xTick = countTrc / 10;
			pCd.coord.xTick = pCd.coord.xTick / 100 * 100;
			draw.strXLabelOverwrite = _T("NMO Panels");
		} 
		else {
			draw.modeOld = draw.mode;
			draw.mode = 10;	//show time section.
			pCd.coord.xmin = vel.vmin;
			pCd.coord.xmax = vmax;
			pCd.coord.xTick = 1;
			// draw.strXLabelOverwrite = _T("RMS Velocity (km/s)";
		}
		if (!isFileExistNotDirectory(ampColorDyn.colFileName))
			ampColorDyn.colFileName = GetPathFromFileSlash(draw.timeSecName) + _T("colPalette.txt");
		para.wiggle = 7;
		setSegyTotalTrace(&fileout, countTrc);

		//testing
		//for (j=0; j<sw.nxmax; j++) {
		//	free(trArr[j].data);
		//}
		//free(trArr);
		// end testing

		fileout.Close();

		free(ampTrc.data); 
		ampTrc.data = NULL;
		free(tTrc.data); 


		para.traveltime = FALSE;
		pCd.coord.vred = 0.;
		pCd.coord.tTick = 1;

		CVelMod vm;

		// now overlay with velocity model curve
		if (!isNmoPanels && isFileExistNotDirectory(velMod.velSecName)) {
			bool isSimple = false;
			CVelMod::VELMOD_X modX;
			modX.dist = tx.xShot;
			vm.initModX(&velMod, &modX, isTimeDomain() == TRUE, true, true, vel.dz);


			if (!isSimple) {
				int nzmaxModelAll = (int)(modX.depthMod[velMod.ncont - 1] / vel.dz + 2.0); // only plus 2 makes it complete
				float *twttTrc = (float *)malloc(sizeof(float)*nzmaxModelAll);
				float *VrmsTrc = (float *)malloc(sizeof(float)*nzmaxModelAll);
				vm.getVelocityRmsTrc(&modX, vel.dz, nzmaxModelAll, &twttTrc[0], &VrmsTrc[0]);
				freeDigAll();
				initDigitizeArray(nzmaxModelAll, 1);
				dig.isZeltFormat2 = FALSE;
				dig.totCurve = 1;
				dig.nPoint[0] = 0;
				for (int icont=0; icont<nzmaxModelAll; icont++) {
					int ip = dig.nPoint[0];
					dig.x[ip][0] = (float)VrmsTrc[icont];
					dig.t[ip][0] = (float)twttTrc[icont];
					dig.nPoint[0] ++;
				} // for icont
				free1float(twttTrc);
				free1float(VrmsTrc);
			}
			else {
				double *twttMod = (double *)malloc(sizeof(double)*velMod.ncont);
				float *VrmsTopMod = (float *)malloc(sizeof(float)*velMod.ncont);
				float *VrmsBotMod = (float *)malloc(sizeof(float)*velMod.ncont);
				vm.getVelocityRmsMod(&modX, vel.dz, x, twttMod, VrmsTopMod, VrmsBotMod);

				freeDigAll();
				initDigitizeArray(MOD_LAYER_MAX*2, 1);
				dig.isZeltFormat2 = FALSE;
				dig.totCurve = 1;
				dig.nPoint[0] = 0;

				for (int icont=0; icont<velMod.ncont-1; icont++) {
					int ip = dig.nPoint[0];
					dig.x[ip][0] = (float)VrmsTopMod[icont];
					dig.t[ip][0] = (float)twttMod[icont];
					if (twttMod[icont] < pCd.coord.tmax && twttMod[icont+1] > pCd.coord.tmax) {
						// we need to add a point at the axis 
						dig.x[ip+1][0] = (float)(VrmsTopMod[icont] + 
							(VrmsBotMod[icont]-VrmsTopMod[icont])/(twttMod[icont+1]-twttMod[icont])*(pCd.coord.tmax-twttMod[icont]) );
						dig.t[ip+1][0] = (float)pCd.coord.tmax;
						dig.t[ip+2][0] = (float)twttMod[icont+1];
						dig.x[ip+2][0] = (float)VrmsBotMod[icont];
						dig.nPoint[0] += 3;
					}
					else {
						dig.x[ip+1][0] = (float)VrmsBotMod[icont];
						dig.t[ip+1][0] = (float)twttMod[icont+1];
						dig.nPoint[0] += 2;
					}
				} // for icont

				free1double(twttMod);
				free1float(VrmsTopMod);
				free1float(VrmsBotMod);
			}




			dig.digName = draw.markerName = GetFileNameAppendExt(velMod.velSecName, _T("_rmsVelTwttNotAni"), _T("txt"));
			CDigitize pDg;
			pDg.myDigSaveAs(&dig, FALSE, FALSE, tx.xShot); 
			freeDigAll();  // must free the dig arrays
			draw.isDigitizing = FALSE;
			showFileInNotePad(dig.digName);
		} // if isNmoPanels

		draw.isSameDataDisplay = FALSE;
		SetModifiedFlag();
		UpdateAllViews(NULL);
		NotifyChanged();

	}



	void CSeisWideDoc::OnModelconversionRmsToIntNotUsingModel()
	{
		if (velMod.velSecName.IsEmpty()) return;

		//Open file dialog.
		CFileDialog dlg( TRUE,_T("txt"),_T("*.txt"),
			OFN_HIDEREADONLY|OFN_EXPLORER,
			_T("Input file for RMS velocity vs TWTT (*.txt)|*.txt|"));

		int pathLen = draw.vrmsTauName.ReverseFind( '\\' );
		CString t = draw.vrmsTauName.Left(pathLen);
		LPCTSTR lpszFileName = t.GetBufferSetLength(t.GetLength());
		if(pathLen>(-1))
		{
			dlg.m_ofn.lpstrInitialDir = lpszFileName;
		}

		if( dlg.DoModal()==IDOK )
		{
			draw.vrmsTauName = dlg.GetPathName();
		}
		else {
			t.ReleaseBuffer();
			return;
		}
		t.ReleaseBuffer();
		delete dlg;

		int tpp = 4000;  // will need to let user enter value



		CString tstr;
		CPoint p;
		float dt = (tpp<1 || tpp > 70000) ?  0.008f  :   (float)( (double)tpp / (double)MIL); 
		int j;

		// first need to determine the tmin and max
		CDigitize pDg;
		dig.digName = draw.vrmsTauName;
		if (!pDg.myDigitizingLoadTXTUnix2(&dig, FALSE, FALSE)) {
			tstr.Format(_T("Failed to load %s"), draw.vrmsTauName);
			myCaption(tstr);
			return;
		}
		float tmin = dig.t[0][0];
		float tmax = dig.t[ dig.nPoint[0]-1 ][0];
		int nt = (int)myRound( (tmax - tmin) / dt);

		float *tau = (float *)malloc(sizeof(float)*dig.nPoint[0]);
		float *vrms = (float *)malloc(sizeof(float)*dig.nPoint[0]);
		float *depthTrc = (float *)ealloc1float(nt);
		float *vint = (float *)malloc(sizeof(float)*nt);



		for (j = 0; j<dig.nPoint[0]; j++) {
			tau[j] = dig.t[j][0];
			vrms[j] = dig.x[j][0];
		} // for j
		CVelMod vm;
		vm.getVelocityIntFromRms(dig.nPoint[0], &tau[0], &vrms[0], nt, dt, (float)tmin, &vint[0]);
		free(tau);
		free(vrms);



		//double depth[MOD_LAYER_MAX],vTop[MOD_LAYER_MAX],vBot[MOD_LAYER_MAX];
		//getVZCurveAtDist(tx.xShotInSegy, &depth[0], &vTop[0], &vBot[0], true);
		//getDepthTrcAtTwttIntervals(velMod.ncont, (double *)&depth[0], (double *)&vTop[0], 
		//	(double *)&vBot[0], nt, (float)tmin, dt, depthTrc); 

		// we need to replace depthTrc[0:nt-1]  using  vint[0:nt-1]
		depthTrc[0] = vint[0] * tmin * 0.5f;
		for (j=1; j<nt; j++) {
			depthTrc[j] = depthTrc[j-1] + vint[j] * dt * 0.5f;
		}




		// now save to file
		freeDigAll();
		initDigitizeArray(nt, 1);
		dig.isZeltFormat2 = FALSE;
		dig.totCurve = 1;
		dig.nPoint[0] = 0;
		for (j=0; j<nt; j++) {
			int ip = dig.nPoint[0];
			dig.x[ip][0] = (float)vint[j];
			dig.t[ip][0] = (float)depthTrc[j];
			dig.nPoint[0]++;
		} // for j
		dig.digName = tstr = GetFileNameAppendExt(velMod.velSecName, _T("_intVel-DepthFromRmsNotUsingModel"), _T("txt"));
		pDg.myDigSaveAs(&dig, FALSE, FALSE, tx.xShot); 
		if (!isTimeDomain()) draw.vrmsTauName = tstr;

		free(vint);
		free1float(depthTrc);
		showFileInNotePad(draw.vrmsTauName);
	}



	void CSeisWideDoc::OnModelconversionRmsToIntUsingModel()
	{
		if (velMod.velSecName.IsEmpty()) return;

		//Open file dialog.
		CFileDialog dlg( TRUE,_T("txt"),_T("*.txt"),
			OFN_HIDEREADONLY|OFN_EXPLORER,
			_T("Input file for RMS velocity vs TWTT (*.txt)|*.txt|"));

		int pathLen = draw.vrmsTauName.ReverseFind( '\\' );
		CString t = draw.vrmsTauName.Left(pathLen);
		LPCTSTR lpszFileName = t.GetBufferSetLength(t.GetLength());
		if(pathLen>(-1))
		{
			dlg.m_ofn.lpstrInitialDir = lpszFileName;
		}

		if( dlg.DoModal()==IDOK )
		{
			draw.vrmsTauName = dlg.GetPathName();
		}
		else {
			t.ReleaseBuffer();
			return;
		}
		t.ReleaseBuffer();
		delete dlg;

		int tpp = 4000;  // will need to let user enter value



		CString tstr;
		CPoint p;
		float dt = (tpp<1 || tpp > 70000) ?  0.008f  :   (float)( (double)tpp / (double)MIL); 
		// this, in addition to tx.xShotInSegy, should be put input parameters
		int j;

		// first need to determine the tmin and max
		CDigitize pDg;
		dig.digName = draw.vrmsTauName;
		if (!pDg.myDigitizingLoadTXTUnix2(&dig, FALSE, FALSE)) {
			tstr.Format(_T("Failed to load %s"), draw.vrmsTauName);
			myCaption(tstr);
			return;
		}
		float tmin = dig.t[0][0];
		float tmax = dig.t[ dig.nPoint[0]-1 ][0];
		int nt = (int)myRound( (tmax - tmin) / dt);

		float *tau = (float *)malloc(sizeof(float)*dig.nPoint[0]);
		float *vrms = (float *)malloc(sizeof(float)*dig.nPoint[0]);
		float *depthTrc = (float *)ealloc1float(nt);
		float *vint = (float *)malloc(sizeof(float)*nt);

		//	double depth[MOD_LAYER_MAX],vTop[MOD_LAYER_MAX],vBot[MOD_LAYER_MAX];
		CVelMod vm;
		CVelMod::VELMOD_X modX;
		modX.dist = tx.xShot;
		vm.initModX(&velMod, &modX, isTimeDomain() == TRUE, true, true, vel.dz);
		// vm.getZtFromZmod(&modX, nt, tmin, dt, depthTrc);

		for (j = 0; j<dig.nPoint[0]; j++) {
			tau[j] = dig.t[j][0];
			vrms[j] = dig.x[j][0];
		} // for j
		vm.getVelocityIntFromRms(dig.nPoint[0], &tau[0], &vrms[0], nt, dt, (float)tmin, &vint[0]);
		free(tau);
		free(vrms);

		// now save to file
		freeDigAll();
		initDigitizeArray(nt, 1);
		dig.isZeltFormat2 = FALSE;
		dig.totCurve = 1;
		dig.nPoint[0] = 0;
		for (j=0; j<nt; j++) {
			int ip = dig.nPoint[0];
			dig.x[ip][0] = (float)vint[j];
			dig.t[ip][0] = (float)depthTrc[j];
			dig.nPoint[0]++;
		} // for j
		dig.digName = tstr = GetFileNameAppendExt(velMod.velSecName, _T("_intVel-DepthFromRmsUsingModel"), _T("txt"));
		pDg.myDigSaveAs(&dig, FALSE, FALSE, tx.xShot); 

		free(vint);
		free1float(depthTrc);
		showFileInNotePad(draw.vrmsTauName);
		if (!isTimeDomain()) draw.vrmsTauName = tstr;

	}


	void CSeisWideDoc::OnModelconversionRmsToIntTwtt()
	{
		CFileDialog dlg( TRUE,_T("txt"),_T("*.txt"),
			OFN_HIDEREADONLY|OFN_EXPLORER,
			_T("Input file for RMS velocity vs TWTT (*.txt)|*.txt|"));

		int pathLen = draw.vrmsTauName.ReverseFind( '\\' );
		CString t = draw.vrmsTauName.Left(pathLen);
		LPCTSTR lpszFileName = t.GetBufferSetLength(t.GetLength());
		if(pathLen>(-1))
		{
			dlg.m_ofn.lpstrInitialDir = lpszFileName;
		}

		if( dlg.DoModal()==IDOK )
		{
			draw.vrmsTauName = dlg.GetPathName();
		}
		else {
			t.ReleaseBuffer();
			return;
		}
		t.ReleaseBuffer();
		delete dlg;

		// int tpp = 4000;  // will need to let user enter value

		CString tstr;
		CDigitize pDg;
		dig.digName = draw.vrmsTauName;
		if (!pDg.myDigitizingLoadTXTUnix2(&dig, FALSE, FALSE)) {
			tstr.Format(_T("Failed to load %s"), draw.vrmsTauName);
			myCaption(tstr);
			return;
		}
		int np = dig.nPoint[0];
		float tmin = dig.t[0][0];
		float tmax = dig.t[ np-1 ][0];
		//	float dt = (tpp<1 || tpp > 70000) ?  0.008f  :   (float)( 2. * (double)tpp / (double)MIL); 
		// this should be put input parameters

		//	int nt = (int)myRound( (tmax - tmin) / dt);
		int j;
		float *tau = (float *)malloc(sizeof(float)*np);
		float *vrms = (float *)malloc(sizeof(float)*np);
		float *vint = (float *)malloc(sizeof(float)*np);
		for (j = 0; j<np; j++) {
			tau[j] = dig.t[j][0];
			vrms[j] = dig.x[j][0];
		} // for j
		// getVelocityIntFromRms(dig.nPoint[0], &tau[0], &vrms[0], nt, dt, (float)tmin, &vint[0]);
		CVelMod vm;
		vm.getVelocityIntFromRms(np, &tau[0], &vrms[0], &vint[0]);
		free(tau);
		free(vrms);

		// now save to file
		freeDigAll();
		initDigitizeArray(np*2, 1);
		dig.isZeltFormat2 = FALSE;
		dig.totCurve = 1;
		for (j=0; j<np-1; j++) {
			dig.x[j*2][0] = vint[j];
			dig.t[j*2][0] = tau[j];
			dig.x[j*2+1][0] = vint[j];
			dig.t[j*2+1][0] = tau[j+1];
		} // for j
		dig.nPoint[0] = np*2;

		free(vint);
		dig.digName = tstr = GetFileNameAppendExt(velMod.velSecName, _T("_intVel-TwttFromRms"), _T("txt"));
		pDg.myDigSaveAs(&dig, FALSE, FALSE, tx.xShot); 
		showFileInNotePad(tstr);
		if (isTimeDomain()) draw.vrmsTauName = tstr;
	}


	void CSeisWideDoc::OnModelconversionIntToRmsvelocity()
	{
		if (isTimeDomain()) {
			AfxMessageBox(_T("Please show a model first."));
			return;
		}
		if (!isFileExistNotDirectory(velMod.velSecName)) return;
		if (velMod.ncont < 2) return;

		// tx.xShotInSegy, should be put input parameters
		if (vel.dz < 0.00001 || vel.dz > 1.) vel.dz = 0.008;
		CString tStr;

		CdlgVZCurve dlg;
		dlg.m_xShot = (float)tx.xShot; 
		if(dlg.DoModal() == IDOK)
			tx.xShot = dlg.m_xShot;
		else
			return;

		bool isSimple = false;
		//double depth[MOD_LAYER_MAX],vTop[MOD_LAYER_MAX],vBot[MOD_LAYER_MAX];
		CVelMod::VELMOD_X modX;
		CVelMod vm;
		modX.dist = tx.xShot;
		vm.initModX(&velMod, &modX, isTimeDomain() == TRUE, true, true, vel.dz);
		int numWaterLayers = (modX.vTop[1]>1.55 || modX.vBot[1]>1.55) ? 1 : 2;
		double *twttMod = (double *)malloc(sizeof(double)*velMod.ncont);
		float *VrmsTopMod = (float *)malloc(sizeof(float)*velMod.ncont);
		float *VrmsBotMod = (float *)malloc(sizeof(float)*velMod.ncont);
		vm.getVelocityRmsMod(&modX, vel.dz, tx.xShot, twttMod, VrmsTopMod, VrmsBotMod);
		freeDigAll();

		double tsf = twttMod[numWaterLayers];

		initDigitizeArray(MOD_LAYER_MAX*2, 1);
		dig.isZeltFormat2 = FALSE;
		dig.totCurve = 1;
		dig.nPoint[0] = 0;

		for (int icont=1; icont<velMod.ncont-1; icont++) {
			int ip = dig.nPoint[0];
			dig.x[ip][0] = (float)myRound(1000.f * VrmsTopMod[icont]);
			dig.t[ip][0] = (float)myRound(1000.f * (twttMod[icont] - tsf));
			dig.nPoint[0] ++;
		} // for icont
		free1double(twttMod);
		free1float(VrmsTopMod);
		free1float(VrmsBotMod);
		draw.markerName = getFileNameSubdir(velMod.velSecName, _T("rms"), _T("RmsVelocityAtMod.txt"), true);
		tStr.Format(_T("#RmsVelocity(m/s)  TWTT_Below_Seafloor(ms) calculated at %f km at model boundary only; %s"), tx.xShot, velMod.velSecName);
		CDigitize pDg;
		dig.digName = draw.markerName;
		dig.strComment += tStr;
		pDg.myDigSaveAs(&dig, FALSE, FALSE, tx.xShot); 


		showFileInNotePad(draw.markerName);

		draw.isSameDataDisplay = FALSE; //internal control and not saved.
		SetModifiedFlag();
		UpdateAllViews(NULL);
		NotifyChanged();
	}




	void CSeisWideDoc::OnModelconversionTormsvelocity2()
	{
		// convert model to RMS velocity without considering anisotropy
		if (isTimeDomain()) {
			AfxMessageBox(_T("Please show a model first."));
			return;
		}
		if (!isFileExistNotDirectory(velMod.velSecName)) return;

		// tx.xShotInSegy, should be put input parameters
		if (vel.dz < 0.00001 || vel.dz > 1.) vel.dz = 0.008;

		CdlgVZCurve dlg;
		dlg.m_xShot = (float)tx.xShot;
		if(dlg.DoModal() == IDOK)
			tx.xShot = dlg.m_xShot;
		else
			return;

		CString tStr;
		bool isSimple = false;
		// double depth[MOD_LAYER_MAX],vTop[MOD_LAYER_MAX],vBot[MOD_LAYER_MAX];
		CVelMod::VELMOD_X modX;
		CVelMod vm;
		modX.dist = tx.xShot;
		vm.initModX(&velMod, &modX, isTimeDomain() == TRUE, false, true, vel.dz);


		// double *twttMod = (double *)malloc(sizeof(double)*velMod.ncont);
		float *VrmsTopMod = (float *)malloc(sizeof(float)*velMod.ncont);
		float *VrmsBotMod = (float *)malloc(sizeof(float)*velMod.ncont);
		vm.getVelocityRmsMod(&modX, vel.dz, tx.xShot, modX.timeMod, VrmsTopMod, VrmsBotMod);
		int numWaterLayers = (modX.vTop[1]>1.55 || modX.vBot[1]>1.55) ? 1 : 2;
		double tsf = modX.timeMod[numWaterLayers];




		if (!isSimple) {
			int nzmaxModelAll = (int)(modX.depthMod[velMod.ncont-1] / vel.dz + 2.0); // only plus 2 makes it complete
			float *twttTrc = (float *)malloc(sizeof(float)*nzmaxModelAll);
			float *VrmsTrc = (float *)malloc(sizeof(float)*nzmaxModelAll);
			vm.getVelocityRmsTrc(&modX, vel.dz, nzmaxModelAll, &twttTrc[0], &VrmsTrc[0]);
			freeDigAll();


			initDigitizeArray(nzmaxModelAll, 1);
			dig.isZeltFormat2 = FALSE;
			dig.totCurve = 1;
			dig.nPoint[0] = 0;
			for (int j=0; j<nzmaxModelAll; j++) {
				if (twttTrc[j] < tsf) continue;
				int ip = dig.nPoint[0];
				dig.x[ip][0] = (float)myRound(1000.f * VrmsTrc[j]);
				dig.t[ip][0] = (float)myRound(1000.f * (twttTrc[j] - tsf));
				dig.nPoint[0] ++;
			} // for icont
			free1float(twttTrc);
			free1float(VrmsTrc);
		} else {
			// this part not tested
			freeDigAll();
			initDigitizeArray(MOD_LAYER_MAX*2, 1);
			dig.isZeltFormat2 = FALSE;
			dig.totCurve = 1;
			dig.nPoint[0] = 0;

			for (int icont=0; icont<velMod.ncont-1; icont++) {
				int ip = dig.nPoint[0];

				dig.x[ip][0] = (float)VrmsTopMod[icont];

				dig.t[ip][0] = (float)modX.timeMod[icont];
				dig.nPoint[0] ++;
			} // for icont
		}



		//free1double(twttMod);
		free1float(VrmsTopMod);
		free1float(VrmsBotMod);


		tStr.Format(_T("#RmsVelocity(m/s)  TWTT_Below_Seafloor(ms) calculated at %f km; %s. No Anisotrophy considered."), tx.xShot, velMod.velSecName);
		// dig.digName = velMod.markerName = GetFileNameAppendExt(velMod.velSecName, _T("_rmsVelTwttNoAnisotropy", _T("txt");
		dig.digName = draw.markerName = getFileNameSubdir(velMod.velSecName, _T("rms"), _T("RmsVelocityNoAni.txt"), true);
		dig.strComment += tStr;
		CDigitize pDg;
		pDg.myDigSaveAs(&dig, FALSE, FALSE, tx.xShot); 
		//myDigSaveAs(&dig, dig.digName, FALSE, FALSE); 
		showFileInNotePad(dig.digName);

		draw.isSameDataDisplay = FALSE; //internal control and not saved.
		SetModifiedFlag();
		UpdateAllViews(NULL);
		NotifyChanged();

	}

	void CSeisWideDoc::OnSonobuoyAutocalculateoffsetfromlat()
	{
		static double xlong_sb = -148.268178;
		static double ylat_sb = 77.260971;
		static bool isTwoSided = false;
		static bool isOffsetVaryWithLatMainly = false;
		static float aFactor = 1.f;
		static BOOL isFactorMIL = TRUE;
		CString tstr;

		CdlgSonobuoyAutoOffset dlg2;
		dlg2.m_timeSecName = draw.timeSecName;
		dlg2.m_long = xlong_sb;
		dlg2.m_lat = ylat_sb;
		dlg2.m_isTwoSided = isTwoSided;
		dlg2.m_isOffsetVaryWithLat = isOffsetVaryWithLatMainly;
		dlg2.m_factor = aFactor;
		dlg2.m_isFactorMIL = isFactorMIL;
		if (dlg2.DoModal() == IDOK) {
			draw.timeSecName = dlg2.m_timeSecName.Trim();
			xlong_sb = dlg2.m_long;
			ylat_sb = dlg2.m_lat;
			isTwoSided = dlg2.m_isTwoSided != FALSE;
			isOffsetVaryWithLatMainly = dlg2.m_isOffsetVaryWithLat != FALSE;
			aFactor = dlg2.m_factor;
			isFactorMIL = dlg2.m_isFactorMIL;
		}
		else return;
		delete dlg2;

		SegyWrapper sw(draw.timeSecName, true);
		if (CSegyMeta::segyHeadInit(draw.timeSecName, &head, 0) != 1) return;
		//sw.m_tminFile = head.tminFile;
		//sw.m_tmaxFile = head.tmaxFile;
		if (sw.open(&head, 0)) {
			if (sw.nxmax < 2) return;
			int gx, gy;
			bool isHeaderUpdNeeded = false;
			for (int ix=0; ix<sw.nxmax; ix++) {
				gx = sw.trArr[ix].gx;
				gy = sw.trArr[ix].gy;
				if (abs(gx) ==0 && abs(gy) == 0) {
					// we have an invalid lat/long. let's fix it

					// we search the correct lat/long on the left
					int i1 = -1;
					for (int i=ix-1; i>=0; i--) {
						if (abs(sw.trArr[i].gx) > 0 || abs(sw.trArr[i].gy) > 0) {
							i1 = i;
							break;
						}
					} // for i

					// we search the correct lat/long on the right
					int i2 = -1;
					for (int i=ix+1; i<sw.nxmax ; i++) {
						if (abs(sw.trArr[i].gx) > 0 || abs(sw.trArr[i].gy) > 0) {
							i2 = i;
							break;
						}
					} // for i

					if (i1>=0 && i2>i1) {
						// let's interpolate
						int trace1 = sw.trArr[i1].tracl;
						int trace2 = sw.trArr[i2].tracl;
						sw.trArr[ix].gx = sw.trArr[i1].gx + (int)myRound( (double)(sw.trArr[i2].gx - sw.trArr[i1].gx) * (double)(sw.trArr[ix].tracl - trace1) / (double)(trace2 - trace1) );
						sw.trArr[ix].gy = sw.trArr[i1].gy + (int)myRound( (double)(sw.trArr[i2].gy - sw.trArr[i1].gy) * (double)(sw.trArr[ix].tracl - trace1) / (double)(trace2 - trace1) );
						sw.trArr[ix].offset = sw.trArr[i1].offset + (int)myRound( (double)(sw.trArr[i2].offset - sw.trArr[i1].offset) * (double)(sw.trArr[ix].tracl - trace1) / (double)(trace2 - trace1) );
						isHeaderUpdNeeded = true;
					}
					else
						continue;
				} // if

			} // for ix
			if (isHeaderUpdNeeded) {
				if(CopyFile(draw.timeSecName, draw.timeSecName + _T(".Copy.sgy"), TRUE)) {
					sw.writeHeaderOnly();
					tstr.Format(_T("Invalid lat/longs are fixed for some traces. Original segy backuped."));
					AfxMessageBox(tstr);
				}
			}
		} // if sw.open






		CFile file;
		if (!file.Open(draw.timeSecName, CFile::modeReadWrite | CFile::typeBinary)) {
			tstr.Format(_T("Outfile cannot be created"));
			AfxMessageBox(tstr);
			return;
		}

		segy tr;
		bhed bh;
		BOOL isUnix = false;
		file.Seek(3200L, CFile::current);
		file.Read(&bh, 400L);
		if (isUnix = IsUnix(bh.format)) SwapTapeHeader(&bh);
		if (isUnix) {
			file.Close();
			tstr.Format(_T("Sorry, Please convert to PC format first and try again."));
			AfxMessageBox(tstr);
			return;
		}

		double dt = (double) bh.hdt /(double)MIL;
		double omil = (isFactorMIL)  ?   1./(double)MIL   :   1./360000.;
		int lenData = (bh.format==3)  ?  bh.hns*2  :  bh.hns*4;

		//bool isFirstTrc = true;
		//bool isSupposedToBeSmallerX;
		//bool isSupposedToBeSmallerY;
		while (file.Read(&tr, 240) == (UINT)240)
		{
			if (isUnix) {
				SwapTraceHeader(&tr);
			}

			//if (abs(tr.gx) ==0 && abs(tr.gy) == 0) {
			//	// we have an invalid lat/long. let's fix it
			//	int indSW = sw.getClosestTrcIndexAtTraceNum((float)tr.tracl);

			//	// we search the correct lat/long on the left
			//	int i1 = -1;
			//	for (int i=indSW-1; i>=0; i--) {
			//		if (abs(sw.trArr[i].gx) > 0 || abs(sw.trArr[i].gy) > 0) {
			//			i1 = i;
			//			break;
			//		}
			//	} // for i

			//	// we search the correct lat/long on the right
			//	int i2 = -1;
			//	for (int i=indSW+1; i<sw.nxmax ; i++) {
			//		if (abs(sw.trArr[i].gx) > 0 || abs(sw.trArr[i].gy) > 0) {
			//			i2 = i;
			//			break;
			//		}
			//	} // for i

			//	if (i1>=0 && i2>i1) {
			//		// let's interpolate
			//		int trace1 = sw.trArr[i1].tracl;
			//		int trace2 = sw.trArr[i2].tracl;
			//		tr.gx = sw.trArr[i1].gx + (int)myRound( (double)(sw.trArr[i2].gx - sw.trArr[i1].gx) * (double)(tr.tracl - trace1) / (double)(trace2 - trace1) );
			//		tr.gy = sw.trArr[i1].gy + (int)myRound( (double)(sw.trArr[i2].gy - sw.trArr[i1].gy) * (double)(tr.tracl - trace1) / (double)(trace2 - trace1) );
			//	}
			//	else
			//		continue;
			//} // if

			double xlong = tr.gx*omil*aFactor;
			double ylat = tr.gy*omil*aFactor;
			float anOffset = (float)calcDist( xlong_sb, ylat_sb, xlong, ylat);
			if (isTwoSided) {
				if (isOffsetVaryWithLatMainly) {
					if (ylat < ylat_sb) anOffset = -anOffset;
				}
				else {
					if (xlong < xlong_sb) anOffset = -anOffset;
				}
			}

			setOffset(&tr, anOffset);
			//	setOffset(&tr, (float)utmSimpsons(tr.sx, tr.sy, tr.gx, tr.gy));

			//if (isFirstTrc) {
			//	isSupposedToBeSmallerX = xlong < xlong_sb;
			//	isSupposedToBeSmallerY = ylat < ylat_sb;
			//	isFirstTrc = false;
			//}

			//register bool isSignSameX;
			//register bool isSignSameY;
			//if (!isTwoSided) {
			//	isSignSameX = true;
			//	isSignSameY = true;
			//}
			//else {
			//	isSignSameX = isSupposedToBeSmallerX && xlong <= xlong_sb;
			//	isSignSameY = isSupposedToBeSmallerY && ylat <= ylat_sb;
			//}

			//if (isSignSameX && isSignSameY) {
			//	setOffset(&tr, fabs(getOffset(&tr))); 
			//}
			//else if (!isSignSameX && !isSignSameY) {
			//	tr.offset = -abs(tr.offset);
			//	setOffset(&tr, -1.f * fabs(getOffset(&tr))); 
			//}
			//else if ( (isOffsetVaryWithLatMainly && isSignSameY)
			//	||
			//	 (!isOffsetVaryWithLatMainly && isSignSameX) ) {
			//	setOffset(&tr, fabs(getOffset(&tr))); 
			//}
			//else {
			//	setOffset(&tr, -1.f * fabs(getOffset(&tr))); 
			//}

			file.Seek(-240, CFile::current);
			file.Write(&tr, 240);
			file.Seek(lenData, CFile::current);

			//if (tr.tracl /10 * 10 == tr.tracl) { 
			//	tstr.Format(_T("T%d....", tr.tracl);
			//	myCaption(tstr);
			//}
		} // while

		file.Close();


		draw.modeOld = draw.mode;
		draw.mode = 0;
		para.isDistanceDisplay = FALSE;
		pCd.coord.vred = para.waterVelocityAboveObs;
		pCd.coord.tmin = -2.0;
		pCd.coord.tmax = 2.0;
		pCd.coord.tTick = 0.1;
		pCd.coord.xmin = 0.;
		// pCd.coord.xmax =  (int)(getOffset(&tr)*0.1 + 1.0) * 10.0;
		pCd.coord.xmax =  fabs(getOffset(&tr));
		para.trace1 = 0;
		para.trace2 = 99999;
		if (isTwoSided)
			pCd.coord.xmin = -pCd.coord.xmax;
		pCd.coord.xTick = 2.0;
		draw.isSameDataDisplay = FALSE;
		//	draw.timeSecOld = _T("");  // this is needed otherwise the section will not be initilized again.
		SetModifiedFlag();
		UpdateAllViews(NULL);
		NotifyChanged();
	}

	/*
	void CSeisWideDoc::OnSonobuoyAutocalculateoffsetfromlat()
	{
	static double xlong_sb = -148.268178;
	static double ylat_sb = 77.260971;
	static bool isTwoSided = false;
	static bool isOffsetVaryWithLatMainly = false;
	static float aFactor = 1.f;
	CdlgSonobuoyAutoOffset dlg2;
	dlg2.m_timeSecName = draw.timeSecName;
	dlg2.m_long = xlong_sb;
	dlg2.m_lat = ylat_sb;
	dlg2.m_isTwoSided = isTwoSided;
	dlg2.m_isOffsetVaryWithLat = isOffsetVaryWithLatMainly;
	dlg2.m_factor = aFactor;
	if (dlg2.DoModal() == IDOK) {
	draw.timeSecName = dlg2.m_timeSecName.Trim();
	xlong_sb = dlg2.m_long;
	ylat_sb = dlg2.m_lat;
	isTwoSided = dlg2.m_isTwoSided != FALSE;
	isOffsetVaryWithLatMainly = dlg2.m_isOffsetVaryWithLat != FALSE;
	aFactor = dlg2.m_factor;
	}
	else return;
	delete dlg2;

	CString tstr;
	CFile file;
	if (!file.Open(draw.timeSecName, CFile::modeReadWrite | CFile::typeBinary)) {
	tstr.Format(_T("Outfile cannot be created");
	AfxMessageBox(tstr);
	return;
	}
	segy tr;
	bhed bh;
	BOOL isUnix = false;
	file.Seek(3200L, CFile::current);
	file.Read(&bh, 400L);
	if (isUnix = IsUnix(bh.format)) SwapTapeHeader(&bh);
	if (isUnix) {
	file.Close();
	tstr.Format(_T("Sorry, Please convert to PC format first and try again.");
	AfxMessageBox(tstr);
	return;
	}

	double dt = (double) bh.hdt /(double)MIL;
	double omil = 1./(double)MIL;
	int lenData = (bh.format==3)  ?  bh.hns*2  :  bh.hns*4;

	bool isFirstTrc = true;
	bool isSupposedToBeSmallerX;
	bool isSupposedToBeSmallerY;
	while (file.Read(&tr, 240) == (UINT)240)
	{
	if (isUnix) {
	SwapTraceHeader(&tr);
	}

	double xlong = tr.gx*omil*aFactor;
	double ylat = tr.gy*omil*aFactor;

	tr.offset = (int)myRound(calcDist( xlong_sb, ylat_sb, xlong, ylat) * 1000.0);  // in meters
	//	tr.offset = utmSimpsons(tr.sx, tr.sy, tr.gx, tr.gy);  // in meters

	if (isFirstTrc) {
	isSupposedToBeSmallerX = xlong < xlong_sb;
	isSupposedToBeSmallerY = ylat < ylat_sb;
	isFirstTrc = false;
	}

	register bool isSignSameX;
	register bool isSignSameY;
	if (!isTwoSided) {
	isSignSameX = true;
	isSignSameY = true;
	}
	else {
	isSignSameX = isSupposedToBeSmallerX && xlong <= xlong_sb;
	isSignSameY = isSupposedToBeSmallerY && ylat <= ylat_sb;
	}


	if (isSignSameX && isSignSameY) {
	tr.offset = abs(tr.offset);
	}
	else if (!isSignSameX && !isSignSameY) {
	tr.offset = -abs(tr.offset);
	}
	else if ( (isOffsetVaryWithLatMainly && isSignSameY)
	||
	(!isOffsetVaryWithLatMainly && isSignSameX) ) {
	tr.offset = abs(tr.offset);
	}
	else {
	tr.offset = -abs(tr.offset);
	}

	file.Seek(-240, CFile::current);
	file.Write(&tr, 240);
	file.Seek(lenData, CFile::current);

	//if (tr.tracl /10 * 10 == tr.tracl) { 
	//	tstr.Format(_T("T%d....", tr.tracl);
	//	myCaption(tstr);
	//}
	} // while

	file.Close();


	draw.mode = 0;
	para.isDistanceDisplay = 0;
	para.vred = para.waterVelocityAboveObs;
	pCd.coord.tmin = -2.0;
	pCd.coord.tmax = 2.0;
	para.tTick = 0.1;
	pCd.coord.xmin = 0.;
	pCd.coord.xmax =  (int)( abs(tr.offset) / 10000.0 + 1.0) * 10.0;
	para.trace1 = 0;
	para.trace2 = 99999;
	if (isTwoSided)
	pCd.coord.xmin = -pCd.coord.xmax;
	para.xTick = 2.0;
	draw.isSameNodeDisplay = TRUE;	
	draw.isSameDataDisplay = FALSE;
	draw.timeSecOld = _T("");  // this is needed otherwise the section will not be initilized again.
	SetModifiedFlag();
	UpdateAllViews(NULL);
	NotifyChanged();
	}
	*/



	void CSeisWideDoc::OnSonobuoyPolyTrace()
	{
		if (draw.mode!=6) return OnSonobuoyPoly();

		int i;
		CString tStr;
		if (!isFileExistNotDirectory(draw.timeSecName))  {
			tStr.Format(_T(" To assign offsets for sonobuoy data, please display a time section with trace or km or NMO."));
			AfxMessageBox(tStr);
			return;
		}
		if (!draw.isDigitizing) {
			// the user is not digitizing. 
			tStr.Format(_T(" To assign offsets for sonobuoy data, please display a time section with trace or km or NMO, and digitize 1 segment only for the water wave, and then 'Associate km to Sonobuoy Traces' to obtain the distance"));
			AfxMessageBox(tStr);
			return;
		}



		if (dig.nPoint[0]<2) {
			tStr.Format(_T(" At least 2 points are needed on the direct water wave to obtain distance"));
			AfxMessageBox(tStr);
			return;
		}


		static float polyA= -0.006f; // typical for Arctic area
		static float polyB = para.waterVelocityAboveObs; // this value is the one GSCA used, in km
		static float polyC = 0.00075f;
		static float gunDelay = 0.051f; // these values are the ones GSCA used, in km, sec
		static BOOL isInterpol4Zero = FALSE;

		// static float VavgWater = 1.44f; // this water velocity is for hyperbola formula only, not for Nina's
		static float xHyperbola = 1.f;
		// static BOOL isUpdatePartial = FALSE;
		BOOL isGunDelayCorr = FALSE;

		CdlgSonobuoyPoly dlg;
		dlg.m_polyA = polyA;
		dlg.m_polyB = polyB;
		dlg.m_polyC = polyC;
		dlg.m_gunDelay = gunDelay;
		dlg.m_isGunDelayCorr = isGunDelayCorr;
		dlg.m_isUpdatePartial = digIsUpdatePartial;
		dlg.m_isIntopol4Zero = isInterpol4Zero;

		// addition on Apr 12, 2012
		dlg.m_vred = para.waterVelocityAboveObs;
		dlg.m_buoydepth = para.obsDepth;
		dlg.m_xHyperbola = xHyperbola;

		if (dlg.DoModal() == IDOK)
		{
			polyA = dlg.m_polyA;
			polyB = dlg.m_polyB;
			polyC = dlg.m_polyC;
			gunDelay = dlg.m_gunDelay;
			isGunDelayCorr = dlg.m_isGunDelayCorr;
			digIsUpdatePartial = dlg.m_isUpdatePartial;
			isInterpol4Zero = dlg.m_isIntopol4Zero;

			para.waterVelocityAboveObs = dlg.m_vred;
			para.obsDepth = dlg.m_buoydepth;
			xHyperbola = dlg.m_xHyperbola;
		}
		else return;

		digIsUpdatePartial = FALSE;  // disable it since it cuts digitized points, need to fix it first.

		if ( fabs(xHyperbola) > 0.f && para.waterVelocityAboveObs < 0.00001f) {
			tStr.Format(_T(" For hyperbola formula, water velocity cannot be zero."));
			AfxMessageBox(tStr);
			return;
		}

		// first check if the digitized points have odds
		int iUserRes = -1;
		for (i=0; i<dig.nPoint[0]-1; i++) {
			if (!sameSign(dig.x[i][0], dig.x[i+1][0])) continue;  // if the points are on both sides of SB/OBS, ignore comparison
			if(digIsUpdatePartial &&  !isInsideFloat(dig.x[i][0], (float)pCd.coord.xmin, (float)pCd.coord.xmax)) continue;

			if (
				(dig.x[i][0] > 0.f &&   dig.t[i][0] > dig.t[i+1][0])
				||
				(dig.x[i][0] < 0.f &&   dig.t[i][0] < dig.t[i+1][0])
				)
			{
				tStr.Format(_T(" Picked times are irregular: (%f, %f)sec at (%f, %f)km. Ignore? No to ignore all"), 
					dig.t[i][0], dig.t[i+1][0], dig.x[i][0], dig.x[i+1][0]);
				if (iUserRes != IDNO) {
					iUserRes = AfxMessageBox(tStr, MB_YESNOCANCEL|MB_ICONINFORMATION);
					if(iUserRes == IDCANCEL) {
						showFileInNotePad(dig.digName);
						return;
					}
				}
			}
		} // for i

		CDigitize pDg;
		CDigitize::DIGITIZE dig2;
		if (!pDg.initDigitizeArray(&dig2, dig.nPoint[0], 1)) return;


		BOOL isUnix = false;
		bhed bh;
		segy tr;

		float range;
		float tw; // water wave travel time
		float offset;


		// before opening the segy file, we want to mark up some traces that have invalid offset info, and fix them up, otherwise
		// those traces will never have any valid offset info written by this routine! This has been found to be happening in some segys!
		SegyWrapper sw(draw.timeSecName, true);
		if (CSegyMeta::segyHeadInit(draw.timeSecName, &head, 0) != 1) return;
		//sw.m_tminFile = head.tminFile;
		//sw.m_tmaxFile = head.tmaxFile;
		if (sw.open(&head, 0)) {
			if (sw.nxmax < 2) return;
		}

		CFile file;
		if (!file.Open(draw.timeSecName, CFile::modeReadWrite | CFile::typeBinary)) {
			tStr.Format(_T("Input time section cannot be opened for writing."));
			AfxMessageBox(tStr);
			return;
		}

		ULONGLONG bytesRead = file.Seek(3200L, CFile::begin);
		bytesRead = file.Read(&bh, 400L);
		if (isUnix = IsUnix(bh.format)) SwapTapeHeader(&bh);
		if(isUnix) {
			tStr.Format(_T("Please convert to PC format first."));
			AfxMessageBox(tStr);
			file.Close();
			return;
		}
		if(bytesRead < 400 || !IsFormatValid(bh.format)) {
			tStr.Format(_T("Binary section header read wrong"));
			AfxMessageBox(tStr);
			file.Close();
			return;
		}

		// get some parameters from the tape header
		int len = (bh.format==3) ? (2*bh.hns) :  4*bh.hns;
		len += 240;
		int numsamp = bh.hns;

		// dig must already be sorted along X-axis
		pDg.myDigSort(&dig, TRUE, FALSE, pCd.coord.xmin, pCd.coord.xmax);	

		dig2.nPoint[0] = 0;
		dig2.isZeltFormat2 = FALSE;
		dig2.digName = isEndWith(dig.digName, _T("_Poly.txt"))  ?  dig.digName  :  GetFileNameAppendExt(dig.digName, _T("_Poly"), _T("txt")); // this name is needed before the following loop since it will auto write once the limit is reached
		bool isPrompt = true;
		int num = dig.nPoint[0];
		while (file.Read(&tr,240) == 240) {
			range = (float)tr.tracl;
			//		dig.x[][0] is actually digitized shot number
			//		dig.t[][0] is digitized absolute time in sec.

			if(range<dig.x[0][0]) {
				tw = dig.t[0][0] +(dig.t[1][0]-dig.t[0][0])
					/(dig.x[1][0]-dig.x[0][0])*(range-dig.x[0][0]);
			}
			else if(range>dig.x[num-1][0]) {
				tw = dig.t[num-2][0] +(dig.t[num-1][0]-dig.t[num-2][0])
					/(dig.x[num-1][0]-dig.x[num-2][0])*(range-dig.x[num-2][0]);
			}
			else {
				for (i=0; i<num-1; i++) {
					if(range>=dig.x[i][0] && range<=dig.x[i+1][0] ) {
						if(dig.x[i][0]!=dig.x[i+1][0])
							tw = dig.t[i][0]+(dig.t[i+1][0]-dig.t[i][0])
							/(dig.x[i+1][0]-dig.x[i][0])*(range-dig.x[i][0]); 
						else
							tw = dig.t[i][0];
						break;
					} // if range
				} // for i
			} // else

			// do a static shift to correect for airgun delay
			if (isGunDelayCorr) {
				// range is now the travel time (sec) of the direct water wave. We apply source delay time
				tw -= gunDelay;
				setTraceDelayF(&tr, (getTraceDelay(&tr)-gunDelay) );
			}


			//convert time to range in km.
			offset = polyA + polyB*tw + polyC*tw*tw;
			if (fabs(offset) < xHyperbola) {
				// now we use our conventional formula of hyperbola
				float aPositive = (tw*tw*para.waterVelocityAboveObs*para.waterVelocityAboveObs) - 
					para.obsDepth * para.obsDepth;
				if (aPositive >= 0.f)
					offset = sqrt(aPositive);
			}

			setOffset(&tr, fabs(offset));  // I give up on negative offsets

			if (dig2.nPoint[0] >=dig2.DIG_POINT_MAX) {
				pDg.myDigSaveAs(&dig2, TRUE, FALSE, tx.xShot);
				pDg.myDigitizingLoadTXTUnix2(&dig2, TRUE, FALSE);
			}
			i = dig2.nPoint[0]; 
			dig2.x[i][0] = getOffset(&tr);
			dig2.t[i][0] = tw;

			dig2.nPoint[0]++;
			pDg.myDigSort(&dig2, TRUE, digIsUpdatePartial, pCd.coord.xmin, pCd.coord.xmax);	// this must be done for new point added. this is important

			file.Seek(-240,CFile::current);
			file.Write(&tr,240);
			file.Seek(len-240,CFile::current);

			tStr.Format(_T("T%d."), tr.tracl);
			myCaption(tStr);

		} // while
		file.Close();


		pDg.myDigSort(&dig2, TRUE, digIsUpdatePartial, pCd.coord.xmin, pCd.coord.xmax);	// this must be done for each loop!  prob: after this sort, na should be changed!
		pDg.myDigSaveAs(&dig2, TRUE, FALSE, tx.xShot);
		dig.digName = dig2.digName;


		tStr.Format(_T("Offset information is assigned successfully."));
		if (isGunDelayCorr)
			tStr += _T(" Correction for gun delay is also applied.");

		tStr += _T(" Revised offset vs direct arrival time is stored in: ") + dig2.digName;
		tStr += _T(" You may revise the digitization and assign offsets again.");

		static bool isShowMsgBox = true;
		if (isShowMsgBox) {
			AfxMessageBox(tStr);
			isShowMsgBox = false;
		}
		else
			myCaption(tStr);


		i = dig2.nPoint[0];
		if (i>0) {
			// with trace display, we need to switch distance display
			pCd.coord.xmin = (float)( (myRound)(dig2.x[0][0]/10)*10. );
			pCd.coord.xmax = (float)( (myRound)(dig2.x[i-1][0]/10)*10. );
			pCd.coord.tmin = -1.;
			pCd.coord.tmax = 2.;
			para.isDistanceDisplay = FALSE;
			para.trace1 = 0;
			para.trace2 = 99999;
			pCd.coord.xTick = (float)( myRound((pCd.coord.xmax-pCd.coord.xmin)/100)*10. );
			pCd.coord.vred = para.waterVelocityAboveObs;
			draw.modeOld = draw.mode;
			draw.mode = 0;
			pDg.freeDigAll(&dig2); //  we need destroy whatever in there first
			pDg.freeDigAll(&dig); 
			draw.isDigitizing = FALSE;  // must stop digitizing, otherwise the trace and offset domains are messed up!
		}

		//	draw.timeSecOld = _T("");  // this will re-calc for amp inilization
		draw.isSameDataDisplay = FALSE;

		//	SetModifiedFlag();
		UpdateAllViews(NULL);
		NotifyChanged();

	}

	void CSeisWideDoc::OnSonobuoyPoly()
	{
		/*
		Nina's empirical formula for offset X  vs direct water wave time Tw. 
		X = 1.441Tw + 0.00075Tw*Tw - 0.006
		with an error estimates of 
		<20m for X<35km
		*/
		if (draw.mode==6) return OnSonobuoyPolyTrace();

		int i, j;
		CString tStr;
		if (!isFileExistNotDirectory(draw.timeSecName) ||
			(draw.mode!=0 && draw.mode!=6 && draw.mode!=7) )  {
				tStr.Format(_T(" To assign offsets for sonobuoy data, please display a time section with trace or km or NMO."));
				AfxMessageBox(tStr);
				return;
		}
		if (!draw.isDigitizing) {
			// the user is not digitizing. 
			tStr.Format(_T(" To assign offsets for sonobuoy data, please display a time section with trace or km or NMO, and digitize 1 segment only for the water wave, and then 'Associate km to Sonobuoy Traces' to obtain the distance"));
			AfxMessageBox(tStr);
			return;
		}
		if (para.isDistanceDisplay) {
			tStr.Format(_T(" Sorry, cannot assign offsets with distance display"));
			AfxMessageBox(tStr);
			return;
		}



		if (dig.nPoint[0]<2) {
			tStr.Format(_T(" At least 2 points are needed on the direct water wave to obtain distance"));
			AfxMessageBox(tStr);
			return;
		}


		static float polyA= -0.006f; // typical for Arctic area
		static float polyB = para.waterVelocityAboveObs; // this value is the one GSCA used, in km
		static float polyC = 0.00075f;
		static float gunDelay = 0.051f; // these values are the ones GSCA used, in km, sec
		static BOOL isInterpol4Zero = FALSE;

		// static float VavgWater = 1.44f; // this water velocity is for hyperbola formula only, not for Nina's
		static float xHyperbola = 1.f;
		// static BOOL isUpdatePartial = FALSE;
		BOOL isGunDelayCorr = FALSE;

		CdlgSonobuoyPoly dlg;
		dlg.m_polyA = polyA;
		dlg.m_polyB = polyB;
		dlg.m_polyC = polyC;
		dlg.m_gunDelay = gunDelay;
		dlg.m_isGunDelayCorr = isGunDelayCorr;
		dlg.m_isUpdatePartial = digIsUpdatePartial;
		dlg.m_isIntopol4Zero = isInterpol4Zero;

		// addition on Apr 12, 2012
		dlg.m_vred = para.waterVelocityAboveObs;
		dlg.m_buoydepth = para.obsDepth;
		dlg.m_xHyperbola = xHyperbola;

		if (dlg.DoModal() == IDOK)
		{
			polyA = dlg.m_polyA;
			polyB = dlg.m_polyB;
			polyC = dlg.m_polyC;
			gunDelay = dlg.m_gunDelay;
			isGunDelayCorr = dlg.m_isGunDelayCorr;
			digIsUpdatePartial = dlg.m_isUpdatePartial;
			isInterpol4Zero = dlg.m_isIntopol4Zero;

			para.waterVelocityAboveObs = dlg.m_vred;
			para.obsDepth = dlg.m_buoydepth;
			xHyperbola = dlg.m_xHyperbola;
		}
		else return;

		digIsUpdatePartial = FALSE;  // disable it since it cuts digitized points, need to fix it first.

		if ( fabs(xHyperbola) > 0.f && para.waterVelocityAboveObs < 0.00001f) {
			tStr.Format(_T(" For hyperbola formula, water velocity cannot be zero."));
			AfxMessageBox(tStr);
			return;
		}

		// first check if the digitized points have odds
		this->OnDigitizingSavedig(); // save first
		int iUserRes = -1;
		for (i=0; i<dig.nPoint[0]-1; i++)
		{
			if (!sameSign(dig.x[i][0], dig.x[i+1][0])) continue;  // if the points are on both sides of SB/OBS, ignore comparison
			if(digIsUpdatePartial &&  !isInsideFloat(dig.x[i][0], (float)pCd.coord.xmin, (float)pCd.coord.xmax)) continue;

			if (
				(dig.x[i][0] > 0.f &&   dig.t[i][0] > dig.t[i+1][0])
				||
				(dig.x[i][0] < 0.f &&   dig.t[i][0] < dig.t[i+1][0])
				)
			{
				if (iUserRes != IDNO) {
					tStr.Format(_T(" Picked times are irregular: (%f, %f)sec at (%f, %f)km. Ignore? No to ignore all."), 
						dig.t[i][0], dig.t[i+1][0], dig.x[i][0], dig.x[i+1][0]);
					iUserRes = AfxMessageBox(tStr, MB_YESNOCANCEL|MB_ICONINFORMATION);
					if(iUserRes == IDCANCEL) {
						showFileInNotePad(dig.digName);
						return;
					}
				}
			}
		} // for i

		CDigitize pDg;
		CDigitize::DIGITIZE dig2;
		if (!pDg.initDigitizeArray(&dig2, dig.nPoint[0], 1)) return;


		BOOL isUnix = false;
		bhed bh;
		segy tr;

		float range;
		float tw; // water wave travel time
		float offset;


		// before opening the segy file, we want to mark up some traces that have invalid offset info, and fix them up, otherwise
		// those traces will never have any valid offset info written by this routine! This has been found to be happening in some segys!
		SegyWrapper sw(draw.timeSecName, true);
		if (CSegyMeta::segyHeadInit(draw.timeSecName, &head, 0) != 1) return;
		//sw.m_tminFile = head.tminFile;
		//sw.m_tmaxFile = head.tmaxFile;
		if (sw.open(&head, 0)) {
			if (sw.nxmax < 2) return;
		}

		if (isInterpol4Zero) {
			int gx, gy;
			bool isHeaderUpdNeeded = false;
			for (int ix=0; ix<sw.nxmax; ix++) {
				gx = sw.trArr[ix].gx;
				gy = sw.trArr[ix].gy;
				if (abs(gx) ==0 && abs(gy) == 0) {
					// we have an invalid lat/long. let's fix it

					// we search the correct lat/long on the left
					int i1 = -1;
					for (int i=ix-1; i>=0; i--) {
						if (abs(sw.trArr[i].gx) > 0 || abs(sw.trArr[i].gy) > 0) {
							i1 = i;
							break;
						}
					} // for i

					// we search the correct lat/long on the right
					int i2 = -1;
					for (int i=ix+1; i<sw.nxmax ; i++) {
						if (abs(sw.trArr[i].gx) > 0 || abs(sw.trArr[i].gy) > 0) {
							i2 = i;
							break;
						}
					} // for i

					if (i1>=0 && i2>i1) {
						// let's interpolate
						int trace1 = sw.trArr[i1].tracl;
						int trace2 = sw.trArr[i2].tracl;
						sw.trArr[ix].gx = sw.trArr[i1].gx + (int)myRound( (double)(sw.trArr[i2].gx - sw.trArr[i1].gx) * (double)(sw.trArr[ix].tracl - trace1) / (double)(trace2 - trace1) );
						sw.trArr[ix].gy = sw.trArr[i1].gy + (int)myRound( (double)(sw.trArr[i2].gy - sw.trArr[i1].gy) * (double)(sw.trArr[ix].tracl - trace1) / (double)(trace2 - trace1) );

						// sw.trArr[ix].offset = sw.trArr[i1].offset + (int)myRound( (double)(sw.trArr[i2].offset - sw.trArr[i1].offset) * (double)(sw.trArr[ix].tracl - trace1) / (double)(trace2 - trace1) );
						offset = getOffset(&sw.trArr[i1]) + (getOffset(&sw.trArr[i2]) - getOffset(&sw.trArr[i1])) * (float)(sw.trArr[ix].tracl - trace1) / (float)(trace2 - trace1);
						setOffset(&sw.trArr[ix], offset);

						isHeaderUpdNeeded = true;
					}
					else
						continue;
				} // if

			} // for ix
			if (isHeaderUpdNeeded)
				sw.writeHeaderOnly();
		} // if isInterpol4Zero



		bool isHeaderErrFixNeeded = false;
		for (int ix=0; ix<sw.nxmax; ix++) {
			if ( abs(sw.trArr[ix].offset) > MIL) {
				// invalid offset found
				if (ix==0) {
					if (abs(sw.trArr[ix+1].offset)<MIL) {
						sw.trArr[ix].offset = sw.trArr[ix+1].offset - 1;
						isHeaderErrFixNeeded = true;
					}
				}
				else if (ix==sw.nxmax-1) {
					if (abs(sw.trArr[ix-1].offset)<MIL) {
						sw.trArr[ix].offset = sw.trArr[ix-1].offset + 1;
						isHeaderErrFixNeeded = true;
					}
				}
				else {
					int x1 = sw.trArr[ix-1].offset;
					int x2 = sw.trArr[ix+1].offset;
					if (abs(x1)<MIL && abs(x2)<MIL) {
						sw.trArr[ix].offset = (x1 + x2) / 2;
						isHeaderErrFixNeeded = true;
					}
				} 
			} // if
		} // for ix
		if (isHeaderErrFixNeeded) sw.writeHeaderOnly();




		CFile file;
		if (!file.Open(draw.timeSecName, CFile::modeReadWrite | CFile::typeBinary)) {
			tStr.Format(_T("Input time section cannot be opened for writing."));
			AfxMessageBox(tStr);
			return;
		}

		ULONGLONG bytesRead = file.Seek(3200L, CFile::begin);
		bytesRead = file.Read(&bh, 400L);
		if (isUnix = IsUnix(bh.format)) SwapTapeHeader(&bh);
		if(isUnix) {
			tStr.Format(_T("Please convert to PC format first."));
			AfxMessageBox(tStr);
			file.Close();
			return;
		}
		if(bytesRead < 400 || !IsFormatValid(bh.format)) {
			tStr.Format(_T("Binary section header read wrong"));
			AfxMessageBox(tStr);
			file.Close();
			return;
		}

		// get some parameters from the tape header
		int len = (bh.format==3) ? (2*bh.hns) :  4*bh.hns;
		len += 240;
		int numsamp = bh.hns;

		// dig must already be sorted along X-axis
		pDg.myDigSort(&dig, TRUE, FALSE, pCd.coord.xmin, pCd.coord.xmax);	

		float rangeSBIn = 0.f;
		// it is not displaying by trace, so the SB must be at 0 km offset

		dig2.nPoint[0] = 0;
		dig2.isZeltFormat2 = FALSE;
		dig2.digName = isEndWith(dig.digName, _T("_Poly.txt"))  ?  dig.digName  :  GetFileNameAppendExt(dig.digName, _T("_Poly"), _T("txt")); // this name is needed before the following loop since it will auto write once the limit is reached
		bool isPrompt = true;
		while (file.Read(&tr,240) == 240)
		{
			//if(tr.trid == 2) // skip dead traces
			//{
			//	file.Seek(len-240, CFile::current); 
			//	continue;
			//}
			// if you skip dead traces, those traces do not have offsets, and can be a problem. It's no hard to have an offset for dead traces, so we do it!

			range = getOffset(&tr);
			bool isPositiveOffset = range >= 0;
			//note: this range is actually the X-axis, which is only raw offsets,
			//		dig.t[][0] is digitized absolute time in sec.


			// to speed up computing, skip undesired traces only if not in trace display mode
			if(digIsUpdatePartial &&  !isInsideFloat(range, (float)pCd.coord.xmin, (float)pCd.coord.xmax) ) {
				for (i=0; i<dig.nPoint[0]; i++) {
					if (range == dig.x[i][0])
					{
						// just need to copy from dig to dig2 for this trace
						//if (dig2.nPoint[0] >=dig2.DIG_POINT_MAX) {
						//	pDg.myDigSaveAs(&dig2, dig2.digName, TRUE, FALSE, tx.xShot);
						//	pDg.myDigitizingLoadTXTUnix2(&dig2, dig2.digName, TRUE, FALSE);
						//}
						j = dig2.nPoint[0]; 
						//dig2.x[j][0] = dig.x[j][0];
						//dig2.t[j][0] = dig.t[j][0];
						//dig2.nPoint[0]++; // no need to sort since it is copied
						pDg.myDigAddPoint(&dig2, 0, (double)dig.x[j][0], (double)dig.t[j][0]);
						break;
					} // if range
				} // for i
				file.Seek(len-240, CFile::current); 
				continue;
			}

			// here we have a problem: if the offset is minus and yet dig.x[0][0] is positive, no interpolation can be extended.
			i = dig.nPoint[0];
			if(!sameSign(range, dig.x[0][0]) && range<dig.x[0][0]) {
				// we need to insert 3 points at 0, -dig.x[0][0], -dig.x[1][0], and then sort
				if (i+3 >=dig.DIG_POINT_MAX) {
					myDigSaveAs(dig.digName);
					dig.digNameOld = _T(""); // this will enforce a reload
					pDg.myDigitizingLoadTXTUnix2(&dig, dig.isSorted, dig.isSortedY);
				}
				dig.x[i][0] = 0.f;
				dig.t[i][0] = dig.t[0][0] +(dig.t[1][0]-dig.t[0][0])/(dig.x[1][0]-dig.x[0][0])*(0.f-dig.x[0][0]);
				dig.x[i+1][0] = -dig.x[0][0];
				dig.t[i+1][0] = dig.t[0][0];
				dig.x[i+2][0] = -dig.x[1][0];
				dig.t[i+2][0] = dig.t[1][0];
				dig.nPoint[0]+=3;
				pDg.myDigSort(&dig, TRUE, FALSE, pCd.coord.xmin, pCd.coord.xmax);	// this must be done for each loop!  
			}
			else if (!sameSign(range, dig.x[i-1][0]) && range>dig.x[i-1][0]) {
				// we need to insert 3 points at 0, -dig.x[i-1][0], -dig.x[i-2][0], and then sort
				if (i+3 >=dig.DIG_POINT_MAX) {
					myDigSaveAs(dig.digName);
					dig.digNameOld = _T(""); // this will enforce a reload
					pDg.myDigitizingLoadTXTUnix2(&dig, dig.isSorted, dig.isSortedY);
				}
				dig.x[i][0] = 0.f;
				dig.t[i][0] = dig.t[i-2][0] +(dig.t[i-1][0]-dig.t[i-2][0])/(dig.x[i-1][0]-dig.x[i-2][0])*(0.f-dig.x[i-2][0]);
				dig.x[i+1][0] = -dig.x[i-1][0];
				dig.t[i+1][0] = dig.t[i-1][0];
				dig.x[i+2][0] = -dig.x[i-2][0];
				dig.t[i+2][0] = dig.t[i-2][0];
				dig.nPoint[0]+=3;
				pDg.myDigSort(&dig, TRUE, FALSE, pCd.coord.xmin, pCd.coord.xmax);	// this must be done for each loop!  
			}


			if(range<dig.x[0][0]) {
				tw = dig.t[0][0] +(dig.t[1][0]-dig.t[0][0])
					/(dig.x[1][0]-dig.x[0][0])*(range-dig.x[0][0]);
			}
			else if(range>dig.x[dig.nPoint[0]-1][0]) {
				tw = dig.t[dig.nPoint[0]-2][0] +(dig.t[dig.nPoint[0]-1][0]-dig.t[dig.nPoint[0]-2][0])
					/(dig.x[dig.nPoint[0]-1][0]-dig.x[dig.nPoint[0]-2][0])*(range-dig.x[dig.nPoint[0]-2][0]);
			}
			else {
				for (i=0; i<dig.nPoint[0]-1; i++)
				{
					if(range>=dig.x[i][0] && range<=dig.x[i+1][0] )
					{
						if(dig.x[i][0]!=dig.x[i+1][0])
							tw = dig.t[i][0]+(dig.t[i+1][0]-dig.t[i][0])
							/(dig.x[i+1][0]-dig.x[i][0])*(range-dig.x[i][0]); 
						else
							tw = dig.t[i][0];
						break;
					} // if range
				} // for i
			} // else

			// do a static shift to correect for airgun delay
			if (isGunDelayCorr) {
				// range is now the travel time (sec) of the direct water wave. We apply source delay time
				tw -= gunDelay;
				setTraceDelayF(&tr, (getTraceDelay(&tr)-gunDelay) );
			}





			//convert time to range in km.
			offset = polyA + polyB*tw + polyC*tw*tw;
			if (fabs(offset) < xHyperbola) {
				// now we use our conventional formula of hyperbola
				float aPositive = (tw*tw*para.waterVelocityAboveObs*para.waterVelocityAboveObs) - 
					para.obsDepth * para.obsDepth;
				if (aPositive >= 0.f)
					offset = sqrt(aPositive);
			}

			if (!isPositiveOffset) offset = -fabs(offset);
			setOffset(&tr, offset); 



			if (dig2.nPoint[0] >=dig2.DIG_POINT_MAX) {
				pDg.myDigSaveAs(&dig2, TRUE, FALSE, tx.xShot);
				pDg.myDigitizingLoadTXTUnix2(&dig2, TRUE, FALSE);
			}
			i = dig2.nPoint[0]; 
			dig2.x[i][0] = getOffset(&tr);
			dig2.t[i][0] = tw;


			//now the label has been overwritten so need to recover (only one label for each curve).
			//tStr.Format(_T("%d.", tr.tracl);
			//LPCTSTR lpszName = tStr.GetBufferSetLength(tStr.GetLength());
			//strncpy(&dig2.label[i*8], lpszName, 8); //label for last curve.
			//tStr.ReleaseBuffer();

			dig2.nPoint[0]++;
			pDg.myDigSort(&dig2, TRUE, digIsUpdatePartial, pCd.coord.xmin, pCd.coord.xmax);	// this must be done for new point added. this is important

			file.Seek(-240,CFile::current);
			file.Write(&tr,240);
			file.Seek(len-240,CFile::current);

			tStr.Format(_T("T%d."), tr.tracl);
			myCaption(tStr);

		} // while
		file.Close();


		pDg.myDigSort(&dig2, TRUE, digIsUpdatePartial, pCd.coord.xmin, pCd.coord.xmax);	// this must be done for each loop!  prob: after this sort, na should be changed!
		pDg.myDigSaveAs(&dig2, TRUE, FALSE, tx.xShot);
		dig.digName = dig2.digName;


		tStr.Format(_T("Offset information is assigned successfully."));
		if (isGunDelayCorr)
			tStr += _T(" Correction for gun delay is also applied.");

		tStr += _T(" Revised offset vs direct arrival time is stored in: ") + dig2.digName;
		tStr += _T(" You may revise the digitization and assign offsets again.");

		static bool isShowMsgBox = true;
		if (isShowMsgBox) {
			AfxMessageBox(tStr);
			isShowMsgBox = false;
		}
		else
			myCaption(tStr);


		//	draw.timeSecOld = _T("");  // this will re-calc for amp inilization
		draw.isSameDataDisplay = FALSE;

		//	SetModifiedFlag();
		UpdateAllViews(NULL);
		NotifyChanged();

	}




	void CSeisWideDoc::OnSegyconversionIeeetoibmfloat()
	{
		long k;
		segy tr;
		bhed bh;
		BOOL isUnix = false;

		//BOOL isDeadTrcExist, isUseReducedTime, GSCformat, trcRenum;
		//BOOL isBackupCDP = false;
		CString inFile = _T(""), outFile=_T("");

		//short *i2buf;
		//long *i4buf;
		//i2buf = (short *) &tr;
		//i4buf = (long *) &i2buf[0];

		CFileDialog dlg( TRUE,_T("sgy; SEG"),_T("*.sgy; *.SEG"),
			OFN_HIDEREADONLY|OFN_OVERWRITEPROMPT|OFN_ALLOWMULTISELECT|OFN_EXPLORER,
			_T("Input Segy File (*.sgy;*.SEG)|*.sgy; *.SEG|"));

		TCHAR* buff=new TCHAR[65535];
		buff[0]='\0';
		dlg.m_ofn.lpstrTitle = _T("Select all segy files with IEEE floating point data for conversion");
		dlg.m_ofn.lpstrFile=buff;
		dlg.m_ofn.nMaxFile = 65535;//sizeof(buff);

		POSITION Position;

		if(dlg.DoModal()==IDOK)
		{
			//Begin progress control.
			CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
			ASSERT(pFrame);
			ASSERT_KINDOF(CMainFrame, pFrame);
			pFrame->BeginProgress();
			Position=dlg.GetStartPosition();
			while(Position)
			{
				inFile = dlg.GetNextPathName(Position);
				CString tempStr = inFile;
				tempStr.MakeLower();
				// must make it lower case before comparing, in case some file has extension
				// like ".Sgy" or ".sGY".
				if(tempStr.Right(4) == _T(".sgy"))
					//outFile = inFile.Left(inFile.GetLength()-4) + _T("IBM.sgy");
						outFile = getFileNameAppend(inFile, _T("IBM"));
				else
					outFile = inFile + _T("IBM.sgy");
				if(outFile==_T("")) {
					delete [] buff;
					return;
				}

				if (!isFileExistNotDirectory(inFile)) continue;
				CFile file;
				if (!file.Open(inFile, CFile::modeRead | CFile::typeBinary)) {
					continue;
				}

				//For progress control, need to know the last bytes no.
				ULONGLONG curBytesRead, totBytesRead = file.GetLength();
				file.Seek(0, CFile::begin);

				UINT bytesRead = file.Read(head.ascHead, 3200L);
				if(bytesRead < 3200) 
				{
					file.Close();
					myCaption(_T("File ") + inFile + _T(" Ascii section header read wrong"));
					continue;
				}
				file.Read(&bh, 400L);
				if(bytesRead < 400) 
				{
					file.Close();
					myCaption(_T("File ") + inFile + _T(" Binary section header read wrong"));
					continue;
				}

				if (isUnix = IsUnix(bh.format)) SwapTapeHeader(&bh);
				int numsamp = bh.hns;
				if(bh.format != 1)
				{
					file.Close();
					myCaption(_T("Not floating point segy: ") + inFile);
					continue;
				}

				int len = numsamp*4 + 240;
				int tpp = bh.hdt;
				ULONGLONG byteFileEnd = file.SeekToEnd();
				file.Seek(3600L, CFile::begin);

				CFile file2;
				if (!file2.Open(outFile, CFile::modeWrite|CFile::modeCreate|CFile::typeBinary)) {
					file.Close();
					continue;
				}
				ebc2asc(head.ascHead, 3200L);
				file2.Write(head.ascHead, 3200L);
				file2.Write(&bh, 400L);

				k = 0;
				while (file.Read(&tr, len) == (UINT)len)
				{
					k ++; //trace counter

					if (isUnix) {
						SwapTraceHeader(&tr);
						SwapN(&tr, bh.format);
					}

					tr.idistopt = 8;
					tr.ns = (unsigned short)numsamp;
					float_to_ibm((int *) tr.dat.data, (int *) tr.dat.data, (int)numsamp);
					file2.Write(&tr, len);

					curBytesRead = file.Seek(0, CFile::current);
					int iPos = (int)((double)curBytesRead/(double)totBytesRead*100.);
					if(iPos<0)iPos=0;
					if(iPos>100)iPos=100;
					pFrame->SetProgress(iPos);
				} //end the while Read loop.
				file.Close();
				file2.Close();


			} //end the while file POSITION loop.
			pFrame->EndProgress();
		} //end dlg.DoModal function.
		delete [] buff;


	}






	void CSeisWideDoc::OnProcessingFilterOffsetvarying()
	{
		// testing

		//processing.filterxt.ta = 4.f;
		//processing.filterxt.tb = 10.f;
		//processing.filterxt.fLowa = 3.f;
		//processing.filterxt.fHigha = 60.f;
		//processing.filterxt.fLowb = 3.f;
		//processing.filterxt.fHighb = 16.f;
		//processing.filterxt.x1 = 1.f;

		//processing.filterxt.tax2 = 5.f;
		//processing.filterxt.tbx2 = 11.f;
		//processing.filterxt.fLowax2 = 3.f;
		//processing.filterxt.fHighax2 = 50.f;
		//processing.filterxt.fLowbx2 = 3.f;
		//processing.filterxt.fHighbx2 = 15.f;
		//processing.filterxt.x2 = 2.f;

		//processing.filterxt.tax3 = 6.f;
		//processing.filterxt.tbx3 = 12.f;
		//processing.filterxt.fLowax3 = 3.f;
		//processing.filterxt.fHighax3 = 40.f;
		//processing.filterxt.fLowbx3 = 3.f;
		//processing.filterxt.fHighbx3 = 14.f;
		//processing.filterxt.x3 = 3.f;

		//processing.filterxt.num_tfilter = 2;

		CString tstr;
		int trc,i;
		CString outFile = _T("");

		float dt;		/* sample spacing			*/
		float nyq;		/* nyquist frequency			*/


		CdlgFilterOffset dlg;
		dlg.m_nameIn = draw.timeSecName;
		dlg.m_nameOut = getFileNameAppend(draw.timeSecName, _T("FX"));
		dlg.m_fLowa = processing.filterxt.fLowa;
		dlg.m_fLowax2 = processing.filterxt.fLowax2;
		dlg.m_fLowax3 = processing.filterxt.fLowax3;
		dlg.m_fLowb = processing.filterxt.fLowb;
		dlg.m_fLowbx2 = processing.filterxt.fLowbx2;
		dlg.m_fLowbx3 = processing.filterxt.fLowbx3;

		dlg.m_fHigha = processing.filterxt.fHigha;
		dlg.m_fHighax2 = processing.filterxt.fHighax2;
		dlg.m_fHighax3 = processing.filterxt.fHighax3;
		dlg.m_fHighb = processing.filterxt.fHighb;
		dlg.m_fHighbx2 = processing.filterxt.fHighbx2;
		dlg.m_fHighbx3 = processing.filterxt.fHighbx3;
		dlg.m_numTFilter = processing.filterxt.num_tfilter;
		dlg.m_ta = processing.filterxt.ta;
		dlg.m_tax2 = processing.filterxt.tax2;
		dlg.m_tax3 = processing.filterxt.tax3;
		dlg.m_tb = processing.filterxt.tb;
		dlg.m_tbx2 = processing.filterxt.tbx2;
		dlg.m_tbx3 = processing.filterxt.tbx3;
		dlg.m_x1 = processing.filterxt.x1;
		dlg.m_x2 = processing.filterxt.x2;
		dlg.m_x3 = processing.filterxt.x3;
		if (dlg.DoModal() == IDOK)
		{
			draw.timeSecName = dlg.m_nameIn.Trim();
			outFile = dlg.m_nameOut;
			processing.filterxt.fLowa =dlg.m_fLowa;
			processing.filterxt.fLowax2 = dlg.m_fLowax2;
			processing.filterxt.fLowax3 = dlg.m_fLowax3;
			processing.filterxt.fLowb = dlg.m_fLowb;
			processing.filterxt.fLowbx2 = dlg.m_fLowbx2;
			processing.filterxt.fLowbx3 = dlg.m_fLowbx3;

			processing.filterxt.fHigha = dlg.m_fHigha;
			processing.filterxt.fHighax2 = dlg.m_fHighax2;
			processing.filterxt.fHighax3 = dlg.m_fHighax3;
			processing.filterxt.fHighb = dlg.m_fHighb;
			processing.filterxt.fHighbx2 = dlg.m_fHighbx2;
			processing.filterxt.fHighbx3 = dlg.m_fHighbx3;
			processing.filterxt.num_tfilter = dlg.m_numTFilter;
			processing.filterxt.ta = dlg.m_ta;
			processing.filterxt.tax2 = dlg.m_tax2;
			processing.filterxt.tax3 = dlg.m_tax3;
			processing.filterxt.tb = dlg.m_tb;
			processing.filterxt.tbx2 = dlg.m_tbx2;
			processing.filterxt.tbx3 = dlg.m_tbx3;
			processing.filterxt.x1 = dlg.m_x1;
			processing.filterxt.x2 = dlg.m_x2;
			processing.filterxt.x3 = dlg.m_x3;
		} // if
		else return;

		delete dlg;
		if(processing.filterxt.fLowa>=processing.filterxt.fHigha) {
			AfxMessageBox(_T(" fLowa>=fHigha. Please correct this."));
			return;
		}
		if (processing.filterxt.fLowb == 0.f || processing.filterxt.fHighb==0.f) {
			// not time varying filter for X1
			processing.filterxt.ta = processing.filterxt.tb = 0.f;
		}
		if (processing.filterxt.fLowbx2 == 0.f || processing.filterxt.fHighbx2==0.f) {
			// not time varying filter for X2
			processing.filterxt.tax2 = processing.filterxt.tbx2 = 0.f;
		}
		if (processing.filterxt.fLowbx3 == 0.f || processing.filterxt.fHighbx3==0.f) {
			// not time varying filter for X3
			processing.filterxt.tax3 = processing.filterxt.tbx3 = 0.f;
		}

		if (processing.filterxt.x2 < processing.filterxt.x1) processing.filterxt.x2 = processing.filterxt.x1;
		if (processing.filterxt.x3 < processing.filterxt.x2) processing.filterxt.x3 = processing.filterxt.x2;

		SegyWrapper sw(draw.timeSecName);
		CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
		if (CSegyMeta::segyHeadInit(draw.timeSecName, &head, 0) != 1) return;
		if (!sw.open(&head, 0)) {
			tstr.Format(_T("Valid input file cannot be opened"));
			AfxMessageBox(tstr);
			return;
		}
		bhed bhout;
		memcpy((void *)&bhout, (void *)&sw.bh, 240L);
		int nsout = bhout.hns;
		tstr.Format(_T("Loaded segy header with %d traces. Distance adjusting..."), sw.nxmax);
		myCaption(tstr);

		double *tData = NULL;
		tData = (double *)malloc((size_t)(nsout*sizeof(double)));
		if( tData == NULL) {
			AfxMessageBox( _T("Insufficient memory available") );
			return;
		}

		CFile fileout;
		if (!fileout.Open(outFile, CFile::modeCreate  |CFile::modeWrite | CFile::typeBinary)) {
			tstr.Format(_T("Outfile cannot be created"));
			AfxMessageBox(tstr);
			return;
		}
		segy tr;
		fileout.Write(sw.ascHead, 3200L);
		//	bhout.format = 1; // only floating is adopted for output
		bhout.format = pFrame->gIsIBMFloatSegy2  ?  1  :  5; // only floating is adopted for output
		fileout.Write(&bhout, 400);

		int format = bhout.format;
		int sampByte = (bhout.format==3) ? 2 :  4;
		int len = sampByte*bhout.hns + 240;

		dt = (float) (sw.bh.hdt /(double)MIL);
		double odt = 1. / dt;
		nyq = (float)(0.5/dt);
		if (processing.filterxt.fLowa <= 0.f) processing.filterxt.fLowb = processing.filterxt.fLowa = 0.00001f;
		if (processing.filterxt.fHigha > nyq) processing.filterxt.fHighb = processing.filterxt.fHigha = nyq;

		CStringArray *strArr = new CStringArray();	

		double temp=0.;
		for (int nxStore=0; nxStore < sw.nxmax; nxStore++) {
			// debias first
			temp=0.;
			for (i=0; i<nsout; i++)
				temp+= sw.trArr[nxStore].data[i];
			if(fabs(temp)>MINAMP){ 
				temp /= (double)nsout;
				for (i=0; i<nsout; i++) sw.trArr[nxStore].data[i] -= (float)temp;
			}

			memset((void *)tr.dat.data,(int) '\0', sampByte*nsout); 
			trc = sw.trArr[nxStore].tracl;
			float offset = abs(getOffset(&sw.trArr[nxStore]));  // negative offset is found to be causing problems!
			float aDelay = getTraceDelay(&sw.trArr[nxStore]);
			//	float aReducecd = getReduceTime(offset);



			int ita = 0;
			int itb = 0;
			double aRatioA;
			double aRatioB;
			float aLowa;
			float aHigha;
			bool isTimeVaryingFilter = false;
			if (processing.filterxt.x2==processing.filterxt.x1 || offset <= processing.filterxt.x1) {
				aLowa = processing.filterxt.fLowa;
				aHigha = processing.filterxt.fHigha;
				ita = (int)myRound( (processing.filterxt.ta - aDelay) * odt );
				itb = (int)myRound( (processing.filterxt.tb - aDelay) * odt );
				isTimeVaryingFilter = (itb>ita);
				if (isTimeVaryingFilter) {
					aRatioA = (processing.filterxt.fLowb - aLowa) / (double)(itb - ita);
					aRatioB = (processing.filterxt.fHighb - aHigha) / (double)(itb - ita);
				}
			} // if
			else if (processing.filterxt.x3==processing.filterxt.x2 || offset <= processing.filterxt.x2) {
				float slope =  (offset - processing.filterxt.x1) / (processing.filterxt.x2 - processing.filterxt.x1);
				aLowa = processing.filterxt.fLowa + (processing.filterxt.fLowax2 - processing.filterxt.fLowa) * slope;
				aHigha = processing.filterxt.fHigha +  (processing.filterxt.fHighax2 - processing.filterxt.fHigha) * slope;
				ita = (int)myRound( (processing.filterxt.ta+(processing.filterxt.tax2-processing.filterxt.ta)*slope - aDelay) * odt );
				itb = (int)myRound( (processing.filterxt.tb+(processing.filterxt.tbx2-processing.filterxt.tb)*slope - aDelay) * odt );
				isTimeVaryingFilter = (itb>ita);
				if (isTimeVaryingFilter) {
					float aLowb = processing.filterxt.fLowb + (processing.filterxt.fLowbx2 - processing.filterxt.fLowb) * slope;
					float aHighb = processing.filterxt.fHighb +  (processing.filterxt.fHighbx2 - processing.filterxt.fHighb) * slope;
					aRatioA = (aLowb - aLowa) / (double)(itb - ita);
					aRatioB = (aHighb - aHigha) / (double)(itb - ita);
				}
			}
			else if (offset <= processing.filterxt.x3) {
				float slope =  (offset - processing.filterxt.x2) / (processing.filterxt.x3 - processing.filterxt.x2);
				aLowa = processing.filterxt.fLowax2 + (processing.filterxt.fLowax3 - processing.filterxt.fLowax2)*slope;
				aHigha = processing.filterxt.fHighax2 +  (processing.filterxt.fHighax3 - processing.filterxt.fHighax2)*slope;
				ita = (int)myRound( (processing.filterxt.tax2+(processing.filterxt.tax3-processing.filterxt.tax2)*slope - aDelay) * odt );
				itb = (int)myRound( (processing.filterxt.tbx2+(processing.filterxt.tbx3-processing.filterxt.tbx2)*slope - aDelay) * odt );
				isTimeVaryingFilter = (itb>ita);
				if (isTimeVaryingFilter) {
					float aLowb = processing.filterxt.fLowbx2 + (processing.filterxt.fLowbx3 - processing.filterxt.fLowbx2) * slope;
					float aHighb = processing.filterxt.fHighbx2 +  (processing.filterxt.fHighbx3 - processing.filterxt.fHighbx2) * slope;
					aRatioA = (aLowb - aLowa) / (double)(itb - ita);
					aRatioB = (aHighb - aHigha) / (double)(itb - ita);
				}
			}
			else {
				aLowa = processing.filterxt.fLowax2;
				aHigha = processing.filterxt.fHighax2;
				ita = (int)myRound( (processing.filterxt.tax3 - aDelay) * odt );
				itb = (int)myRound( (processing.filterxt.tbx3 - aDelay) * odt );
				isTimeVaryingFilter = (itb>ita);
				if (isTimeVaryingFilter) {
					aRatioA = (processing.filterxt.fLowbx3 - aLowa) / (double)(itb - ita);
					aRatioB = (processing.filterxt.fHighbx3 - aHigha) / (double)(itb - ita);
				}
			}

			double a,b, c0,c1,c2, d1,d2;
			for (int n=0; n<processing.filterxt.num_tfilter; n++) {
				if (isTimeVaryingFilter) {
					a=tan(PI*aLowa*dt);
					b=tan(PI*aHigha*dt);
					c0 = -b/(1.+a)/(1.+b);
					c1 = 0.;
					c2 = -c0;
					d1 = ((1.+a)*(1.-b)+(1.-a)*(1.+b))/((1.+a)*(1.+b));
					d2 = -((1.-a)*(1.-b))/((1.+a)*(1.+b));

					// prepare for time varying filter
					tData[0] = c0*sw.trArr[nxStore].data[0];
					tData[1] = c0*sw.trArr[nxStore].data[1]+c1*sw.trArr[nxStore].data[0] + d1*tData[0];
					for (i=2; i<nsout; i++) {
						if (i>=ita && i<=itb) {
							float fLow = aLowa + (float)((i - ita) *  aRatioA);
							float fHigh = aHigha + (float)((i - ita) *  aRatioB);
							if ((int)(i /100) * 100 == i || i==ita || i==itb) { 
								//tstr.Format(_T("%d  %f(km)  %d  %f(s)  %f-%f(Hz); At %f(s) calc freq is %f-%f", 
								//	trc, offset, i, (float)(i*dt+aDelay), fLow, fHigh, 
								//	(float)(ita*dt+aDelay), aLowa, aHigha);
								tstr.Format(_T("Trc%d  X=%f(km)  %d  T=%f(s)  %f-%f(Hz)"), 
									trc, offset, i, (float)(i*dt+aDelay), fLow, fHigh);
								strArr->Add(tstr);
							}
							a=tan(PI*fLow*dt);
							b=tan(PI*fHigh*dt);
							c0 = -b/(1.+a)/(1.+b);
							c1 = 0.;
							c2 = -c0;
							d1 = ((1.+a)*(1.-b)+(1.-a)*(1.+b))/((1.+a)*(1.+b));
							d2 = -((1.-a)*(1.-b))/((1.+a)*(1.+b));
						}
						tData[i] = c0*sw.trArr[nxStore].data[i]+
							c1*sw.trArr[nxStore].data[i-1]+
							c2*sw.trArr[nxStore].data[i-2] + 
							d1*tData[i-1]+d2*tData[i-2];
						if (fabs(tData[i]) > 100000.0) {
							int dfs = 1;
						}

					} // for i
				} // if
				else {
					a=tan(PI*aLowa*dt);
					b=tan(PI*aHigha*dt);
					c0 = -b/(1.+a)/(1.+b);
					c1 = 0.;
					c2 = -c0;
					d1 = ((1.+a)*(1.-b)+(1.-a)*(1.+b))/((1.+a)*(1.+b));
					d2 = -((1.-a)*(1.-b))/((1.+a)*(1.+b));
					tData[0] = c0*sw.trArr[nxStore].data[0];
					tData[1] = c0*sw.trArr[nxStore].data[1]+c1*sw.trArr[nxStore].data[0] + d1*tData[0];
					for (i=2; i<nsout; i++)
						tData[i] = c0*sw.trArr[nxStore].data[i]+
						c1*sw.trArr[nxStore].data[i-1]+
						c2*sw.trArr[nxStore].data[i-2] + 
						d1*tData[i-1]+d2*tData[i-2];
				}

				for (i=0; i<nsout; i++)
					sw.trArr[nxStore].data[i] = -(float)tData[i];
			} // for n
			memcpy( (void *)&tr.dat,   (void *)&sw.trArr[nxStore].data[0],  sampByte*nsout);
			if ( bhout.format==1 ) {
				float_to_ibm((int *) tr.dat.data, (int *) tr.dat.data, nsout); // we always output as floating pt
			}

			//	float bDelay = getTraceDelay(&sw.trArr[nxStore]);  // test


			fileout.Write(&sw.trArr[nxStore], 240);
			fileout.Write(&tr.dat.data[0], bhout.hns*sizeof(float));
			if ((int)(nxStore /10) * 10 == nxStore) { 
				tstr.Format(_T("F%d...."), nxStore);
				myCaption(tstr);
			}
		} // for nxStore

		fileout.Close();

		tstr = getFileNameTemp(draw.timeSecName, _T("_freqCalc.txt"), TRUE);
		saveStringArrayToFile(strArr, tstr);
		strArr->RemoveAll();
		delete strArr;
		showFileInNotePad(tstr);
		draw.timeSecName = outFile;
		if (tData != NULL) free(tData);
		OnToolbarRefreshAll();
	}

	void CSeisWideDoc::OnSonobuoyAssignoffsetfromsegy()
	{
		CString tStr;
		tStr.Format(_T("Assign offsets for the currently displayed segy file using another file. If a trace number or FFID is not found in the 2nd file, the offset in the 1st file will not be modified. Trace length of the 2nd file can be different from the 1st. No statics are copied. \nYES=use trace number, \nNO=use FFID \nto assign offsets."));
		int ifeedback = AfxMessageBox(tStr, MB_YESNOCANCEL|MB_ICONINFORMATION);

		if(ifeedback == IDCANCEL) return;

		bool isTraceNumBased = (ifeedback == IDYES);


		if (!isFileExistNotDirectory(draw.timeSecName))  {
			tStr.Format(_T(" To assign offsets for sonobuoy data, please display a time section."));
			AfxMessageBox(tStr);
			return;
		}

		//open file dialog.
		CString file2;
		CFileDialog dlg2( FALSE,_T(""),_T("*.sgy"), OFN_EXPLORER,
			_T("Copy offsets from a second segy file (*.sgy)|*.sgy|"));
		dlg2.m_ofn.lpstrTitle = _T("Select the 2nd segy file");
		if(dlg2.DoModal()==IDOK)
			file2 = dlg2.GetPathName();
		else {
			return;
		}
		delete dlg2;

		if (file2 == draw.timeSecName) {
			tStr.Format(_T("Sorry. your first file is the same as the second file."));
			AfxMessageBox(tStr);
			return;
		}

		SegyWrapper sw(draw.timeSecName);
		sw.m_isHeadersOnly = true;
		if (CSegyMeta::segyHeadInit(draw.timeSecName, &head, 0) != 1) return;
		if (!sw.open(&head, 0)) {
			tStr.Format(_T("Input file cannot be opened properly."));
			AfxMessageBox(tStr);
			return;
		}
		if (sw.m_isUnixInFile) {
			tStr.Format(_T("Sorry, this routine only deals with PC format."));
			AfxMessageBox(tStr);
			return;
		}

		HEAD head2;
		SegyWrapper sw2(file2);
		sw2.m_isHeadersOnly = true;
		if (CSegyMeta::segyHeadInit(file2, &head2, 0) != 1) return;
		bool isTrue = sw2.open(&head2, 0);
		CSegyMeta::segyHeadFree(&head2);  // head2 must free manually, but head should not free
		if (!isTrue) {
			tStr.Format(_T("Input file cannot be opened properly."));
			AfxMessageBox(tStr);
			return;
		}

		CFile file;
		if (!file.Open(draw.timeSecName, CFile::modeReadWrite | CFile::typeBinary)) {
			tStr.Format(_T("Input time section cannot be opened for writing."));
			AfxMessageBox(tStr);
			return;
		}
		file.Seek(3600L, CFile::begin);
		segy tr;
		int sampByte = (sw.bh.format != 3) ?  4  :  2;
		int lenByte = sw.bh.hns*sampByte;
		int numTracesNotFound = 0;
		int numTracesModified = 0;
		while (file.Read(&tr,240) == 240)
		{
			if(tr.trid == 2 ) //dead traces.
			{
				file.Seek(lenByte, CFile::current); 
				continue;
			}
			int i;
			if (isTraceNumBased)
				i = sw2.getArrIndexAtTrace(tr.tracl);
			else
				i = sw2.getArrIndexAtFFID(tr.fldr);

			if (i >= 0) {
				setOffset(&tr, getOffset(&sw2.trArr[i]));
				file.Seek(-240,CFile::current);
				file.Write(&tr,240);
				numTracesModified++;
			}
			else
				numTracesNotFound++;
			file.Seek(lenByte,CFile::current);
		} // while

		tStr.Format(_T("Successfully updated offsets for %d traces, with %d traces unmodified in offset."), numTracesModified, numTracesNotFound);
		myCaption(tStr);
	}

	void CSeisWideDoc::OnProcessingGainadjust()
	{
		CString tStr;
		if (!isFileExistNotDirectory(draw.timeSecName))  {
			tStr.Format(_T(" To adjust gain, please display a time section first."));
			AfxMessageBox(tStr);
			return;
		}

		static float gain_mult = 1.f;
		int i, ii, j;

		CdlgGainAdjust dlg;
		dlg.m_timeSecName = draw.timeSecName; // this is read-only
		dlg.m_trace1 = para.trace1;
		dlg.m_trace2 = para.trace2;
		dlg.m_multiply = gain_mult;
		if (dlg.DoModal() == IDOK) {
			gain_mult = dlg.m_multiply;
		}
		else return;

		if (gain_mult == 1.f) return;

		// now we will use:
		// gain_mult, dlg.m_trace1, dlg.m_trace2
		if (dlg.m_trace1 == 0) dlg.m_trace1 = -999999;
		if (dlg.m_trace2 == 0) dlg.m_trace2 = 999999;

		SegyWrapper sw(draw.timeSecName);
		//	sw.m_isIBMFloatSegy2 = pFrame->gIsIBMFloatSegy2==TRUE;
		if (CSegyMeta::segyHeadInit(draw.timeSecName, &head, 0) != 1) return;
		if (!sw.open(&head, 0)) {
			tStr.Format(_T("Input file cannot be opened properly."));
			AfxMessageBox(tStr);
			return;
		}


		for (i=0; i<=sw.nxmax; i++) {
			ii = sw.trArr[i].tracl;
			if (ii >= dlg.m_trace1 && ii <= dlg.m_trace2) {
				for (j=0; j<sw.bh.hns; j++)
					sw.trArr[i].data[j] *= gain_mult;
			} // if i
		} // for i

		ii = sw.writeDataBetweenTraces(dlg.m_trace1, dlg.m_trace2);
		tStr.Format(_T("%d traces updated."), ii);
		myCaption(tStr);
	}

	void CSeisWideDoc::OnFileSaveasdefaults()
	{
		// save all non-doc dependent parameters to SeisWide.ini file. Copy a few functions 
		//   getAmpColorArray(CString colFileName)  and  saveAmpColorToFile(CString colFileName)
		//   from dlgSegyColor2.cpp  parameter 
		myCaption(_T("To be implemented."));
	}



	void CSeisWideDoc::OnProcessingTracesubtractalongcurve()
	{
		CString tStr;
		tStr.Format(_T("Removal of noise that is slightly curved with offset and nearly cyclic in time. \nYES=Continue, \nNO=Show Help. \nTraces not covered by digitized points will not be affected. Can run this multiple times with each time a different digitizing file."));
		int ifeedback = AfxMessageBox(tStr, MB_YESNOCANCEL|MB_ICONINFORMATION);
		if(ifeedback == IDCANCEL) return;
		else if(ifeedback == IDNO) {
			myShowHelp("proc_DigitizingLinearNoiseRemoval.html");
			return;
		}

		if (!isFileExistNotDirectory(draw.timeSecName) || para.isDistanceDisplay || !draw.isDigitizing)  {
			tStr.Format(_T(" Please display a time section in offset mode only, and digitize one curve along which the subtraction will be performed. Reduction velocity is fully considered."));
			AfxMessageBox(tStr);
			return;
		}
		// backup segy file first

		//if (!draw.isDigitizing) {
		//	// the user is not digitizing. 
		//	tStr.Format(_T(" To do trace subtraction, digitize some curves indicating the subtraction curvatures, and then re-run this function.");
		//	AfxMessageBox(tStr);
		//	return;
		//}

		if (dig.totCurve<1 || dig.nPoint[0]<2)
		{
			tStr.Format(_T(" At least 2 points are needed for each digitized curve."));
			AfxMessageBox(tStr);
			return;
		}

		SegyWrapper sw(draw.timeSecName);
		CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
		//sw.m_isIBMFloatSegy2 = pFrame->gIsIBMFloatSegy2==TRUE;
		if (CSegyMeta::segyHeadInit(draw.timeSecName, &head, 0) != 1) return;
		if (!sw.open(&head, 0) || sw.nxmax<2) {
			tStr.Format(_T("Input segy file cannot be opened properly."));
			AfxMessageBox(tStr);
			return;
		}


		int i, j; // for trace indeces
		int ic,ip; // for digitized curve indexes
		float offset1, offset2;
		segy tr;


		double odt = (double)MIL / (double) sw.bh.hdt;
		double dt = 1./odt;
		float slope;
		float dx;
		float *tTrace = ealloc1float(sw.bh.hns);
		int count = 0;
		for (i=0; i<sw.nxmax-1; i++) {
			// calc offset1, offset2
			if (draw.mode == 6) {
				offset1 = (float)sw.trArr[i].tracl;
				offset2 = (float)sw.trArr[i+1].tracl;
			} else {
				offset1 = (para.isDistanceDisplay)  ?  sw.trArr[i].trcdist  :  getOffset(&sw.trArr[i]);
				offset2 = (para.isDistanceDisplay)  ?  sw.trArr[i+1].trcdist  :  getOffset(&sw.trArr[i+1]);

			}

			// now calc the delta time of the second trace (at i+1) relative to the first trace (at i)
			slope = ERRORVAL;
			for (ic=0; ic<dig.totCurve; ic++) {
				for (ip=0; ip<dig.nPoint[ic]-1; ip++) {
					if(isInsideFloat(offset1, dig.x[ip][ic], dig.x[ip+1][ic])) {
						dx = dig.x[ip+1][ic] - dig.x[ip][ic];
						slope = (dx == 0.f)  ?  0.f  :  (dig.t[ip+1][ic]-dig.t[ip][ic])/dx;
						break; 
					} // if
				} // for ip
				if (slope != ERRORVAL) break;
			} // for ic
			if (slope == ERRORVAL) {
				// if here, we had problems in getting the slope.
				continue;
			} // if

			// now calc the trace delay
			float tDelta = slope*(offset2-offset1);
			tTrace[0] = (float)(getTraceDelay(&sw.trArr[i]) + tDelta);
			for (j=1; j<sw.bh.hns; j++) {
				tTrace[j] = tTrace[j-1] + (float)dt;
			} // for i

			ints8r(         sw.bh.hns, // ntin
				(float)dt,   // dtin
				getTraceDelay(&sw.trArr[i+1]),   // ftin
				&sw.trArr[i+1].data[0], // yin[t=ntin], with yin[0] = y(fxin)
				0.f,  // yinl    value used to extrapolate yin values to left of yin[0]
				0.f,  // yinr	 value used to extrapolate yin values to right of yin[ntin-1]
				sw.bh.hns,   // nxout
				(float *)&tTrace[0],  // 
				(float *)&tr.dat.data[0]);    // tout
			// now, tr.dat.data[] is interpolated data of trace [i+1] with each sample 

			for (j=0; j<sw.bh.hns; j++)
				sw.trArr[i].data[j] -= tr.dat.data[j];
			count++;
		} // for i
		free1float(tTrace);

		for (j=0; j<sw.bh.hns; j++)
			sw.trArr[sw.nxmax-1].data[j] = sw.trArr[sw.nxmax-2].data[j];
		sw.trArr[sw.nxmax-1].delrt = sw.trArr[sw.nxmax-2].delrt;
		sw.trArr[sw.nxmax-1].t1 = sw.trArr[sw.nxmax-2].t1;

		tStr = getFileNameAppend(draw.timeSecName, _T("Subtract"));
		int ii = sw.writeDataAll(tStr);
		draw.timeSecName = tStr;
		tStr.Format(_T("%d out of %d traces affected in output."), count, ii);
		AfxMessageBox(tStr);
		this->OnDigitizeFinishdigitizing();
		OnToolbarRefreshAll();
	}

	void CSeisWideDoc::OnProcessingSplitoddeventraces()
	{
		CString tStr;
		if(AfxMessageBox(_T("This will split an on screen segy file into two based on odd and even traces. Continue?"), MB_YESNO |MB_ICONINFORMATION) != IDYES) {
			return;
		}

		if (!isFileExistNotDirectory(draw.timeSecName)) {
			myCaption(_T("Please display a valid segy file to split."));
			return;
		}
		SegyWrapper sw(draw.timeSecName);
		CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
		//	sw.m_isIBMFloatSegy2 = pFrame->gIsIBMFloatSegy2==TRUE;
		if (CSegyMeta::segyHeadInit(draw.timeSecName, &head, 0) != 1) return;
		if (!sw.open(&head, 0) || sw.nxmax<2) {
			tStr.Format(_T("Input file cannot be opened properly."));
			AfxMessageBox(tStr);
			return;
		}


		CFile filez;
		CString outFile = getFileNameAppend(draw.timeSecName, _T("Even"));
		if (!filez.Open(outFile, CFile::modeWrite|CFile::modeCreate|CFile::typeBinary)) {
			return;
		}
		filez.Write(sw.ascHead, 3200L);
		filez.Write(&sw.bh, 400);

		CString outFile2 = getFileNameAppend(draw.timeSecName, _T("Odd"));
		CFile filez2;
		if (!filez2.Open(outFile2, CFile::modeWrite|CFile::modeCreate|CFile::typeBinary)) {
			filez.Close();
			return;
		}
		filez2.Write(sw.ascHead, 3200L);
		filez2.Write(&sw.bh, 400);

		int count1 = 0;
		int count2 = 0;
		int sampByte = (sw.bh.format != 3) ?  4  :  2;
		int lenByte = sw.bh.hns*sampByte;

		for (int i=0; i<sw.nxmax; i++) {
			if ( (int)(i/2)*2 == i) {
				// this is even case
				filez.Write(&sw.trArr[i], 240);
				filez.Write(&sw.trArr[i].data[0], lenByte);
				count1++;
			}
			else {
				filez2.Write(&sw.trArr[i], 240);
				filez2.Write(&sw.trArr[i].data[0], lenByte);
				count2++;
			}
		} //end of for loop.


		if (count1 > 0)
			setSegyTotalTrace(&filez, (unsigned short)count1);
		if (count2 > 0)
			setSegyTotalTrace(&filez, (unsigned short)count2);

		filez.Close();
		filez2.Close();
		tStr.Format(_T("Finished segy file split. Please check files: \n%s \nand \n%s ."), outFile, outFile2);
		AfxMessageBox(tStr);

	}

	void CSeisWideDoc::OnReflectionFaultenhancing()
	{
		CString tStr;
		bool isSquared = true;
		tStr.Format(_T("Fault enhancement shall be done by subtracting nearby traces. Do you want to the output segy squared? "));
		int ifeedback = AfxMessageBox(tStr, MB_YESNOCANCEL|MB_ICONINFORMATION);
		if(ifeedback == IDCANCEL) {
			// myShowHelp("proc_DigitizingLinearNoiseRemoval.html");
			myCaption(_T("Help file to be constructed."));
			return;
		}
		else if(ifeedback == IDNO) {
			isSquared = false;
		}

		if (!isFileExistNotDirectory(draw.timeSecName))  {
			tStr.Format(_T(" Please display a time section first."));
			AfxMessageBox(tStr);
			return;
		}

		SegyWrapper sw(draw.timeSecName);
		CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
		//sw.m_isIBMFloatSegy2 = pFrame->gIsIBMFloatSegy2 == TRUE;
		if (CSegyMeta::segyHeadInit(draw.timeSecName, &head, 0) != 1) return;
		if (!sw.open(&head, 0) || sw.nxmax<2) {
			tStr.Format(_T("Input file cannot be opened properly."));
			AfxMessageBox(tStr);
			return;
		}


		int i, j; // for trace indeces
		segy tr;


		double odt = (double)MIL / (double) sw.bh.hdt;
		double dt = 1./odt;
		float *tTrace = ealloc1float(sw.bh.hns);
		float tdelay1;
		float tdelay2;
		for (i=0; i<sw.nxmax-1; i++) {
			tdelay1 = getTraceDelay(&sw.trArr[i]);
			tdelay2 = getTraceDelay(&sw.trArr[i+1]);
			if (tdelay1 != tdelay2) {
				for (j=0; j<sw.bh.hns; j++) {
					tTrace[j] = (float)(tdelay1 + (float)j*dt);
				} // for i
				ints8r(         sw.bh.hns, // ntin
					(float)dt,   // dtin
					tdelay2,   // ftin
					&sw.trArr[i+1].data[0], // yin[t=ntin], with yin[0] = y(fxin)
					0.f,  // yinl    value used to extrapolate yin values to left of yin[0]
					0.f,  // yinr	 value used to extrapolate yin values to right of yin[ntin-1]
					sw.bh.hns,   // nxout
					(float *)&tTrace[0],  // 
					(float *)&tr.dat.data[0]);    // tout
				// now, tr.dat.data[] is interpolated data of trace [i+1] with each sample 
				for (j=0; j<sw.bh.hns; j++)
					sw.trArr[i].data[j] -= tr.dat.data[j];
			}
			else {
				// trace delay is not changed for traces at i and i+1, so we just subtract directly.
				for (j=0; j<sw.bh.hns; j++)
					sw.trArr[i].data[j] -= sw.trArr[i+1].data[j];
			}

			// finally, make it energy only
			if (isSquared) {
				for (j=0; j<sw.bh.hns; j++)
					sw.trArr[i].data[j] = sw.trArr[i].data[j] * fabs(sw.trArr[i].data[j]);
			}

		} // for i
		free1float(tTrace);

		for (j=0; j<sw.bh.hns; j++)
			sw.trArr[sw.nxmax-1].data[j] = sw.trArr[sw.nxmax-2].data[j];
		sw.trArr[sw.nxmax-1].delrt = sw.trArr[sw.nxmax-2].delrt;
		sw.trArr[sw.nxmax-1].t1 = sw.trArr[sw.nxmax-2].t1;

		tStr = getFileNameAppend(draw.timeSecName, _T("FaultEnh"));
		int ii = sw.writeDataAll(tStr);
		draw.timeSecName = tStr;
		tStr.Format(_T("%d traces written."), ii);
		myCaption(tStr);
		OnToolbarRefreshAll();
	}


	void CSeisWideDoc::OnReflectionCoherencyplot()
	{
		CString tStr;

		//The following three lines are used by OnProcessingCohmix() only.
		if (!isFileExistNotDirectory(draw.timeSecName)) {
			tStr.Format(_T("Please display as 'Time Section by Trace' or 'Time Section by km' \n and then re-run Data this routine again. "));
			AfxMessageBox(tStr);
			return;
		}

		int ix,iv,iw,i;
		long totTrace=0;
		double rrv;
		double slopeMin, slopeMax;
		static double dxMix= (draw.mode == 6)  ?  11  :   0.25; // in km, mixing window width (offset or distance)
		static double tWindowFull = 0.2; // in sec, full mixing time window
		static bool isNotReduced = (draw.mode == 6) || (draw.mode!=6 && isFloatEqual(pCd.coord.vred, 0.0));
		static double velMin=isNotReduced  ?  -0.2  :  0.125;
		static double velMax=isNotReduced  ?  0.2   :  0.5;

		static int outputMethod = 1; //if outputMethod=1, multiply output by coherency.
		//	float ampMax=MIL;


		CString outFile = _T(""), inFile=_T("");
		int numCoh;

		CdlgCohMix dlg;
		dlg.m_dxMix = (float)dxMix;
		dlg.m_procVelmin = (float)velMin;
		dlg.m_procVelmax = (float)velMax;
		dlg.m_procTWindow = (float)tWindowFull;
		dlg.m_procNameIn = draw.timeSecName;
		dlg.m_procNameOut = getFileNameAppend(draw.timeSecName, _T("Coh"));

		dlg.m_procTmax = (float)pCd.coord.tmax;
		dlg.m_procTmin = (float)pCd.coord.tmin;
		dlg.m_outputMethod = outputMethod;
		// dlg.m_multByCoh = TRUE;
		if (dlg.DoModal() == IDOK)
		{
			dxMix = dlg.m_dxMix;
			inFile = dlg.m_procNameIn;
			outFile = dlg.m_procNameOut;
			pCd.coord.tmax = dlg.m_procTmax;
			pCd.coord.tmin = dlg.m_procTmin;
			tWindowFull = dlg.m_procTWindow;
			velMin = dlg.m_procVelmin;
			velMax = dlg.m_procVelmax;
			numCoh = dlg.m_numCoh;
			outputMethod = dlg.m_outputMethod;
		}
		else 
		{
			return;
		}

		delete dlg;
		if (!isFileExistNotDirectory(inFile)) return;
		if(outFile==_T("")) return;
		CString tempStr = outFile;
		CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
		segy tr;
		CFile filez;

		static const int NVELMAX = 10;


		CStringArray *tArray = new CStringArray();
		bool isTesting = false;




		for (int counterCoh=0; counterCoh<numCoh; counterCoh++) {	
			//Repeat the coherency process by numCoh times.



			double ymin = pCd.coord.tmin - 1.;
			double ymax = pCd.coord.tmax + 1.;
			CSegyMeta::segyHeadInit(inFile, &head, 0);
			SegyWrapperEx sw(inFile, pCd.coord.xmin, pCd.coord.xmax, ymin, ymax, draw.mode, pCd.coord.vred);
			sw.m_dxMin = 0; // read all traces
			sw.m_zGun = para.gunDepth2; // not used in this routine
			sw.m_vWater = para.waterVelocityAboveObs; // not used in this routine
			sw.m_waterDepth = para.waterVelocityAboveObs;
			sw.m_obsDepth = para.obsDepth;

			double trcInterval = (para.isDistanceDisplay)  ?  head.distInterval  :  head.offsetInterval;
			if (!sw.openDistance(!para.isDistanceDisplay, trcInterval, head.numTraces, &head) ||  sw.nxmax < 2) {
				tStr.Format(_T("Input file cannot be opened properly."));
				AfxMessageBox(tStr);
				return;
			}
			sw.sortDistance(!para.isDistanceDisplay);
			// after the sorting, the first trace should have the m_xmin, and we can correctly use mixing function


			int NDISTMAX = (draw.mode==6)  ?  
				(int)dxMix  
				:  
			(int)myRound(dxMix / sw.getAvgKmInterval(para.isDistanceDisplay == TRUE));
			if (NDISTMAX > 100) NDISTMAX = 100;

			if (counterCoh==0 && draw.mode!=6) {
				tStr.Format(_T("Mixing window shall span <=%d traces for a size of %f km. Continue?"), NDISTMAX, dxMix);
				if (AfxMessageBox(tStr, MB_YESNO|MB_ICONINFORMATION) != IDYES) return;
			}

			int numsamp = sw.bh.hns;
			double dt = (double) sw.bh.hdt/(double)MIL;
			double odt = 1. / dt;
			float ***amp = (float***)ealloc3float(numsamp,NDISTMAX, NVELMAX);
			if (ERROR == amp) return;

			float *famRange = (float*)ealloc1float(NDISTMAX);
			float *famOffset = (float*)ealloc1float(NDISTMAX);
			float *weights = (float*)ealloc1float(NDISTMAX);
			//float *rData = (float*)ealloc1float(numsamp);
			//float *midData = (float*)ealloc1float(numsamp);
			float *tTrace = ealloc1float(numsamp);

			draw.timeSecName= outFile;

			// note: although the display may use NMO display, the coherency will be calculated only along a slope of a chosen reduction velocity
			if(fabs(pCd.coord.vred)<MINAMP) rrv = 0.;
			else rrv = 1./pCd.coord.vred;
			int lWindow = (int)myRound(tWindowFull*0.5*odt);
			int lenWinTotal = 2*lWindow+1;

			totTrace = 0;

			slopeMin = velMin;
			slopeMax = velMax;
			int numSlope = NVELMAX;
			if (numSlope < 2) numSlope = 2;
			double deltaSlope = (slopeMax-slopeMin)/(double)(numSlope-1);


			//float **numi3 = (float **)ealloc2float(lenWinTotal, NVELMAX);
			//float **deno3 = (float **)ealloc2float(lenWinTotal, NVELMAX);
			//float **nnz3 = (float **)ealloc2float(lenWinTotal, NVELMAX);
			float **numi = (float**)ealloc2float(numsamp,NVELMAX);
			float **deno = (float**)ealloc2float(numsamp,NVELMAX);
			float **nnz = (float**)ealloc2float(numsamp,NVELMAX);

			float nsum[NVELMAX];
			float dsum[NVELMAX];

			if (!filez.Open(outFile, CFile::modeCreate|CFile::modeWrite|CFile::typeBinary)) {
				break;
			}

			int outLen = (int)myRound((ymax - ymin + tWindowFull) * odt) + 1;
			if (outLen > numsamp) outLen = numsamp;  // all the co arrays are of numsamp size!
			sw.bh.format = pFrame->gIsIBMFloatSegy2  ?  1  :  5; // only floating is adopted for output
			sw.bh.hns = (WORD)outLen;  // modify the output trace length 
			filez.Write(sw.ascHead, 3200L);
			filez.Write(&sw.bh, 400L);
			sw.bh.hns = numsamp;  // change it back otherwise it is confusing
			/*
			C.....Coherency filtering:
			C     I:      index of samples for the output trace
			C     IV:     counter in a loop for scanning velocities from VELMIN to 
			C             VELMAX km/sec. The increment of calculation is 0.5 km/sec
			C     fam(I,IX): Array storing data of the gather (NUM traces)
			C     VELMIN:    Minimum scanning velocity for calculating coherency/stacking
			C     VELMAX:    Minimum scanning velocity for calculating coherency/stacking
			C     numi(I,IV): Temparory array storing the total energy
			C     deno(I,IV):  Temparory array storing the similarity of traces of the 
			C                  gather  
			numRed= (VELMAX-VELMIN)*2.+1.5 ! Number of scanning velocities 
			km=FLOAT(NUM)*.5+.5          ! Index of the middle trace of the gather
			lwindow=TWINDOW*INTRATE*.5     ! Calculate half window length in records
			reci=1./FLOAT((2*LWINDOW+1)*NUM) ! Reciprocal of N*M
			*/
			for (int iTrc=0; iTrc<sw.nxmax; iTrc++) {
				register float xCenter = getTraceXVal(&sw.trArr[iTrc], draw.mode, para.isDistanceDisplay);
				register float offsetCenter = getOffset(&sw.trArr[iTrc]);  // negative offset is found to be causing problems!
				register double tminCalcCenter = getTraceDelay(&sw.trArr[iTrc]);  // centered around the famXXX arrays for all semblance calculations
				register int ixStart = iTrc - NDISTMAX / 2;
				if (ixStart < 0) ixStart = 0;
				float x1 = getTraceXVal(&sw.trArr[ixStart], draw.mode, para.isDistanceDisplay);
				for (ix=ixStart; ix<=iTrc; ix++) {
					float x = getTraceXVal(&sw.trArr[ix], draw.mode, para.isDistanceDisplay);
					if (x >= xCenter - dxMix/2.) {
						ixStart = ix;  // found the starting trace index for mix
						break;
					}
				} // for ix

				int numTrcMix = 0;
				for (ix=ixStart; ix<iTrc + NDISTMAX; ix++) {
					if (numTrcMix >= NDISTMAX || ix >= sw.nxmax) break; // this is important to avoid crash
					famRange[numTrcMix] = getTraceXVal(&sw.trArr[ix], draw.mode, para.isDistanceDisplay);
					if (famRange[numTrcMix] > (float)(xCenter + dxMix/2.)) break;
					famOffset[numTrcMix] = getOffset(&sw.trArr[ix]); //this is truly offset, range can be either offset or distance.
					// negative offset is found to be causing problems!
					numTrcMix++;
				} 
				// now, the mix should start at trace number of ix1 and span numTrcMix traces

				//	int nMid = numTrcMix / 2;
				//	rangeMid= 0.5*(famRange[0]+famRange[numTrcMix-1]);
				//	offsetMid= 0.5*(famOffset[0]+famOffset[numTrcMix-1]); // of course, in offset display mode, rangeMid=offsetMid

				// now the rule of thumb: if we have reducing velocity, we have to scan slopes using offset, otherwise the reducing time is different from adjancent mixing window.
				// If we do not have reducing velocity, we can use the current para.isDistanceDisplay to use either offset or distance for mixing window
				//double tShiftRelative; // relatie time shift in the mixing window; 0 at the center of the window
				// float tminTraceThis;  // absolute starting time in sec for each trace in the mixing window, loop thru
				double slope; // slope is actually the slope: dt/dx. Must consider reducing velocities!!!
				register double vredThis;
				for (iv=0; iv<numSlope; iv++) {
					// note: the segy data itself does not know about reducing velocity; only display cares about Vred.
					slope=slopeMin + (double)iv*deltaSlope; // slope is actually the slope: dt/dx. Must consider reducing velocities!!!
					if (fabs(slope) < 0.0001) continue;
					vredThis = 1. /slope;

					for (ix=0; ix<numTrcMix; ix++) {

						tTrace[0] = (float)tminCalcCenter; // initialize
						if (fabs(pCd.coord.vred)>0.001) {
							tTrace[0] += (float)getReduceTime(famOffset[ix], vredThis) - (float)getReduceTime(offsetCenter, vredThis);
						} else {
							tTrace[0] += (float)( (famRange[ix] - xCenter) * slope );
						}

						for (i=1; i<outLen; i++) {
							tTrace[i] = tTrace[i-1] + (float)dt;
						} // for i

						ints8r(         sw.bh.hns, // ntin
							(float)dt,   // dtin
							getTraceDelay(&sw.trArr[ixStart+ix]), // ftin
							&sw.trArr[ixStart+ix].data[0], // yin[t=ntin], with yin[0] = y(fxin)
							0.f,  // yinl    value used to extrapolate yin values to left of yin[0]
							0.f,  // yinr	 value used to extrapolate yin values to right of yin[ntin-1]
							outLen,   // nxout
							(float *)&tTrace[0],  // 
							(float *)&amp[iv][ix][0]);    // tout
					} // for ix

					memset((void *) &numi[iv][0],(int) '\0',outLen*sizeof(float)); 
					memset((void *) &deno[iv][0],(int) '\0',outLen*sizeof(float)); 
					memset((void *) &nnz[iv][0],(int) '\0',outLen*sizeof(float)); 
					for (ix=0; ix<numTrcMix; ix++) {
						for (i=0; i<outLen; i++) {
							if (fabs(amp[iv][ix][i]) > MINAMP) {
								numi[iv][i] += amp[iv][ix][i];
								deno[iv][i] += amp[iv][ix][i] * amp[iv][ix][i];
								nnz[iv][i]  += 1.f;
							}
						}
					} // for ix
				} // for iv

				for (i=0; i<outLen; i++) {
					memset((void *) &nsum[0],(int) '\0',numSlope*sizeof(float)); 
					memset((void *) &dsum[0],(int) '\0',numSlope*sizeof(float)); 

					for (iv=0; iv<numSlope; iv++) {
						// amp[iv][ix][i] is the data to mix, we want to normalize it first in each window, put to 
						//  numi[iv][iw]   and  deno[iv][iw]
						// we calc weights[] for each trace in this small window 
						//int ii = (i + lenWinTotal > outLen)  ?  outLen - lenWinTotal  :  i;

						//for (ix=0; ix<numTrcMix; ix++) {
						//	if (i + lenWinTotal > outLen) 
						//		weights[ix] = 0.f;
						//	else {
						//			weights[ix] = getMaxValueAbsolute(&amp[iv][ix][i], lenWinTotal);
						//			if (weights[ix] > MINAMP) weights[ix] = 1.f / weights[ix];
						//	}
						//} // for ix

						//memset((void *) &numi3[iv][0],(int) '\0',lenWinTotal*sizeof(float)); 
						//memset((void *) &deno3[iv][0],(int) '\0',lenWinTotal*sizeof(float)); 
						//memset((void *) &nnz3[iv][0],(int) '\0',lenWinTotal*sizeof(float)); 
						//for (ix=0; ix<numTrcMix; ix++) {
						//	float aWeight2 = weights[ix] * weights[ix];
						//	for (iw=0; iw<lenWinTotal; iw++) {
						//		if ( i+iw<outLen && fabs(amp[iv][ix][i+iw]) > MINAMP) {
						//			numi3[iv][iw] += amp[iv][ix][i+iw] * weights[ix];
						//			deno3[iv][iw] += amp[iv][ix][i+iw] * amp[iv][ix][i+iw] * aWeight2;
						//			nnz3[iv][iw]  += 1.f;
						//		}
						//	}
						//} // for ix

						for (iw=i; iw<i+lenWinTotal; iw++) {
							if (iw<outLen) {
								nsum[iv] += numi[iv][iw]*numi[iv][iw];
								dsum[iv] += deno[iv][iw];
							}
						} // for iw
						nsum[iv] = (dsum[iv]>MINAMP) ? (float)(nsum[iv] / dsum[iv])  :   0.0f;
					} // for iv

					int ind = getMaxIndex(nsum, numSlope);
					float reci = 0.f;
					if (ind >= 0 && nnz[ind][i] > 0.f) {
						reci = (float)(6000./(double)(lenWinTotal*nnz[ind][i])); //Reciprocal of N*M 
						// why divide by 1000? Because it can be too big
						tr.dat.data[i] = numi[ind][i];
						switch (outputMethod) {
						case 0:
							break;
						case 1:
							tr.dat.data[i] *= nsum[ind] / reci;
							break;
						case 2:
							// if here, it will output the max coherency at each sample at the last counterCoh
							tr.dat.data[i] = (counterCoh < numCoh-1)  ?  numi[ind][i]*nsum[ind] / reci  :  nsum[ind] / reci;
							break;
						default:
							tr.dat.data[i] = amp[ind][numTrcMix / 2][i] * nsum[ind] / reci;
						}  // end switch
					}
					else
						tr.dat.data[i] = 0.f;

					if (isTesting) {
						slope=slopeMin + (double)ind*deltaSlope; 
						vredThis = (fabs(slope) < 0.0001)  ?  0.  :  1. /slope;
						tStr.Format(_T("x=%f t=%f v=%f sum=%f coh=%f"), 
							xCenter,
							(float)(tminCalcCenter+i*dt-getReduceTime(offsetCenter, pCd.coord.vred)),
							(float)vredThis, 
							numi[ind][i],
							(counterCoh < numCoh-1)  ?  numi[ind][i]*nsum[ind] / reci  :  nsum[ind] / reci);
						tArray->Add(tStr);
						// tr.dat.data[i] = amp[0][numTrcMix / 2][i];
					}
				} // for i


				float ampLimit = (float)(1000. * getMedianAbsolute(&tr.dat.data[0], (long)outLen) );
				for (i=0; i<outLen; i++) {
					if (_isnan(tr.dat.data[i])) tr.dat.data[i] = 0.f;
					else if ( tr.dat.data[i] > ampLimit) 
						tr.dat.data[i] = ampLimit;
					else if ( tr.dat.data[i] < -ampLimit) 
						tr.dat.data[i] = -ampLimit;
				}

				memcpy( (void *)&tr,   (void *)&sw.trArr[iTrc],  240L);
				tr.ns = (WORD)outLen;
				setTraceDelayF( &tr, tminCalcCenter );  

				filez.Write(&tr, 240);

				// convert data to IBM floating points
				if ( sw.bh.format==1 ) {
					float_to_ibm((int *) tr.dat.data, (int *) tr.dat.data, (int)outLen);
				}
				filez.Write(&tr.dat.data[0], outLen*sizeof(float));
				totTrace++; 
				if ( (int)(totTrace/10)*10 == totTrace ) {
					tStr.Format(_T("T%d | %d"), totTrace, sw.nxmax);
					myCaption(tStr);
				}
			} // for iTrc

			if(totTrace>0) 
			{
				setSegyTotalTrace(&filez, (unsigned short)totTrace);
				tStr.Format(_T("Succesfully Mixing the data! A total of %d traces processed"), totTrace);
			}
			else
				tStr.Format(_T("Not even one trace processed!"));
			myCaption(tStr);

			filez.Close();
			free3float(amp); 
			free2float(numi); 
			free2float(deno); 
			free2float(nnz); 
			free1float(famRange);
			free1float(famOffset);
			free1float(weights);

			//free1float(rData);
			//free1float(midData);
			free1float(tTrace);

			//Prepare for numCoh loop. Be careful, very confusing here.
			outFile = outFile + _T(".tmpcohOnce");
			DeleteFile(outFile);
			if(!MoveFile(draw.timeSecName, outFile)) 
			{
				AfxMessageBox(_T("Can not move a temporary file!"));
				return;
			}
			inFile = outFile;
			outFile = draw.timeSecName;
		}	//end of numCoh loop.

		if (isTesting) {
			showStringArrayToFile(tArray);
		}
		tArray->RemoveAll();
		delete tArray;

		outFile = outFile + _T(".tmpcohOnce");
		if(!MoveFile(outFile, draw.timeSecName)) 
		{
			AfxMessageBox(_T("Can not move to the output file!"));
			return;
		}


		//	draw.timeSecOld = _T("");	//re-calculate initAmp().
		draw.isSameDataDisplay = FALSE; //indicate display has been changed and will re-load all data in OnDraw().
		SetModifiedFlag();
		UpdateAllViews(NULL);
		NotifyChanged();
	}

#include "dlgToolPoly.h"

	void CSeisWideDoc::OnToolDumppolynomialpoints()
	{
		CString tStr;
		static float polyA = 1.472443f;
		static float polyB = 0.050237f;
		static float polyC = 0.0466364347460489f;
		static float dt = 0.008f;
		static float tmax = 10.f;
		static float tsf = 5.172f;

		CdlgToolPoly dlg;
		dlg.m_polyA = polyA;
		dlg.m_polyB = polyB;
		dlg.m_polyC = polyC;
		dlg.m_dt = dt;
		dlg.m_tmax = tmax;
		dlg.m_tsf = tsf;
		if (dlg.DoModal() == IDOK) {
			polyA = dlg.m_polyA;
			polyB = dlg.m_polyB;
			polyC = dlg.m_polyC;
			dt = dlg.m_dt;
			tmax = dlg.m_tmax;
			tsf = dlg.m_tsf;
		}
		else return;

		CStringArray *xtArray = new CStringArray();
		tStr.Format(_T("#Computed results at discrete points for Polynomial formula with a=%f, b=%f c=%f assuming seafloor at %f"), polyA, polyB, polyC, tsf);
		xtArray->Add(tStr);
		tStr.Format(_T("#Y   X or T listed below:"));
		xtArray->Add(tStr);

		float y;
		for (float t=0.f; t<=tmax; t+=dt) {
			y = polyA + polyB*t + polyC*t*t;
			tStr.Format(_T("%.3f  %.3f"), y, t+tsf);
			xtArray->Add(tStr);
		} // for t

		CString aName = getFileNameSubdir(draw.timeSecName, _T("rms"), _T("polyDiscretePoints.txt"), true);
		if (saveStringArrayToFile(xtArray, aName)) {
			showFileInNotePad(aName);
			draw.vrmsTauName = aName;
		}
		else {
			tStr.Format(_T("Sorry, failed to save to file %s"), aName);
		}

		// clean up
		xtArray->RemoveAll();
		delete xtArray;
		xtArray = NULL;
		this->OnToolbarRefresh();

	}

	void CSeisWideDoc::OnWideNmostretching()
	{
		CString tStr;
		tStr.Format(_T("NMO stretching with a RMS velocity file loaded. \nYES=Continue, \nNO=Show Help."));
		int ifeedback = AfxMessageBox(tStr, MB_YESNOCANCEL|MB_ICONINFORMATION);
		if(ifeedback == IDCANCEL) return;
		else if(ifeedback == IDNO) {
			myShowHelp("proc_NMOStretching.html");
			return;
		}

		if (!isFileExistNotDirectory(draw.timeSecName))  {
			tStr.Format(_T(" Please display a time section in offset mode."));
			AfxMessageBox(tStr);
			return;
		}
		if (draw.mode!=6 && para.isDistanceDisplay) {
			tStr.Format(_T(" Sorry, cannot work with distance display."));
			AfxMessageBox(tStr);
			return;
		}
		// backup segy file first

		if (!draw.isDigitizing) {
			// the user is not digitizing. 
			tStr.Format(_T(" Digitize a X-Y curve with RMS velocity (km/s) and TWTT time (sec)."));
			AfxMessageBox(tStr);
			return;
		}

		if (dig.totCurve<1 || dig.nPoint[0]<2)
		{
			tStr.Format(_T(" At least 2 points are needed."));
			AfxMessageBox(tStr);
			return;
		}

		SegyWrapper sw(draw.timeSecName);
		CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
		//sw.m_isIBMFloatSegy2 = pFrame->gIsIBMFloatSegy2 == TRUE;
		if (CSegyMeta::segyHeadInit(draw.timeSecName, &head, 0) != 1) return;
		if (!sw.open(&head, 0) || sw.nxmax<2) {
			tStr.Format(_T("Input file cannot be opened properly."));
			AfxMessageBox(tStr);
			return;
		}

		static float percMute = 0.9f; 
		// static float xmax = 7.f; 

		int i, j; // for trace indeces
		float offset;
		float t;
		float tDelay;
		segy tr;


		double odt = (double)MIL / (double) sw.bh.hdt;
		double dt = 1./odt;
		float x2;
		float *tTrace = ealloc1float(sw.bh.hns);
		CDigitize pDg;
		for (i=0; i<sw.nxmax; i++) {
			offset = getOffset(&sw.trArr[i]);
			tDelay = getTraceDelay(&sw.trArr[i]);
			x2 = offset*offset;
			for (j=0; j<sw.bh.hns; j++) {
				t = tDelay + (float)(j*dt);
				register double vt = pDg.getDigXfromT(&dig, t);
				tTrace[j] = (float)sqrt(t*t + x2/(vt*vt));

				// muting
				if (t>0.00001f && (tTrace[j]-t)/t > percMute)
					tTrace[j] = -1.f;
			} // for i

			ints8r(         sw.bh.hns, // ntin
				(float)dt,   // dtin
				getTraceDelay(&sw.trArr[i]),   // ftin
				&sw.trArr[i].data[0], // yin[t=ntin], with yin[0] = y(fxin)
				0.f,  // yinl    value used to extrapolate yin values to left of yin[0]
				0.f,  // yinr	 value used to extrapolate yin values to right of yin[ntin-1]
				sw.bh.hns,   // nxout
				(float *)&tTrace[0],  // 
				(float *)&tr.dat.data[0]);    // tout
			// now, tr.dat.data[] is interpolated data of trace [i+1] with each sample 

			for (j=0; j<sw.bh.hns; j++)
				sw.trArr[i].data[j] = tr.dat.data[j];
		} // for i
		free1float(tTrace);

		tStr = getFileNameAppend(draw.timeSecName, _T("NMOStretched"));
		int ii = sw.writeDataAll(tStr);
		draw.timeSecName = tStr;
		tStr.Format(_T("%d traces updated."), ii);
		myCaption(tStr);
		// this->OnDigitizeFinishdigitizing();
		OnToolbarRefreshAll();
	}

	/*
	this function is the standard for reading and writing ....... Deping, Jan. 20, 2011
	*/
	void CSeisWideDoc::OnMenuProcessingTrcBalancing()
	{
		CString tstr;

		dlgAgc dlg;
		dlg.m_inFile = draw.timeSecName;
		CString outfile= getFileNameAppend(draw.timeSecName, _T("TrcBalanced"));
		static float winSliding = 0.3f;
		dlg.m_window_sliding = winSliding;
		dlg.m_outFile = outfile;

		if (dlg.DoModal() == IDOK)	{
			draw.timeSecName = dlg.m_inFile.Trim();
			outfile = dlg.m_outFile;
			winSliding = dlg.m_window_sliding;
		} else  {
			return;
		}

		if (!isFileExistNotDirectory(draw.timeSecName)) return;
		if(outfile==_T("")) return;
		if(outfile == draw.timeSecName) {
			tstr.Format(_T("Output file name is the same as the input file name!"));
			AfxMessageBox(tstr);
			return;
		}
		SegyWrapper sw(draw.timeSecName);
		CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
		if (CSegyMeta::segyHeadInit(draw.timeSecName, &head, 0) != 1) return;
		if (!sw.open(&head, 0)) {
			tstr.Format(_T("Input file cannot be opened"));
			AfxMessageBox(tstr);
			return;
		}
		tstr.Format(_T("Loaded segy with %d traces."), sw.nxmax);
		myCaption(tstr);

		CFile fileout;
		if (!fileout.Open(outfile, CFile::modeCreate  |CFile::modeWrite | CFile::typeBinary)) {
			tstr.Format(_T("Outfile cannot be created"));
			AfxMessageBox(tstr);
			return;
		}

		double dt = (double) sw.bh.hdt /(double)MIL;

		int i;
		bhed bhout;
		fileout.Write(sw.ascHead, 3200L);
		memcpy((void *)&bhout, (void *)&sw.bh, 240L);
		int nsout = bhout.hns;
		//bhout.format = 1; // only floating is adopted for output
		bhout.format = pFrame->gIsIBMFloatSegy2  ?  1  :  5; // only floating is adopted for output
		fileout.Write(&bhout, 400);

		// isTrue = setGainCorr(&tr2, bh.format, bh.hdt, para.sphericOrder, para.attenuationCorr, para.attenuationSeafloor);
		// now calculate how many points are needed for storing AGC points
		int nWinLen = (int)myRound(winSliding / dt);
		//int iLen = iHalf*2+1;
		int numMaxWin = (int)myRound(bhout.hns * dt / (winSliding*0.5))  + 1;
		float *tt = (float*)ealloc1(numMaxWin,sizeof(float));
		float *agc = (float*)ealloc1(numMaxWin,sizeof(float));
		float aGain;

		CStringArray *strArr = new CStringArray();
		for (int nxStore=0; nxStore < sw.nxmax; nxStore++) {
			float x = getOffset(&sw.trArr[nxStore]);
			int count = 0;
			float aMinValue = getAvgValueAbsolute(&sw.trArr[nxStore].data[0], bhout.hns) * 0.001f;  // we treat anything below average/1000 will not be considered
			for (i=0; i<bhout.hns; i+=nWinLen) {
				int iStart = i;
				//if (iStart < 0) iStart = 0;
				if (iStart > bhout.hns-nWinLen) iStart = bhout.hns-nWinLen;
				agc[count] = (float)getMedianAbsolute(&sw.trArr[nxStore].data[iStart], nWinLen);
				agc[count] = (agc[count] > aMinValue)  ?  aMinValue*1000.f/agc[count]  :  1.f;
				if (agc[count] > 10.f || agc[count] < 0.1f) {
					agc[count] = 1.f; // unstable here
				}
				tt[count] = (float)i;
				tstr.Format(_T("%f %f %d"), i*dt, agc[count], nxStore);
				strArr->Add(tstr);
				count++;
				if (count >= numMaxWin) break; // to be safe
			} // for i


			// now do the AGC gaining
			for (i=0; i<bhout.hns; i++) {
				aGain = -1.f;
				for (int iw=0; iw<count-1; iw++) {
					if (i <= tt[0]) {
						aGain = agc[0];
						break;
					} 
					else if (i >= tt[count-1] ) {
						aGain = agc[count-1];
						break;
					} // if
					else if (i >= tt[iw] && i < tt[iw+1]) {
						aGain = agc[iw] + (agc[iw+1] - agc[iw]) * (i - tt[iw]) / (tt[iw+1] - tt[iw]); 
						//aGain = agc[iw]; 
						// tt[iw+1] is already diff from tt[iw] for sure
						break;
					}
				} // for iw

				if (aGain >= 0.f)
					sw.trArr[nxStore].data[i] *= aGain;
			} // for i


			if (bhout.format==1 ) {
				float_to_ibm((int *) &sw.trArr[nxStore].data[0], (int *) &sw.trArr[nxStore].data[0], (int)bhout.hns);
			}

			fileout.Write(&sw.trArr[nxStore], 240);
			fileout.Write(&sw.trArr[nxStore].data[0], bhout.hns*sizeof(float));
			if (nxStore /10 * 10 == nxStore) { 
				tstr.Format(_T("A%d...."), nxStore);
				myCaption(tstr);
			}
		} // for nxStore
		showStringArrayToFile(strArr);
		strArr->RemoveAll();
		delete strArr;
		free1float(tt);
		free1float(agc);
		fileout.Close();


		// now finished work. Clean up
		draw.timeSecName = outfile;
		draw.isSameDataDisplay = FALSE;
		//	para.gainDist = FALSE;
		para.sphericOrder = 0.f;
		para.attenuationCorr = 0.f;


		SetModifiedFlag();
		UpdateAllViews(NULL);
		NotifyChanged();
	}

	void CSeisWideDoc::OnMenuTracebalanceXt()
	{
		if (!isTimeDomain()) return;

		CString tstr;
		static float winSliding = 0.3f;
		static float dxMix = 0.25f;  // this will be ignored in trace display
		static int numTraceMix = 5;

		CdlgTraceBalanceXT dlg;
		dlg.m_inFile = draw.timeSecName;
		CString outfile= getFileNameAppend(draw.timeSecName, _T("TrcBalancedXT"));
		dlg.m_outFile = outfile;

		dlg.m_window_sliding = winSliding;
		dlg.m_numTraceMix = numTraceMix;
		dlg.m_dxMix = dxMix;

		if (dlg.DoModal() == IDOK)
		{
			draw.timeSecName = dlg.m_inFile.Trim();
			outfile = dlg.m_outFile;
			winSliding = dlg.m_window_sliding;
			numTraceMix = dlg.m_numTraceMix;
			if (numTraceMix < 3) return;
			dxMix = dlg.m_dxMix;
		} else  {
			return;
		}

		if (!isFileExistNotDirectory(draw.timeSecName)) return;
		if(outfile==_T("")) return;
		if(outfile == draw.timeSecName) {
			tstr.Format(_T("Output file name is the same as the input file name!"));
			AfxMessageBox(tstr);
			return;
		}
		SegyWrapper sw(draw.timeSecName);
		CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
		//	sw.m_isIBMFloatSegy2 = pFrame->gIsIBMFloatSegy2 == TRUE;
		if (CSegyMeta::segyHeadInit(draw.timeSecName, &head, 0) != 1) return;
		if (!sw.open(&head, 0)) {
			tstr.Format(_T("Input file cannot be opened"));
			AfxMessageBox(tstr);
			return;
		}
		tstr.Format(_T("Loaded segy with %d traces."), sw.nxmax);
		myCaption(tstr);

		CFile fileout;
		if (!fileout.Open(outfile, CFile::modeCreate  |CFile::modeWrite | CFile::typeBinary)) {
			tstr.Format(_T("Outfile cannot be created"));
			AfxMessageBox(tstr);
			return;
		}

		double dt = (double) sw.bh.hdt /(double)MIL;

		int i;
		bhed bhout;
		fileout.Write(sw.ascHead, 3200L);
		memcpy((void *)&bhout, (void *)&sw.bh, 240L);
		int nsout = bhout.hns;
		// bhout.format = 1; // only floating is adopted for output
		bhout.format = pFrame->gIsIBMFloatSegy2  ?  1  :  5; // only floating is adopted for output
		fileout.Write(&bhout, 400);

		// isTrue = setGainCorr(&tr2, bh.format, bh.hdt, para.sphericOrder, para.attenuationCorr, para.attenuationSeafloor);
		// now calculate how many points are needed for storing AGC points
		int nWinLen = (int)myRound(winSliding / dt);
		//int iLen = iHalf*2+1;
		int numMaxWin = (int)myRound(bhout.hns * dt / (winSliding*0.5))  + 1;
		float *tt = (float*)ealloc1float(numMaxWin);
		float *weights = (float *)ealloc1float(numTraceMix);
		float **agcXT = (float**)ealloc2float(numMaxWin, sw.nxmax);
		float *minTrcValues = (float *)ealloc1float(sw.nxmax);
		float aGain;


		CStringArray *strArr = new CStringArray();
		for (int nxStore=0; nxStore < sw.nxmax; nxStore++) {
			float x = getOffset(&sw.trArr[nxStore]);
			int count = 0;
			minTrcValues[nxStore] = getAvgValueAbsolute(&sw.trArr[nxStore].data[0], bhout.hns) * 0.001f;  // we treat anything below average/1000 will not be considered
			for (i=0; i<bhout.hns; i+=nWinLen) {
				int iStart = i;
				if (iStart > bhout.hns-nWinLen) iStart = bhout.hns-nWinLen;
				agcXT[nxStore][count] = (float)getMedianAbsolute(&sw.trArr[nxStore].data[iStart], nWinLen);
				agcXT[nxStore][count] = (agcXT[nxStore][count] > minTrcValues[nxStore])  ?  minTrcValues[nxStore]*1000.f/agcXT[nxStore][count]  :  1.f;
				if (agcXT[nxStore][count] > 10.f || agcXT[nxStore][count] < 0.1f) {
					agcXT[nxStore][count] = 1.f; // unstable here
				}
				tt[count] = (float)i;
				tstr.Format(_T("%f %f %d"), i*dt, agcXT[nxStore][count], nxStore);
				strArr->Add(tstr);
				count++;
				if (count >= numMaxWin) break; // to be safe
			} // for i
			numMaxWin = count;  // to be sure we have the right limit
		} // for nxStore

		// now we do a balance along X axis for  agcXT[nxStore][0:numMaxWin-1]
		int nx1;
		int nx2;
		int iTrc;
		float xCenter;
		float xLoop;
		float **agcXT2 = (float**)ealloc2float(numMaxWin, sw.nxmax);
		for (int nxStore=0; nxStore < sw.nxmax; nxStore++) {
			nx1 = nxStore - numTraceMix / 2;
			nx2 = nxStore + numTraceMix / 2 + 1;
			if (nx1 < 0) nx1 = 0;
			if (nx2 > sw.nxmax) nx2 = sw.nxmax;

			if (draw.mode != 6) {
				// consider X-axis limits
				xCenter = getTraceXVal(&sw.trArr[nxStore], draw.mode, para.isDistanceDisplay);
				for (iTrc=nx1; iTrc<nx2; iTrc++) {
					xLoop = getTraceXVal(&sw.trArr[iTrc], draw.mode, para.isDistanceDisplay);
					if (xLoop <= xCenter - dxMix * 0.5f) {
						nx1 = iTrc;
						break;
					}
				}
				for (iTrc=nx2-1; iTrc>=nx1; iTrc--) {
					xLoop = getTraceXVal(&sw.trArr[iTrc], draw.mode, para.isDistanceDisplay);
					if (xLoop <= xCenter + dxMix * 0.5f) {
						nx2 = iTrc;
						break;
					}
				}
			} // if

			for (i=0; i<numMaxWin; i++) {
				for (int nxLoop=0; nxLoop<nx2-nx1; nxLoop++) 
					weights[nxLoop] = agcXT[nxLoop+nx1][i];
				if (agcXT[nxStore][i] > minTrcValues[nxStore])
					agcXT2[nxStore][i] = (float)getMedianValue(weights, nx2-nx1) / agcXT[nxStore][i];
				else
					agcXT2[nxStore][i] = agcXT[nxStore][i];
			}
		} // for nxStore
		for (int nxStore=0; nxStore < sw.nxmax; nxStore++)
			for (i=0; i<numMaxWin; i++)
				agcXT[nxStore][i] = agcXT2[nxStore][i];

		free2float(agcXT2);



		// now do the AGC gaining
		for (int nxStore=0; nxStore < sw.nxmax; nxStore++) {
			for (i=0; i<bhout.hns; i++) {
				aGain = -1.f;
				for (int iw=0; iw<numMaxWin-1; iw++) {
					if (i <= tt[0]) {
						aGain = agcXT[nxStore][0];
						break;
					} 
					else if (i >= tt[numMaxWin-1] ) {
						aGain = agcXT[nxStore][numMaxWin-1];
						break;
					} // if
					else if (i >= tt[iw] && i < tt[iw+1]) {
						aGain = agcXT[nxStore][iw] + (agcXT[nxStore][iw+1] - agcXT[nxStore][iw]) * (i - tt[iw]) / (tt[iw+1] - tt[iw]); 
						//aGain = agc[iw]; 
						// tt[iw+1] is already diff from tt[iw] for sure
						break;
					}
				} // for iw

				if (aGain >= 0.f)
					sw.trArr[nxStore].data[i] *= aGain;
			} // for i


			if ( bhout.format==1 ) {
				float_to_ibm((int *) &sw.trArr[nxStore].data[0], (int *) &sw.trArr[nxStore].data[0], (int)bhout.hns);
			}

			fileout.Write(&sw.trArr[nxStore], 240);
			fileout.Write(&sw.trArr[nxStore].data[0], bhout.hns*sizeof(float));
			if (nxStore /10 * 10 == nxStore) { 
				tstr.Format(_T("A%d...."), nxStore);
				myCaption(tstr);
			}
		} // for nxStore
		fileout.Close();

		showStringArrayToFile(strArr);
		strArr->RemoveAll();
		delete strArr;
		free1float(tt);
		free1float(weights);
		free2float(agcXT);
		free1float(minTrcValues);


		// now finished work. Clean up
		draw.timeSecName = outfile;
		draw.isSameDataDisplay = FALSE;
		para.sphericOrder = 0.f;
		para.attenuationCorr = 0.f;


		SetModifiedFlag();
		UpdateAllViews(NULL);
		NotifyChanged();
	}

	void CSeisWideDoc::OnSonobuoyShifttracenumber()
	{
		CString tstr;
		tstr.Format(_T("This will shift the trace numbers of the current segy by a constant amount as entered after"));
		AfxMessageBox(tstr);

		static int trShift = 0;
		CdlgInputValie dlg;
		dlg.m_value = (float)trShift;

		if (dlg.DoModal() == IDOK)
		{
			trShift = (int)dlg.m_value;
		}
		else 
		{
			return;
		}

		if (!isFileExistNotDirectory(draw.timeSecName)) return;
		SegyWrapper sw(draw.timeSecName, true);
		if (CSegyMeta::segyHeadInit(draw.timeSecName, &head, 0) != 1) return;
		if (!sw.open(&head, 0)) {
			tstr.Format(_T("Input file cannot be opened"));
			AfxMessageBox(tstr);
			return;
		}
		tstr.Format(_T("Loaded segy with %d traces."), sw.nxmax);
		myCaption(tstr);

		for (int nxStore=0; nxStore < sw.nxmax; nxStore++) {
			sw.trArr[nxStore].tracl += trShift;
		} // for nxStore
		sw.writeHeaderOnly(true);

		tstr.Format(_T("Updated segy with %d traces."), sw.nxmax);
		myCaption(tstr);
	}


	void CSeisWideDoc::OnProcessingDistanceadjustment()
	{
		CString tstr;

		static float x0 = 0.f;
		static float factor = 1.f;

		CdlgDistanceAdjust dlg;
		dlg.x0 = x0;
		dlg.m_timeSecName = draw.timeSecName;
		dlg.m_factor = factor;
		if (dlg.DoModal() == IDOK)
		{
			x0 = dlg.x0;
			factor = dlg.m_factor;
		}
		else 
		{
			return;
		}

		if (!isFileExistNotDirectory(draw.timeSecName)) return;
		SegyWrapper sw(draw.timeSecName, true);
		if (CSegyMeta::segyHeadInit(draw.timeSecName, &head, 0) != 1) return;
		if (!sw.open(&head, 0)) {
			tstr.Format(_T("Input file cannot be opened"));
			AfxMessageBox(tstr);
			return;
		}
		tstr.Format(_T("Loaded segy with %d traces."), sw.nxmax);
		myCaption(tstr);

		float x;
		for (int nxStore=0; nxStore < sw.nxmax; nxStore++) {
			x = getDistance(&sw.trArr[nxStore]);
			x = x0 + (x - x0)*factor;
			setDistance(&sw.trArr[nxStore], x);
		} // for nxStore
		sw.writeHeaderOnly(true);

		tstr.Format(_T("Finished updating segy with %d traces."), sw.nxmax);
		myCaption(tstr);
	}

	void CSeisWideDoc::DrawRayPathTwtt(CDC * pDC)
	{
		if(!para.traveltime) return;
		if (!isTimeDomain()) return;

		int i,j;
		UINT nBytes;
		CPoint *plt;
		CPen aPen;
		CString tStr;

		setXShotAll();


		//make rPath.out file in the same directory as velMod.velSecName.
		SetCurrentDirectory(GetPathFromFileSlash(velMod.velSecName));
		int irrcol = 0;
		if (!loadRayPathFromDepth2TWTT(_T("rPath.out"), _T("rPath.out.twtt"), &this->raypathsTwtt, 1500, 500)) return;


		int irrcolOld = -1;
		COLORREF colorThis = RGB(rand()*205 ,rand()*205 ,rand()*205 );

		CStringArray 	*icolrr = new CStringArray();				
		CString cstr;

		for (int count=0; count<raypathsTwtt.totCurve; count++) {
			int npts = raypathsTwtt.npts[count];
			int irrcol = raypathsTwtt.irrcol[count];
			if (irrcolOld != irrcol) {
				// a new ray group encountered. Need to change color
				colorThis = this->getRaycodeColor(irrcol);
				irrcolOld = irrcol;
			}

			nBytes = npts*sizeof(float);

			//// now we want to correct for the depth using tx.gunDepth
			//double oneov = (velMod.vf[0][0][0] > 0.)  ?   1. / velMod.vf[0][0][0]  :  0.f;
			//oneov *= para.gunDepth;
			//for (j=0; j<npts; j++) {
			//	zr[j] += (float)oneov;
			//}

			// now decide if we should plot this ray path
			BOOL isPlotThisRay = FALSE;
			if (tx.rayCodeShow>=0) {
				register int rayCodeCurr = (irrcol>20)  ?  (int)(irrcol/20) * 20  :  irrcol;
				if (rayCodeCurr == tx.rayCodeShow) {
					isPlotThisRay = TRUE;
					//tStr.Format(_T("%d %d"), rayCodeCurr, tx.rayCodeShow);
					//myCaption(tStr);
				}
			} else {
				if (tx.iShot<=0 || tx.iShot>= 100) {
					// this case will plot all rays
					isPlotThisRay = TRUE;
				}
				else {
					// now we only plot for a certain shot or OBS
					float xs = tx.shots[tx.iShot][0];
					float zs = tx.shots[tx.iShot][1];
					float dist0 = (xs-raypathsTwtt.xr[count][0])*(xs-raypathsTwtt.xr[count][0]) + 
						(zs-raypathsTwtt.zr[count][0])*(zs-raypathsTwtt.zr[count][0]);
					if (dist0 < 0.001f) isPlotThisRay = TRUE;
				}
			}

			// now do clipping
			if (isPlotThisRay) {
				double* xtemp = (double *)malloc((size_t)npts*2*sizeof(double));
				double* ztemp = (double *)malloc((size_t)npts*2*sizeof(double));
				for (i=0; i<npts; i++) {
					xtemp[i] = raypathsTwtt.xr[count][i];
					ztemp[i] = raypathsTwtt.zr[count][i];
				}
				npts = myClipPoints2(npts, 2*npts, xtemp, ztemp, pCd.coord.xmin, pCd.coord.xmax, pCd.coord.tmin, pCd.coord.tmax);
				if(npts>0) {
					plt = (CPoint *)malloc(npts*sizeof(CPoint));
					for (j=0; j<npts; j++) {
						plt[j] = pCd.mm_coordt(xtemp[j],ztemp[j]);
					}
					if(draw.TTCurveColor<4) {
						aPen.CreatePen(PS_SOLID, 0, getRayColor(draw.TTCurveColor));
					} else {
						aPen.CreatePen(PS_SOLID, min(60, (int)myRound(10.0* ((CMainFrame*)AfxGetMainWnd())->thicknessLines )), colorThis);
					}
					CPen* oldPen = pDC->SelectObject(&aPen);
					pDC->Polyline(plt,npts);
					pDC->SelectObject(oldPen);
					aPen.DeleteObject();
					free(plt);
				}
				free(xtemp);
				free(ztemp);
			} // if isPlotThisRay
		} // for


		// clean up
		icolrr->RemoveAll();
		delete icolrr;
		icolrr = NULL;
	}



	// this is not working!
	//void CSeisWideDoc::DrawRayPathTwttDetail(CDC * pDC)
	//{
	//	if(!para.traveltime) return;
	//	if (!isTimeDomain()) return;
	//
	//	int i,j;
	//	UINT nBytes;
	////	float *xr, *zr;
	//	CPoint *plt;
	//	CPen aPen;
	//	CString tStr;
	//
	//	setXShotAll();
	//
	//
	//	//make rPath.out file in the same directory as velMod.velSecName.
	//	SetCurrentDirectory(GetPathFromFileSlash(velMod.velSecName));
	//	// CFile file, file2;
	//	int irrcol = 0;
	////	RAYPATHS raypathsTwtt;
	//	if (!loadRayPathFromDepth2TWTT(_T("rPath.out"), _T("rPath.out.twtt"), &this->raypathsTwtt, 1500, 500)) 
	//		return;
	//
	//
	//	if (!isFileNewer("rPath.out.twtt", _T("rPath.out"))) {
	//		// we need to re-create file:  rPath.out.twtt   
	//		if (!file2.Open(_T("rPath.out.twtt"), CFile::modeCreate|CFile::modeWrite | CFile::typeBinary)) {
	//			return;
	//		}
	//		if (!file.Open(_T("rPath.out"), CFile::modeRead | CFile::typeBinary)) {
	//			return;
	//		}
	//
	//
	//		double depth[MOD_LAYER_MAX],vTop[MOD_LAYER_MAX],vBot[MOD_LAYER_MAX];
	//	//	if (!isVelModValid()) MyInitVel();
	//
	//
	//		double dxv = vel.dxV;
	//		int nxv = 50;  		//myRound((pCd.coord.xmax - pCd.coord.xmin) / dxv);
	//		dxv = (velMod.xmax - velMod.xmin) / (float)(nxv-1);
	//		int nzv = (int)myRound(velMod.zmax / vel.dz) + 1;
	//		float **trv = (float **)alloc2float(nzv, nxv);  // vtr[ix][iz] is for caching the Z-T conversion table for quicker action, iz=[0, vel.dz ...]
	//		for (int ix=0; ix<nxv; ix++) {
	//			getVZCurveAtDist((float)(velMod.xmin+ix*dxv), &depth[0], &vTop[0], &vBot[0]);
	//			getTwttFromVz(velMod.ncont, (double *)&depth[0], (double *)&vTop[0], (double *)&vBot[0], nzv, 0.f, (float)vel.dz, &trv[ix][0]); 
	//		}
	//
	//
	//
	////		segy tr;
	//		while(file.Read(&npts, sizeof(int)) == sizeof(int))
	//		{
	//			file2.Write(&npts, sizeof(int));
	//			file.Read(&irrcol, sizeof(int));
	//			file2.Write(&irrcol, sizeof(int));
	//			nBytes = npts*sizeof(float);
	//			xr = (float*)malloc(nBytes);
	//			zr = (float*)malloc(nBytes);
	// 			if( xr == NULL || zr == NULL)
	//			{
	//			   AfxMessageBox( _T("Insufficient memory available") );
	//			   return;
	//			}
	//	  
	//			if(file.Read(xr, nBytes) != nBytes) 
	//			{
	//				free(xr);
	//				free(zr);
	//				file.Close();
	//				return;
	//			}
	//			if(file.Read(zr, nBytes) != nBytes)
	//			{
	//				free(xr);
	//				free(zr);
	//				file.Close();
	//				return;
	//			}
	//
	//			// we cannot do the gunDepth correction here. Do it later
	//			//for (j=0; j<npts; j++) {
	//			//	zr[j] += tx.gunDepth;
	//			//}
	//
	//			// now convert zr[] to twtt domain
	//			for (j=0; j<npts; j++) {
	//				//getVZCurveAtDist(xr[j], &depth[0], &vTop[0], &vBot[0]);
	//				//float anz = zr[j] / (float)vel.dz;
	//				//int nz = (int)anz + 1;
	//				//if (nz>1) {
	//				//	getTwttFromVz(velMod.ncont, (double *)&depth[0], (double *)&vTop[0], (double *)&vBot[0], nz, 0.f, (float)vel.dz, &tr.dat.data[0]); 
	//				//	// vel.dxV
	//				//		//  here, iz=0 is at the surface, not at pCd.coord.zmin !
	//				//		// now tr.dat.data[] contains TWTT trace data
	//				//	// zr[j]  would correspond to a point inside:  tr.dat.data[nz-1]  and  tr.dat.data[nz]
	//				//	zr[j] = tr.dat.data[nz-2] + (tr.dat.data[nz-1] - tr.dat.data[nz-2]) * (float)(anz - nz);
	//				//}
	//
	//				register float aix = (float)(xr[j] / dxv);
	//				register int ix = (int)aix;
	//				if (ix<0) ix = 0;
	//				if (ix>nxv-1) ix = nxv-1;
	//				register float aiz = zr[j] / (float)vel.dz;  // zr[] is in depth (km)
	//				register int iz = (int)aiz + 1;
	//				if (iz > 1) {
	//					register float a = trv[ix][iz-2] + (trv[ix][iz-1] - trv[ix][iz-2]) * (float)(aiz - iz);
	//					if (ix<nxv-1) {
	//						register float b = trv[ix+1][iz-2] + (trv[ix+1][iz-1] - trv[ix+1][iz-2]) * (float)(aiz - iz);
	//						a = a + (b-a)*(aix-ix);
	//					}
	//					zr[j] = a;  // zr[] is now TWTT
	//				}
	//				else
	//					zr[j] = 0.f;
	//			} // for i
	//			file2.Write(xr, nBytes);
	//			file2.Write(zr, nBytes);
	//			free(xr);
	//			free(zr);
	//		} // while
	//		free2float(trv);
	//
	//		file.Close();
	//		file2.Close();
	//	}
	//
	//
	//	freeRaypathsAll(&raypathsTwtt);
	//	if (!file.Open(_T("rPath.out.twtt"), CFile::modeRead | CFile::typeBinary)) {
	//		return;
	//	}
	//
	//
	//
	//	int irrcolOld = -1;
	//	COLORREF colorThis = RGB(rand()*205 ,rand()*205 ,rand()*205 );
	//
	//	CStringArray 	*icolrr = new CStringArray();				
	//	CString cstr;
	//
	//	//for (int count=0; count<raypathsTwtt.totCurve; count++) {
	//	//	int npts = raypathsTwtt.npts[count];
	//	//	int irrcol = raypathsTwtt.irrcol[count];
	//	//	if (irrcolOld != irrcol) {
	//	//		// a new ray group encountered. Need to change color
	//	//		colorThis = this->getRaycodeColor(irrcol);
	//	//		irrcolOld = irrcol;
	//	//	}
	//
	//	//	nBytes = npts*sizeof(float);
	//
	//	//	//// now we want to correct for the depth using tx.gunDepth
	//	//	//double oneov = (velMod.vf[0][0][0] > 0.)  ?   1. / velMod.vf[0][0][0]  :  0.f;
	//	//	//oneov *= para.gunDepth;
	//	//	//for (j=0; j<npts; j++) {
	//	//	//	zr[j] += (float)oneov;
	//	//	//}
	//
	//	//	// now decide if we should plot this ray path
	//	//	BOOL isPlotThisRay = FALSE;
	//	//	if (tx.rayCodeShow>=0) {
	//	//		register int rayCodeCurr = (irrcol>20)  ?  (int)(irrcol/20) * 20  :  irrcol;
	//	//		if (rayCodeCurr == tx.rayCodeShow) {
	//	//			isPlotThisRay = TRUE;
	//	//			//tStr.Format(_T("%d %d"), rayCodeCurr, tx.rayCodeShow);
	//	//			//myCaption(tStr);
	//	//		}
	//	//	} else {
	//	//		if (tx.iShot<=0 || tx.iShot>= 100) {
	//	//			// this case will plot all rays
	//	//			isPlotThisRay = TRUE;
	//	//		}
	//	//		else {
	//	//			// now we only plot for a certain shot or OBS
	//	//			float xs = tx.shots[tx.iShot][0];
	//	//			float zs = tx.shots[tx.iShot][1];
	//	//			float dist0 = (xs-raypathsTwtt.xr[count][0])*(xs-raypathsTwtt.xr[count][0]) + 
	//	//				(zs-raypathsTwtt.zr[count][0])*(zs-raypathsTwtt.zr[count][0]);
	//	//			if (dist0 < 0.001f) isPlotThisRay = TRUE;
	//	//		}
	//	//	}
	//
	//	//	// now do clipping
	//	//	if (isPlotThisRay) {
	//	//		double* xtemp = (double *)malloc((size_t)npts*2*sizeof(double));
	//	//		double* ztemp = (double *)malloc((size_t)npts*2*sizeof(double));
	//	//		for (i=0; i<npts; i++) {
	//	//			xtemp[i] = raypathsTwtt.xr[count][i];
	//	//			ztemp[i] = raypathsTwtt.zr[count][i];
	//	//		}
	//	//		npts = myClipPoints2(npts, 2*npts, xtemp, ztemp, pCd.coord.xmin, pCd.coord.xmax, pCd.coord.tmin, pCd.coord.tmax);
	//	//		if(npts>0) {
	//	//			plt = (CPoint *)malloc(npts*sizeof(CPoint));
	//	//			for (j=0; j<npts; j++) {
	//	//				plt[j] = pCd.mm_coordt(xtemp[j],ztemp[j]);
	//	//			}
	//	//			if(draw.TTCurveColor<4) {
	//	//				aPen.CreatePen(PS_SOLID, 0, getRayColor(draw.TTCurveColor));
	//	//			} else {
	//	//				aPen.CreatePen(PS_SOLID, min(60, (int)myRound(10.0* ((CMainFrame*)AfxGetMainWnd())->thicknessLines )), colorThis);
	//	//			}
	//	//			CPen* oldPen = pDC->SelectObject(&aPen);
	//	//			pDC->Polyline(plt,npts);
	//	//			pDC->SelectObject(oldPen);
	//	//			aPen.DeleteObject();
	//	//			free(plt);
	//	//		}
	//	//		free(xtemp);
	//	//		free(ztemp);
	//	//	} // if isPlotThisRay
	//	//} // for
	//
	//
	//	// clean up
	//	icolrr->RemoveAll();
	//	delete icolrr;
	//	icolrr = NULL;
	//}


	// This function is disabled!
	void CSeisWideDoc::OnReflectionFlattenboundary()
	{
		CString tStr;
		tStr.Format(_T("Flatten any digitized curve in a time section.\n First, digitize 1 segment above which all amplitudes will be zero-ed."));
		AfxMessageBox(tStr);

		if (!isTimeDomain() || draw.mode!=6) 
		{
			AfxMessageBox(_T("Please show a time section in trace mode."));
			return;
		}
		if (!draw.isDigitizing || dig.nPoint[0]<2) {
			// the user is not digitizing. 
			tStr.Format(_T("Pleaser digitize 1 segment with >= 2 points."));
			AfxMessageBox(tStr);
			return;
		}

		SegyWrapper sw(draw.timeSecName);
		CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
		// sw.m_isIBMFloatSegy2 = pFrame->gIsIBMFloatSegy2 == TRUE;
		if (CSegyMeta::segyHeadInit(draw.timeSecName, &head, 0) != 1) return;
		if (!sw.open(&head, 0) || sw.nxmax<2) {
			tStr.Format(_T("Input segy file cannot be opened properly."));
			AfxMessageBox(tStr);
			return;
		}

		int i, j; // for trace indeces
		int ic,ip; // for digitized curve indexes
		segy tr;


		double odt = (double)MIL / (double) sw.bh.hdt;
		double dt = 1./odt;
		float slope;
		float dx;
		float offset1 = 0.f, offset2 = 0.f;
		float *tTrace = ealloc1float(sw.bh.hns);
		for (i=0; i<sw.nxmax-1; i++) {
			// offset1 = (para.isDistanceDisplay)  ?  sw.trArr[i].trcdist  :  getOffset(&sw.trArr[i]);

			slope = ERRORVAL;


			// now calc the delta time of the second trace (at i+1) relative to the first trace (at i)
			for (ic=0; ic<dig.totCurve; ic++) {
				for (ip=0; ip<dig.nPoint[ic]-1; ip++) {
					if(isInsideFloat(offset1, dig.x[ip][ic], dig.x[ip+1][ic])) {
						dx = dig.x[ip+1][ic] - dig.x[ip][ic];
						slope = (dx == 0.f)  ?  0.f  :  (dig.t[ip+1][ic]-dig.t[ip][ic])/dx;
						break;
					} // if
				} // for ip
				if (slope != ERRORVAL) break;
			} // for ic

			if (slope == ERRORVAL) {
				// if here, we had problems in getting the slope.
				continue;
			} // if

			float tDelta = slope*(offset2-offset1);
			tTrace[0] = (float)(getTraceDelay(&sw.trArr[i]) + tDelta);
			for (j=1; j<sw.bh.hns; j++) {
				tTrace[j] = tTrace[j-1] + (float)dt;
			} // for i

			ints8r(         sw.bh.hns, // ntin
				(float)dt,   // dtin
				getTraceDelay(&sw.trArr[i+1]),   // ftin
				&sw.trArr[i+1].data[0], // yin[t=ntin], with yin[0] = y(fxin)
				0.f,  // yinl    value used to extrapolate yin values to left of yin[0]
				0.f,  // yinr	 value used to extrapolate yin values to right of yin[ntin-1]
				sw.bh.hns,   // nxout
				(float *)&tTrace[0],  // 
				(float *)&tr.dat.data[0]);    // tout
			// now, tr.dat.data[] is interpolated data of trace [i+1] with each sample 

			for (j=0; j<sw.bh.hns; j++)
				sw.trArr[i].data[j] -= tr.dat.data[j];
		} // for i
		free1float(tTrace);

		for (j=0; j<sw.bh.hns; j++)
			sw.trArr[sw.nxmax-1].data[j] = sw.trArr[sw.nxmax-2].data[j];
		sw.trArr[sw.nxmax-1].delrt = sw.trArr[sw.nxmax-2].delrt;
		sw.trArr[sw.nxmax-1].t1 = sw.trArr[sw.nxmax-2].t1;

		tStr = getFileNameAppend(draw.timeSecName, _T("Subtract"));
		int ii = sw.writeDataAll(tStr);
		draw.timeSecName = tStr;
		tStr.Format(_T("%d traces updated."), ii);
		myCaption(tStr);
		this->OnDigitizeFinishdigitizing();
		OnToolbarRefreshAll();

		// need to get the zDig (the digitized curve depth) at x
		//zDig = -99999.;
		//if (x <= dig.x[0][0]) zDig = dig.t[0][0];
		//else if (x >= dig.x[np-1][0]) zDig = dig.t[np-1][0];
		//else {
		//	for (int i=0; i<np-1; i++) {
		//		if (x > dig.x[i][0]  && x<=dig.x[i+1][0]) {
		//			zDig = (dig.x[i+1][0] - dig.x[i][0]) == 0.f  ?  dig.t[i][0]  :
		//				dig.t[i][0] + (dig.t[i+1][0] - dig.t[i][0]) * (x-dig.x[i][0]) / (dig.x[i+1][0] - dig.x[i][0]);
		//			break;
		//		} 
		//	} // for
		//}

	}



	// a protected routine to handle new empty view, such as the user dropped a new file to SeisWide frame
	// return true if the file has been properly handled.
	bool CSeisWideDoc::myOpenNewFile(CString fName) {
		//CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
		//ASSERT(pFrame);
		CString tStr;

		// if(draw.mode >= 0) return false;
		CString t = GetFileExtension(fName).MakeLower();
		bool isTrue = false;
		//t == _T("sgy") || 
		//t == _T("segy") || 
		//t == _T("bin") || 
		//t == _T("txt") || 
		//t == _T("bmp");

		draw.modeOld = -1;
		// else if (sExt == _T("bin") || sExt == _T("vxml")) {
		if ( t == _T("bin") || t == _T("vxml")) {
			// if here, the user has dropped a .bin file in the blank seiswide window, and we should display the whole velocity model
			velMod.velSecName = fName;
			CVelMod vm;
			if (vm.loadInitVel(&velMod, velMod.velSecName, vel.dz)) {
				draw.mode = 2;
				pCd.coord.xmin = velMod.xmin;
				pCd.coord.xmax = velMod.xmax;
				pCd.coord.zmin =  velMod.zmin;
				pCd.coord.zmax =  velMod.zmax;
				pCd.coord.xTick = getTickRounded(pCd.coord.xmin, pCd.coord.xmax, 2, 50, 0.0);
				vel.zTick = getTickRounded(pCd.coord.zmin, pCd.coord.zmax, 2, 50, 0.0);
				isTrue = true;
			}
			else {
				velMod.velSecName = "";
				isTrue = false;
				myCaption(_T("Sorry, failed to initialize the velocity file"));
			}
		}
		else if ( t == _T("sgy") || t == _T("segy")) {
			// if here, the user has dropped a segy file in the blank seiswide window, and we should display trc by trc
			// note: since  dlg.CalcSegyInfo()  is inside OnViewTimesectrc(), I cannot call it directly from CView.
			draw.timeSecName = fName;
			if (CSegyMeta::getSegyMeta(draw.timeSecName, &head) && head.numTraces>0) {
				pCd.coord.tmin = head.tminFile;
				pCd.coord.tmax = head.tmaxFile;
				pCd.coord.xmin = para.trace1 = head.traces[0];
				pCd.coord.xmax = para.trace2 = head.traces[ head.numTraces-1 ];
				draw.modeOld = draw.mode = 6;
				para.wiggle = 4;
				pCd.coord.tTick = getTickRounded(pCd.coord.tmin, pCd.coord.tmax, 2, 50, 0.0);
				pCd.coord.xTick = getTickRounded(pCd.coord.xmin, pCd.coord.xmax, 2, 10, 100.0);
				isTrue = true;
			}
			else {
				// myCaption(_T("Sorry, failed to initialize the file."));
				isTrue = false;
			}
		}
		else if ( t == _T("txt")) {
			//###################testing
			if ( isTxtFile6Columns(fName)) {
				// since it is 6 columns, we need to convert it to proper digitizing format for properly displaying
				tStr.Format(_T("Convert 6 columns to 3 columns.\nYes=Depth in Sub-basement; \nNo=Sub-seafloor;\nCancel=Depth as is."));
				int idSatt = AfxMessageBox(tStr, MB_YESNOCANCEL | MB_ICONINFORMATION);
				if (idSatt == IDYES)
					tStr = conv6ColTo3ColSubBasement(fName);
				else if (idSatt == IDNO)
					tStr = conv6ColTo3ColSubSeafloor(fName);
				else
					tStr = conv6ColTo3Col(fName);

				if ( tStr.Compare(fName) == 0) {
					AfxMessageBox(_T("6 columns detected, but cannot convert or save to 3 columns digitizing format."));
				}
				else {
					AfxMessageBox(_T("6 columns are converted and saved to 3 columns in digitizing format."));
					fName = tStr;
				}
				showFileInNotePad(fName);
			}

			//draw.markerName = fName;
			dig.digName = fName;
			CDigitize pDg;
			if (pDg.myDigitizingLoadTXTUnix2(&dig, FALSE, FALSE) && dig.totCurve>0) {
				this->draw.mode = 0;
				if (dig.totCurve > 500000) dig.totCurve = 500000;  // a measure to prevent mal atempt!

				// Note: if here, I have a MessageBox() shows up, it will fire the ondraw() and try to display it 
				//       without its content read in.
				//tStr.Format(_T("Detected %d curves to plot. Continue? \nYes=Plot in digitize format; \nOtherwise will show in Notepad."), this->dig.totCurve);
				//if(AfxMessageBox(tStr, MB_YESNO |MB_ICONINFORMATION) == IDYES) {
				pDg.getDigLimits(&dig, &pCd.coord.xmin, &pCd.coord.xmax, &pCd.coord.tmin, &pCd.coord.tmax);
				this->pCd.coord.xTick = getTickRounded(this->pCd.coord.xmin, this->pCd.coord.xmax, 2, 50, 0.0);
				this->pCd.coord.xmin = getMinRounded(this->pCd.coord.xmin, this->pCd.coord.xmax, 10);
				this->pCd.coord.xmax = getMaxRounded(this->pCd.coord.xmin, this->pCd.coord.xmax, 10);
				this->pCd.coord.tTick = getTickRounded(this->pCd.coord.tmin, this->pCd.coord.tmax, 2, 50, 0.0);
				this->pCd.coord.tmin = getMinRounded(this->pCd.coord.tmin, this->pCd.coord.tmax, 10);
				this->pCd.coord.tmax = getMaxRounded(this->pCd.coord.tmin, this->pCd.coord.tmax, 10);
				this->pCd.coord.isFaceUp = 0;
				//}
				//else {
				//	showFileInNotePad(this->draw.markerName);
				//}
			}
			else {
				showFileInNotePad(this->draw.markerName);
			}
			isTrue = true;
		}
		else if ( t == _T("bmp")) {
			// if here, the user has dropped a BMP file in the blank seiswide window, and we should display trc by trc
			this->bmp24.bmp24Name = fName;
			CdlgImportbitmap dlg;
			dlg.m_name = this->bmp24.bmp24Name;
			dlg.m_X1 = (float)this->pCd.coord.xmin;
			dlg.m_Z1 = (float)this->pCd.coord.tmin;
			dlg.m_X2 = (float)this->pCd.coord.xmax;
			dlg.m_Z2 = (float)this->pCd.coord.tmax;
			dlg.m_isDepth = FALSE; //if TRUE, a time section, otherwise a depth section.
			this->draw.mode = 0; // this will prevent ondraw() to fire up a dialogbox.
			isTrue = true;
			//this->Invalidate(TRUE);
		}

		close_unused_documents(this);
		return isTrue;
	}



	void CSeisWideDoc::velModFreeArrays()
	{
		CVelMod vm;
		vm.velModFreeArrays(&this->velMod);
	}

	void CSeisWideDoc::OnModelPerturbvel()
	{
		if(!isVelModShown(&velMod) || !isTimeDomain()) {
			AfxMessageBox(_T(" Please show model in time domain on screen as percentage perterbation is meanful only in time domain."));
			return;
		}

		static double deltavPercent = 3.0;
		static int layer1 = 1;
		static int layer2 = 99;
		static CString strLines = _T("");
		CdlgVelocityPerturb dlg;
		dlg.m_vValue = (float)deltavPercent;
		dlg.m_layer1 = layer1;
		dlg.m_layer2 = layer2;
		dlg.m_strLines = strLines;
		if (dlg.m_layer2 > velMod.ncont-1)
			dlg.m_layer2 = velMod.ncont-1;
		if(dlg.DoModal() == IDOK) {

			deltavPercent = dlg.m_vValue;
			layer1 = dlg.m_layer1;
			layer2 = dlg.m_layer2;
			strLines = dlg.m_strLines;
			CVelMod vm;
			if (strLines.GetLength() < 5) {
				if (!vm.velModVelocityPerturb(&velMod, deltavPercent, layer1, layer2)) 
					return;
			} else if (!vm.velModVelocityPerturb(&velMod, strLines)) {
				return;
			}
		}
		else return;

		OnToolbarSaveasv();
		SetModifiedFlag();
		UpdateAllViews(NULL);
		NotifyChanged();
	}

	void CSeisWideDoc::OnModelToggleraydetails()
	{
		this->velMod.isRayDetails = !this->velMod.isRayDetails;
		UpdateAllViews(NULL);
		NotifyChanged();

	}

	// this is tricky, more complex than yminFile
	double CSeisWideDoc::getXminFile(void)
	{
		double xminFile = 0.;
		if (head.numTraces > 1) {
			if (this->draw.mode == 6)
				xminFile = head.traces[0];
			else if (para.isDistanceDisplay)
				xminFile = head.dist[0];
			else
				xminFile = head.offsets[0];
		}
		else if (isVelModValid()) 
			xminFile = velMod.xmin;

		return xminFile;
	}

	double CSeisWideDoc::getXmaxFile(void)
	{
		double xmaxFile = 100.;
		if (head.numTraces > 1) {
			int n = head.numTraces - 1;
			if (this->draw.mode == 6)
				xmaxFile = head.traces[n];
			else if (para.isDistanceDisplay)
				xmaxFile = head.dist[n];
			else
				xmaxFile = head.offsets[n];
		}
		else if (isVelModValid()) 
			xmaxFile = velMod.xmax;

		return xmaxFile;
	}

	void CSeisWideDoc::OnViewSizingofgraph()
	{
		if(draw.printX<1.f || draw.printX>10.f) draw.printX = 1.f;
		if(draw.printY<1.f || draw.printY>10.f) draw.printY = 1.f;

		CdlgPrint dlg;
		dlg.m_printX = draw.printX;
		dlg.m_printY = draw.printY;
		dlg.m_compactToOnePerTrace = draw.isFillSmall;
		dlg.m_memoryMax = draw.memMaxMB;
		dlg.m_removeLabels = draw.isNoLableOutside;

		if (dlg.DoModal() == IDOK) {
			draw.printX = dlg.m_printX;
			draw.printY = dlg.m_printY;
			draw.isFillSmall = dlg.m_compactToOnePerTrace;
			draw.memMaxMB = dlg.m_memoryMax;
			draw.isNoLableOutside = dlg.m_removeLabels;
			SetModifiedFlag();
			UpdateAllViews(NULL);
			NotifyChanged();
		} 
	}
